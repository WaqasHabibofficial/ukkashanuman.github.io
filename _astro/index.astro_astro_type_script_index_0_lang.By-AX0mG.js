/* empty css                       */
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function getDefaultExportFromCjs(l) {
    return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l
}
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "177",
    CullFaceNone = 0,
    CullFaceBack = 1,
    CullFaceFront = 2,
    PCFShadowMap = 1,
    PCFSoftShadowMap = 2,
    VSMShadowMap = 3,
    FrontSide = 0,
    BackSide = 1,
    DoubleSide = 2,
    NoBlending = 0,
    NormalBlending = 1,
    AdditiveBlending = 2,
    SubtractiveBlending = 3,
    MultiplyBlending = 4,
    CustomBlending = 5,
    AddEquation = 100,
    SubtractEquation = 101,
    ReverseSubtractEquation = 102,
    MinEquation = 103,
    MaxEquation = 104,
    ZeroFactor = 200,
    OneFactor = 201,
    SrcColorFactor = 202,
    OneMinusSrcColorFactor = 203,
    SrcAlphaFactor = 204,
    OneMinusSrcAlphaFactor = 205,
    DstAlphaFactor = 206,
    OneMinusDstAlphaFactor = 207,
    DstColorFactor = 208,
    OneMinusDstColorFactor = 209,
    SrcAlphaSaturateFactor = 210,
    ConstantColorFactor = 211,
    OneMinusConstantColorFactor = 212,
    ConstantAlphaFactor = 213,
    OneMinusConstantAlphaFactor = 214,
    NeverDepth = 0,
    AlwaysDepth = 1,
    LessDepth = 2,
    LessEqualDepth = 3,
    EqualDepth = 4,
    GreaterEqualDepth = 5,
    GreaterDepth = 6,
    NotEqualDepth = 7,
    MultiplyOperation = 0,
    MixOperation = 1,
    AddOperation = 2,
    NoToneMapping = 0,
    LinearToneMapping = 1,
    ReinhardToneMapping = 2,
    CineonToneMapping = 3,
    ACESFilmicToneMapping = 4,
    CustomToneMapping = 5,
    AgXToneMapping = 6,
    NeutralToneMapping = 7,
    AttachedBindMode = "attached",
    DetachedBindMode = "detached",
    UVMapping = 300,
    CubeReflectionMapping = 301,
    CubeRefractionMapping = 302,
    EquirectangularReflectionMapping = 303,
    EquirectangularRefractionMapping = 304,
    CubeUVReflectionMapping = 306,
    RepeatWrapping = 1e3,
    ClampToEdgeWrapping = 1001,
    MirroredRepeatWrapping = 1002,
    NearestFilter = 1003,
    NearestMipmapNearestFilter = 1004,
    NearestMipmapLinearFilter = 1005,
    LinearFilter = 1006,
    LinearMipmapNearestFilter = 1007,
    LinearMipmapLinearFilter = 1008,
    UnsignedByteType = 1009,
    ByteType = 1010,
    ShortType = 1011,
    UnsignedShortType = 1012,
    IntType = 1013,
    UnsignedIntType = 1014,
    FloatType = 1015,
    HalfFloatType = 1016,
    UnsignedShort4444Type = 1017,
    UnsignedShort5551Type = 1018,
    UnsignedInt248Type = 1020,
    UnsignedInt5999Type = 35902,
    AlphaFormat = 1021,
    RGBFormat = 1022,
    RGBAFormat = 1023,
    DepthFormat = 1026,
    DepthStencilFormat = 1027,
    RedFormat = 1028,
    RedIntegerFormat = 1029,
    RGFormat = 1030,
    RGIntegerFormat = 1031,
    RGBAIntegerFormat = 1033,
    RGB_S3TC_DXT1_Format = 33776,
    RGBA_S3TC_DXT1_Format = 33777,
    RGBA_S3TC_DXT3_Format = 33778,
    RGBA_S3TC_DXT5_Format = 33779,
    RGB_PVRTC_4BPPV1_Format = 35840,
    RGB_PVRTC_2BPPV1_Format = 35841,
    RGBA_PVRTC_4BPPV1_Format = 35842,
    RGBA_PVRTC_2BPPV1_Format = 35843,
    RGB_ETC1_Format = 36196,
    RGB_ETC2_Format = 37492,
    RGBA_ETC2_EAC_Format = 37496,
    RGBA_ASTC_4x4_Format = 37808,
    RGBA_ASTC_5x4_Format = 37809,
    RGBA_ASTC_5x5_Format = 37810,
    RGBA_ASTC_6x5_Format = 37811,
    RGBA_ASTC_6x6_Format = 37812,
    RGBA_ASTC_8x5_Format = 37813,
    RGBA_ASTC_8x6_Format = 37814,
    RGBA_ASTC_8x8_Format = 37815,
    RGBA_ASTC_10x5_Format = 37816,
    RGBA_ASTC_10x6_Format = 37817,
    RGBA_ASTC_10x8_Format = 37818,
    RGBA_ASTC_10x10_Format = 37819,
    RGBA_ASTC_12x10_Format = 37820,
    RGBA_ASTC_12x12_Format = 37821,
    RGBA_BPTC_Format = 36492,
    RGB_BPTC_SIGNED_Format = 36494,
    RGB_BPTC_UNSIGNED_Format = 36495,
    RED_RGTC1_Format = 36283,
    SIGNED_RED_RGTC1_Format = 36284,
    RED_GREEN_RGTC2_Format = 36285,
    SIGNED_RED_GREEN_RGTC2_Format = 36286,
    InterpolateDiscrete = 2300,
    InterpolateLinear = 2301,
    InterpolateSmooth = 2302,
    ZeroCurvatureEnding = 2400,
    ZeroSlopeEnding = 2401,
    WrapAroundEnding = 2402,
    NormalAnimationBlendMode = 2500,
    TrianglesDrawMode = 0,
    TriangleStripDrawMode = 1,
    TriangleFanDrawMode = 2,
    BasicDepthPacking = 3200,
    RGBADepthPacking = 3201,
    TangentSpaceNormalMap = 0,
    ObjectSpaceNormalMap = 1,
    NoColorSpace = "",
    SRGBColorSpace = "srgb",
    LinearSRGBColorSpace = "srgb-linear",
    LinearTransfer = "linear",
    SRGBTransfer = "srgb",
    KeepStencilOp = 7680,
    AlwaysStencilFunc = 519,
    NeverCompare = 512,
    LessCompare = 513,
    EqualCompare = 514,
    LessEqualCompare = 515,
    GreaterCompare = 516,
    NotEqualCompare = 517,
    GreaterEqualCompare = 518,
    AlwaysCompare = 519,
    StaticDrawUsage = 35044,
    GLSL3 = "300 es",
    WebGLCoordinateSystem = 2e3,
    WebGPUCoordinateSystem = 2001;
class EventDispatcher {
    addEventListener(i, o) {
        this._listeners === void 0 && (this._listeners = {});
        const c = this._listeners;
        c[i] === void 0 && (c[i] = []), c[i].indexOf(o) === -1 && c[i].push(o)
    }
    hasEventListener(i, o) {
        const c = this._listeners;
        return c === void 0 ? !1 : c[i] !== void 0 && c[i].indexOf(o) !== -1
    }
    removeEventListener(i, o) {
        const c = this._listeners;
        if (c === void 0) return;
        const u = c[i];
        if (u !== void 0) {
            const p = u.indexOf(o);
            p !== -1 && u.splice(p, 1)
        }
    }
    dispatchEvent(i) {
        const o = this._listeners;
        if (o === void 0) return;
        const c = o[i.type];
        if (c !== void 0) {
            i.target = this;
            const u = c.slice(0);
            for (let p = 0, m = u.length; p < m; p++) u[p].call(this, i);
            i.target = null
        }
    }
}
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180,
    RAD2DEG = 180 / Math.PI;

function generateUUID() {
    const l = Math.random() * 4294967295 | 0,
        i = Math.random() * 4294967295 | 0,
        o = Math.random() * 4294967295 | 0,
        c = Math.random() * 4294967295 | 0;
    return (_lut[l & 255] + _lut[l >> 8 & 255] + _lut[l >> 16 & 255] + _lut[l >> 24 & 255] + "-" + _lut[i & 255] + _lut[i >> 8 & 255] + "-" + _lut[i >> 16 & 15 | 64] + _lut[i >> 24 & 255] + "-" + _lut[o & 63 | 128] + _lut[o >> 8 & 255] + "-" + _lut[o >> 16 & 255] + _lut[o >> 24 & 255] + _lut[c & 255] + _lut[c >> 8 & 255] + _lut[c >> 16 & 255] + _lut[c >> 24 & 255]).toLowerCase()
}

function clamp$3(l, i, o) {
    return Math.max(i, Math.min(o, l))
}

function euclideanModulo(l, i) {
    return (l % i + i) % i
}

function mapLinear(l, i, o, c, u) {
    return c + (l - i) * (u - c) / (o - i)
}

function inverseLerp(l, i, o) {
    return l !== i ? (o - l) / (i - l) : 0
}

function lerp$1(l, i, o) {
    return (1 - o) * l + o * i
}

function damp$1(l, i, o, c) {
    return lerp$1(l, i, 1 - Math.exp(-o * c))
}

function pingpong(l, i = 1) {
    return i - Math.abs(euclideanModulo(l, i * 2) - i)
}

function smoothstep(l, i, o) {
    return l <= i ? 0 : l >= o ? 1 : (l = (l - i) / (o - i), l * l * (3 - 2 * l))
}

function smootherstep(l, i, o) {
    return l <= i ? 0 : l >= o ? 1 : (l = (l - i) / (o - i), l * l * l * (l * (l * 6 - 15) + 10))
}

function randInt(l, i) {
    return l + Math.floor(Math.random() * (i - l + 1))
}

function randFloat(l, i) {
    return l + Math.random() * (i - l)
}

function randFloatSpread(l) {
    return l * (.5 - Math.random())
}

function seededRandom(l) {
    l !== void 0 && (_seed = l);
    let i = _seed += 1831565813;
    return i = Math.imul(i ^ i >>> 15, i | 1), i ^= i + Math.imul(i ^ i >>> 7, i | 61), ((i ^ i >>> 14) >>> 0) / 4294967296
}

function degToRad(l) {
    return l * DEG2RAD
}

function radToDeg(l) {
    return l * RAD2DEG
}

function isPowerOfTwo(l) {
    return (l & l - 1) === 0 && l !== 0
}

function ceilPowerOfTwo(l) {
    return Math.pow(2, Math.ceil(Math.log(l) / Math.LN2))
}

function floorPowerOfTwo(l) {
    return Math.pow(2, Math.floor(Math.log(l) / Math.LN2))
}

function setQuaternionFromProperEuler(l, i, o, c, u) {
    const p = Math.cos,
        m = Math.sin,
        g = p(o / 2),
        _ = m(o / 2),
        v = p((i + c) / 2),
        x = m((i + c) / 2),
        y = p((i - c) / 2),
        b = m((i - c) / 2),
        S = p((c - i) / 2),
        C = m((c - i) / 2);
    switch (u) {
        case "XYX":
            l.set(g * x, _ * y, _ * b, g * v);
            break;
        case "YZY":
            l.set(_ * b, g * x, _ * y, g * v);
            break;
        case "ZXZ":
            l.set(_ * y, _ * b, g * x, g * v);
            break;
        case "XZX":
            l.set(g * x, _ * C, _ * S, g * v);
            break;
        case "YXY":
            l.set(_ * S, g * x, _ * C, g * v);
            break;
        case "ZYZ":
            l.set(_ * C, _ * S, g * x, g * v);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + u)
    }
}

function denormalize(l, i) {
    switch (i.constructor) {
        case Float32Array:
            return l;
        case Uint32Array:
            return l / 4294967295;
        case Uint16Array:
            return l / 65535;
        case Uint8Array:
            return l / 255;
        case Int32Array:
            return Math.max(l / 2147483647, -1);
        case Int16Array:
            return Math.max(l / 32767, -1);
        case Int8Array:
            return Math.max(l / 127, -1);
        default:
            throw new Error("Invalid component type.")
    }
}

function normalize$1(l, i) {
    switch (i.constructor) {
        case Float32Array:
            return l;
        case Uint32Array:
            return Math.round(l * 4294967295);
        case Uint16Array:
            return Math.round(l * 65535);
        case Uint8Array:
            return Math.round(l * 255);
        case Int32Array:
            return Math.round(l * 2147483647);
        case Int16Array:
            return Math.round(l * 32767);
        case Int8Array:
            return Math.round(l * 127);
        default:
            throw new Error("Invalid component type.")
    }
}
const MathUtils = {
    DEG2RAD,
    RAD2DEG,
    generateUUID,
    clamp: clamp$3,
    euclideanModulo,
    mapLinear,
    inverseLerp,
    lerp: lerp$1,
    damp: damp$1,
    pingpong,
    smoothstep,
    smootherstep,
    randInt,
    randFloat,
    randFloatSpread,
    seededRandom,
    degToRad,
    radToDeg,
    isPowerOfTwo,
    ceilPowerOfTwo,
    floorPowerOfTwo,
    setQuaternionFromProperEuler,
    normalize: normalize$1,
    denormalize
};
class Vector2 {
    constructor(i = 0, o = 0) {
        Vector2.prototype.isVector2 = !0, this.x = i, this.y = o
    }
    get width() {
        return this.x
    }
    set width(i) {
        this.x = i
    }
    get height() {
        return this.y
    }
    set height(i) {
        this.y = i
    }
    set(i, o) {
        return this.x = i, this.y = o, this
    }
    setScalar(i) {
        return this.x = i, this.y = i, this
    }
    setX(i) {
        return this.x = i, this
    }
    setY(i) {
        return this.y = i, this
    }
    setComponent(i, o) {
        switch (i) {
            case 0:
                this.x = o;
                break;
            case 1:
                this.y = o;
                break;
            default:
                throw new Error("index is out of range: " + i)
        }
        return this
    }
    getComponent(i) {
        switch (i) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + i)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y)
    }
    copy(i) {
        return this.x = i.x, this.y = i.y, this
    }
    add(i) {
        return this.x += i.x, this.y += i.y, this
    }
    addScalar(i) {
        return this.x += i, this.y += i, this
    }
    addVectors(i, o) {
        return this.x = i.x + o.x, this.y = i.y + o.y, this
    }
    addScaledVector(i, o) {
        return this.x += i.x * o, this.y += i.y * o, this
    }
    sub(i) {
        return this.x -= i.x, this.y -= i.y, this
    }
    subScalar(i) {
        return this.x -= i, this.y -= i, this
    }
    subVectors(i, o) {
        return this.x = i.x - o.x, this.y = i.y - o.y, this
    }
    multiply(i) {
        return this.x *= i.x, this.y *= i.y, this
    }
    multiplyScalar(i) {
        return this.x *= i, this.y *= i, this
    }
    divide(i) {
        return this.x /= i.x, this.y /= i.y, this
    }
    divideScalar(i) {
        return this.multiplyScalar(1 / i)
    }
    applyMatrix3(i) {
        const o = this.x,
            c = this.y,
            u = i.elements;
        return this.x = u[0] * o + u[3] * c + u[6], this.y = u[1] * o + u[4] * c + u[7], this
    }
    min(i) {
        return this.x = Math.min(this.x, i.x), this.y = Math.min(this.y, i.y), this
    }
    max(i) {
        return this.x = Math.max(this.x, i.x), this.y = Math.max(this.y, i.y), this
    }
    clamp(i, o) {
        return this.x = clamp$3(this.x, i.x, o.x), this.y = clamp$3(this.y, i.y, o.y), this
    }
    clampScalar(i, o) {
        return this.x = clamp$3(this.x, i, o), this.y = clamp$3(this.y, i, o), this
    }
    clampLength(i, o) {
        const c = this.length();
        return this.divideScalar(c || 1).multiplyScalar(clamp$3(c, i, o))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(i) {
        return this.x * i.x + this.y * i.y
    }
    cross(i) {
        return this.x * i.y - this.y * i.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(i) {
        const o = Math.sqrt(this.lengthSq() * i.lengthSq());
        if (o === 0) return Math.PI / 2;
        const c = this.dot(i) / o;
        return Math.acos(clamp$3(c, -1, 1))
    }
    distanceTo(i) {
        return Math.sqrt(this.distanceToSquared(i))
    }
    distanceToSquared(i) {
        const o = this.x - i.x,
            c = this.y - i.y;
        return o * o + c * c
    }
    manhattanDistanceTo(i) {
        return Math.abs(this.x - i.x) + Math.abs(this.y - i.y)
    }
    setLength(i) {
        return this.normalize().multiplyScalar(i)
    }
    lerp(i, o) {
        return this.x += (i.x - this.x) * o, this.y += (i.y - this.y) * o, this
    }
    lerpVectors(i, o, c) {
        return this.x = i.x + (o.x - i.x) * c, this.y = i.y + (o.y - i.y) * c, this
    }
    equals(i) {
        return i.x === this.x && i.y === this.y
    }
    fromArray(i, o = 0) {
        return this.x = i[o], this.y = i[o + 1], this
    }
    toArray(i = [], o = 0) {
        return i[o] = this.x, i[o + 1] = this.y, i
    }
    fromBufferAttribute(i, o) {
        return this.x = i.getX(o), this.y = i.getY(o), this
    }
    rotateAround(i, o) {
        const c = Math.cos(o),
            u = Math.sin(o),
            p = this.x - i.x,
            m = this.y - i.y;
        return this.x = p * c - m * u + i.x, this.y = p * u + m * c + i.y, this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y
    }
}
let Quaternion$1 = class {
        constructor(i = 0, o = 0, c = 0, u = 1) {
            this.isQuaternion = !0, this._x = i, this._y = o, this._z = c, this._w = u
        }
        static slerpFlat(i, o, c, u, p, m, g) {
            let _ = c[u + 0],
                v = c[u + 1],
                x = c[u + 2],
                y = c[u + 3];
            const b = p[m + 0],
                S = p[m + 1],
                C = p[m + 2],
                E = p[m + 3];
            if (g === 0) {
                i[o + 0] = _, i[o + 1] = v, i[o + 2] = x, i[o + 3] = y;
                return
            }
            if (g === 1) {
                i[o + 0] = b, i[o + 1] = S, i[o + 2] = C, i[o + 3] = E;
                return
            }
            if (y !== E || _ !== b || v !== S || x !== C) {
                let P = 1 - g;
                const w = _ * b + v * S + x * C + y * E,
                    T = w >= 0 ? 1 : -1,
                    M = 1 - w * w;
                if (M > Number.EPSILON) {
                    const D = Math.sqrt(M),
                        R = Math.atan2(D, w * T);
                    P = Math.sin(P * R) / D, g = Math.sin(g * R) / D
                }
                const A = g * T;
                if (_ = _ * P + b * A, v = v * P + S * A, x = x * P + C * A, y = y * P + E * A, P === 1 - g) {
                    const D = 1 / Math.sqrt(_ * _ + v * v + x * x + y * y);
                    _ *= D, v *= D, x *= D, y *= D
                }
            }
            i[o] = _, i[o + 1] = v, i[o + 2] = x, i[o + 3] = y
        }
        static multiplyQuaternionsFlat(i, o, c, u, p, m) {
            const g = c[u],
                _ = c[u + 1],
                v = c[u + 2],
                x = c[u + 3],
                y = p[m],
                b = p[m + 1],
                S = p[m + 2],
                C = p[m + 3];
            return i[o] = g * C + x * y + _ * S - v * b, i[o + 1] = _ * C + x * b + v * y - g * S, i[o + 2] = v * C + x * S + g * b - _ * y, i[o + 3] = x * C - g * y - _ * b - v * S, i
        }
        get x() {
            return this._x
        }
        set x(i) {
            this._x = i, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(i) {
            this._y = i, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(i) {
            this._z = i, this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(i) {
            this._w = i, this._onChangeCallback()
        }
        set(i, o, c, u) {
            return this._x = i, this._y = o, this._z = c, this._w = u, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(i) {
            return this._x = i.x, this._y = i.y, this._z = i.z, this._w = i.w, this._onChangeCallback(), this
        }
        setFromEuler(i, o = !0) {
            const c = i._x,
                u = i._y,
                p = i._z,
                m = i._order,
                g = Math.cos,
                _ = Math.sin,
                v = g(c / 2),
                x = g(u / 2),
                y = g(p / 2),
                b = _(c / 2),
                S = _(u / 2),
                C = _(p / 2);
            switch (m) {
                case "XYZ":
                    this._x = b * x * y + v * S * C, this._y = v * S * y - b * x * C, this._z = v * x * C + b * S * y, this._w = v * x * y - b * S * C;
                    break;
                case "YXZ":
                    this._x = b * x * y + v * S * C, this._y = v * S * y - b * x * C, this._z = v * x * C - b * S * y, this._w = v * x * y + b * S * C;
                    break;
                case "ZXY":
                    this._x = b * x * y - v * S * C, this._y = v * S * y + b * x * C, this._z = v * x * C + b * S * y, this._w = v * x * y - b * S * C;
                    break;
                case "ZYX":
                    this._x = b * x * y - v * S * C, this._y = v * S * y + b * x * C, this._z = v * x * C - b * S * y, this._w = v * x * y + b * S * C;
                    break;
                case "YZX":
                    this._x = b * x * y + v * S * C, this._y = v * S * y + b * x * C, this._z = v * x * C - b * S * y, this._w = v * x * y - b * S * C;
                    break;
                case "XZY":
                    this._x = b * x * y - v * S * C, this._y = v * S * y - b * x * C, this._z = v * x * C + b * S * y, this._w = v * x * y + b * S * C;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + m)
            }
            return o === !0 && this._onChangeCallback(), this
        }
        setFromAxisAngle(i, o) {
            const c = o / 2,
                u = Math.sin(c);
            return this._x = i.x * u, this._y = i.y * u, this._z = i.z * u, this._w = Math.cos(c), this._onChangeCallback(), this
        }
        setFromRotationMatrix(i) {
            const o = i.elements,
                c = o[0],
                u = o[4],
                p = o[8],
                m = o[1],
                g = o[5],
                _ = o[9],
                v = o[2],
                x = o[6],
                y = o[10],
                b = c + g + y;
            if (b > 0) {
                const S = .5 / Math.sqrt(b + 1);
                this._w = .25 / S, this._x = (x - _) * S, this._y = (p - v) * S, this._z = (m - u) * S
            } else if (c > g && c > y) {
                const S = 2 * Math.sqrt(1 + c - g - y);
                this._w = (x - _) / S, this._x = .25 * S, this._y = (u + m) / S, this._z = (p + v) / S
            } else if (g > y) {
                const S = 2 * Math.sqrt(1 + g - c - y);
                this._w = (p - v) / S, this._x = (u + m) / S, this._y = .25 * S, this._z = (_ + x) / S
            } else {
                const S = 2 * Math.sqrt(1 + y - c - g);
                this._w = (m - u) / S, this._x = (p + v) / S, this._y = (_ + x) / S, this._z = .25 * S
            }
            return this._onChangeCallback(), this
        }
        setFromUnitVectors(i, o) {
            let c = i.dot(o) + 1;
            return c < Number.EPSILON ? (c = 0, Math.abs(i.x) > Math.abs(i.z) ? (this._x = -i.y, this._y = i.x, this._z = 0, this._w = c) : (this._x = 0, this._y = -i.z, this._z = i.y, this._w = c)) : (this._x = i.y * o.z - i.z * o.y, this._y = i.z * o.x - i.x * o.z, this._z = i.x * o.y - i.y * o.x, this._w = c), this.normalize()
        }
        angleTo(i) {
            return 2 * Math.acos(Math.abs(clamp$3(this.dot(i), -1, 1)))
        }
        rotateTowards(i, o) {
            const c = this.angleTo(i);
            if (c === 0) return this;
            const u = Math.min(1, o / c);
            return this.slerp(i, u), this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        }
        dot(i) {
            return this._x * i._x + this._y * i._y + this._z * i._z + this._w * i._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let i = this.length();
            return i === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (i = 1 / i, this._x = this._x * i, this._y = this._y * i, this._z = this._z * i, this._w = this._w * i), this._onChangeCallback(), this
        }
        multiply(i) {
            return this.multiplyQuaternions(this, i)
        }
        premultiply(i) {
            return this.multiplyQuaternions(i, this)
        }
        multiplyQuaternions(i, o) {
            const c = i._x,
                u = i._y,
                p = i._z,
                m = i._w,
                g = o._x,
                _ = o._y,
                v = o._z,
                x = o._w;
            return this._x = c * x + m * g + u * v - p * _, this._y = u * x + m * _ + p * g - c * v, this._z = p * x + m * v + c * _ - u * g, this._w = m * x - c * g - u * _ - p * v, this._onChangeCallback(), this
        }
        slerp(i, o) {
            if (o === 0) return this;
            if (o === 1) return this.copy(i);
            const c = this._x,
                u = this._y,
                p = this._z,
                m = this._w;
            let g = m * i._w + c * i._x + u * i._y + p * i._z;
            if (g < 0 ? (this._w = -i._w, this._x = -i._x, this._y = -i._y, this._z = -i._z, g = -g) : this.copy(i), g >= 1) return this._w = m, this._x = c, this._y = u, this._z = p, this;
            const _ = 1 - g * g;
            if (_ <= Number.EPSILON) {
                const S = 1 - o;
                return this._w = S * m + o * this._w, this._x = S * c + o * this._x, this._y = S * u + o * this._y, this._z = S * p + o * this._z, this.normalize(), this
            }
            const v = Math.sqrt(_),
                x = Math.atan2(v, g),
                y = Math.sin((1 - o) * x) / v,
                b = Math.sin(o * x) / v;
            return this._w = m * y + this._w * b, this._x = c * y + this._x * b, this._y = u * y + this._y * b, this._z = p * y + this._z * b, this._onChangeCallback(), this
        }
        slerpQuaternions(i, o, c) {
            return this.copy(i).slerp(o, c)
        }
        random() {
            const i = 2 * Math.PI * Math.random(),
                o = 2 * Math.PI * Math.random(),
                c = Math.random(),
                u = Math.sqrt(1 - c),
                p = Math.sqrt(c);
            return this.set(u * Math.sin(i), u * Math.cos(i), p * Math.sin(o), p * Math.cos(o))
        }
        equals(i) {
            return i._x === this._x && i._y === this._y && i._z === this._z && i._w === this._w
        }
        fromArray(i, o = 0) {
            return this._x = i[o], this._y = i[o + 1], this._z = i[o + 2], this._w = i[o + 3], this._onChangeCallback(), this
        }
        toArray(i = [], o = 0) {
            return i[o] = this._x, i[o + 1] = this._y, i[o + 2] = this._z, i[o + 3] = this._w, i
        }
        fromBufferAttribute(i, o) {
            return this._x = i.getX(o), this._y = i.getY(o), this._z = i.getZ(o), this._w = i.getW(o), this._onChangeCallback(), this
        }
        toJSON() {
            return this.toArray()
        }
        _onChange(i) {
            return this._onChangeCallback = i, this
        }
        _onChangeCallback() {}*[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w
        }
    },
    Vector3$1 = class zr {
        constructor(i = 0, o = 0, c = 0) {
            zr.prototype.isVector3 = !0, this.x = i, this.y = o, this.z = c
        }
        set(i, o, c) {
            return c === void 0 && (c = this.z), this.x = i, this.y = o, this.z = c, this
        }
        setScalar(i) {
            return this.x = i, this.y = i, this.z = i, this
        }
        setX(i) {
            return this.x = i, this
        }
        setY(i) {
            return this.y = i, this
        }
        setZ(i) {
            return this.z = i, this
        }
        setComponent(i, o) {
            switch (i) {
                case 0:
                    this.x = o;
                    break;
                case 1:
                    this.y = o;
                    break;
                case 2:
                    this.z = o;
                    break;
                default:
                    throw new Error("index is out of range: " + i)
            }
            return this
        }
        getComponent(i) {
            switch (i) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + i)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z)
        }
        copy(i) {
            return this.x = i.x, this.y = i.y, this.z = i.z, this
        }
        add(i) {
            return this.x += i.x, this.y += i.y, this.z += i.z, this
        }
        addScalar(i) {
            return this.x += i, this.y += i, this.z += i, this
        }
        addVectors(i, o) {
            return this.x = i.x + o.x, this.y = i.y + o.y, this.z = i.z + o.z, this
        }
        addScaledVector(i, o) {
            return this.x += i.x * o, this.y += i.y * o, this.z += i.z * o, this
        }
        sub(i) {
            return this.x -= i.x, this.y -= i.y, this.z -= i.z, this
        }
        subScalar(i) {
            return this.x -= i, this.y -= i, this.z -= i, this
        }
        subVectors(i, o) {
            return this.x = i.x - o.x, this.y = i.y - o.y, this.z = i.z - o.z, this
        }
        multiply(i) {
            return this.x *= i.x, this.y *= i.y, this.z *= i.z, this
        }
        multiplyScalar(i) {
            return this.x *= i, this.y *= i, this.z *= i, this
        }
        multiplyVectors(i, o) {
            return this.x = i.x * o.x, this.y = i.y * o.y, this.z = i.z * o.z, this
        }
        applyEuler(i) {
            return this.applyQuaternion(_quaternion$4.setFromEuler(i))
        }
        applyAxisAngle(i, o) {
            return this.applyQuaternion(_quaternion$4.setFromAxisAngle(i, o))
        }
        applyMatrix3(i) {
            const o = this.x,
                c = this.y,
                u = this.z,
                p = i.elements;
            return this.x = p[0] * o + p[3] * c + p[6] * u, this.y = p[1] * o + p[4] * c + p[7] * u, this.z = p[2] * o + p[5] * c + p[8] * u, this
        }
        applyNormalMatrix(i) {
            return this.applyMatrix3(i).normalize()
        }
        applyMatrix4(i) {
            const o = this.x,
                c = this.y,
                u = this.z,
                p = i.elements,
                m = 1 / (p[3] * o + p[7] * c + p[11] * u + p[15]);
            return this.x = (p[0] * o + p[4] * c + p[8] * u + p[12]) * m, this.y = (p[1] * o + p[5] * c + p[9] * u + p[13]) * m, this.z = (p[2] * o + p[6] * c + p[10] * u + p[14]) * m, this
        }
        applyQuaternion(i) {
            const o = this.x,
                c = this.y,
                u = this.z,
                p = i.x,
                m = i.y,
                g = i.z,
                _ = i.w,
                v = 2 * (m * u - g * c),
                x = 2 * (g * o - p * u),
                y = 2 * (p * c - m * o);
            return this.x = o + _ * v + m * y - g * x, this.y = c + _ * x + g * v - p * y, this.z = u + _ * y + p * x - m * v, this
        }
        project(i) {
            return this.applyMatrix4(i.matrixWorldInverse).applyMatrix4(i.projectionMatrix)
        }
        unproject(i) {
            return this.applyMatrix4(i.projectionMatrixInverse).applyMatrix4(i.matrixWorld)
        }
        transformDirection(i) {
            const o = this.x,
                c = this.y,
                u = this.z,
                p = i.elements;
            return this.x = p[0] * o + p[4] * c + p[8] * u, this.y = p[1] * o + p[5] * c + p[9] * u, this.z = p[2] * o + p[6] * c + p[10] * u, this.normalize()
        }
        divide(i) {
            return this.x /= i.x, this.y /= i.y, this.z /= i.z, this
        }
        divideScalar(i) {
            return this.multiplyScalar(1 / i)
        }
        min(i) {
            return this.x = Math.min(this.x, i.x), this.y = Math.min(this.y, i.y), this.z = Math.min(this.z, i.z), this
        }
        max(i) {
            return this.x = Math.max(this.x, i.x), this.y = Math.max(this.y, i.y), this.z = Math.max(this.z, i.z), this
        }
        clamp(i, o) {
            return this.x = clamp$3(this.x, i.x, o.x), this.y = clamp$3(this.y, i.y, o.y), this.z = clamp$3(this.z, i.z, o.z), this
        }
        clampScalar(i, o) {
            return this.x = clamp$3(this.x, i, o), this.y = clamp$3(this.y, i, o), this.z = clamp$3(this.z, i, o), this
        }
        clampLength(i, o) {
            const c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(clamp$3(c, i, o))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }
        dot(i) {
            return this.x * i.x + this.y * i.y + this.z * i.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(i) {
            return this.normalize().multiplyScalar(i)
        }
        lerp(i, o) {
            return this.x += (i.x - this.x) * o, this.y += (i.y - this.y) * o, this.z += (i.z - this.z) * o, this
        }
        lerpVectors(i, o, c) {
            return this.x = i.x + (o.x - i.x) * c, this.y = i.y + (o.y - i.y) * c, this.z = i.z + (o.z - i.z) * c, this
        }
        cross(i) {
            return this.crossVectors(this, i)
        }
        crossVectors(i, o) {
            const c = i.x,
                u = i.y,
                p = i.z,
                m = o.x,
                g = o.y,
                _ = o.z;
            return this.x = u * _ - p * g, this.y = p * m - c * _, this.z = c * g - u * m, this
        }
        projectOnVector(i) {
            const o = i.lengthSq();
            if (o === 0) return this.set(0, 0, 0);
            const c = i.dot(this) / o;
            return this.copy(i).multiplyScalar(c)
        }
        projectOnPlane(i) {
            return _vector$c.copy(this).projectOnVector(i), this.sub(_vector$c)
        }
        reflect(i) {
            return this.sub(_vector$c.copy(i).multiplyScalar(2 * this.dot(i)))
        }
        angleTo(i) {
            const o = Math.sqrt(this.lengthSq() * i.lengthSq());
            if (o === 0) return Math.PI / 2;
            const c = this.dot(i) / o;
            return Math.acos(clamp$3(c, -1, 1))
        }
        distanceTo(i) {
            return Math.sqrt(this.distanceToSquared(i))
        }
        distanceToSquared(i) {
            const o = this.x - i.x,
                c = this.y - i.y,
                u = this.z - i.z;
            return o * o + c * c + u * u
        }
        manhattanDistanceTo(i) {
            return Math.abs(this.x - i.x) + Math.abs(this.y - i.y) + Math.abs(this.z - i.z)
        }
        setFromSpherical(i) {
            return this.setFromSphericalCoords(i.radius, i.phi, i.theta)
        }
        setFromSphericalCoords(i, o, c) {
            const u = Math.sin(o) * i;
            return this.x = u * Math.sin(c), this.y = Math.cos(o) * i, this.z = u * Math.cos(c), this
        }
        setFromCylindrical(i) {
            return this.setFromCylindricalCoords(i.radius, i.theta, i.y)
        }
        setFromCylindricalCoords(i, o, c) {
            return this.x = i * Math.sin(o), this.y = c, this.z = i * Math.cos(o), this
        }
        setFromMatrixPosition(i) {
            const o = i.elements;
            return this.x = o[12], this.y = o[13], this.z = o[14], this
        }
        setFromMatrixScale(i) {
            const o = this.setFromMatrixColumn(i, 0).length(),
                c = this.setFromMatrixColumn(i, 1).length(),
                u = this.setFromMatrixColumn(i, 2).length();
            return this.x = o, this.y = c, this.z = u, this
        }
        setFromMatrixColumn(i, o) {
            return this.fromArray(i.elements, o * 4)
        }
        setFromMatrix3Column(i, o) {
            return this.fromArray(i.elements, o * 3)
        }
        setFromEuler(i) {
            return this.x = i._x, this.y = i._y, this.z = i._z, this
        }
        setFromColor(i) {
            return this.x = i.r, this.y = i.g, this.z = i.b, this
        }
        equals(i) {
            return i.x === this.x && i.y === this.y && i.z === this.z
        }
        fromArray(i, o = 0) {
            return this.x = i[o], this.y = i[o + 1], this.z = i[o + 2], this
        }
        toArray(i = [], o = 0) {
            return i[o] = this.x, i[o + 1] = this.y, i[o + 2] = this.z, i
        }
        fromBufferAttribute(i, o) {
            return this.x = i.getX(o), this.y = i.getY(o), this.z = i.getZ(o), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
        randomDirection() {
            const i = Math.random() * Math.PI * 2,
                o = Math.random() * 2 - 1,
                c = Math.sqrt(1 - o * o);
            return this.x = c * Math.cos(i), this.y = o, this.z = c * Math.sin(i), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z
        }
    };
const _vector$c = new Vector3$1,
    _quaternion$4 = new Quaternion$1;
class Matrix3 {
    constructor(i, o, c, u, p, m, g, _, v) {
        Matrix3.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], i !== void 0 && this.set(i, o, c, u, p, m, g, _, v)
    }
    set(i, o, c, u, p, m, g, _, v) {
        const x = this.elements;
        return x[0] = i, x[1] = u, x[2] = g, x[3] = o, x[4] = p, x[5] = _, x[6] = c, x[7] = m, x[8] = v, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(i) {
        const o = this.elements,
            c = i.elements;
        return o[0] = c[0], o[1] = c[1], o[2] = c[2], o[3] = c[3], o[4] = c[4], o[5] = c[5], o[6] = c[6], o[7] = c[7], o[8] = c[8], this
    }
    extractBasis(i, o, c) {
        return i.setFromMatrix3Column(this, 0), o.setFromMatrix3Column(this, 1), c.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(i) {
        const o = i.elements;
        return this.set(o[0], o[4], o[8], o[1], o[5], o[9], o[2], o[6], o[10]), this
    }
    multiply(i) {
        return this.multiplyMatrices(this, i)
    }
    premultiply(i) {
        return this.multiplyMatrices(i, this)
    }
    multiplyMatrices(i, o) {
        const c = i.elements,
            u = o.elements,
            p = this.elements,
            m = c[0],
            g = c[3],
            _ = c[6],
            v = c[1],
            x = c[4],
            y = c[7],
            b = c[2],
            S = c[5],
            C = c[8],
            E = u[0],
            P = u[3],
            w = u[6],
            T = u[1],
            M = u[4],
            A = u[7],
            D = u[2],
            R = u[5],
            I = u[8];
        return p[0] = m * E + g * T + _ * D, p[3] = m * P + g * M + _ * R, p[6] = m * w + g * A + _ * I, p[1] = v * E + x * T + y * D, p[4] = v * P + x * M + y * R, p[7] = v * w + x * A + y * I, p[2] = b * E + S * T + C * D, p[5] = b * P + S * M + C * R, p[8] = b * w + S * A + C * I, this
    }
    multiplyScalar(i) {
        const o = this.elements;
        return o[0] *= i, o[3] *= i, o[6] *= i, o[1] *= i, o[4] *= i, o[7] *= i, o[2] *= i, o[5] *= i, o[8] *= i, this
    }
    determinant() {
        const i = this.elements,
            o = i[0],
            c = i[1],
            u = i[2],
            p = i[3],
            m = i[4],
            g = i[5],
            _ = i[6],
            v = i[7],
            x = i[8];
        return o * m * x - o * g * v - c * p * x + c * g * _ + u * p * v - u * m * _
    }
    invert() {
        const i = this.elements,
            o = i[0],
            c = i[1],
            u = i[2],
            p = i[3],
            m = i[4],
            g = i[5],
            _ = i[6],
            v = i[7],
            x = i[8],
            y = x * m - g * v,
            b = g * _ - x * p,
            S = v * p - m * _,
            C = o * y + c * b + u * S;
        if (C === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const E = 1 / C;
        return i[0] = y * E, i[1] = (u * v - x * c) * E, i[2] = (g * c - u * m) * E, i[3] = b * E, i[4] = (x * o - u * _) * E, i[5] = (u * p - g * o) * E, i[6] = S * E, i[7] = (c * _ - v * o) * E, i[8] = (m * o - c * p) * E, this
    }
    transpose() {
        let i;
        const o = this.elements;
        return i = o[1], o[1] = o[3], o[3] = i, i = o[2], o[2] = o[6], o[6] = i, i = o[5], o[5] = o[7], o[7] = i, this
    }
    getNormalMatrix(i) {
        return this.setFromMatrix4(i).invert().transpose()
    }
    transposeIntoArray(i) {
        const o = this.elements;
        return i[0] = o[0], i[1] = o[3], i[2] = o[6], i[3] = o[1], i[4] = o[4], i[5] = o[7], i[6] = o[2], i[7] = o[5], i[8] = o[8], this
    }
    setUvTransform(i, o, c, u, p, m, g) {
        const _ = Math.cos(p),
            v = Math.sin(p);
        return this.set(c * _, c * v, -c * (_ * m + v * g) + m + i, -u * v, u * _, -u * (-v * m + _ * g) + g + o, 0, 0, 1), this
    }
    scale(i, o) {
        return this.premultiply(_m3.makeScale(i, o)), this
    }
    rotate(i) {
        return this.premultiply(_m3.makeRotation(-i)), this
    }
    translate(i, o) {
        return this.premultiply(_m3.makeTranslation(i, o)), this
    }
    makeTranslation(i, o) {
        return i.isVector2 ? this.set(1, 0, i.x, 0, 1, i.y, 0, 0, 1) : this.set(1, 0, i, 0, 1, o, 0, 0, 1), this
    }
    makeRotation(i) {
        const o = Math.cos(i),
            c = Math.sin(i);
        return this.set(o, -c, 0, c, o, 0, 0, 0, 1), this
    }
    makeScale(i, o) {
        return this.set(i, 0, 0, 0, o, 0, 0, 0, 1), this
    }
    equals(i) {
        const o = this.elements,
            c = i.elements;
        for (let u = 0; u < 9; u++)
            if (o[u] !== c[u]) return !1;
        return !0
    }
    fromArray(i, o = 0) {
        for (let c = 0; c < 9; c++) this.elements[c] = i[c + o];
        return this
    }
    toArray(i = [], o = 0) {
        const c = this.elements;
        return i[o] = c[0], i[o + 1] = c[1], i[o + 2] = c[2], i[o + 3] = c[3], i[o + 4] = c[4], i[o + 5] = c[5], i[o + 6] = c[6], i[o + 7] = c[7], i[o + 8] = c[8], i
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const _m3 = new Matrix3;

function arrayNeedsUint32(l) {
    for (let i = l.length - 1; i >= 0; --i)
        if (l[i] >= 65535) return !0;
    return !1
}

function createElementNS(l) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", l)
}

function createCanvasElement() {
    const l = createElementNS("canvas");
    return l.style.display = "block", l
}
const _cache = {};

function warnOnce(l) {
    l in _cache || (_cache[l] = !0, console.warn(l))
}

function probeAsync(l, i, o) {
    return new Promise(function(c, u) {
        function p() {
            switch (l.clientWaitSync(i, l.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                case l.WAIT_FAILED:
                    u();
                    break;
                case l.TIMEOUT_EXPIRED:
                    setTimeout(p, o);
                    break;
                default:
                    c()
            }
        }
        setTimeout(p, o)
    })
}

function toNormalizedProjectionMatrix(l) {
    const i = l.elements;
    i[2] = .5 * i[2] + .5 * i[3], i[6] = .5 * i[6] + .5 * i[7], i[10] = .5 * i[10] + .5 * i[11], i[14] = .5 * i[14] + .5 * i[15]
}

function toReversedProjectionMatrix(l) {
    const i = l.elements;
    i[11] === -1 ? (i[10] = -i[10] - 1, i[14] = -i[14]) : (i[10] = -i[10], i[14] = -i[14] + 1)
}
const LINEAR_REC709_TO_XYZ = new Matrix3().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322),
    XYZ_TO_LINEAR_REC709 = new Matrix3().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);

function createColorManagement() {
    const l = {
            enabled: !0,
            workingColorSpace: LinearSRGBColorSpace,
            spaces: {},
            convert: function(u, p, m) {
                return this.enabled === !1 || p === m || !p || !m || (this.spaces[p].transfer === SRGBTransfer && (u.r = SRGBToLinear(u.r), u.g = SRGBToLinear(u.g), u.b = SRGBToLinear(u.b)), this.spaces[p].primaries !== this.spaces[m].primaries && (u.applyMatrix3(this.spaces[p].toXYZ), u.applyMatrix3(this.spaces[m].fromXYZ)), this.spaces[m].transfer === SRGBTransfer && (u.r = LinearToSRGB(u.r), u.g = LinearToSRGB(u.g), u.b = LinearToSRGB(u.b))), u
            },
            workingToColorSpace: function(u, p) {
                return this.convert(u, this.workingColorSpace, p)
            },
            colorSpaceToWorking: function(u, p) {
                return this.convert(u, p, this.workingColorSpace)
            },
            getPrimaries: function(u) {
                return this.spaces[u].primaries
            },
            getTransfer: function(u) {
                return u === NoColorSpace ? LinearTransfer : this.spaces[u].transfer
            },
            getLuminanceCoefficients: function(u, p = this.workingColorSpace) {
                return u.fromArray(this.spaces[p].luminanceCoefficients)
            },
            define: function(u) {
                Object.assign(this.spaces, u)
            },
            _getMatrix: function(u, p, m) {
                return u.copy(this.spaces[p].toXYZ).multiply(this.spaces[m].fromXYZ)
            },
            _getDrawingBufferColorSpace: function(u) {
                return this.spaces[u].outputColorSpaceConfig.drawingBufferColorSpace
            },
            _getUnpackColorSpace: function(u = this.workingColorSpace) {
                return this.spaces[u].workingColorSpaceConfig.unpackColorSpace
            },
            fromWorkingColorSpace: function(u, p) {
                return warnOnce("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), l.workingToColorSpace(u, p)
            },
            toWorkingColorSpace: function(u, p) {
                return warnOnce("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), l.colorSpaceToWorking(u, p)
            }
        },
        i = [.64, .33, .3, .6, .15, .06],
        o = [.2126, .7152, .0722],
        c = [.3127, .329];
    return l.define({
        [LinearSRGBColorSpace]: {
            primaries: i,
            whitePoint: c,
            transfer: LinearTransfer,
            toXYZ: LINEAR_REC709_TO_XYZ,
            fromXYZ: XYZ_TO_LINEAR_REC709,
            luminanceCoefficients: o,
            workingColorSpaceConfig: {
                unpackColorSpace: SRGBColorSpace
            },
            outputColorSpaceConfig: {
                drawingBufferColorSpace: SRGBColorSpace
            }
        },
        [SRGBColorSpace]: {
            primaries: i,
            whitePoint: c,
            transfer: SRGBTransfer,
            toXYZ: LINEAR_REC709_TO_XYZ,
            fromXYZ: XYZ_TO_LINEAR_REC709,
            luminanceCoefficients: o,
            outputColorSpaceConfig: {
                drawingBufferColorSpace: SRGBColorSpace
            }
        }
    }), l
}
const ColorManagement = createColorManagement();

function SRGBToLinear(l) {
    return l < .04045 ? l * .0773993808 : Math.pow(l * .9478672986 + .0521327014, 2.4)
}

function LinearToSRGB(l) {
    return l < .0031308 ? l * 12.92 : 1.055 * Math.pow(l, .41666) - .055
}
let _canvas;
class ImageUtils {
    static getDataURL(i, o = "image/png") {
        if (/^data:/i.test(i.src) || typeof HTMLCanvasElement > "u") return i.src;
        let c;
        if (i instanceof HTMLCanvasElement) c = i;
        else {
            _canvas === void 0 && (_canvas = createElementNS("canvas")), _canvas.width = i.width, _canvas.height = i.height;
            const u = _canvas.getContext("2d");
            i instanceof ImageData ? u.putImageData(i, 0, 0) : u.drawImage(i, 0, 0, i.width, i.height), c = _canvas
        }
        return c.toDataURL(o)
    }
    static sRGBToLinear(i) {
        if (typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap) {
            const o = createElementNS("canvas");
            o.width = i.width, o.height = i.height;
            const c = o.getContext("2d");
            c.drawImage(i, 0, 0, i.width, i.height);
            const u = c.getImageData(0, 0, i.width, i.height),
                p = u.data;
            for (let m = 0; m < p.length; m++) p[m] = SRGBToLinear(p[m] / 255) * 255;
            return c.putImageData(u, 0, 0), o
        } else if (i.data) {
            const o = i.data.slice(0);
            for (let c = 0; c < o.length; c++) o instanceof Uint8Array || o instanceof Uint8ClampedArray ? o[c] = Math.floor(SRGBToLinear(o[c] / 255) * 255) : o[c] = SRGBToLinear(o[c]);
            return {
                data: o,
                width: i.width,
                height: i.height
            }
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), i
    }
}
let _sourceId = 0;
class Source {
    constructor(i = null) {
        this.isSource = !0, Object.defineProperty(this, "id", {
            value: _sourceId++
        }), this.uuid = generateUUID(), this.data = i, this.dataReady = !0, this.version = 0
    }
    getSize(i) {
        const o = this.data;
        return o instanceof HTMLVideoElement ? i.set(o.videoWidth, o.videoHeight) : o !== null ? i.set(o.width, o.height, o.depth || 0) : i.set(0, 0, 0), i
    }
    set needsUpdate(i) {
        i === !0 && this.version++
    }
    toJSON(i) {
        const o = i === void 0 || typeof i == "string";
        if (!o && i.images[this.uuid] !== void 0) return i.images[this.uuid];
        const c = {
                uuid: this.uuid,
                url: ""
            },
            u = this.data;
        if (u !== null) {
            let p;
            if (Array.isArray(u)) {
                p = [];
                for (let m = 0, g = u.length; m < g; m++) u[m].isDataTexture ? p.push(serializeImage(u[m].image)) : p.push(serializeImage(u[m]))
            } else p = serializeImage(u);
            c.url = p
        }
        return o || (i.images[this.uuid] = c), c
    }
}

function serializeImage(l) {
    return typeof HTMLImageElement < "u" && l instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && l instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && l instanceof ImageBitmap ? ImageUtils.getDataURL(l) : l.data ? {
        data: Array.from(l.data),
        width: l.width,
        height: l.height,
        type: l.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let _textureId = 0;
const _tempVec3 = new Vector3$1;
class Texture extends EventDispatcher {
    constructor(i = Texture.DEFAULT_IMAGE, o = Texture.DEFAULT_MAPPING, c = ClampToEdgeWrapping, u = ClampToEdgeWrapping, p = LinearFilter, m = LinearMipmapLinearFilter, g = RGBAFormat, _ = UnsignedByteType, v = Texture.DEFAULT_ANISOTROPY, x = NoColorSpace) {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
            value: _textureId++
        }), this.uuid = generateUUID(), this.name = "", this.source = new Source(i), this.mipmaps = [], this.mapping = o, this.channel = 0, this.wrapS = c, this.wrapT = u, this.magFilter = p, this.minFilter = m, this.anisotropy = v, this.format = g, this.internalFormat = null, this.type = _, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = x, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(i && i.depth && i.depth > 1), this.pmremVersion = 0
    }
    get width() {
        return this.source.getSize(_tempVec3).x
    }
    get height() {
        return this.source.getSize(_tempVec3).y
    }
    get depth() {
        return this.source.getSize(_tempVec3).z
    }
    get image() {
        return this.source.data
    }
    set image(i = null) {
        this.source.data = i
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    addUpdateRange(i, o) {
        this.updateRanges.push({
            start: i,
            count: o
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(i) {
        return this.name = i.name, this.source = i.source, this.mipmaps = i.mipmaps.slice(0), this.mapping = i.mapping, this.channel = i.channel, this.wrapS = i.wrapS, this.wrapT = i.wrapT, this.magFilter = i.magFilter, this.minFilter = i.minFilter, this.anisotropy = i.anisotropy, this.format = i.format, this.internalFormat = i.internalFormat, this.type = i.type, this.offset.copy(i.offset), this.repeat.copy(i.repeat), this.center.copy(i.center), this.rotation = i.rotation, this.matrixAutoUpdate = i.matrixAutoUpdate, this.matrix.copy(i.matrix), this.generateMipmaps = i.generateMipmaps, this.premultiplyAlpha = i.premultiplyAlpha, this.flipY = i.flipY, this.unpackAlignment = i.unpackAlignment, this.colorSpace = i.colorSpace, this.renderTarget = i.renderTarget, this.isRenderTargetTexture = i.isRenderTargetTexture, this.isArrayTexture = i.isArrayTexture, this.userData = JSON.parse(JSON.stringify(i.userData)), this.needsUpdate = !0, this
    }
    setValues(i) {
        for (const o in i) {
            const c = i[o];
            if (c === void 0) {
                console.warn(`THREE.Texture.setValues(): parameter '${o}' has value of undefined.`);
                continue
            }
            const u = this[o];
            if (u === void 0) {
                console.warn(`THREE.Texture.setValues(): property '${o}' does not exist.`);
                continue
            }
            u && c && u.isVector2 && c.isVector2 || u && c && u.isVector3 && c.isVector3 || u && c && u.isMatrix3 && c.isMatrix3 ? u.copy(c) : this[o] = c
        }
    }
    toJSON(i) {
        const o = i === void 0 || typeof i == "string";
        if (!o && i.textures[this.uuid] !== void 0) return i.textures[this.uuid];
        const c = {
            metadata: {
                version: 4.7,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(i).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (c.userData = this.userData), o || (i.textures[this.uuid] = c), c
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(i) {
        if (this.mapping !== UVMapping) return i;
        if (i.applyMatrix3(this.matrix), i.x < 0 || i.x > 1) switch (this.wrapS) {
            case RepeatWrapping:
                i.x = i.x - Math.floor(i.x);
                break;
            case ClampToEdgeWrapping:
                i.x = i.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                Math.abs(Math.floor(i.x) % 2) === 1 ? i.x = Math.ceil(i.x) - i.x : i.x = i.x - Math.floor(i.x);
                break
        }
        if (i.y < 0 || i.y > 1) switch (this.wrapT) {
            case RepeatWrapping:
                i.y = i.y - Math.floor(i.y);
                break;
            case ClampToEdgeWrapping:
                i.y = i.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                Math.abs(Math.floor(i.y) % 2) === 1 ? i.y = Math.ceil(i.y) - i.y : i.y = i.y - Math.floor(i.y);
                break
        }
        return this.flipY && (i.y = 1 - i.y), i
    }
    set needsUpdate(i) {
        i === !0 && (this.version++, this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(i) {
        i === !0 && this.pmremVersion++
    }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
    constructor(i = 0, o = 0, c = 0, u = 1) {
        Vector4.prototype.isVector4 = !0, this.x = i, this.y = o, this.z = c, this.w = u
    }
    get width() {
        return this.z
    }
    set width(i) {
        this.z = i
    }
    get height() {
        return this.w
    }
    set height(i) {
        this.w = i
    }
    set(i, o, c, u) {
        return this.x = i, this.y = o, this.z = c, this.w = u, this
    }
    setScalar(i) {
        return this.x = i, this.y = i, this.z = i, this.w = i, this
    }
    setX(i) {
        return this.x = i, this
    }
    setY(i) {
        return this.y = i, this
    }
    setZ(i) {
        return this.z = i, this
    }
    setW(i) {
        return this.w = i, this
    }
    setComponent(i, o) {
        switch (i) {
            case 0:
                this.x = o;
                break;
            case 1:
                this.y = o;
                break;
            case 2:
                this.z = o;
                break;
            case 3:
                this.w = o;
                break;
            default:
                throw new Error("index is out of range: " + i)
        }
        return this
    }
    getComponent(i) {
        switch (i) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + i)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(i) {
        return this.x = i.x, this.y = i.y, this.z = i.z, this.w = i.w !== void 0 ? i.w : 1, this
    }
    add(i) {
        return this.x += i.x, this.y += i.y, this.z += i.z, this.w += i.w, this
    }
    addScalar(i) {
        return this.x += i, this.y += i, this.z += i, this.w += i, this
    }
    addVectors(i, o) {
        return this.x = i.x + o.x, this.y = i.y + o.y, this.z = i.z + o.z, this.w = i.w + o.w, this
    }
    addScaledVector(i, o) {
        return this.x += i.x * o, this.y += i.y * o, this.z += i.z * o, this.w += i.w * o, this
    }
    sub(i) {
        return this.x -= i.x, this.y -= i.y, this.z -= i.z, this.w -= i.w, this
    }
    subScalar(i) {
        return this.x -= i, this.y -= i, this.z -= i, this.w -= i, this
    }
    subVectors(i, o) {
        return this.x = i.x - o.x, this.y = i.y - o.y, this.z = i.z - o.z, this.w = i.w - o.w, this
    }
    multiply(i) {
        return this.x *= i.x, this.y *= i.y, this.z *= i.z, this.w *= i.w, this
    }
    multiplyScalar(i) {
        return this.x *= i, this.y *= i, this.z *= i, this.w *= i, this
    }
    applyMatrix4(i) {
        const o = this.x,
            c = this.y,
            u = this.z,
            p = this.w,
            m = i.elements;
        return this.x = m[0] * o + m[4] * c + m[8] * u + m[12] * p, this.y = m[1] * o + m[5] * c + m[9] * u + m[13] * p, this.z = m[2] * o + m[6] * c + m[10] * u + m[14] * p, this.w = m[3] * o + m[7] * c + m[11] * u + m[15] * p, this
    }
    divide(i) {
        return this.x /= i.x, this.y /= i.y, this.z /= i.z, this.w /= i.w, this
    }
    divideScalar(i) {
        return this.multiplyScalar(1 / i)
    }
    setAxisAngleFromQuaternion(i) {
        this.w = 2 * Math.acos(i.w);
        const o = Math.sqrt(1 - i.w * i.w);
        return o < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = i.x / o, this.y = i.y / o, this.z = i.z / o), this
    }
    setAxisAngleFromRotationMatrix(i) {
        let o, c, u, p;
        const _ = i.elements,
            v = _[0],
            x = _[4],
            y = _[8],
            b = _[1],
            S = _[5],
            C = _[9],
            E = _[2],
            P = _[6],
            w = _[10];
        if (Math.abs(x - b) < .01 && Math.abs(y - E) < .01 && Math.abs(C - P) < .01) {
            if (Math.abs(x + b) < .1 && Math.abs(y + E) < .1 && Math.abs(C + P) < .1 && Math.abs(v + S + w - 3) < .1) return this.set(1, 0, 0, 0), this;
            o = Math.PI;
            const M = (v + 1) / 2,
                A = (S + 1) / 2,
                D = (w + 1) / 2,
                R = (x + b) / 4,
                I = (y + E) / 4,
                k = (C + P) / 4;
            return M > A && M > D ? M < .01 ? (c = 0, u = .707106781, p = .707106781) : (c = Math.sqrt(M), u = R / c, p = I / c) : A > D ? A < .01 ? (c = .707106781, u = 0, p = .707106781) : (u = Math.sqrt(A), c = R / u, p = k / u) : D < .01 ? (c = .707106781, u = .707106781, p = 0) : (p = Math.sqrt(D), c = I / p, u = k / p), this.set(c, u, p, o), this
        }
        let T = Math.sqrt((P - C) * (P - C) + (y - E) * (y - E) + (b - x) * (b - x));
        return Math.abs(T) < .001 && (T = 1), this.x = (P - C) / T, this.y = (y - E) / T, this.z = (b - x) / T, this.w = Math.acos((v + S + w - 1) / 2), this
    }
    setFromMatrixPosition(i) {
        const o = i.elements;
        return this.x = o[12], this.y = o[13], this.z = o[14], this.w = o[15], this
    }
    min(i) {
        return this.x = Math.min(this.x, i.x), this.y = Math.min(this.y, i.y), this.z = Math.min(this.z, i.z), this.w = Math.min(this.w, i.w), this
    }
    max(i) {
        return this.x = Math.max(this.x, i.x), this.y = Math.max(this.y, i.y), this.z = Math.max(this.z, i.z), this.w = Math.max(this.w, i.w), this
    }
    clamp(i, o) {
        return this.x = clamp$3(this.x, i.x, o.x), this.y = clamp$3(this.y, i.y, o.y), this.z = clamp$3(this.z, i.z, o.z), this.w = clamp$3(this.w, i.w, o.w), this
    }
    clampScalar(i, o) {
        return this.x = clamp$3(this.x, i, o), this.y = clamp$3(this.y, i, o), this.z = clamp$3(this.z, i, o), this.w = clamp$3(this.w, i, o), this
    }
    clampLength(i, o) {
        const c = this.length();
        return this.divideScalar(c || 1).multiplyScalar(clamp$3(c, i, o))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(i) {
        return this.x * i.x + this.y * i.y + this.z * i.z + this.w * i.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(i) {
        return this.normalize().multiplyScalar(i)
    }
    lerp(i, o) {
        return this.x += (i.x - this.x) * o, this.y += (i.y - this.y) * o, this.z += (i.z - this.z) * o, this.w += (i.w - this.w) * o, this
    }
    lerpVectors(i, o, c) {
        return this.x = i.x + (o.x - i.x) * c, this.y = i.y + (o.y - i.y) * c, this.z = i.z + (o.z - i.z) * c, this.w = i.w + (o.w - i.w) * c, this
    }
    equals(i) {
        return i.x === this.x && i.y === this.y && i.z === this.z && i.w === this.w
    }
    fromArray(i, o = 0) {
        return this.x = i[o], this.y = i[o + 1], this.z = i[o + 2], this.w = i[o + 3], this
    }
    toArray(i = [], o = 0) {
        return i[o] = this.x, i[o + 1] = this.y, i[o + 2] = this.z, i[o + 3] = this.w, i
    }
    fromBufferAttribute(i, o) {
        return this.x = i.getX(o), this.y = i.getY(o), this.z = i.getZ(o), this.w = i.getW(o), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w
    }
}
class RenderTarget extends EventDispatcher {
    constructor(i = 1, o = 1, c = {}) {
        super(), c = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: LinearFilter,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1,
            depth: 1,
            multiview: !1
        }, c), this.isRenderTarget = !0, this.width = i, this.height = o, this.depth = c.depth, this.scissor = new Vector4(0, 0, i, o), this.scissorTest = !1, this.viewport = new Vector4(0, 0, i, o);
        const u = {
                width: i,
                height: o,
                depth: c.depth
            },
            p = new Texture(u);
        this.textures = [];
        const m = c.count;
        for (let g = 0; g < m; g++) this.textures[g] = p.clone(), this.textures[g].isRenderTargetTexture = !0, this.textures[g].renderTarget = this;
        this._setTextureOptions(c), this.depthBuffer = c.depthBuffer, this.stencilBuffer = c.stencilBuffer, this.resolveDepthBuffer = c.resolveDepthBuffer, this.resolveStencilBuffer = c.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = c.depthTexture, this.samples = c.samples, this.multiview = c.multiview
    }
    _setTextureOptions(i = {}) {
        const o = {
            minFilter: LinearFilter,
            generateMipmaps: !1,
            flipY: !1,
            internalFormat: null
        };
        i.mapping !== void 0 && (o.mapping = i.mapping), i.wrapS !== void 0 && (o.wrapS = i.wrapS), i.wrapT !== void 0 && (o.wrapT = i.wrapT), i.wrapR !== void 0 && (o.wrapR = i.wrapR), i.magFilter !== void 0 && (o.magFilter = i.magFilter), i.minFilter !== void 0 && (o.minFilter = i.minFilter), i.format !== void 0 && (o.format = i.format), i.type !== void 0 && (o.type = i.type), i.anisotropy !== void 0 && (o.anisotropy = i.anisotropy), i.colorSpace !== void 0 && (o.colorSpace = i.colorSpace), i.flipY !== void 0 && (o.flipY = i.flipY), i.generateMipmaps !== void 0 && (o.generateMipmaps = i.generateMipmaps), i.internalFormat !== void 0 && (o.internalFormat = i.internalFormat);
        for (let c = 0; c < this.textures.length; c++) this.textures[c].setValues(o)
    }
    get texture() {
        return this.textures[0]
    }
    set texture(i) {
        this.textures[0] = i
    }
    set depthTexture(i) {
        this._depthTexture !== null && (this._depthTexture.renderTarget = null), i !== null && (i.renderTarget = this), this._depthTexture = i
    }
    get depthTexture() {
        return this._depthTexture
    }
    setSize(i, o, c = 1) {
        if (this.width !== i || this.height !== o || this.depth !== c) {
            this.width = i, this.height = o, this.depth = c;
            for (let u = 0, p = this.textures.length; u < p; u++) this.textures[u].image.width = i, this.textures[u].image.height = o, this.textures[u].image.depth = c, this.textures[u].isArrayTexture = this.textures[u].image.depth > 1;
            this.dispose()
        }
        this.viewport.set(0, 0, i, o), this.scissor.set(0, 0, i, o)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(i) {
        this.width = i.width, this.height = i.height, this.depth = i.depth, this.scissor.copy(i.scissor), this.scissorTest = i.scissorTest, this.viewport.copy(i.viewport), this.textures.length = 0;
        for (let o = 0, c = i.textures.length; o < c; o++) {
            this.textures[o] = i.textures[o].clone(), this.textures[o].isRenderTargetTexture = !0, this.textures[o].renderTarget = this;
            const u = Object.assign({}, i.textures[o].image);
            this.textures[o].source = new Source(u)
        }
        return this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, i.depthTexture !== null && (this.depthTexture = i.depthTexture.clone()), this.samples = i.samples, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class WebGLRenderTarget extends RenderTarget {
    constructor(i = 1, o = 1, c = {}) {
        super(i, o, c), this.isWebGLRenderTarget = !0
    }
}
class DataArrayTexture extends Texture {
    constructor(i = null, o = 1, c = 1, u = 1) {
        super(null), this.isDataArrayTexture = !0, this.image = {
            data: i,
            width: o,
            height: c,
            depth: u
        }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
    }
    addLayerUpdate(i) {
        this.layerUpdates.add(i)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class Data3DTexture extends Texture {
    constructor(i = null, o = 1, c = 1, u = 1) {
        super(null), this.isData3DTexture = !0, this.image = {
            data: i,
            width: o,
            height: c,
            depth: u
        }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class Box3 {
    constructor(i = new Vector3$1(1 / 0, 1 / 0, 1 / 0), o = new Vector3$1(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = i, this.max = o
    }
    set(i, o) {
        return this.min.copy(i), this.max.copy(o), this
    }
    setFromArray(i) {
        this.makeEmpty();
        for (let o = 0, c = i.length; o < c; o += 3) this.expandByPoint(_vector$b.fromArray(i, o));
        return this
    }
    setFromBufferAttribute(i) {
        this.makeEmpty();
        for (let o = 0, c = i.count; o < c; o++) this.expandByPoint(_vector$b.fromBufferAttribute(i, o));
        return this
    }
    setFromPoints(i) {
        this.makeEmpty();
        for (let o = 0, c = i.length; o < c; o++) this.expandByPoint(i[o]);
        return this
    }
    setFromCenterAndSize(i, o) {
        const c = _vector$b.copy(o).multiplyScalar(.5);
        return this.min.copy(i).sub(c), this.max.copy(i).add(c), this
    }
    setFromObject(i, o = !1) {
        return this.makeEmpty(), this.expandByObject(i, o)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(i) {
        return this.min.copy(i.min), this.max.copy(i.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(i) {
        return this.isEmpty() ? i.set(0, 0, 0) : i.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(i) {
        return this.isEmpty() ? i.set(0, 0, 0) : i.subVectors(this.max, this.min)
    }
    expandByPoint(i) {
        return this.min.min(i), this.max.max(i), this
    }
    expandByVector(i) {
        return this.min.sub(i), this.max.add(i), this
    }
    expandByScalar(i) {
        return this.min.addScalar(-i), this.max.addScalar(i), this
    }
    expandByObject(i, o = !1) {
        i.updateWorldMatrix(!1, !1);
        const c = i.geometry;
        if (c !== void 0) {
            const p = c.getAttribute("position");
            if (o === !0 && p !== void 0 && i.isInstancedMesh !== !0)
                for (let m = 0, g = p.count; m < g; m++) i.isMesh === !0 ? i.getVertexPosition(m, _vector$b) : _vector$b.fromBufferAttribute(p, m), _vector$b.applyMatrix4(i.matrixWorld), this.expandByPoint(_vector$b);
            else i.boundingBox !== void 0 ? (i.boundingBox === null && i.computeBoundingBox(), _box$4.copy(i.boundingBox)) : (c.boundingBox === null && c.computeBoundingBox(), _box$4.copy(c.boundingBox)), _box$4.applyMatrix4(i.matrixWorld), this.union(_box$4)
        }
        const u = i.children;
        for (let p = 0, m = u.length; p < m; p++) this.expandByObject(u[p], o);
        return this
    }
    containsPoint(i) {
        return i.x >= this.min.x && i.x <= this.max.x && i.y >= this.min.y && i.y <= this.max.y && i.z >= this.min.z && i.z <= this.max.z
    }
    containsBox(i) {
        return this.min.x <= i.min.x && i.max.x <= this.max.x && this.min.y <= i.min.y && i.max.y <= this.max.y && this.min.z <= i.min.z && i.max.z <= this.max.z
    }
    getParameter(i, o) {
        return o.set((i.x - this.min.x) / (this.max.x - this.min.x), (i.y - this.min.y) / (this.max.y - this.min.y), (i.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(i) {
        return i.max.x >= this.min.x && i.min.x <= this.max.x && i.max.y >= this.min.y && i.min.y <= this.max.y && i.max.z >= this.min.z && i.min.z <= this.max.z
    }
    intersectsSphere(i) {
        return this.clampPoint(i.center, _vector$b), _vector$b.distanceToSquared(i.center) <= i.radius * i.radius
    }
    intersectsPlane(i) {
        let o, c;
        return i.normal.x > 0 ? (o = i.normal.x * this.min.x, c = i.normal.x * this.max.x) : (o = i.normal.x * this.max.x, c = i.normal.x * this.min.x), i.normal.y > 0 ? (o += i.normal.y * this.min.y, c += i.normal.y * this.max.y) : (o += i.normal.y * this.max.y, c += i.normal.y * this.min.y), i.normal.z > 0 ? (o += i.normal.z * this.min.z, c += i.normal.z * this.max.z) : (o += i.normal.z * this.max.z, c += i.normal.z * this.min.z), o <= -i.constant && c >= -i.constant
    }
    intersectsTriangle(i) {
        if (this.isEmpty()) return !1;
        this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2.subVectors(i.a, _center), _v1$7.subVectors(i.b, _center), _v2$4.subVectors(i.c, _center), _f0.subVectors(_v1$7, _v0$2), _f1.subVectors(_v2$4, _v1$7), _f2.subVectors(_v0$2, _v2$4);
        let o = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
        return !satForAxes(o, _v0$2, _v1$7, _v2$4, _extents) || (o = [1, 0, 0, 0, 1, 0, 0, 0, 1], !satForAxes(o, _v0$2, _v1$7, _v2$4, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1), o = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], satForAxes(o, _v0$2, _v1$7, _v2$4, _extents))
    }
    clampPoint(i, o) {
        return o.copy(i).clamp(this.min, this.max)
    }
    distanceToPoint(i) {
        return this.clampPoint(i, _vector$b).distanceTo(i)
    }
    getBoundingSphere(i) {
        return this.isEmpty() ? i.makeEmpty() : (this.getCenter(i.center), i.radius = this.getSize(_vector$b).length() * .5), i
    }
    intersect(i) {
        return this.min.max(i.min), this.max.min(i.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(i) {
        return this.min.min(i.min), this.max.max(i.max), this
    }
    applyMatrix4(i) {
        return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(i), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(i), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(i), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(i), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(i), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(i), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(i), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(i), this.setFromPoints(_points), this)
    }
    translate(i) {
        return this.min.add(i), this.max.add(i), this
    }
    equals(i) {
        return i.min.equals(this.min) && i.max.equals(this.max)
    }
    toJSON() {
        return {
            min: this.min.toArray(),
            max: this.max.toArray()
        }
    }
    fromJSON(i) {
        return this.min.fromArray(i.min), this.max.fromArray(i.max), this
    }
}
const _points = [new Vector3$1, new Vector3$1, new Vector3$1, new Vector3$1, new Vector3$1, new Vector3$1, new Vector3$1, new Vector3$1],
    _vector$b = new Vector3$1,
    _box$4 = new Box3,
    _v0$2 = new Vector3$1,
    _v1$7 = new Vector3$1,
    _v2$4 = new Vector3$1,
    _f0 = new Vector3$1,
    _f1 = new Vector3$1,
    _f2 = new Vector3$1,
    _center = new Vector3$1,
    _extents = new Vector3$1,
    _triangleNormal = new Vector3$1,
    _testAxis = new Vector3$1;

function satForAxes(l, i, o, c, u) {
    for (let p = 0, m = l.length - 3; p <= m; p += 3) {
        _testAxis.fromArray(l, p);
        const g = u.x * Math.abs(_testAxis.x) + u.y * Math.abs(_testAxis.y) + u.z * Math.abs(_testAxis.z),
            _ = i.dot(_testAxis),
            v = o.dot(_testAxis),
            x = c.dot(_testAxis);
        if (Math.max(-Math.max(_, v, x), Math.min(_, v, x)) > g) return !1
    }
    return !0
}
const _box$3 = new Box3,
    _v1$6 = new Vector3$1,
    _v2$3 = new Vector3$1;
class Sphere {
    constructor(i = new Vector3$1, o = -1) {
        this.isSphere = !0, this.center = i, this.radius = o
    }
    set(i, o) {
        return this.center.copy(i), this.radius = o, this
    }
    setFromPoints(i, o) {
        const c = this.center;
        o !== void 0 ? c.copy(o) : _box$3.setFromPoints(i).getCenter(c);
        let u = 0;
        for (let p = 0, m = i.length; p < m; p++) u = Math.max(u, c.distanceToSquared(i[p]));
        return this.radius = Math.sqrt(u), this
    }
    copy(i) {
        return this.center.copy(i.center), this.radius = i.radius, this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(i) {
        return i.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(i) {
        return i.distanceTo(this.center) - this.radius
    }
    intersectsSphere(i) {
        const o = this.radius + i.radius;
        return i.center.distanceToSquared(this.center) <= o * o
    }
    intersectsBox(i) {
        return i.intersectsSphere(this)
    }
    intersectsPlane(i) {
        return Math.abs(i.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(i, o) {
        const c = this.center.distanceToSquared(i);
        return o.copy(i), c > this.radius * this.radius && (o.sub(this.center).normalize(), o.multiplyScalar(this.radius).add(this.center)), o
    }
    getBoundingBox(i) {
        return this.isEmpty() ? (i.makeEmpty(), i) : (i.set(this.center, this.center), i.expandByScalar(this.radius), i)
    }
    applyMatrix4(i) {
        return this.center.applyMatrix4(i), this.radius = this.radius * i.getMaxScaleOnAxis(), this
    }
    translate(i) {
        return this.center.add(i), this
    }
    expandByPoint(i) {
        if (this.isEmpty()) return this.center.copy(i), this.radius = 0, this;
        _v1$6.subVectors(i, this.center);
        const o = _v1$6.lengthSq();
        if (o > this.radius * this.radius) {
            const c = Math.sqrt(o),
                u = (c - this.radius) * .5;
            this.center.addScaledVector(_v1$6, u / c), this.radius += u
        }
        return this
    }
    union(i) {
        return i.isEmpty() ? this : this.isEmpty() ? (this.copy(i), this) : (this.center.equals(i.center) === !0 ? this.radius = Math.max(this.radius, i.radius) : (_v2$3.subVectors(i.center, this.center).setLength(i.radius), this.expandByPoint(_v1$6.copy(i.center).add(_v2$3)), this.expandByPoint(_v1$6.copy(i.center).sub(_v2$3))), this)
    }
    equals(i) {
        return i.center.equals(this.center) && i.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        return {
            radius: this.radius,
            center: this.center.toArray()
        }
    }
    fromJSON(i) {
        return this.radius = i.radius, this.center.fromArray(i.center), this
    }
}
const _vector$a = new Vector3$1,
    _segCenter = new Vector3$1,
    _segDir = new Vector3$1,
    _diff = new Vector3$1,
    _edge1 = new Vector3$1,
    _edge2 = new Vector3$1,
    _normal$1 = new Vector3$1;
class Ray {
    constructor(i = new Vector3$1, o = new Vector3$1(0, 0, -1)) {
        this.origin = i, this.direction = o
    }
    set(i, o) {
        return this.origin.copy(i), this.direction.copy(o), this
    }
    copy(i) {
        return this.origin.copy(i.origin), this.direction.copy(i.direction), this
    }
    at(i, o) {
        return o.copy(this.origin).addScaledVector(this.direction, i)
    }
    lookAt(i) {
        return this.direction.copy(i).sub(this.origin).normalize(), this
    }
    recast(i) {
        return this.origin.copy(this.at(i, _vector$a)), this
    }
    closestPointToPoint(i, o) {
        o.subVectors(i, this.origin);
        const c = o.dot(this.direction);
        return c < 0 ? o.copy(this.origin) : o.copy(this.origin).addScaledVector(this.direction, c)
    }
    distanceToPoint(i) {
        return Math.sqrt(this.distanceSqToPoint(i))
    }
    distanceSqToPoint(i) {
        const o = _vector$a.subVectors(i, this.origin).dot(this.direction);
        return o < 0 ? this.origin.distanceToSquared(i) : (_vector$a.copy(this.origin).addScaledVector(this.direction, o), _vector$a.distanceToSquared(i))
    }
    distanceSqToSegment(i, o, c, u) {
        _segCenter.copy(i).add(o).multiplyScalar(.5), _segDir.copy(o).sub(i).normalize(), _diff.copy(this.origin).sub(_segCenter);
        const p = i.distanceTo(o) * .5,
            m = -this.direction.dot(_segDir),
            g = _diff.dot(this.direction),
            _ = -_diff.dot(_segDir),
            v = _diff.lengthSq(),
            x = Math.abs(1 - m * m);
        let y, b, S, C;
        if (x > 0)
            if (y = m * _ - g, b = m * g - _, C = p * x, y >= 0)
                if (b >= -C)
                    if (b <= C) {
                        const E = 1 / x;
                        y *= E, b *= E, S = y * (y + m * b + 2 * g) + b * (m * y + b + 2 * _) + v
                    } else b = p, y = Math.max(0, -(m * b + g)), S = -y * y + b * (b + 2 * _) + v;
        else b = -p, y = Math.max(0, -(m * b + g)), S = -y * y + b * (b + 2 * _) + v;
        else b <= -C ? (y = Math.max(0, -(-m * p + g)), b = y > 0 ? -p : Math.min(Math.max(-p, -_), p), S = -y * y + b * (b + 2 * _) + v) : b <= C ? (y = 0, b = Math.min(Math.max(-p, -_), p), S = b * (b + 2 * _) + v) : (y = Math.max(0, -(m * p + g)), b = y > 0 ? p : Math.min(Math.max(-p, -_), p), S = -y * y + b * (b + 2 * _) + v);
        else b = m > 0 ? -p : p, y = Math.max(0, -(m * b + g)), S = -y * y + b * (b + 2 * _) + v;
        return c && c.copy(this.origin).addScaledVector(this.direction, y), u && u.copy(_segCenter).addScaledVector(_segDir, b), S
    }
    intersectSphere(i, o) {
        _vector$a.subVectors(i.center, this.origin);
        const c = _vector$a.dot(this.direction),
            u = _vector$a.dot(_vector$a) - c * c,
            p = i.radius * i.radius;
        if (u > p) return null;
        const m = Math.sqrt(p - u),
            g = c - m,
            _ = c + m;
        return _ < 0 ? null : g < 0 ? this.at(_, o) : this.at(g, o)
    }
    intersectsSphere(i) {
        return i.radius < 0 ? !1 : this.distanceSqToPoint(i.center) <= i.radius * i.radius
    }
    distanceToPlane(i) {
        const o = i.normal.dot(this.direction);
        if (o === 0) return i.distanceToPoint(this.origin) === 0 ? 0 : null;
        const c = -(this.origin.dot(i.normal) + i.constant) / o;
        return c >= 0 ? c : null
    }
    intersectPlane(i, o) {
        const c = this.distanceToPlane(i);
        return c === null ? null : this.at(c, o)
    }
    intersectsPlane(i) {
        const o = i.distanceToPoint(this.origin);
        return o === 0 || i.normal.dot(this.direction) * o < 0
    }
    intersectBox(i, o) {
        let c, u, p, m, g, _;
        const v = 1 / this.direction.x,
            x = 1 / this.direction.y,
            y = 1 / this.direction.z,
            b = this.origin;
        return v >= 0 ? (c = (i.min.x - b.x) * v, u = (i.max.x - b.x) * v) : (c = (i.max.x - b.x) * v, u = (i.min.x - b.x) * v), x >= 0 ? (p = (i.min.y - b.y) * x, m = (i.max.y - b.y) * x) : (p = (i.max.y - b.y) * x, m = (i.min.y - b.y) * x), c > m || p > u || ((p > c || isNaN(c)) && (c = p), (m < u || isNaN(u)) && (u = m), y >= 0 ? (g = (i.min.z - b.z) * y, _ = (i.max.z - b.z) * y) : (g = (i.max.z - b.z) * y, _ = (i.min.z - b.z) * y), c > _ || g > u) || ((g > c || c !== c) && (c = g), (_ < u || u !== u) && (u = _), u < 0) ? null : this.at(c >= 0 ? c : u, o)
    }
    intersectsBox(i) {
        return this.intersectBox(i, _vector$a) !== null
    }
    intersectTriangle(i, o, c, u, p) {
        _edge1.subVectors(o, i), _edge2.subVectors(c, i), _normal$1.crossVectors(_edge1, _edge2);
        let m = this.direction.dot(_normal$1),
            g;
        if (m > 0) {
            if (u) return null;
            g = 1
        } else if (m < 0) g = -1, m = -m;
        else return null;
        _diff.subVectors(this.origin, i);
        const _ = g * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (_ < 0) return null;
        const v = g * this.direction.dot(_edge1.cross(_diff));
        if (v < 0 || _ + v > m) return null;
        const x = -g * _diff.dot(_normal$1);
        return x < 0 ? null : this.at(x / m, p)
    }
    applyMatrix4(i) {
        return this.origin.applyMatrix4(i), this.direction.transformDirection(i), this
    }
    equals(i) {
        return i.origin.equals(this.origin) && i.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Matrix4 {
    constructor(i, o, c, u, p, m, g, _, v, x, y, b, S, C, E, P) {
        Matrix4.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], i !== void 0 && this.set(i, o, c, u, p, m, g, _, v, x, y, b, S, C, E, P)
    }
    set(i, o, c, u, p, m, g, _, v, x, y, b, S, C, E, P) {
        const w = this.elements;
        return w[0] = i, w[4] = o, w[8] = c, w[12] = u, w[1] = p, w[5] = m, w[9] = g, w[13] = _, w[2] = v, w[6] = x, w[10] = y, w[14] = b, w[3] = S, w[7] = C, w[11] = E, w[15] = P, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone() {
        return new Matrix4().fromArray(this.elements)
    }
    copy(i) {
        const o = this.elements,
            c = i.elements;
        return o[0] = c[0], o[1] = c[1], o[2] = c[2], o[3] = c[3], o[4] = c[4], o[5] = c[5], o[6] = c[6], o[7] = c[7], o[8] = c[8], o[9] = c[9], o[10] = c[10], o[11] = c[11], o[12] = c[12], o[13] = c[13], o[14] = c[14], o[15] = c[15], this
    }
    copyPosition(i) {
        const o = this.elements,
            c = i.elements;
        return o[12] = c[12], o[13] = c[13], o[14] = c[14], this
    }
    setFromMatrix3(i) {
        const o = i.elements;
        return this.set(o[0], o[3], o[6], 0, o[1], o[4], o[7], 0, o[2], o[5], o[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(i, o, c) {
        return i.setFromMatrixColumn(this, 0), o.setFromMatrixColumn(this, 1), c.setFromMatrixColumn(this, 2), this
    }
    makeBasis(i, o, c) {
        return this.set(i.x, o.x, c.x, 0, i.y, o.y, c.y, 0, i.z, o.z, c.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(i) {
        const o = this.elements,
            c = i.elements,
            u = 1 / _v1$5.setFromMatrixColumn(i, 0).length(),
            p = 1 / _v1$5.setFromMatrixColumn(i, 1).length(),
            m = 1 / _v1$5.setFromMatrixColumn(i, 2).length();
        return o[0] = c[0] * u, o[1] = c[1] * u, o[2] = c[2] * u, o[3] = 0, o[4] = c[4] * p, o[5] = c[5] * p, o[6] = c[6] * p, o[7] = 0, o[8] = c[8] * m, o[9] = c[9] * m, o[10] = c[10] * m, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, this
    }
    makeRotationFromEuler(i) {
        const o = this.elements,
            c = i.x,
            u = i.y,
            p = i.z,
            m = Math.cos(c),
            g = Math.sin(c),
            _ = Math.cos(u),
            v = Math.sin(u),
            x = Math.cos(p),
            y = Math.sin(p);
        if (i.order === "XYZ") {
            const b = m * x,
                S = m * y,
                C = g * x,
                E = g * y;
            o[0] = _ * x, o[4] = -_ * y, o[8] = v, o[1] = S + C * v, o[5] = b - E * v, o[9] = -g * _, o[2] = E - b * v, o[6] = C + S * v, o[10] = m * _
        } else if (i.order === "YXZ") {
            const b = _ * x,
                S = _ * y,
                C = v * x,
                E = v * y;
            o[0] = b + E * g, o[4] = C * g - S, o[8] = m * v, o[1] = m * y, o[5] = m * x, o[9] = -g, o[2] = S * g - C, o[6] = E + b * g, o[10] = m * _
        } else if (i.order === "ZXY") {
            const b = _ * x,
                S = _ * y,
                C = v * x,
                E = v * y;
            o[0] = b - E * g, o[4] = -m * y, o[8] = C + S * g, o[1] = S + C * g, o[5] = m * x, o[9] = E - b * g, o[2] = -m * v, o[6] = g, o[10] = m * _
        } else if (i.order === "ZYX") {
            const b = m * x,
                S = m * y,
                C = g * x,
                E = g * y;
            o[0] = _ * x, o[4] = C * v - S, o[8] = b * v + E, o[1] = _ * y, o[5] = E * v + b, o[9] = S * v - C, o[2] = -v, o[6] = g * _, o[10] = m * _
        } else if (i.order === "YZX") {
            const b = m * _,
                S = m * v,
                C = g * _,
                E = g * v;
            o[0] = _ * x, o[4] = E - b * y, o[8] = C * y + S, o[1] = y, o[5] = m * x, o[9] = -g * x, o[2] = -v * x, o[6] = S * y + C, o[10] = b - E * y
        } else if (i.order === "XZY") {
            const b = m * _,
                S = m * v,
                C = g * _,
                E = g * v;
            o[0] = _ * x, o[4] = -y, o[8] = v * x, o[1] = b * y + E, o[5] = m * x, o[9] = S * y - C, o[2] = C * y - S, o[6] = g * x, o[10] = E * y + b
        }
        return o[3] = 0, o[7] = 0, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, this
    }
    makeRotationFromQuaternion(i) {
        return this.compose(_zero, i, _one)
    }
    lookAt(i, o, c) {
        const u = this.elements;
        return _z.subVectors(i, o), _z.lengthSq() === 0 && (_z.z = 1), _z.normalize(), _x.crossVectors(c, _z), _x.lengthSq() === 0 && (Math.abs(c.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(c, _z)), _x.normalize(), _y.crossVectors(_z, _x), u[0] = _x.x, u[4] = _y.x, u[8] = _z.x, u[1] = _x.y, u[5] = _y.y, u[9] = _z.y, u[2] = _x.z, u[6] = _y.z, u[10] = _z.z, this
    }
    multiply(i) {
        return this.multiplyMatrices(this, i)
    }
    premultiply(i) {
        return this.multiplyMatrices(i, this)
    }
    multiplyMatrices(i, o) {
        const c = i.elements,
            u = o.elements,
            p = this.elements,
            m = c[0],
            g = c[4],
            _ = c[8],
            v = c[12],
            x = c[1],
            y = c[5],
            b = c[9],
            S = c[13],
            C = c[2],
            E = c[6],
            P = c[10],
            w = c[14],
            T = c[3],
            M = c[7],
            A = c[11],
            D = c[15],
            R = u[0],
            I = u[4],
            k = u[8],
            F = u[12],
            V = u[1],
            B = u[5],
            U = u[9],
            H = u[13],
            Q = u[2],
            Y = u[6],
            O = u[10],
            G = u[14],
            L = u[3],
            N = u[7],
            K = u[11],
            Z = u[15];
        return p[0] = m * R + g * V + _ * Q + v * L, p[4] = m * I + g * B + _ * Y + v * N, p[8] = m * k + g * U + _ * O + v * K, p[12] = m * F + g * H + _ * G + v * Z, p[1] = x * R + y * V + b * Q + S * L, p[5] = x * I + y * B + b * Y + S * N, p[9] = x * k + y * U + b * O + S * K, p[13] = x * F + y * H + b * G + S * Z, p[2] = C * R + E * V + P * Q + w * L, p[6] = C * I + E * B + P * Y + w * N, p[10] = C * k + E * U + P * O + w * K, p[14] = C * F + E * H + P * G + w * Z, p[3] = T * R + M * V + A * Q + D * L, p[7] = T * I + M * B + A * Y + D * N, p[11] = T * k + M * U + A * O + D * K, p[15] = T * F + M * H + A * G + D * Z, this
    }
    multiplyScalar(i) {
        const o = this.elements;
        return o[0] *= i, o[4] *= i, o[8] *= i, o[12] *= i, o[1] *= i, o[5] *= i, o[9] *= i, o[13] *= i, o[2] *= i, o[6] *= i, o[10] *= i, o[14] *= i, o[3] *= i, o[7] *= i, o[11] *= i, o[15] *= i, this
    }
    determinant() {
        const i = this.elements,
            o = i[0],
            c = i[4],
            u = i[8],
            p = i[12],
            m = i[1],
            g = i[5],
            _ = i[9],
            v = i[13],
            x = i[2],
            y = i[6],
            b = i[10],
            S = i[14],
            C = i[3],
            E = i[7],
            P = i[11],
            w = i[15];
        return C * (+p * _ * y - u * v * y - p * g * b + c * v * b + u * g * S - c * _ * S) + E * (+o * _ * S - o * v * b + p * m * b - u * m * S + u * v * x - p * _ * x) + P * (+o * v * y - o * g * S - p * m * y + c * m * S + p * g * x - c * v * x) + w * (-u * g * x - o * _ * y + o * g * b + u * m * y - c * m * b + c * _ * x)
    }
    transpose() {
        const i = this.elements;
        let o;
        return o = i[1], i[1] = i[4], i[4] = o, o = i[2], i[2] = i[8], i[8] = o, o = i[6], i[6] = i[9], i[9] = o, o = i[3], i[3] = i[12], i[12] = o, o = i[7], i[7] = i[13], i[13] = o, o = i[11], i[11] = i[14], i[14] = o, this
    }
    setPosition(i, o, c) {
        const u = this.elements;
        return i.isVector3 ? (u[12] = i.x, u[13] = i.y, u[14] = i.z) : (u[12] = i, u[13] = o, u[14] = c), this
    }
    invert() {
        const i = this.elements,
            o = i[0],
            c = i[1],
            u = i[2],
            p = i[3],
            m = i[4],
            g = i[5],
            _ = i[6],
            v = i[7],
            x = i[8],
            y = i[9],
            b = i[10],
            S = i[11],
            C = i[12],
            E = i[13],
            P = i[14],
            w = i[15],
            T = y * P * v - E * b * v + E * _ * S - g * P * S - y * _ * w + g * b * w,
            M = C * b * v - x * P * v - C * _ * S + m * P * S + x * _ * w - m * b * w,
            A = x * E * v - C * y * v + C * g * S - m * E * S - x * g * w + m * y * w,
            D = C * y * _ - x * E * _ - C * g * b + m * E * b + x * g * P - m * y * P,
            R = o * T + c * M + u * A + p * D;
        if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const I = 1 / R;
        return i[0] = T * I, i[1] = (E * b * p - y * P * p - E * u * S + c * P * S + y * u * w - c * b * w) * I, i[2] = (g * P * p - E * _ * p + E * u * v - c * P * v - g * u * w + c * _ * w) * I, i[3] = (y * _ * p - g * b * p - y * u * v + c * b * v + g * u * S - c * _ * S) * I, i[4] = M * I, i[5] = (x * P * p - C * b * p + C * u * S - o * P * S - x * u * w + o * b * w) * I, i[6] = (C * _ * p - m * P * p - C * u * v + o * P * v + m * u * w - o * _ * w) * I, i[7] = (m * b * p - x * _ * p + x * u * v - o * b * v - m * u * S + o * _ * S) * I, i[8] = A * I, i[9] = (C * y * p - x * E * p - C * c * S + o * E * S + x * c * w - o * y * w) * I, i[10] = (m * E * p - C * g * p + C * c * v - o * E * v - m * c * w + o * g * w) * I, i[11] = (x * g * p - m * y * p - x * c * v + o * y * v + m * c * S - o * g * S) * I, i[12] = D * I, i[13] = (x * E * u - C * y * u + C * c * b - o * E * b - x * c * P + o * y * P) * I, i[14] = (C * g * u - m * E * u - C * c * _ + o * E * _ + m * c * P - o * g * P) * I, i[15] = (m * y * u - x * g * u + x * c * _ - o * y * _ - m * c * b + o * g * b) * I, this
    }
    scale(i) {
        const o = this.elements,
            c = i.x,
            u = i.y,
            p = i.z;
        return o[0] *= c, o[4] *= u, o[8] *= p, o[1] *= c, o[5] *= u, o[9] *= p, o[2] *= c, o[6] *= u, o[10] *= p, o[3] *= c, o[7] *= u, o[11] *= p, this
    }
    getMaxScaleOnAxis() {
        const i = this.elements,
            o = i[0] * i[0] + i[1] * i[1] + i[2] * i[2],
            c = i[4] * i[4] + i[5] * i[5] + i[6] * i[6],
            u = i[8] * i[8] + i[9] * i[9] + i[10] * i[10];
        return Math.sqrt(Math.max(o, c, u))
    }
    makeTranslation(i, o, c) {
        return i.isVector3 ? this.set(1, 0, 0, i.x, 0, 1, 0, i.y, 0, 0, 1, i.z, 0, 0, 0, 1) : this.set(1, 0, 0, i, 0, 1, 0, o, 0, 0, 1, c, 0, 0, 0, 1), this
    }
    makeRotationX(i) {
        const o = Math.cos(i),
            c = Math.sin(i);
        return this.set(1, 0, 0, 0, 0, o, -c, 0, 0, c, o, 0, 0, 0, 0, 1), this
    }
    makeRotationY(i) {
        const o = Math.cos(i),
            c = Math.sin(i);
        return this.set(o, 0, c, 0, 0, 1, 0, 0, -c, 0, o, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(i) {
        const o = Math.cos(i),
            c = Math.sin(i);
        return this.set(o, -c, 0, 0, c, o, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(i, o) {
        const c = Math.cos(o),
            u = Math.sin(o),
            p = 1 - c,
            m = i.x,
            g = i.y,
            _ = i.z,
            v = p * m,
            x = p * g;
        return this.set(v * m + c, v * g - u * _, v * _ + u * g, 0, v * g + u * _, x * g + c, x * _ - u * m, 0, v * _ - u * g, x * _ + u * m, p * _ * _ + c, 0, 0, 0, 0, 1), this
    }
    makeScale(i, o, c) {
        return this.set(i, 0, 0, 0, 0, o, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this
    }
    makeShear(i, o, c, u, p, m) {
        return this.set(1, c, p, 0, i, 1, m, 0, o, u, 1, 0, 0, 0, 0, 1), this
    }
    compose(i, o, c) {
        const u = this.elements,
            p = o._x,
            m = o._y,
            g = o._z,
            _ = o._w,
            v = p + p,
            x = m + m,
            y = g + g,
            b = p * v,
            S = p * x,
            C = p * y,
            E = m * x,
            P = m * y,
            w = g * y,
            T = _ * v,
            M = _ * x,
            A = _ * y,
            D = c.x,
            R = c.y,
            I = c.z;
        return u[0] = (1 - (E + w)) * D, u[1] = (S + A) * D, u[2] = (C - M) * D, u[3] = 0, u[4] = (S - A) * R, u[5] = (1 - (b + w)) * R, u[6] = (P + T) * R, u[7] = 0, u[8] = (C + M) * I, u[9] = (P - T) * I, u[10] = (1 - (b + E)) * I, u[11] = 0, u[12] = i.x, u[13] = i.y, u[14] = i.z, u[15] = 1, this
    }
    decompose(i, o, c) {
        const u = this.elements;
        let p = _v1$5.set(u[0], u[1], u[2]).length();
        const m = _v1$5.set(u[4], u[5], u[6]).length(),
            g = _v1$5.set(u[8], u[9], u[10]).length();
        this.determinant() < 0 && (p = -p), i.x = u[12], i.y = u[13], i.z = u[14], _m1$2.copy(this);
        const v = 1 / p,
            x = 1 / m,
            y = 1 / g;
        return _m1$2.elements[0] *= v, _m1$2.elements[1] *= v, _m1$2.elements[2] *= v, _m1$2.elements[4] *= x, _m1$2.elements[5] *= x, _m1$2.elements[6] *= x, _m1$2.elements[8] *= y, _m1$2.elements[9] *= y, _m1$2.elements[10] *= y, o.setFromRotationMatrix(_m1$2), c.x = p, c.y = m, c.z = g, this
    }
    makePerspective(i, o, c, u, p, m, g = WebGLCoordinateSystem) {
        const _ = this.elements,
            v = 2 * p / (o - i),
            x = 2 * p / (c - u),
            y = (o + i) / (o - i),
            b = (c + u) / (c - u);
        let S, C;
        if (g === WebGLCoordinateSystem) S = -(m + p) / (m - p), C = -2 * m * p / (m - p);
        else if (g === WebGPUCoordinateSystem) S = -m / (m - p), C = -m * p / (m - p);
        else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + g);
        return _[0] = v, _[4] = 0, _[8] = y, _[12] = 0, _[1] = 0, _[5] = x, _[9] = b, _[13] = 0, _[2] = 0, _[6] = 0, _[10] = S, _[14] = C, _[3] = 0, _[7] = 0, _[11] = -1, _[15] = 0, this
    }
    makeOrthographic(i, o, c, u, p, m, g = WebGLCoordinateSystem) {
        const _ = this.elements,
            v = 1 / (o - i),
            x = 1 / (c - u),
            y = 1 / (m - p),
            b = (o + i) * v,
            S = (c + u) * x;
        let C, E;
        if (g === WebGLCoordinateSystem) C = (m + p) * y, E = -2 * y;
        else if (g === WebGPUCoordinateSystem) C = p * y, E = -1 * y;
        else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + g);
        return _[0] = 2 * v, _[4] = 0, _[8] = 0, _[12] = -b, _[1] = 0, _[5] = 2 * x, _[9] = 0, _[13] = -S, _[2] = 0, _[6] = 0, _[10] = E, _[14] = -C, _[3] = 0, _[7] = 0, _[11] = 0, _[15] = 1, this
    }
    equals(i) {
        const o = this.elements,
            c = i.elements;
        for (let u = 0; u < 16; u++)
            if (o[u] !== c[u]) return !1;
        return !0
    }
    fromArray(i, o = 0) {
        for (let c = 0; c < 16; c++) this.elements[c] = i[c + o];
        return this
    }
    toArray(i = [], o = 0) {
        const c = this.elements;
        return i[o] = c[0], i[o + 1] = c[1], i[o + 2] = c[2], i[o + 3] = c[3], i[o + 4] = c[4], i[o + 5] = c[5], i[o + 6] = c[6], i[o + 7] = c[7], i[o + 8] = c[8], i[o + 9] = c[9], i[o + 10] = c[10], i[o + 11] = c[11], i[o + 12] = c[12], i[o + 13] = c[13], i[o + 14] = c[14], i[o + 15] = c[15], i
    }
}
const _v1$5 = new Vector3$1,
    _m1$2 = new Matrix4,
    _zero = new Vector3$1(0, 0, 0),
    _one = new Vector3$1(1, 1, 1),
    _x = new Vector3$1,
    _y = new Vector3$1,
    _z = new Vector3$1,
    _matrix$2 = new Matrix4,
    _quaternion$3 = new Quaternion$1;
let Euler$1 = class Gr {
    constructor(i = 0, o = 0, c = 0, u = Gr.DEFAULT_ORDER) {
        this.isEuler = !0, this._x = i, this._y = o, this._z = c, this._order = u
    }
    get x() {
        return this._x
    }
    set x(i) {
        this._x = i, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(i) {
        this._y = i, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(i) {
        this._z = i, this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(i) {
        this._order = i, this._onChangeCallback()
    }
    set(i, o, c, u = this._order) {
        return this._x = i, this._y = o, this._z = c, this._order = u, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(i) {
        return this._x = i._x, this._y = i._y, this._z = i._z, this._order = i._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(i, o = this._order, c = !0) {
        const u = i.elements,
            p = u[0],
            m = u[4],
            g = u[8],
            _ = u[1],
            v = u[5],
            x = u[9],
            y = u[2],
            b = u[6],
            S = u[10];
        switch (o) {
            case "XYZ":
                this._y = Math.asin(clamp$3(g, -1, 1)), Math.abs(g) < .9999999 ? (this._x = Math.atan2(-x, S), this._z = Math.atan2(-m, p)) : (this._x = Math.atan2(b, v), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-clamp$3(x, -1, 1)), Math.abs(x) < .9999999 ? (this._y = Math.atan2(g, S), this._z = Math.atan2(_, v)) : (this._y = Math.atan2(-y, p), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(clamp$3(b, -1, 1)), Math.abs(b) < .9999999 ? (this._y = Math.atan2(-y, S), this._z = Math.atan2(-m, v)) : (this._y = 0, this._z = Math.atan2(_, p));
                break;
            case "ZYX":
                this._y = Math.asin(-clamp$3(y, -1, 1)), Math.abs(y) < .9999999 ? (this._x = Math.atan2(b, S), this._z = Math.atan2(_, p)) : (this._x = 0, this._z = Math.atan2(-m, v));
                break;
            case "YZX":
                this._z = Math.asin(clamp$3(_, -1, 1)), Math.abs(_) < .9999999 ? (this._x = Math.atan2(-x, v), this._y = Math.atan2(-y, p)) : (this._x = 0, this._y = Math.atan2(g, S));
                break;
            case "XZY":
                this._z = Math.asin(-clamp$3(m, -1, 1)), Math.abs(m) < .9999999 ? (this._x = Math.atan2(b, v), this._y = Math.atan2(g, p)) : (this._x = Math.atan2(-x, S), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + o)
        }
        return this._order = o, c === !0 && this._onChangeCallback(), this
    }
    setFromQuaternion(i, o, c) {
        return _matrix$2.makeRotationFromQuaternion(i), this.setFromRotationMatrix(_matrix$2, o, c)
    }
    setFromVector3(i, o = this._order) {
        return this.set(i.x, i.y, i.z, o)
    }
    reorder(i) {
        return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, i)
    }
    equals(i) {
        return i._x === this._x && i._y === this._y && i._z === this._z && i._order === this._order
    }
    fromArray(i) {
        return this._x = i[0], this._y = i[1], this._z = i[2], i[3] !== void 0 && (this._order = i[3]), this._onChangeCallback(), this
    }
    toArray(i = [], o = 0) {
        return i[o] = this._x, i[o + 1] = this._y, i[o + 2] = this._z, i[o + 3] = this._order, i
    }
    _onChange(i) {
        return this._onChangeCallback = i, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order
    }
};
Euler$1.DEFAULT_ORDER = "XYZ";
class Layers {
    constructor() {
        this.mask = 1
    }
    set(i) {
        this.mask = (1 << i | 0) >>> 0
    }
    enable(i) {
        this.mask |= 1 << i | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(i) {
        this.mask ^= 1 << i | 0
    }
    disable(i) {
        this.mask &= ~(1 << i | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(i) {
        return (this.mask & i.mask) !== 0
    }
    isEnabled(i) {
        return (this.mask & (1 << i | 0)) !== 0
    }
}
let _object3DId = 0;
const _v1$4 = new Vector3$1,
    _q1 = new Quaternion$1,
    _m1$1$1 = new Matrix4,
    _target = new Vector3$1,
    _position$3 = new Vector3$1,
    _scale$2 = new Vector3$1,
    _quaternion$2 = new Quaternion$1,
    _xAxis = new Vector3$1(1, 0, 0),
    _yAxis = new Vector3$1(0, 1, 0),
    _zAxis = new Vector3$1(0, 0, 1),
    _addedEvent = {
        type: "added"
    },
    _removedEvent = {
        type: "removed"
    },
    _childaddedEvent = {
        type: "childadded",
        child: null
    },
    _childremovedEvent = {
        type: "childremoved",
        child: null
    };
class Object3D extends EventDispatcher {
    constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
            value: _object3DId++
        }), this.uuid = generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DEFAULT_UP.clone();
        const i = new Vector3$1,
            o = new Euler$1,
            c = new Quaternion$1,
            u = new Vector3$1(1, 1, 1);

        function p() {
            c.setFromEuler(o, !1)
        }

        function m() {
            o.setFromQuaternion(c, void 0, !1)
        }
        o._onChange(p), c._onChange(m), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: o
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: c
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: u
            },
            modelViewMatrix: {
                value: new Matrix4
            },
            normalMatrix: {
                value: new Matrix3
            }
        }), this.matrix = new Matrix4, this.matrixWorld = new Matrix4, this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(i) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(i), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(i) {
        return this.quaternion.premultiply(i), this
    }
    setRotationFromAxisAngle(i, o) {
        this.quaternion.setFromAxisAngle(i, o)
    }
    setRotationFromEuler(i) {
        this.quaternion.setFromEuler(i, !0)
    }
    setRotationFromMatrix(i) {
        this.quaternion.setFromRotationMatrix(i)
    }
    setRotationFromQuaternion(i) {
        this.quaternion.copy(i)
    }
    rotateOnAxis(i, o) {
        return _q1.setFromAxisAngle(i, o), this.quaternion.multiply(_q1), this
    }
    rotateOnWorldAxis(i, o) {
        return _q1.setFromAxisAngle(i, o), this.quaternion.premultiply(_q1), this
    }
    rotateX(i) {
        return this.rotateOnAxis(_xAxis, i)
    }
    rotateY(i) {
        return this.rotateOnAxis(_yAxis, i)
    }
    rotateZ(i) {
        return this.rotateOnAxis(_zAxis, i)
    }
    translateOnAxis(i, o) {
        return _v1$4.copy(i).applyQuaternion(this.quaternion), this.position.add(_v1$4.multiplyScalar(o)), this
    }
    translateX(i) {
        return this.translateOnAxis(_xAxis, i)
    }
    translateY(i) {
        return this.translateOnAxis(_yAxis, i)
    }
    translateZ(i) {
        return this.translateOnAxis(_zAxis, i)
    }
    localToWorld(i) {
        return this.updateWorldMatrix(!0, !1), i.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(i) {
        return this.updateWorldMatrix(!0, !1), i.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert())
    }
    lookAt(i, o, c) {
        i.isVector3 ? _target.copy(i) : _target.set(i, o, c);
        const u = this.parent;
        this.updateWorldMatrix(!0, !1), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1$1.lookAt(_position$3, _target, this.up) : _m1$1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1$1), u && (_m1$1$1.extractRotation(u.matrixWorld), _q1.setFromRotationMatrix(_m1$1$1), this.quaternion.premultiply(_q1.invert()))
    }
    add(i) {
        if (arguments.length > 1) {
            for (let o = 0; o < arguments.length; o++) this.add(arguments[o]);
            return this
        }
        return i === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", i), this) : (i && i.isObject3D ? (i.removeFromParent(), i.parent = this, this.children.push(i), i.dispatchEvent(_addedEvent), _childaddedEvent.child = i, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", i), this)
    }
    remove(i) {
        if (arguments.length > 1) {
            for (let c = 0; c < arguments.length; c++) this.remove(arguments[c]);
            return this
        }
        const o = this.children.indexOf(i);
        return o !== -1 && (i.parent = null, this.children.splice(o, 1), i.dispatchEvent(_removedEvent), _childremovedEvent.child = i, this.dispatchEvent(_childremovedEvent), _childremovedEvent.child = null), this
    }
    removeFromParent() {
        const i = this.parent;
        return i !== null && i.remove(this), this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(i) {
        return this.updateWorldMatrix(!0, !1), _m1$1$1.copy(this.matrixWorld).invert(), i.parent !== null && (i.parent.updateWorldMatrix(!0, !1), _m1$1$1.multiply(i.parent.matrixWorld)), i.applyMatrix4(_m1$1$1), i.removeFromParent(), i.parent = this, this.children.push(i), i.updateWorldMatrix(!1, !0), i.dispatchEvent(_addedEvent), _childaddedEvent.child = i, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null, this
    }
    getObjectById(i) {
        return this.getObjectByProperty("id", i)
    }
    getObjectByName(i) {
        return this.getObjectByProperty("name", i)
    }
    getObjectByProperty(i, o) {
        if (this[i] === o) return this;
        for (let c = 0, u = this.children.length; c < u; c++) {
            const m = this.children[c].getObjectByProperty(i, o);
            if (m !== void 0) return m
        }
    }
    getObjectsByProperty(i, o, c = []) {
        this[i] === o && c.push(this);
        const u = this.children;
        for (let p = 0, m = u.length; p < m; p++) u[p].getObjectsByProperty(i, o, c);
        return c
    }
    getWorldPosition(i) {
        return this.updateWorldMatrix(!0, !1), i.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(i) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, i, _scale$2), i
    }
    getWorldScale(i) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, _quaternion$2, i), i
    }
    getWorldDirection(i) {
        this.updateWorldMatrix(!0, !1);
        const o = this.matrixWorld.elements;
        return i.set(o[8], o[9], o[10]).normalize()
    }
    raycast() {}
    traverse(i) {
        i(this);
        const o = this.children;
        for (let c = 0, u = o.length; c < u; c++) o[c].traverse(i)
    }
    traverseVisible(i) {
        if (this.visible === !1) return;
        i(this);
        const o = this.children;
        for (let c = 0, u = o.length; c < u; c++) o[c].traverseVisible(i)
    }
    traverseAncestors(i) {
        const o = this.parent;
        o !== null && (i(o), o.traverseAncestors(i))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(i) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || i) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, i = !0);
        const o = this.children;
        for (let c = 0, u = o.length; c < u; c++) o[c].updateMatrixWorld(i)
    }
    updateWorldMatrix(i, o) {
        const c = this.parent;
        if (i === !0 && c !== null && c.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), o === !0) {
            const u = this.children;
            for (let p = 0, m = u.length; p < m; p++) u[p].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(i) {
        const o = i === void 0 || typeof i == "string",
            c = {};
        o && (i = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, c.metadata = {
            version: 4.7,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const u = {};
        u.uuid = this.uuid, u.type = this.type, this.name !== "" && (u.name = this.name), this.castShadow === !0 && (u.castShadow = !0), this.receiveShadow === !0 && (u.receiveShadow = !0), this.visible === !1 && (u.visible = !1), this.frustumCulled === !1 && (u.frustumCulled = !1), this.renderOrder !== 0 && (u.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (u.userData = this.userData), u.layers = this.layers.mask, u.matrix = this.matrix.toArray(), u.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (u.matrixAutoUpdate = !1), this.isInstancedMesh && (u.type = "InstancedMesh", u.count = this.count, u.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (u.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (u.type = "BatchedMesh", u.perObjectFrustumCulled = this.perObjectFrustumCulled, u.sortObjects = this.sortObjects, u.drawRanges = this._drawRanges, u.reservedRanges = this._reservedRanges, u.geometryInfo = this._geometryInfo.map(g => ({ ...g,
            boundingBox: g.boundingBox ? g.boundingBox.toJSON() : void 0,
            boundingSphere: g.boundingSphere ? g.boundingSphere.toJSON() : void 0
        })), u.instanceInfo = this._instanceInfo.map(g => ({ ...g
        })), u.availableInstanceIds = this._availableInstanceIds.slice(), u.availableGeometryIds = this._availableGeometryIds.slice(), u.nextIndexStart = this._nextIndexStart, u.nextVertexStart = this._nextVertexStart, u.geometryCount = this._geometryCount, u.maxInstanceCount = this._maxInstanceCount, u.maxVertexCount = this._maxVertexCount, u.maxIndexCount = this._maxIndexCount, u.geometryInitialized = this._geometryInitialized, u.matricesTexture = this._matricesTexture.toJSON(i), u.indirectTexture = this._indirectTexture.toJSON(i), this._colorsTexture !== null && (u.colorsTexture = this._colorsTexture.toJSON(i)), this.boundingSphere !== null && (u.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (u.boundingBox = this.boundingBox.toJSON()));

        function p(g, _) {
            return g[_.uuid] === void 0 && (g[_.uuid] = _.toJSON(i)), _.uuid
        }
        if (this.isScene) this.background && (this.background.isColor ? u.background = this.background.toJSON() : this.background.isTexture && (u.background = this.background.toJSON(i).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (u.environment = this.environment.toJSON(i).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            u.geometry = p(i.geometries, this.geometry);
            const g = this.geometry.parameters;
            if (g !== void 0 && g.shapes !== void 0) {
                const _ = g.shapes;
                if (Array.isArray(_))
                    for (let v = 0, x = _.length; v < x; v++) {
                        const y = _[v];
                        p(i.shapes, y)
                    } else p(i.shapes, _)
            }
        }
        if (this.isSkinnedMesh && (u.bindMode = this.bindMode, u.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (p(i.skeletons, this.skeleton), u.skeleton = this.skeleton.uuid)), this.material !== void 0)
            if (Array.isArray(this.material)) {
                const g = [];
                for (let _ = 0, v = this.material.length; _ < v; _++) g.push(p(i.materials, this.material[_]));
                u.material = g
            } else u.material = p(i.materials, this.material);
        if (this.children.length > 0) {
            u.children = [];
            for (let g = 0; g < this.children.length; g++) u.children.push(this.children[g].toJSON(i).object)
        }
        if (this.animations.length > 0) {
            u.animations = [];
            for (let g = 0; g < this.animations.length; g++) {
                const _ = this.animations[g];
                u.animations.push(p(i.animations, _))
            }
        }
        if (o) {
            const g = m(i.geometries),
                _ = m(i.materials),
                v = m(i.textures),
                x = m(i.images),
                y = m(i.shapes),
                b = m(i.skeletons),
                S = m(i.animations),
                C = m(i.nodes);
            g.length > 0 && (c.geometries = g), _.length > 0 && (c.materials = _), v.length > 0 && (c.textures = v), x.length > 0 && (c.images = x), y.length > 0 && (c.shapes = y), b.length > 0 && (c.skeletons = b), S.length > 0 && (c.animations = S), C.length > 0 && (c.nodes = C)
        }
        return c.object = u, c;

        function m(g) {
            const _ = [];
            for (const v in g) {
                const x = g[v];
                delete x.metadata, _.push(x)
            }
            return _
        }
    }
    clone(i) {
        return new this.constructor().copy(this, i)
    }
    copy(i, o = !0) {
        if (this.name = i.name, this.up.copy(i.up), this.position.copy(i.position), this.rotation.order = i.rotation.order, this.quaternion.copy(i.quaternion), this.scale.copy(i.scale), this.matrix.copy(i.matrix), this.matrixWorld.copy(i.matrixWorld), this.matrixAutoUpdate = i.matrixAutoUpdate, this.matrixWorldAutoUpdate = i.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = i.matrixWorldNeedsUpdate, this.layers.mask = i.layers.mask, this.visible = i.visible, this.castShadow = i.castShadow, this.receiveShadow = i.receiveShadow, this.frustumCulled = i.frustumCulled, this.renderOrder = i.renderOrder, this.animations = i.animations.slice(), this.userData = JSON.parse(JSON.stringify(i.userData)), o === !0)
            for (let c = 0; c < i.children.length; c++) {
                const u = i.children[c];
                this.add(u.clone())
            }
        return this
    }
}
Object3D.DEFAULT_UP = new Vector3$1(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const _v0$1 = new Vector3$1,
    _v1$3 = new Vector3$1,
    _v2$2 = new Vector3$1,
    _v3$2 = new Vector3$1,
    _vab = new Vector3$1,
    _vac = new Vector3$1,
    _vbc = new Vector3$1,
    _vap = new Vector3$1,
    _vbp = new Vector3$1,
    _vcp = new Vector3$1,
    _v40 = new Vector4,
    _v41 = new Vector4,
    _v42 = new Vector4;
class Triangle {
    constructor(i = new Vector3$1, o = new Vector3$1, c = new Vector3$1) {
        this.a = i, this.b = o, this.c = c
    }
    static getNormal(i, o, c, u) {
        u.subVectors(c, o), _v0$1.subVectors(i, o), u.cross(_v0$1);
        const p = u.lengthSq();
        return p > 0 ? u.multiplyScalar(1 / Math.sqrt(p)) : u.set(0, 0, 0)
    }
    static getBarycoord(i, o, c, u, p) {
        _v0$1.subVectors(u, o), _v1$3.subVectors(c, o), _v2$2.subVectors(i, o);
        const m = _v0$1.dot(_v0$1),
            g = _v0$1.dot(_v1$3),
            _ = _v0$1.dot(_v2$2),
            v = _v1$3.dot(_v1$3),
            x = _v1$3.dot(_v2$2),
            y = m * v - g * g;
        if (y === 0) return p.set(0, 0, 0), null;
        const b = 1 / y,
            S = (v * _ - g * x) * b,
            C = (m * x - g * _) * b;
        return p.set(1 - S - C, C, S)
    }
    static containsPoint(i, o, c, u) {
        return this.getBarycoord(i, o, c, u, _v3$2) === null ? !1 : _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1
    }
    static getInterpolation(i, o, c, u, p, m, g, _) {
        return this.getBarycoord(i, o, c, u, _v3$2) === null ? (_.x = 0, _.y = 0, "z" in _ && (_.z = 0), "w" in _ && (_.w = 0), null) : (_.setScalar(0), _.addScaledVector(p, _v3$2.x), _.addScaledVector(m, _v3$2.y), _.addScaledVector(g, _v3$2.z), _)
    }
    static getInterpolatedAttribute(i, o, c, u, p, m) {
        return _v40.setScalar(0), _v41.setScalar(0), _v42.setScalar(0), _v40.fromBufferAttribute(i, o), _v41.fromBufferAttribute(i, c), _v42.fromBufferAttribute(i, u), m.setScalar(0), m.addScaledVector(_v40, p.x), m.addScaledVector(_v41, p.y), m.addScaledVector(_v42, p.z), m
    }
    static isFrontFacing(i, o, c, u) {
        return _v0$1.subVectors(c, o), _v1$3.subVectors(i, o), _v0$1.cross(_v1$3).dot(u) < 0
    }
    set(i, o, c) {
        return this.a.copy(i), this.b.copy(o), this.c.copy(c), this
    }
    setFromPointsAndIndices(i, o, c, u) {
        return this.a.copy(i[o]), this.b.copy(i[c]), this.c.copy(i[u]), this
    }
    setFromAttributeAndIndices(i, o, c, u) {
        return this.a.fromBufferAttribute(i, o), this.b.fromBufferAttribute(i, c), this.c.fromBufferAttribute(i, u), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(i) {
        return this.a.copy(i.a), this.b.copy(i.b), this.c.copy(i.c), this
    }
    getArea() {
        return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), _v0$1.cross(_v1$3).length() * .5
    }
    getMidpoint(i) {
        return i.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(i) {
        return Triangle.getNormal(this.a, this.b, this.c, i)
    }
    getPlane(i) {
        return i.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(i, o) {
        return Triangle.getBarycoord(i, this.a, this.b, this.c, o)
    }
    getInterpolation(i, o, c, u, p) {
        return Triangle.getInterpolation(i, this.a, this.b, this.c, o, c, u, p)
    }
    containsPoint(i) {
        return Triangle.containsPoint(i, this.a, this.b, this.c)
    }
    isFrontFacing(i) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, i)
    }
    intersectsBox(i) {
        return i.intersectsTriangle(this)
    }
    closestPointToPoint(i, o) {
        const c = this.a,
            u = this.b,
            p = this.c;
        let m, g;
        _vab.subVectors(u, c), _vac.subVectors(p, c), _vap.subVectors(i, c);
        const _ = _vab.dot(_vap),
            v = _vac.dot(_vap);
        if (_ <= 0 && v <= 0) return o.copy(c);
        _vbp.subVectors(i, u);
        const x = _vab.dot(_vbp),
            y = _vac.dot(_vbp);
        if (x >= 0 && y <= x) return o.copy(u);
        const b = _ * y - x * v;
        if (b <= 0 && _ >= 0 && x <= 0) return m = _ / (_ - x), o.copy(c).addScaledVector(_vab, m);
        _vcp.subVectors(i, p);
        const S = _vab.dot(_vcp),
            C = _vac.dot(_vcp);
        if (C >= 0 && S <= C) return o.copy(p);
        const E = S * v - _ * C;
        if (E <= 0 && v >= 0 && C <= 0) return g = v / (v - C), o.copy(c).addScaledVector(_vac, g);
        const P = x * C - S * y;
        if (P <= 0 && y - x >= 0 && S - C >= 0) return _vbc.subVectors(p, u), g = (y - x) / (y - x + (S - C)), o.copy(u).addScaledVector(_vbc, g);
        const w = 1 / (P + E + b);
        return m = E * w, g = b * w, o.copy(c).addScaledVector(_vab, m).addScaledVector(_vac, g)
    }
    equals(i) {
        return i.a.equals(this.a) && i.b.equals(this.b) && i.c.equals(this.c)
    }
}
const _colorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    _hslA = {
        h: 0,
        s: 0,
        l: 0
    },
    _hslB = {
        h: 0,
        s: 0,
        l: 0
    };

function hue2rgb(l, i, o) {
    return o < 0 && (o += 1), o > 1 && (o -= 1), o < 1 / 6 ? l + (i - l) * 6 * o : o < 1 / 2 ? i : o < 2 / 3 ? l + (i - l) * 6 * (2 / 3 - o) : l
}
class Color {
    constructor(i, o, c) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(i, o, c)
    }
    set(i, o, c) {
        if (o === void 0 && c === void 0) {
            const u = i;
            u && u.isColor ? this.copy(u) : typeof u == "number" ? this.setHex(u) : typeof u == "string" && this.setStyle(u)
        } else this.setRGB(i, o, c);
        return this
    }
    setScalar(i) {
        return this.r = i, this.g = i, this.b = i, this
    }
    setHex(i, o = SRGBColorSpace) {
        return i = Math.floor(i), this.r = (i >> 16 & 255) / 255, this.g = (i >> 8 & 255) / 255, this.b = (i & 255) / 255, ColorManagement.colorSpaceToWorking(this, o), this
    }
    setRGB(i, o, c, u = ColorManagement.workingColorSpace) {
        return this.r = i, this.g = o, this.b = c, ColorManagement.colorSpaceToWorking(this, u), this
    }
    setHSL(i, o, c, u = ColorManagement.workingColorSpace) {
        if (i = euclideanModulo(i, 1), o = clamp$3(o, 0, 1), c = clamp$3(c, 0, 1), o === 0) this.r = this.g = this.b = c;
        else {
            const p = c <= .5 ? c * (1 + o) : c + o - c * o,
                m = 2 * c - p;
            this.r = hue2rgb(m, p, i + 1 / 3), this.g = hue2rgb(m, p, i), this.b = hue2rgb(m, p, i - 1 / 3)
        }
        return ColorManagement.colorSpaceToWorking(this, u), this
    }
    setStyle(i, o = SRGBColorSpace) {
        function c(p) {
            p !== void 0 && parseFloat(p) < 1 && console.warn("THREE.Color: Alpha component of " + i + " will be ignored.")
        }
        let u;
        if (u = /^(\w+)\(([^\)]*)\)/.exec(i)) {
            let p;
            const m = u[1],
                g = u[2];
            switch (m) {
                case "rgb":
                case "rgba":
                    if (p = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(g)) return c(p[4]), this.setRGB(Math.min(255, parseInt(p[1], 10)) / 255, Math.min(255, parseInt(p[2], 10)) / 255, Math.min(255, parseInt(p[3], 10)) / 255, o);
                    if (p = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(g)) return c(p[4]), this.setRGB(Math.min(100, parseInt(p[1], 10)) / 100, Math.min(100, parseInt(p[2], 10)) / 100, Math.min(100, parseInt(p[3], 10)) / 100, o);
                    break;
                case "hsl":
                case "hsla":
                    if (p = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(g)) return c(p[4]), this.setHSL(parseFloat(p[1]) / 360, parseFloat(p[2]) / 100, parseFloat(p[3]) / 100, o);
                    break;
                default:
                    console.warn("THREE.Color: Unknown color model " + i)
            }
        } else if (u = /^\#([A-Fa-f\d]+)$/.exec(i)) {
            const p = u[1],
                m = p.length;
            if (m === 3) return this.setRGB(parseInt(p.charAt(0), 16) / 15, parseInt(p.charAt(1), 16) / 15, parseInt(p.charAt(2), 16) / 15, o);
            if (m === 6) return this.setHex(parseInt(p, 16), o);
            console.warn("THREE.Color: Invalid hex color " + i)
        } else if (i && i.length > 0) return this.setColorName(i, o);
        return this
    }
    setColorName(i, o = SRGBColorSpace) {
        const c = _colorKeywords[i.toLowerCase()];
        return c !== void 0 ? this.setHex(c, o) : console.warn("THREE.Color: Unknown color " + i), this
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(i) {
        return this.r = i.r, this.g = i.g, this.b = i.b, this
    }
    copySRGBToLinear(i) {
        return this.r = SRGBToLinear(i.r), this.g = SRGBToLinear(i.g), this.b = SRGBToLinear(i.b), this
    }
    copyLinearToSRGB(i) {
        return this.r = LinearToSRGB(i.r), this.g = LinearToSRGB(i.g), this.b = LinearToSRGB(i.b), this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }
    getHex(i = SRGBColorSpace) {
        return ColorManagement.workingToColorSpace(_color.copy(this), i), Math.round(clamp$3(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp$3(_color.g * 255, 0, 255)) * 256 + Math.round(clamp$3(_color.b * 255, 0, 255))
    }
    getHexString(i = SRGBColorSpace) {
        return ("000000" + this.getHex(i).toString(16)).slice(-6)
    }
    getHSL(i, o = ColorManagement.workingColorSpace) {
        ColorManagement.workingToColorSpace(_color.copy(this), o);
        const c = _color.r,
            u = _color.g,
            p = _color.b,
            m = Math.max(c, u, p),
            g = Math.min(c, u, p);
        let _, v;
        const x = (g + m) / 2;
        if (g === m) _ = 0, v = 0;
        else {
            const y = m - g;
            switch (v = x <= .5 ? y / (m + g) : y / (2 - m - g), m) {
                case c:
                    _ = (u - p) / y + (u < p ? 6 : 0);
                    break;
                case u:
                    _ = (p - c) / y + 2;
                    break;
                case p:
                    _ = (c - u) / y + 4;
                    break
            }
            _ /= 6
        }
        return i.h = _, i.s = v, i.l = x, i
    }
    getRGB(i, o = ColorManagement.workingColorSpace) {
        return ColorManagement.workingToColorSpace(_color.copy(this), o), i.r = _color.r, i.g = _color.g, i.b = _color.b, i
    }
    getStyle(i = SRGBColorSpace) {
        ColorManagement.workingToColorSpace(_color.copy(this), i);
        const o = _color.r,
            c = _color.g,
            u = _color.b;
        return i !== SRGBColorSpace ? `color(${i} ${o.toFixed(3)} ${c.toFixed(3)} ${u.toFixed(3)})` : `rgb(${Math.round(o*255)},${Math.round(c*255)},${Math.round(u*255)})`
    }
    offsetHSL(i, o, c) {
        return this.getHSL(_hslA), this.setHSL(_hslA.h + i, _hslA.s + o, _hslA.l + c)
    }
    add(i) {
        return this.r += i.r, this.g += i.g, this.b += i.b, this
    }
    addColors(i, o) {
        return this.r = i.r + o.r, this.g = i.g + o.g, this.b = i.b + o.b, this
    }
    addScalar(i) {
        return this.r += i, this.g += i, this.b += i, this
    }
    sub(i) {
        return this.r = Math.max(0, this.r - i.r), this.g = Math.max(0, this.g - i.g), this.b = Math.max(0, this.b - i.b), this
    }
    multiply(i) {
        return this.r *= i.r, this.g *= i.g, this.b *= i.b, this
    }
    multiplyScalar(i) {
        return this.r *= i, this.g *= i, this.b *= i, this
    }
    lerp(i, o) {
        return this.r += (i.r - this.r) * o, this.g += (i.g - this.g) * o, this.b += (i.b - this.b) * o, this
    }
    lerpColors(i, o, c) {
        return this.r = i.r + (o.r - i.r) * c, this.g = i.g + (o.g - i.g) * c, this.b = i.b + (o.b - i.b) * c, this
    }
    lerpHSL(i, o) {
        this.getHSL(_hslA), i.getHSL(_hslB);
        const c = lerp$1(_hslA.h, _hslB.h, o),
            u = lerp$1(_hslA.s, _hslB.s, o),
            p = lerp$1(_hslA.l, _hslB.l, o);
        return this.setHSL(c, u, p), this
    }
    setFromVector3(i) {
        return this.r = i.x, this.g = i.y, this.b = i.z, this
    }
    applyMatrix3(i) {
        const o = this.r,
            c = this.g,
            u = this.b,
            p = i.elements;
        return this.r = p[0] * o + p[3] * c + p[6] * u, this.g = p[1] * o + p[4] * c + p[7] * u, this.b = p[2] * o + p[5] * c + p[8] * u, this
    }
    equals(i) {
        return i.r === this.r && i.g === this.g && i.b === this.b
    }
    fromArray(i, o = 0) {
        return this.r = i[o], this.g = i[o + 1], this.b = i[o + 2], this
    }
    toArray(i = [], o = 0) {
        return i[o] = this.r, i[o + 1] = this.g, i[o + 2] = this.b, i
    }
    fromBufferAttribute(i, o) {
        return this.r = i.getX(o), this.g = i.getY(o), this.b = i.getZ(o), this
    }
    toJSON() {
        return this.getHex()
    }*[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b
    }
}
const _color = new Color;
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
    constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
            value: _materialId++
        }), this.uuid = generateUUID(), this.name = "", this.type = "Material", this.blending = NormalBlending, this.side = FrontSide, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Color(0, 0, 0), this.blendAlpha = 0, this.depthFunc = LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(i) {
        this._alphaTest > 0 != i > 0 && this.version++, this._alphaTest = i
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(i) {
        if (i !== void 0)
            for (const o in i) {
                const c = i[o];
                if (c === void 0) {
                    console.warn(`THREE.Material: parameter '${o}' has value of undefined.`);
                    continue
                }
                const u = this[o];
                if (u === void 0) {
                    console.warn(`THREE.Material: '${o}' is not a property of THREE.${this.type}.`);
                    continue
                }
                u && u.isColor ? u.set(c) : u && u.isVector3 && c && c.isVector3 ? u.copy(c) : this[o] = c
            }
    }
    toJSON(i) {
        const o = i === void 0 || typeof i == "string";
        o && (i = {
            textures: {},
            images: {}
        });
        const c = {
            metadata: {
                version: 4.7,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        c.uuid = this.uuid, c.type = this.type, this.name !== "" && (c.name = this.name), this.color && this.color.isColor && (c.color = this.color.getHex()), this.roughness !== void 0 && (c.roughness = this.roughness), this.metalness !== void 0 && (c.metalness = this.metalness), this.sheen !== void 0 && (c.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (c.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (c.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (c.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (c.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (c.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (c.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (c.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (c.shininess = this.shininess), this.clearcoat !== void 0 && (c.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (c.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (c.clearcoatMap = this.clearcoatMap.toJSON(i).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (c.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(i).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (c.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(i).uuid, c.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (c.dispersion = this.dispersion), this.iridescence !== void 0 && (c.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (c.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (c.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (c.iridescenceMap = this.iridescenceMap.toJSON(i).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (c.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(i).uuid), this.anisotropy !== void 0 && (c.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (c.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (c.anisotropyMap = this.anisotropyMap.toJSON(i).uuid), this.map && this.map.isTexture && (c.map = this.map.toJSON(i).uuid), this.matcap && this.matcap.isTexture && (c.matcap = this.matcap.toJSON(i).uuid), this.alphaMap && this.alphaMap.isTexture && (c.alphaMap = this.alphaMap.toJSON(i).uuid), this.lightMap && this.lightMap.isTexture && (c.lightMap = this.lightMap.toJSON(i).uuid, c.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (c.aoMap = this.aoMap.toJSON(i).uuid, c.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (c.bumpMap = this.bumpMap.toJSON(i).uuid, c.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (c.normalMap = this.normalMap.toJSON(i).uuid, c.normalMapType = this.normalMapType, c.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (c.displacementMap = this.displacementMap.toJSON(i).uuid, c.displacementScale = this.displacementScale, c.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (c.roughnessMap = this.roughnessMap.toJSON(i).uuid), this.metalnessMap && this.metalnessMap.isTexture && (c.metalnessMap = this.metalnessMap.toJSON(i).uuid), this.emissiveMap && this.emissiveMap.isTexture && (c.emissiveMap = this.emissiveMap.toJSON(i).uuid), this.specularMap && this.specularMap.isTexture && (c.specularMap = this.specularMap.toJSON(i).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (c.specularIntensityMap = this.specularIntensityMap.toJSON(i).uuid), this.specularColorMap && this.specularColorMap.isTexture && (c.specularColorMap = this.specularColorMap.toJSON(i).uuid), this.envMap && this.envMap.isTexture && (c.envMap = this.envMap.toJSON(i).uuid, this.combine !== void 0 && (c.combine = this.combine)), this.envMapRotation !== void 0 && (c.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (c.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (c.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (c.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (c.gradientMap = this.gradientMap.toJSON(i).uuid), this.transmission !== void 0 && (c.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (c.transmissionMap = this.transmissionMap.toJSON(i).uuid), this.thickness !== void 0 && (c.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (c.thicknessMap = this.thicknessMap.toJSON(i).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (c.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (c.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (c.size = this.size), this.shadowSide !== null && (c.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (c.sizeAttenuation = this.sizeAttenuation), this.blending !== NormalBlending && (c.blending = this.blending), this.side !== FrontSide && (c.side = this.side), this.vertexColors === !0 && (c.vertexColors = !0), this.opacity < 1 && (c.opacity = this.opacity), this.transparent === !0 && (c.transparent = !0), this.blendSrc !== SrcAlphaFactor && (c.blendSrc = this.blendSrc), this.blendDst !== OneMinusSrcAlphaFactor && (c.blendDst = this.blendDst), this.blendEquation !== AddEquation && (c.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (c.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (c.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (c.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (c.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (c.blendAlpha = this.blendAlpha), this.depthFunc !== LessEqualDepth && (c.depthFunc = this.depthFunc), this.depthTest === !1 && (c.depthTest = this.depthTest), this.depthWrite === !1 && (c.depthWrite = this.depthWrite), this.colorWrite === !1 && (c.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (c.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== AlwaysStencilFunc && (c.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (c.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (c.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== KeepStencilOp && (c.stencilFail = this.stencilFail), this.stencilZFail !== KeepStencilOp && (c.stencilZFail = this.stencilZFail), this.stencilZPass !== KeepStencilOp && (c.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (c.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (c.rotation = this.rotation), this.polygonOffset === !0 && (c.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (c.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (c.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (c.linewidth = this.linewidth), this.dashSize !== void 0 && (c.dashSize = this.dashSize), this.gapSize !== void 0 && (c.gapSize = this.gapSize), this.scale !== void 0 && (c.scale = this.scale), this.dithering === !0 && (c.dithering = !0), this.alphaTest > 0 && (c.alphaTest = this.alphaTest), this.alphaHash === !0 && (c.alphaHash = !0), this.alphaToCoverage === !0 && (c.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (c.premultipliedAlpha = !0), this.forceSinglePass === !0 && (c.forceSinglePass = !0), this.wireframe === !0 && (c.wireframe = !0), this.wireframeLinewidth > 1 && (c.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (c.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (c.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (c.flatShading = !0), this.visible === !1 && (c.visible = !1), this.toneMapped === !1 && (c.toneMapped = !1), this.fog === !1 && (c.fog = !1), Object.keys(this.userData).length > 0 && (c.userData = this.userData);

        function u(p) {
            const m = [];
            for (const g in p) {
                const _ = p[g];
                delete _.metadata, m.push(_)
            }
            return m
        }
        if (o) {
            const p = u(i.textures),
                m = u(i.images);
            p.length > 0 && (c.textures = p), m.length > 0 && (c.images = m)
        }
        return c
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(i) {
        this.name = i.name, this.blending = i.blending, this.side = i.side, this.vertexColors = i.vertexColors, this.opacity = i.opacity, this.transparent = i.transparent, this.blendSrc = i.blendSrc, this.blendDst = i.blendDst, this.blendEquation = i.blendEquation, this.blendSrcAlpha = i.blendSrcAlpha, this.blendDstAlpha = i.blendDstAlpha, this.blendEquationAlpha = i.blendEquationAlpha, this.blendColor.copy(i.blendColor), this.blendAlpha = i.blendAlpha, this.depthFunc = i.depthFunc, this.depthTest = i.depthTest, this.depthWrite = i.depthWrite, this.stencilWriteMask = i.stencilWriteMask, this.stencilFunc = i.stencilFunc, this.stencilRef = i.stencilRef, this.stencilFuncMask = i.stencilFuncMask, this.stencilFail = i.stencilFail, this.stencilZFail = i.stencilZFail, this.stencilZPass = i.stencilZPass, this.stencilWrite = i.stencilWrite;
        const o = i.clippingPlanes;
        let c = null;
        if (o !== null) {
            const u = o.length;
            c = new Array(u);
            for (let p = 0; p !== u; ++p) c[p] = o[p].clone()
        }
        return this.clippingPlanes = c, this.clipIntersection = i.clipIntersection, this.clipShadows = i.clipShadows, this.shadowSide = i.shadowSide, this.colorWrite = i.colorWrite, this.precision = i.precision, this.polygonOffset = i.polygonOffset, this.polygonOffsetFactor = i.polygonOffsetFactor, this.polygonOffsetUnits = i.polygonOffsetUnits, this.dithering = i.dithering, this.alphaTest = i.alphaTest, this.alphaHash = i.alphaHash, this.alphaToCoverage = i.alphaToCoverage, this.premultipliedAlpha = i.premultipliedAlpha, this.forceSinglePass = i.forceSinglePass, this.visible = i.visible, this.toneMapped = i.toneMapped, this.userData = JSON.parse(JSON.stringify(i.userData)), this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(i) {
        i === !0 && this.version++
    }
}
class MeshBasicMaterial extends Material {
    constructor(i) {
        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler$1, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(i)
    }
    copy(i) {
        return super.copy(i), this.color.copy(i.color), this.map = i.map, this.lightMap = i.lightMap, this.lightMapIntensity = i.lightMapIntensity, this.aoMap = i.aoMap, this.aoMapIntensity = i.aoMapIntensity, this.specularMap = i.specularMap, this.alphaMap = i.alphaMap, this.envMap = i.envMap, this.envMapRotation.copy(i.envMapRotation), this.combine = i.combine, this.reflectivity = i.reflectivity, this.refractionRatio = i.refractionRatio, this.wireframe = i.wireframe, this.wireframeLinewidth = i.wireframeLinewidth, this.wireframeLinecap = i.wireframeLinecap, this.wireframeLinejoin = i.wireframeLinejoin, this.fog = i.fog, this
    }
}
const _vector$9 = new Vector3$1,
    _vector2$1 = new Vector2;
let _id$2 = 0;
class BufferAttribute {
    constructor(i, o, c = !1) {
        if (Array.isArray(i)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
            value: _id$2++
        }), this.name = "", this.array = i, this.itemSize = o, this.count = i !== void 0 ? i.length / o : 0, this.normalized = c, this.usage = StaticDrawUsage, this.updateRanges = [], this.gpuType = FloatType, this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(i) {
        i === !0 && this.version++
    }
    setUsage(i) {
        return this.usage = i, this
    }
    addUpdateRange(i, o) {
        this.updateRanges.push({
            start: i,
            count: o
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(i) {
        return this.name = i.name, this.array = new i.array.constructor(i.array), this.itemSize = i.itemSize, this.count = i.count, this.normalized = i.normalized, this.usage = i.usage, this.gpuType = i.gpuType, this
    }
    copyAt(i, o, c) {
        i *= this.itemSize, c *= o.itemSize;
        for (let u = 0, p = this.itemSize; u < p; u++) this.array[i + u] = o.array[c + u];
        return this
    }
    copyArray(i) {
        return this.array.set(i), this
    }
    applyMatrix3(i) {
        if (this.itemSize === 2)
            for (let o = 0, c = this.count; o < c; o++) _vector2$1.fromBufferAttribute(this, o), _vector2$1.applyMatrix3(i), this.setXY(o, _vector2$1.x, _vector2$1.y);
        else if (this.itemSize === 3)
            for (let o = 0, c = this.count; o < c; o++) _vector$9.fromBufferAttribute(this, o), _vector$9.applyMatrix3(i), this.setXYZ(o, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    applyMatrix4(i) {
        for (let o = 0, c = this.count; o < c; o++) _vector$9.fromBufferAttribute(this, o), _vector$9.applyMatrix4(i), this.setXYZ(o, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    applyNormalMatrix(i) {
        for (let o = 0, c = this.count; o < c; o++) _vector$9.fromBufferAttribute(this, o), _vector$9.applyNormalMatrix(i), this.setXYZ(o, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    transformDirection(i) {
        for (let o = 0, c = this.count; o < c; o++) _vector$9.fromBufferAttribute(this, o), _vector$9.transformDirection(i), this.setXYZ(o, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    set(i, o = 0) {
        return this.array.set(i, o), this
    }
    getComponent(i, o) {
        let c = this.array[i * this.itemSize + o];
        return this.normalized && (c = denormalize(c, this.array)), c
    }
    setComponent(i, o, c) {
        return this.normalized && (c = normalize$1(c, this.array)), this.array[i * this.itemSize + o] = c, this
    }
    getX(i) {
        let o = this.array[i * this.itemSize];
        return this.normalized && (o = denormalize(o, this.array)), o
    }
    setX(i, o) {
        return this.normalized && (o = normalize$1(o, this.array)), this.array[i * this.itemSize] = o, this
    }
    getY(i) {
        let o = this.array[i * this.itemSize + 1];
        return this.normalized && (o = denormalize(o, this.array)), o
    }
    setY(i, o) {
        return this.normalized && (o = normalize$1(o, this.array)), this.array[i * this.itemSize + 1] = o, this
    }
    getZ(i) {
        let o = this.array[i * this.itemSize + 2];
        return this.normalized && (o = denormalize(o, this.array)), o
    }
    setZ(i, o) {
        return this.normalized && (o = normalize$1(o, this.array)), this.array[i * this.itemSize + 2] = o, this
    }
    getW(i) {
        let o = this.array[i * this.itemSize + 3];
        return this.normalized && (o = denormalize(o, this.array)), o
    }
    setW(i, o) {
        return this.normalized && (o = normalize$1(o, this.array)), this.array[i * this.itemSize + 3] = o, this
    }
    setXY(i, o, c) {
        return i *= this.itemSize, this.normalized && (o = normalize$1(o, this.array), c = normalize$1(c, this.array)), this.array[i + 0] = o, this.array[i + 1] = c, this
    }
    setXYZ(i, o, c, u) {
        return i *= this.itemSize, this.normalized && (o = normalize$1(o, this.array), c = normalize$1(c, this.array), u = normalize$1(u, this.array)), this.array[i + 0] = o, this.array[i + 1] = c, this.array[i + 2] = u, this
    }
    setXYZW(i, o, c, u, p) {
        return i *= this.itemSize, this.normalized && (o = normalize$1(o, this.array), c = normalize$1(c, this.array), u = normalize$1(u, this.array), p = normalize$1(p, this.array)), this.array[i + 0] = o, this.array[i + 1] = c, this.array[i + 2] = u, this.array[i + 3] = p, this
    }
    onUpload(i) {
        return this.onUploadCallback = i, this
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
        const i = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (i.name = this.name), this.usage !== StaticDrawUsage && (i.usage = this.usage), i
    }
}
class Uint16BufferAttribute extends BufferAttribute {
    constructor(i, o, c) {
        super(new Uint16Array(i), o, c)
    }
}
class Uint32BufferAttribute extends BufferAttribute {
    constructor(i, o, c) {
        super(new Uint32Array(i), o, c)
    }
}
class Float32BufferAttribute extends BufferAttribute {
    constructor(i, o, c) {
        super(new Float32Array(i), o, c)
    }
}
let _id$1 = 0;
const _m1$3 = new Matrix4,
    _obj = new Object3D,
    _offset = new Vector3$1,
    _box$2 = new Box3,
    _boxMorphTargets = new Box3,
    _vector$8 = new Vector3$1;
class BufferGeometry extends EventDispatcher {
    constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
            value: _id$1++
        }), this.uuid = generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(i) {
        return Array.isArray(i) ? this.index = new(arrayNeedsUint32(i) ? Uint32BufferAttribute : Uint16BufferAttribute)(i, 1) : this.index = i, this
    }
    setIndirect(i) {
        return this.indirect = i, this
    }
    getIndirect() {
        return this.indirect
    }
    getAttribute(i) {
        return this.attributes[i]
    }
    setAttribute(i, o) {
        return this.attributes[i] = o, this
    }
    deleteAttribute(i) {
        return delete this.attributes[i], this
    }
    hasAttribute(i) {
        return this.attributes[i] !== void 0
    }
    addGroup(i, o, c = 0) {
        this.groups.push({
            start: i,
            count: o,
            materialIndex: c
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(i, o) {
        this.drawRange.start = i, this.drawRange.count = o
    }
    applyMatrix4(i) {
        const o = this.attributes.position;
        o !== void 0 && (o.applyMatrix4(i), o.needsUpdate = !0);
        const c = this.attributes.normal;
        if (c !== void 0) {
            const p = new Matrix3().getNormalMatrix(i);
            c.applyNormalMatrix(p), c.needsUpdate = !0
        }
        const u = this.attributes.tangent;
        return u !== void 0 && (u.transformDirection(i), u.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }
    applyQuaternion(i) {
        return _m1$3.makeRotationFromQuaternion(i), this.applyMatrix4(_m1$3), this
    }
    rotateX(i) {
        return _m1$3.makeRotationX(i), this.applyMatrix4(_m1$3), this
    }
    rotateY(i) {
        return _m1$3.makeRotationY(i), this.applyMatrix4(_m1$3), this
    }
    rotateZ(i) {
        return _m1$3.makeRotationZ(i), this.applyMatrix4(_m1$3), this
    }
    translate(i, o, c) {
        return _m1$3.makeTranslation(i, o, c), this.applyMatrix4(_m1$3), this
    }
    scale(i, o, c) {
        return _m1$3.makeScale(i, o, c), this.applyMatrix4(_m1$3), this
    }
    lookAt(i) {
        return _obj.lookAt(i), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this
    }
    setFromPoints(i) {
        const o = this.getAttribute("position");
        if (o === void 0) {
            const c = [];
            for (let u = 0, p = i.length; u < p; u++) {
                const m = i[u];
                c.push(m.x, m.y, m.z || 0)
            }
            this.setAttribute("position", new Float32BufferAttribute(c, 3))
        } else {
            const c = Math.min(i.length, o.count);
            for (let u = 0; u < c; u++) {
                const p = i[u];
                o.setXYZ(u, p.x, p.y, p.z || 0)
            }
            i.length > o.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), o.needsUpdate = !0
        }
        return this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Box3);
        const i = this.attributes.position,
            o = this.morphAttributes.position;
        if (i && i.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new Vector3$1(-1 / 0, -1 / 0, -1 / 0), new Vector3$1(1 / 0, 1 / 0, 1 / 0));
            return
        }
        if (i !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(i), o)
                for (let c = 0, u = o.length; c < u; c++) {
                    const p = o[c];
                    _box$2.setFromBufferAttribute(p), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2.max))
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Sphere);
        const i = this.attributes.position,
            o = this.morphAttributes.position;
        if (i && i.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Vector3$1, 1 / 0);
            return
        }
        if (i) {
            const c = this.boundingSphere.center;
            if (_box$2.setFromBufferAttribute(i), o)
                for (let p = 0, m = o.length; p < m; p++) {
                    const g = o[p];
                    _boxMorphTargets.setFromBufferAttribute(g), this.morphTargetsRelative ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$8), _vector$8.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$8)) : (_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max))
                }
            _box$2.getCenter(c);
            let u = 0;
            for (let p = 0, m = i.count; p < m; p++) _vector$8.fromBufferAttribute(i, p), u = Math.max(u, c.distanceToSquared(_vector$8));
            if (o)
                for (let p = 0, m = o.length; p < m; p++) {
                    const g = o[p],
                        _ = this.morphTargetsRelative;
                    for (let v = 0, x = g.count; v < x; v++) _vector$8.fromBufferAttribute(g, v), _ && (_offset.fromBufferAttribute(i, v), _vector$8.add(_offset)), u = Math.max(u, c.distanceToSquared(_vector$8))
                }
            this.boundingSphere.radius = Math.sqrt(u), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const i = this.index,
            o = this.attributes;
        if (i === null || o.position === void 0 || o.normal === void 0 || o.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const c = o.position,
            u = o.normal,
            p = o.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * c.count), 4));
        const m = this.getAttribute("tangent"),
            g = [],
            _ = [];
        for (let k = 0; k < c.count; k++) g[k] = new Vector3$1, _[k] = new Vector3$1;
        const v = new Vector3$1,
            x = new Vector3$1,
            y = new Vector3$1,
            b = new Vector2,
            S = new Vector2,
            C = new Vector2,
            E = new Vector3$1,
            P = new Vector3$1;

        function w(k, F, V) {
            v.fromBufferAttribute(c, k), x.fromBufferAttribute(c, F), y.fromBufferAttribute(c, V), b.fromBufferAttribute(p, k), S.fromBufferAttribute(p, F), C.fromBufferAttribute(p, V), x.sub(v), y.sub(v), S.sub(b), C.sub(b);
            const B = 1 / (S.x * C.y - C.x * S.y);
            isFinite(B) && (E.copy(x).multiplyScalar(C.y).addScaledVector(y, -S.y).multiplyScalar(B), P.copy(y).multiplyScalar(S.x).addScaledVector(x, -C.x).multiplyScalar(B), g[k].add(E), g[F].add(E), g[V].add(E), _[k].add(P), _[F].add(P), _[V].add(P))
        }
        let T = this.groups;
        T.length === 0 && (T = [{
            start: 0,
            count: i.count
        }]);
        for (let k = 0, F = T.length; k < F; ++k) {
            const V = T[k],
                B = V.start,
                U = V.count;
            for (let H = B, Q = B + U; H < Q; H += 3) w(i.getX(H + 0), i.getX(H + 1), i.getX(H + 2))
        }
        const M = new Vector3$1,
            A = new Vector3$1,
            D = new Vector3$1,
            R = new Vector3$1;

        function I(k) {
            D.fromBufferAttribute(u, k), R.copy(D);
            const F = g[k];
            M.copy(F), M.sub(D.multiplyScalar(D.dot(F))).normalize(), A.crossVectors(R, F);
            const B = A.dot(_[k]) < 0 ? -1 : 1;
            m.setXYZW(k, M.x, M.y, M.z, B)
        }
        for (let k = 0, F = T.length; k < F; ++k) {
            const V = T[k],
                B = V.start,
                U = V.count;
            for (let H = B, Q = B + U; H < Q; H += 3) I(i.getX(H + 0)), I(i.getX(H + 1)), I(i.getX(H + 2))
        }
    }
    computeVertexNormals() {
        const i = this.index,
            o = this.getAttribute("position");
        if (o !== void 0) {
            let c = this.getAttribute("normal");
            if (c === void 0) c = new BufferAttribute(new Float32Array(o.count * 3), 3), this.setAttribute("normal", c);
            else
                for (let b = 0, S = c.count; b < S; b++) c.setXYZ(b, 0, 0, 0);
            const u = new Vector3$1,
                p = new Vector3$1,
                m = new Vector3$1,
                g = new Vector3$1,
                _ = new Vector3$1,
                v = new Vector3$1,
                x = new Vector3$1,
                y = new Vector3$1;
            if (i)
                for (let b = 0, S = i.count; b < S; b += 3) {
                    const C = i.getX(b + 0),
                        E = i.getX(b + 1),
                        P = i.getX(b + 2);
                    u.fromBufferAttribute(o, C), p.fromBufferAttribute(o, E), m.fromBufferAttribute(o, P), x.subVectors(m, p), y.subVectors(u, p), x.cross(y), g.fromBufferAttribute(c, C), _.fromBufferAttribute(c, E), v.fromBufferAttribute(c, P), g.add(x), _.add(x), v.add(x), c.setXYZ(C, g.x, g.y, g.z), c.setXYZ(E, _.x, _.y, _.z), c.setXYZ(P, v.x, v.y, v.z)
                } else
                    for (let b = 0, S = o.count; b < S; b += 3) u.fromBufferAttribute(o, b + 0), p.fromBufferAttribute(o, b + 1), m.fromBufferAttribute(o, b + 2), x.subVectors(m, p), y.subVectors(u, p), x.cross(y), c.setXYZ(b + 0, x.x, x.y, x.z), c.setXYZ(b + 1, x.x, x.y, x.z), c.setXYZ(b + 2, x.x, x.y, x.z);
            this.normalizeNormals(), c.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const i = this.attributes.normal;
        for (let o = 0, c = i.count; o < c; o++) _vector$8.fromBufferAttribute(i, o), _vector$8.normalize(), i.setXYZ(o, _vector$8.x, _vector$8.y, _vector$8.z)
    }
    toNonIndexed() {
        function i(g, _) {
            const v = g.array,
                x = g.itemSize,
                y = g.normalized,
                b = new v.constructor(_.length * x);
            let S = 0,
                C = 0;
            for (let E = 0, P = _.length; E < P; E++) {
                g.isInterleavedBufferAttribute ? S = _[E] * g.data.stride + g.offset : S = _[E] * x;
                for (let w = 0; w < x; w++) b[C++] = v[S++]
            }
            return new BufferAttribute(b, x, y)
        }
        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const o = new BufferGeometry,
            c = this.index.array,
            u = this.attributes;
        for (const g in u) {
            const _ = u[g],
                v = i(_, c);
            o.setAttribute(g, v)
        }
        const p = this.morphAttributes;
        for (const g in p) {
            const _ = [],
                v = p[g];
            for (let x = 0, y = v.length; x < y; x++) {
                const b = v[x],
                    S = i(b, c);
                _.push(S)
            }
            o.morphAttributes[g] = _
        }
        o.morphTargetsRelative = this.morphTargetsRelative;
        const m = this.groups;
        for (let g = 0, _ = m.length; g < _; g++) {
            const v = m[g];
            o.addGroup(v.start, v.count, v.materialIndex)
        }
        return o
    }
    toJSON() {
        const i = {
            metadata: {
                version: 4.7,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), Object.keys(this.userData).length > 0 && (i.userData = this.userData), this.parameters !== void 0) {
            const _ = this.parameters;
            for (const v in _) _[v] !== void 0 && (i[v] = _[v]);
            return i
        }
        i.data = {
            attributes: {}
        };
        const o = this.index;
        o !== null && (i.data.index = {
            type: o.array.constructor.name,
            array: Array.prototype.slice.call(o.array)
        });
        const c = this.attributes;
        for (const _ in c) {
            const v = c[_];
            i.data.attributes[_] = v.toJSON(i.data)
        }
        const u = {};
        let p = !1;
        for (const _ in this.morphAttributes) {
            const v = this.morphAttributes[_],
                x = [];
            for (let y = 0, b = v.length; y < b; y++) {
                const S = v[y];
                x.push(S.toJSON(i.data))
            }
            x.length > 0 && (u[_] = x, p = !0)
        }
        p && (i.data.morphAttributes = u, i.data.morphTargetsRelative = this.morphTargetsRelative);
        const m = this.groups;
        m.length > 0 && (i.data.groups = JSON.parse(JSON.stringify(m)));
        const g = this.boundingSphere;
        return g !== null && (i.data.boundingSphere = g.toJSON()), i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(i) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const o = {};
        this.name = i.name;
        const c = i.index;
        c !== null && this.setIndex(c.clone());
        const u = i.attributes;
        for (const v in u) {
            const x = u[v];
            this.setAttribute(v, x.clone(o))
        }
        const p = i.morphAttributes;
        for (const v in p) {
            const x = [],
                y = p[v];
            for (let b = 0, S = y.length; b < S; b++) x.push(y[b].clone(o));
            this.morphAttributes[v] = x
        }
        this.morphTargetsRelative = i.morphTargetsRelative;
        const m = i.groups;
        for (let v = 0, x = m.length; v < x; v++) {
            const y = m[v];
            this.addGroup(y.start, y.count, y.materialIndex)
        }
        const g = i.boundingBox;
        g !== null && (this.boundingBox = g.clone());
        const _ = i.boundingSphere;
        return _ !== null && (this.boundingSphere = _.clone()), this.drawRange.start = i.drawRange.start, this.drawRange.count = i.drawRange.count, this.userData = i.userData, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const _inverseMatrix$3 = new Matrix4,
    _ray$3 = new Ray,
    _sphere$6 = new Sphere,
    _sphereHitAt = new Vector3$1,
    _vA$1 = new Vector3$1,
    _vB$1 = new Vector3$1,
    _vC$1 = new Vector3$1,
    _tempA = new Vector3$1,
    _morphA = new Vector3$1,
    _intersectionPoint = new Vector3$1,
    _intersectionPointWorld = new Vector3$1;
class Mesh extends Object3D {
    constructor(i = new BufferGeometry, o = new MeshBasicMaterial) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = i, this.material = o, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets()
    }
    copy(i, o) {
        return super.copy(i, o), i.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = i.morphTargetInfluences.slice()), i.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, i.morphTargetDictionary)), this.material = Array.isArray(i.material) ? i.material.slice() : i.material, this.geometry = i.geometry, this
    }
    updateMorphTargets() {
        const o = this.geometry.morphAttributes,
            c = Object.keys(o);
        if (c.length > 0) {
            const u = o[c[0]];
            if (u !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let p = 0, m = u.length; p < m; p++) {
                    const g = u[p].name || String(p);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[g] = p
                }
            }
        }
    }
    getVertexPosition(i, o) {
        const c = this.geometry,
            u = c.attributes.position,
            p = c.morphAttributes.position,
            m = c.morphTargetsRelative;
        o.fromBufferAttribute(u, i);
        const g = this.morphTargetInfluences;
        if (p && g) {
            _morphA.set(0, 0, 0);
            for (let _ = 0, v = p.length; _ < v; _++) {
                const x = g[_],
                    y = p[_];
                x !== 0 && (_tempA.fromBufferAttribute(y, i), m ? _morphA.addScaledVector(_tempA, x) : _morphA.addScaledVector(_tempA.sub(o), x))
            }
            o.add(_morphA)
        }
        return o
    }
    raycast(i, o) {
        const c = this.geometry,
            u = this.material,
            p = this.matrixWorld;
        u !== void 0 && (c.boundingSphere === null && c.computeBoundingSphere(), _sphere$6.copy(c.boundingSphere), _sphere$6.applyMatrix4(p), _ray$3.copy(i.ray).recast(i.near), !(_sphere$6.containsPoint(_ray$3.origin) === !1 && (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null || _ray$3.origin.distanceToSquared(_sphereHitAt) > (i.far - i.near) ** 2)) && (_inverseMatrix$3.copy(p).invert(), _ray$3.copy(i.ray).applyMatrix4(_inverseMatrix$3), !(c.boundingBox !== null && _ray$3.intersectsBox(c.boundingBox) === !1) && this._computeIntersections(i, o, _ray$3)))
    }
    _computeIntersections(i, o, c) {
        let u;
        const p = this.geometry,
            m = this.material,
            g = p.index,
            _ = p.attributes.position,
            v = p.attributes.uv,
            x = p.attributes.uv1,
            y = p.attributes.normal,
            b = p.groups,
            S = p.drawRange;
        if (g !== null)
            if (Array.isArray(m))
                for (let C = 0, E = b.length; C < E; C++) {
                    const P = b[C],
                        w = m[P.materialIndex],
                        T = Math.max(P.start, S.start),
                        M = Math.min(g.count, Math.min(P.start + P.count, S.start + S.count));
                    for (let A = T, D = M; A < D; A += 3) {
                        const R = g.getX(A),
                            I = g.getX(A + 1),
                            k = g.getX(A + 2);
                        u = checkGeometryIntersection(this, w, i, c, v, x, y, R, I, k), u && (u.faceIndex = Math.floor(A / 3), u.face.materialIndex = P.materialIndex, o.push(u))
                    }
                } else {
                    const C = Math.max(0, S.start),
                        E = Math.min(g.count, S.start + S.count);
                    for (let P = C, w = E; P < w; P += 3) {
                        const T = g.getX(P),
                            M = g.getX(P + 1),
                            A = g.getX(P + 2);
                        u = checkGeometryIntersection(this, m, i, c, v, x, y, T, M, A), u && (u.faceIndex = Math.floor(P / 3), o.push(u))
                    }
                } else if (_ !== void 0)
                    if (Array.isArray(m))
                        for (let C = 0, E = b.length; C < E; C++) {
                            const P = b[C],
                                w = m[P.materialIndex],
                                T = Math.max(P.start, S.start),
                                M = Math.min(_.count, Math.min(P.start + P.count, S.start + S.count));
                            for (let A = T, D = M; A < D; A += 3) {
                                const R = A,
                                    I = A + 1,
                                    k = A + 2;
                                u = checkGeometryIntersection(this, w, i, c, v, x, y, R, I, k), u && (u.faceIndex = Math.floor(A / 3), u.face.materialIndex = P.materialIndex, o.push(u))
                            }
                        } else {
                            const C = Math.max(0, S.start),
                                E = Math.min(_.count, S.start + S.count);
                            for (let P = C, w = E; P < w; P += 3) {
                                const T = P,
                                    M = P + 1,
                                    A = P + 2;
                                u = checkGeometryIntersection(this, m, i, c, v, x, y, T, M, A), u && (u.faceIndex = Math.floor(P / 3), o.push(u))
                            }
                        }
    }
}

function checkIntersection$1(l, i, o, c, u, p, m, g) {
    let _;
    if (i.side === BackSide ? _ = c.intersectTriangle(m, p, u, !0, g) : _ = c.intersectTriangle(u, p, m, i.side === FrontSide, g), _ === null) return null;
    _intersectionPointWorld.copy(g), _intersectionPointWorld.applyMatrix4(l.matrixWorld);
    const v = o.ray.origin.distanceTo(_intersectionPointWorld);
    return v < o.near || v > o.far ? null : {
        distance: v,
        point: _intersectionPointWorld.clone(),
        object: l
    }
}

function checkGeometryIntersection(l, i, o, c, u, p, m, g, _, v) {
    l.getVertexPosition(g, _vA$1), l.getVertexPosition(_, _vB$1), l.getVertexPosition(v, _vC$1);
    const x = checkIntersection$1(l, i, o, c, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (x) {
        const y = new Vector3$1;
        Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, y), u && (x.uv = Triangle.getInterpolatedAttribute(u, g, _, v, y, new Vector2)), p && (x.uv1 = Triangle.getInterpolatedAttribute(p, g, _, v, y, new Vector2)), m && (x.normal = Triangle.getInterpolatedAttribute(m, g, _, v, y, new Vector3$1), x.normal.dot(c.direction) > 0 && x.normal.multiplyScalar(-1));
        const b = {
            a: g,
            b: _,
            c: v,
            normal: new Vector3$1,
            materialIndex: 0
        };
        Triangle.getNormal(_vA$1, _vB$1, _vC$1, b.normal), x.face = b, x.barycoord = y
    }
    return x
}
class BoxGeometry extends BufferGeometry {
    constructor(i = 1, o = 1, c = 1, u = 1, p = 1, m = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: i,
            height: o,
            depth: c,
            widthSegments: u,
            heightSegments: p,
            depthSegments: m
        };
        const g = this;
        u = Math.floor(u), p = Math.floor(p), m = Math.floor(m);
        const _ = [],
            v = [],
            x = [],
            y = [];
        let b = 0,
            S = 0;
        C("z", "y", "x", -1, -1, c, o, i, m, p, 0), C("z", "y", "x", 1, -1, c, o, -i, m, p, 1), C("x", "z", "y", 1, 1, i, c, o, u, m, 2), C("x", "z", "y", 1, -1, i, c, -o, u, m, 3), C("x", "y", "z", 1, -1, i, o, c, u, p, 4), C("x", "y", "z", -1, -1, i, o, -c, u, p, 5), this.setIndex(_), this.setAttribute("position", new Float32BufferAttribute(v, 3)), this.setAttribute("normal", new Float32BufferAttribute(x, 3)), this.setAttribute("uv", new Float32BufferAttribute(y, 2));

        function C(E, P, w, T, M, A, D, R, I, k, F) {
            const V = A / I,
                B = D / k,
                U = A / 2,
                H = D / 2,
                Q = R / 2,
                Y = I + 1,
                O = k + 1;
            let G = 0,
                L = 0;
            const N = new Vector3$1;
            for (let K = 0; K < O; K++) {
                const Z = K * B - H;
                for (let he = 0; he < Y; he++) {
                    const we = he * V - U;
                    N[E] = we * T, N[P] = Z * M, N[w] = Q, v.push(N.x, N.y, N.z), N[E] = 0, N[P] = 0, N[w] = R > 0 ? 1 : -1, x.push(N.x, N.y, N.z), y.push(he / I), y.push(1 - K / k), G += 1
                }
            }
            for (let K = 0; K < k; K++)
                for (let Z = 0; Z < I; Z++) {
                    const he = b + Z + Y * K,
                        we = b + Z + Y * (K + 1),
                        ie = b + (Z + 1) + Y * (K + 1),
                        _e = b + (Z + 1) + Y * K;
                    _.push(he, we, _e), _.push(we, ie, _e), L += 6
                }
            g.addGroup(S, L, F), S += L, b += G
        }
    }
    copy(i) {
        return super.copy(i), this.parameters = Object.assign({}, i.parameters), this
    }
    static fromJSON(i) {
        return new BoxGeometry(i.width, i.height, i.depth, i.widthSegments, i.heightSegments, i.depthSegments)
    }
}

function cloneUniforms(l) {
    const i = {};
    for (const o in l) {
        i[o] = {};
        for (const c in l[o]) {
            const u = l[o][c];
            u && (u.isColor || u.isMatrix3 || u.isMatrix4 || u.isVector2 || u.isVector3 || u.isVector4 || u.isTexture || u.isQuaternion) ? u.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), i[o][c] = null) : i[o][c] = u.clone() : Array.isArray(u) ? i[o][c] = u.slice() : i[o][c] = u
        }
    }
    return i
}

function mergeUniforms(l) {
    const i = {};
    for (let o = 0; o < l.length; o++) {
        const c = cloneUniforms(l[o]);
        for (const u in c) i[u] = c[u]
    }
    return i
}

function cloneUniformsGroups(l) {
    const i = [];
    for (let o = 0; o < l.length; o++) i.push(l[o].clone());
    return i
}

function getUnlitUniformColorSpace(l) {
    const i = l.getRenderTarget();
    return i === null ? l.outputColorSpace : i.isXRRenderTarget === !0 ? i.texture.colorSpace : ColorManagement.workingColorSpace
}
const UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
    constructor(i) {
        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, i !== void 0 && this.setValues(i)
    }
    copy(i) {
        return super.copy(i), this.fragmentShader = i.fragmentShader, this.vertexShader = i.vertexShader, this.uniforms = cloneUniforms(i.uniforms), this.uniformsGroups = cloneUniformsGroups(i.uniformsGroups), this.defines = Object.assign({}, i.defines), this.wireframe = i.wireframe, this.wireframeLinewidth = i.wireframeLinewidth, this.fog = i.fog, this.lights = i.lights, this.clipping = i.clipping, this.extensions = Object.assign({}, i.extensions), this.glslVersion = i.glslVersion, this
    }
    toJSON(i) {
        const o = super.toJSON(i);
        o.glslVersion = this.glslVersion, o.uniforms = {};
        for (const u in this.uniforms) {
            const m = this.uniforms[u].value;
            m && m.isTexture ? o.uniforms[u] = {
                type: "t",
                value: m.toJSON(i).uuid
            } : m && m.isColor ? o.uniforms[u] = {
                type: "c",
                value: m.getHex()
            } : m && m.isVector2 ? o.uniforms[u] = {
                type: "v2",
                value: m.toArray()
            } : m && m.isVector3 ? o.uniforms[u] = {
                type: "v3",
                value: m.toArray()
            } : m && m.isVector4 ? o.uniforms[u] = {
                type: "v4",
                value: m.toArray()
            } : m && m.isMatrix3 ? o.uniforms[u] = {
                type: "m3",
                value: m.toArray()
            } : m && m.isMatrix4 ? o.uniforms[u] = {
                type: "m4",
                value: m.toArray()
            } : o.uniforms[u] = {
                value: m
            }
        }
        Object.keys(this.defines).length > 0 && (o.defines = this.defines), o.vertexShader = this.vertexShader, o.fragmentShader = this.fragmentShader, o.lights = this.lights, o.clipping = this.clipping;
        const c = {};
        for (const u in this.extensions) this.extensions[u] === !0 && (c[u] = !0);
        return Object.keys(c).length > 0 && (o.extensions = c), o
    }
}
class Camera extends Object3D {
    constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Matrix4, this.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4, this.coordinateSystem = WebGLCoordinateSystem
    }
    copy(i, o) {
        return super.copy(i, o), this.matrixWorldInverse.copy(i.matrixWorldInverse), this.projectionMatrix.copy(i.projectionMatrix), this.projectionMatrixInverse.copy(i.projectionMatrixInverse), this.coordinateSystem = i.coordinateSystem, this
    }
    getWorldDirection(i) {
        return super.getWorldDirection(i).negate()
    }
    updateMatrixWorld(i) {
        super.updateMatrixWorld(i), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(i, o) {
        super.updateWorldMatrix(i, o), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _v3$1 = new Vector3$1,
    _minTarget = new Vector2,
    _maxTarget = new Vector2;
class PerspectiveCamera extends Camera {
    constructor(i = 50, o = 1, c = .1, u = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = i, this.zoom = 1, this.near = c, this.far = u, this.focus = 10, this.aspect = o, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    copy(i, o) {
        return super.copy(i, o), this.fov = i.fov, this.zoom = i.zoom, this.near = i.near, this.far = i.far, this.focus = i.focus, this.aspect = i.aspect, this.view = i.view === null ? null : Object.assign({}, i.view), this.filmGauge = i.filmGauge, this.filmOffset = i.filmOffset, this
    }
    setFocalLength(i) {
        const o = .5 * this.getFilmHeight() / i;
        this.fov = RAD2DEG * 2 * Math.atan(o), this.updateProjectionMatrix()
    }
    getFocalLength() {
        const i = Math.tan(DEG2RAD * .5 * this.fov);
        return .5 * this.getFilmHeight() / i
    }
    getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(i, o, c) {
        _v3$1.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), o.set(_v3$1.x, _v3$1.y).multiplyScalar(-i / _v3$1.z), _v3$1.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), c.set(_v3$1.x, _v3$1.y).multiplyScalar(-i / _v3$1.z)
    }
    getViewSize(i, o) {
        return this.getViewBounds(i, _minTarget, _maxTarget), o.subVectors(_maxTarget, _minTarget)
    }
    setViewOffset(i, o, c, u, p, m) {
        this.aspect = i / o, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = i, this.view.fullHeight = o, this.view.offsetX = c, this.view.offsetY = u, this.view.width = p, this.view.height = m, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const i = this.near;
        let o = i * Math.tan(DEG2RAD * .5 * this.fov) / this.zoom,
            c = 2 * o,
            u = this.aspect * c,
            p = -.5 * u;
        const m = this.view;
        if (this.view !== null && this.view.enabled) {
            const _ = m.fullWidth,
                v = m.fullHeight;
            p += m.offsetX * u / _, o -= m.offsetY * c / v, u *= m.width / _, c *= m.height / v
        }
        const g = this.filmOffset;
        g !== 0 && (p += i * g / this.getFilmWidth()), this.projectionMatrix.makePerspective(p, p + u, o, o - c, i, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(i) {
        const o = super.toJSON(i);
        return o.object.fov = this.fov, o.object.zoom = this.zoom, o.object.near = this.near, o.object.far = this.far, o.object.focus = this.focus, o.object.aspect = this.aspect, this.view !== null && (o.object.view = Object.assign({}, this.view)), o.object.filmGauge = this.filmGauge, o.object.filmOffset = this.filmOffset, o
    }
}
const fov = -90,
    aspect = 1;
class CubeCamera extends Object3D {
    constructor(i, o, c) {
        super(), this.type = "CubeCamera", this.renderTarget = c, this.coordinateSystem = null, this.activeMipmapLevel = 0;
        const u = new PerspectiveCamera(fov, aspect, i, o);
        u.layers = this.layers, this.add(u);
        const p = new PerspectiveCamera(fov, aspect, i, o);
        p.layers = this.layers, this.add(p);
        const m = new PerspectiveCamera(fov, aspect, i, o);
        m.layers = this.layers, this.add(m);
        const g = new PerspectiveCamera(fov, aspect, i, o);
        g.layers = this.layers, this.add(g);
        const _ = new PerspectiveCamera(fov, aspect, i, o);
        _.layers = this.layers, this.add(_);
        const v = new PerspectiveCamera(fov, aspect, i, o);
        v.layers = this.layers, this.add(v)
    }
    updateCoordinateSystem() {
        const i = this.coordinateSystem,
            o = this.children.concat(),
            [c, u, p, m, g, _] = o;
        for (const v of o) this.remove(v);
        if (i === WebGLCoordinateSystem) c.up.set(0, 1, 0), c.lookAt(1, 0, 0), u.up.set(0, 1, 0), u.lookAt(-1, 0, 0), p.up.set(0, 0, -1), p.lookAt(0, 1, 0), m.up.set(0, 0, 1), m.lookAt(0, -1, 0), g.up.set(0, 1, 0), g.lookAt(0, 0, 1), _.up.set(0, 1, 0), _.lookAt(0, 0, -1);
        else if (i === WebGPUCoordinateSystem) c.up.set(0, -1, 0), c.lookAt(-1, 0, 0), u.up.set(0, -1, 0), u.lookAt(1, 0, 0), p.up.set(0, 0, 1), p.lookAt(0, 1, 0), m.up.set(0, 0, -1), m.lookAt(0, -1, 0), g.up.set(0, -1, 0), g.lookAt(0, 0, 1), _.up.set(0, -1, 0), _.lookAt(0, 0, -1);
        else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + i);
        for (const v of o) this.add(v), v.updateMatrixWorld()
    }
    update(i, o) {
        this.parent === null && this.updateMatrixWorld();
        const {
            renderTarget: c,
            activeMipmapLevel: u
        } = this;
        this.coordinateSystem !== i.coordinateSystem && (this.coordinateSystem = i.coordinateSystem, this.updateCoordinateSystem());
        const [p, m, g, _, v, x] = this.children, y = i.getRenderTarget(), b = i.getActiveCubeFace(), S = i.getActiveMipmapLevel(), C = i.xr.enabled;
        i.xr.enabled = !1;
        const E = c.texture.generateMipmaps;
        c.texture.generateMipmaps = !1, i.setRenderTarget(c, 0, u), i.render(o, p), i.setRenderTarget(c, 1, u), i.render(o, m), i.setRenderTarget(c, 2, u), i.render(o, g), i.setRenderTarget(c, 3, u), i.render(o, _), i.setRenderTarget(c, 4, u), i.render(o, v), c.texture.generateMipmaps = E, i.setRenderTarget(c, 5, u), i.render(o, x), i.setRenderTarget(y, b, S), i.xr.enabled = C, c.texture.needsPMREMUpdate = !0
    }
}
class CubeTexture extends Texture {
    constructor(i = [], o = CubeReflectionMapping, c, u, p, m, g, _, v, x) {
        super(i, o, c, u, p, m, g, _, v, x), this.isCubeTexture = !0, this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(i) {
        this.image = i
    }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
    constructor(i = 1, o = {}) {
        super(i, i, o), this.isWebGLCubeRenderTarget = !0;
        const c = {
                width: i,
                height: i,
                depth: 1
            },
            u = [c, c, c, c, c, c];
        this.texture = new CubeTexture(u), this._setTextureOptions(o), this.texture.isRenderTargetTexture = !0
    }
    fromEquirectangularTexture(i, o) {
        this.texture.type = o.type, this.texture.colorSpace = o.colorSpace, this.texture.generateMipmaps = o.generateMipmaps, this.texture.minFilter = o.minFilter, this.texture.magFilter = o.magFilter;
        const c = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            },
            u = new BoxGeometry(5, 5, 5),
            p = new ShaderMaterial({
                name: "CubemapFromEquirect",
                uniforms: cloneUniforms(c.uniforms),
                vertexShader: c.vertexShader,
                fragmentShader: c.fragmentShader,
                side: BackSide,
                blending: NoBlending
            });
        p.uniforms.tEquirect.value = o;
        const m = new Mesh(u, p),
            g = o.minFilter;
        return o.minFilter === LinearMipmapLinearFilter && (o.minFilter = LinearFilter), new CubeCamera(1, 10, this).update(i, m), o.minFilter = g, m.geometry.dispose(), m.material.dispose(), this
    }
    clear(i, o = !0, c = !0, u = !0) {
        const p = i.getRenderTarget();
        for (let m = 0; m < 6; m++) i.setRenderTarget(this, m), i.clear(o, c, u);
        i.setRenderTarget(p)
    }
}
class Group extends Object3D {
    constructor() {
        super(), this.isGroup = !0, this.type = "Group"
    }
}
const _moveEvent = {
    type: "move"
};
class WebXRController {
    constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Group, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Group, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Vector3$1, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Vector3$1), this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Group, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Vector3$1, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Vector3$1), this._grip
    }
    dispatchEvent(i) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(i), this._grip !== null && this._grip.dispatchEvent(i), this._hand !== null && this._hand.dispatchEvent(i), this
    }
    connect(i) {
        if (i && i.hand) {
            const o = this._hand;
            if (o)
                for (const c of i.hand.values()) this._getHandJoint(o, c)
        }
        return this.dispatchEvent({
            type: "connected",
            data: i
        }), this
    }
    disconnect(i) {
        return this.dispatchEvent({
            type: "disconnected",
            data: i
        }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
    }
    update(i, o, c) {
        let u = null,
            p = null,
            m = null;
        const g = this._targetRay,
            _ = this._grip,
            v = this._hand;
        if (i && o.session.visibilityState !== "visible-blurred") {
            if (v && i.hand) {
                m = !0;
                for (const E of i.hand.values()) {
                    const P = o.getJointPose(E, c),
                        w = this._getHandJoint(v, E);
                    P !== null && (w.matrix.fromArray(P.transform.matrix), w.matrix.decompose(w.position, w.rotation, w.scale), w.matrixWorldNeedsUpdate = !0, w.jointRadius = P.radius), w.visible = P !== null
                }
                const x = v.joints["index-finger-tip"],
                    y = v.joints["thumb-tip"],
                    b = x.position.distanceTo(y.position),
                    S = .02,
                    C = .005;
                v.inputState.pinching && b > S + C ? (v.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: i.handedness,
                    target: this
                })) : !v.inputState.pinching && b <= S - C && (v.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: i.handedness,
                    target: this
                }))
            } else _ !== null && i.gripSpace && (p = o.getPose(i.gripSpace, c), p !== null && (_.matrix.fromArray(p.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.matrixWorldNeedsUpdate = !0, p.linearVelocity ? (_.hasLinearVelocity = !0, _.linearVelocity.copy(p.linearVelocity)) : _.hasLinearVelocity = !1, p.angularVelocity ? (_.hasAngularVelocity = !0, _.angularVelocity.copy(p.angularVelocity)) : _.hasAngularVelocity = !1));
            g !== null && (u = o.getPose(i.targetRaySpace, c), u === null && p !== null && (u = p), u !== null && (g.matrix.fromArray(u.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, u.linearVelocity ? (g.hasLinearVelocity = !0, g.linearVelocity.copy(u.linearVelocity)) : g.hasLinearVelocity = !1, u.angularVelocity ? (g.hasAngularVelocity = !0, g.angularVelocity.copy(u.angularVelocity)) : g.hasAngularVelocity = !1, this.dispatchEvent(_moveEvent)))
        }
        return g !== null && (g.visible = u !== null), _ !== null && (_.visible = p !== null), v !== null && (v.visible = m !== null), this
    }
    _getHandJoint(i, o) {
        if (i.joints[o.jointName] === void 0) {
            const c = new Group;
            c.matrixAutoUpdate = !1, c.visible = !1, i.joints[o.jointName] = c, i.add(c)
        }
        return i.joints[o.jointName]
    }
}
class Scene extends Object3D {
    constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Euler$1, this.environmentIntensity = 1, this.environmentRotation = new Euler$1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(i, o) {
        return super.copy(i, o), i.background !== null && (this.background = i.background.clone()), i.environment !== null && (this.environment = i.environment.clone()), i.fog !== null && (this.fog = i.fog.clone()), this.backgroundBlurriness = i.backgroundBlurriness, this.backgroundIntensity = i.backgroundIntensity, this.backgroundRotation.copy(i.backgroundRotation), this.environmentIntensity = i.environmentIntensity, this.environmentRotation.copy(i.environmentRotation), i.overrideMaterial !== null && (this.overrideMaterial = i.overrideMaterial.clone()), this.matrixAutoUpdate = i.matrixAutoUpdate, this
    }
    toJSON(i) {
        const o = super.toJSON(i);
        return this.fog !== null && (o.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (o.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (o.object.backgroundIntensity = this.backgroundIntensity), o.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (o.object.environmentIntensity = this.environmentIntensity), o.object.environmentRotation = this.environmentRotation.toArray(), o
    }
}
class InterleavedBuffer {
    constructor(i, o) {
        this.isInterleavedBuffer = !0, this.array = i, this.stride = o, this.count = i !== void 0 ? i.length / o : 0, this.usage = StaticDrawUsage, this.updateRanges = [], this.version = 0, this.uuid = generateUUID()
    }
    onUploadCallback() {}
    set needsUpdate(i) {
        i === !0 && this.version++
    }
    setUsage(i) {
        return this.usage = i, this
    }
    addUpdateRange(i, o) {
        this.updateRanges.push({
            start: i,
            count: o
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(i) {
        return this.array = new i.array.constructor(i.array), this.count = i.count, this.stride = i.stride, this.usage = i.usage, this
    }
    copyAt(i, o, c) {
        i *= this.stride, c *= o.stride;
        for (let u = 0, p = this.stride; u < p; u++) this.array[i + u] = o.array[c + u];
        return this
    }
    set(i, o = 0) {
        return this.array.set(i, o), this
    }
    clone(i) {
        i.arrayBuffers === void 0 && (i.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), i.arrayBuffers[this.array.buffer._uuid] === void 0 && (i.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const o = new this.array.constructor(i.arrayBuffers[this.array.buffer._uuid]),
            c = new this.constructor(o, this.stride);
        return c.setUsage(this.usage), c
    }
    onUpload(i) {
        return this.onUploadCallback = i, this
    }
    toJSON(i) {
        return i.arrayBuffers === void 0 && (i.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), i.arrayBuffers[this.array.buffer._uuid] === void 0 && (i.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const _vector$7 = new Vector3$1;
class InterleavedBufferAttribute {
    constructor(i, o, c, u = !1) {
        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = i, this.itemSize = o, this.offset = c, this.normalized = u
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(i) {
        this.data.needsUpdate = i
    }
    applyMatrix4(i) {
        for (let o = 0, c = this.data.count; o < c; o++) _vector$7.fromBufferAttribute(this, o), _vector$7.applyMatrix4(i), this.setXYZ(o, _vector$7.x, _vector$7.y, _vector$7.z);
        return this
    }
    applyNormalMatrix(i) {
        for (let o = 0, c = this.count; o < c; o++) _vector$7.fromBufferAttribute(this, o), _vector$7.applyNormalMatrix(i), this.setXYZ(o, _vector$7.x, _vector$7.y, _vector$7.z);
        return this
    }
    transformDirection(i) {
        for (let o = 0, c = this.count; o < c; o++) _vector$7.fromBufferAttribute(this, o), _vector$7.transformDirection(i), this.setXYZ(o, _vector$7.x, _vector$7.y, _vector$7.z);
        return this
    }
    getComponent(i, o) {
        let c = this.array[i * this.data.stride + this.offset + o];
        return this.normalized && (c = denormalize(c, this.array)), c
    }
    setComponent(i, o, c) {
        return this.normalized && (c = normalize$1(c, this.array)), this.data.array[i * this.data.stride + this.offset + o] = c, this
    }
    setX(i, o) {
        return this.normalized && (o = normalize$1(o, this.array)), this.data.array[i * this.data.stride + this.offset] = o, this
    }
    setY(i, o) {
        return this.normalized && (o = normalize$1(o, this.array)), this.data.array[i * this.data.stride + this.offset + 1] = o, this
    }
    setZ(i, o) {
        return this.normalized && (o = normalize$1(o, this.array)), this.data.array[i * this.data.stride + this.offset + 2] = o, this
    }
    setW(i, o) {
        return this.normalized && (o = normalize$1(o, this.array)), this.data.array[i * this.data.stride + this.offset + 3] = o, this
    }
    getX(i) {
        let o = this.data.array[i * this.data.stride + this.offset];
        return this.normalized && (o = denormalize(o, this.array)), o
    }
    getY(i) {
        let o = this.data.array[i * this.data.stride + this.offset + 1];
        return this.normalized && (o = denormalize(o, this.array)), o
    }
    getZ(i) {
        let o = this.data.array[i * this.data.stride + this.offset + 2];
        return this.normalized && (o = denormalize(o, this.array)), o
    }
    getW(i) {
        let o = this.data.array[i * this.data.stride + this.offset + 3];
        return this.normalized && (o = denormalize(o, this.array)), o
    }
    setXY(i, o, c) {
        return i = i * this.data.stride + this.offset, this.normalized && (o = normalize$1(o, this.array), c = normalize$1(c, this.array)), this.data.array[i + 0] = o, this.data.array[i + 1] = c, this
    }
    setXYZ(i, o, c, u) {
        return i = i * this.data.stride + this.offset, this.normalized && (o = normalize$1(o, this.array), c = normalize$1(c, this.array), u = normalize$1(u, this.array)), this.data.array[i + 0] = o, this.data.array[i + 1] = c, this.data.array[i + 2] = u, this
    }
    setXYZW(i, o, c, u, p) {
        return i = i * this.data.stride + this.offset, this.normalized && (o = normalize$1(o, this.array), c = normalize$1(c, this.array), u = normalize$1(u, this.array), p = normalize$1(p, this.array)), this.data.array[i + 0] = o, this.data.array[i + 1] = c, this.data.array[i + 2] = u, this.data.array[i + 3] = p, this
    }
    clone(i) {
        if (i === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const o = [];
            for (let c = 0; c < this.count; c++) {
                const u = c * this.data.stride + this.offset;
                for (let p = 0; p < this.itemSize; p++) o.push(this.data.array[u + p])
            }
            return new BufferAttribute(new this.array.constructor(o), this.itemSize, this.normalized)
        } else return i.interleavedBuffers === void 0 && (i.interleavedBuffers = {}), i.interleavedBuffers[this.data.uuid] === void 0 && (i.interleavedBuffers[this.data.uuid] = this.data.clone(i)), new InterleavedBufferAttribute(i.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(i) {
        if (i === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const o = [];
            for (let c = 0; c < this.count; c++) {
                const u = c * this.data.stride + this.offset;
                for (let p = 0; p < this.itemSize; p++) o.push(this.data.array[u + p])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: o,
                normalized: this.normalized
            }
        } else return i.interleavedBuffers === void 0 && (i.interleavedBuffers = {}), i.interleavedBuffers[this.data.uuid] === void 0 && (i.interleavedBuffers[this.data.uuid] = this.data.toJSON(i)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
const _basePosition = new Vector3$1,
    _skinIndex = new Vector4,
    _skinWeight = new Vector4,
    _vector3 = new Vector3$1,
    _matrix4 = new Matrix4,
    _vertex = new Vector3$1,
    _sphere$5 = new Sphere,
    _inverseMatrix$2 = new Matrix4,
    _ray$2 = new Ray;
class SkinnedMesh extends Mesh {
    constructor(i, o) {
        super(i, o), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = AttachedBindMode, this.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4, this.boundingBox = null, this.boundingSphere = null
    }
    computeBoundingBox() {
        const i = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Box3), this.boundingBox.makeEmpty();
        const o = i.getAttribute("position");
        for (let c = 0; c < o.count; c++) this.getVertexPosition(c, _vertex), this.boundingBox.expandByPoint(_vertex)
    }
    computeBoundingSphere() {
        const i = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new Sphere), this.boundingSphere.makeEmpty();
        const o = i.getAttribute("position");
        for (let c = 0; c < o.count; c++) this.getVertexPosition(c, _vertex), this.boundingSphere.expandByPoint(_vertex)
    }
    copy(i, o) {
        return super.copy(i, o), this.bindMode = i.bindMode, this.bindMatrix.copy(i.bindMatrix), this.bindMatrixInverse.copy(i.bindMatrixInverse), this.skeleton = i.skeleton, i.boundingBox !== null && (this.boundingBox = i.boundingBox.clone()), i.boundingSphere !== null && (this.boundingSphere = i.boundingSphere.clone()), this
    }
    raycast(i, o) {
        const c = this.material,
            u = this.matrixWorld;
        c !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _sphere$5.copy(this.boundingSphere), _sphere$5.applyMatrix4(u), i.ray.intersectsSphere(_sphere$5) !== !1 && (_inverseMatrix$2.copy(u).invert(), _ray$2.copy(i.ray).applyMatrix4(_inverseMatrix$2), !(this.boundingBox !== null && _ray$2.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(i, o, _ray$2)))
    }
    getVertexPosition(i, o) {
        return super.getVertexPosition(i, o), this.applyBoneTransform(i, o), o
    }
    bind(i, o) {
        this.skeleton = i, o === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), o = this.matrixWorld), this.bindMatrix.copy(o), this.bindMatrixInverse.copy(o).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const i = new Vector4,
            o = this.geometry.attributes.skinWeight;
        for (let c = 0, u = o.count; c < u; c++) {
            i.fromBufferAttribute(o, c);
            const p = 1 / i.manhattanLength();
            p !== 1 / 0 ? i.multiplyScalar(p) : i.set(1, 0, 0, 0), o.setXYZW(c, i.x, i.y, i.z, i.w)
        }
    }
    updateMatrixWorld(i) {
        super.updateMatrixWorld(i), this.bindMode === AttachedBindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === DetachedBindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(i, o) {
        const c = this.skeleton,
            u = this.geometry;
        _skinIndex.fromBufferAttribute(u.attributes.skinIndex, i), _skinWeight.fromBufferAttribute(u.attributes.skinWeight, i), _basePosition.copy(o).applyMatrix4(this.bindMatrix), o.set(0, 0, 0);
        for (let p = 0; p < 4; p++) {
            const m = _skinWeight.getComponent(p);
            if (m !== 0) {
                const g = _skinIndex.getComponent(p);
                _matrix4.multiplyMatrices(c.bones[g].matrixWorld, c.boneInverses[g]), o.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), m)
            }
        }
        return o.applyMatrix4(this.bindMatrixInverse)
    }
}
class Bone extends Object3D {
    constructor() {
        super(), this.isBone = !0, this.type = "Bone"
    }
}
class DataTexture extends Texture {
    constructor(i = null, o = 1, c = 1, u, p, m, g, _, v = NearestFilter, x = NearestFilter, y, b) {
        super(null, m, g, _, v, x, u, p, y, b), this.isDataTexture = !0, this.image = {
            data: i,
            width: o,
            height: c
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
const _offsetMatrix = new Matrix4,
    _identityMatrix$1 = new Matrix4;
class Skeleton {
    constructor(i = [], o = []) {
        this.uuid = generateUUID(), this.bones = i.slice(0), this.boneInverses = o, this.boneMatrices = null, this.boneTexture = null, this.init()
    }
    init() {
        const i = this.bones,
            o = this.boneInverses;
        if (this.boneMatrices = new Float32Array(i.length * 16), o.length === 0) this.calculateInverses();
        else if (i.length !== o.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let c = 0, u = this.bones.length; c < u; c++) this.boneInverses.push(new Matrix4)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let i = 0, o = this.bones.length; i < o; i++) {
            const c = new Matrix4;
            this.bones[i] && c.copy(this.bones[i].matrixWorld).invert(), this.boneInverses.push(c)
        }
    }
    pose() {
        for (let i = 0, o = this.bones.length; i < o; i++) {
            const c = this.bones[i];
            c && c.matrixWorld.copy(this.boneInverses[i]).invert()
        }
        for (let i = 0, o = this.bones.length; i < o; i++) {
            const c = this.bones[i];
            c && (c.parent && c.parent.isBone ? (c.matrix.copy(c.parent.matrixWorld).invert(), c.matrix.multiply(c.matrixWorld)) : c.matrix.copy(c.matrixWorld), c.matrix.decompose(c.position, c.quaternion, c.scale))
        }
    }
    update() {
        const i = this.bones,
            o = this.boneInverses,
            c = this.boneMatrices,
            u = this.boneTexture;
        for (let p = 0, m = i.length; p < m; p++) {
            const g = i[p] ? i[p].matrixWorld : _identityMatrix$1;
            _offsetMatrix.multiplyMatrices(g, o[p]), _offsetMatrix.toArray(c, p * 16)
        }
        u !== null && (u.needsUpdate = !0)
    }
    clone() {
        return new Skeleton(this.bones, this.boneInverses)
    }
    computeBoneTexture() {
        let i = Math.sqrt(this.bones.length * 4);
        i = Math.ceil(i / 4) * 4, i = Math.max(i, 4);
        const o = new Float32Array(i * i * 4);
        o.set(this.boneMatrices);
        const c = new DataTexture(o, i, i, RGBAFormat, FloatType);
        return c.needsUpdate = !0, this.boneMatrices = o, this.boneTexture = c, this
    }
    getBoneByName(i) {
        for (let o = 0, c = this.bones.length; o < c; o++) {
            const u = this.bones[o];
            if (u.name === i) return u
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
    }
    fromJSON(i, o) {
        this.uuid = i.uuid;
        for (let c = 0, u = i.bones.length; c < u; c++) {
            const p = i.bones[c];
            let m = o[p];
            m === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", p), m = new Bone), this.bones.push(m), this.boneInverses.push(new Matrix4().fromArray(i.boneInverses[c]))
        }
        return this.init(), this
    }
    toJSON() {
        const i = {
            metadata: {
                version: 4.7,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        i.uuid = this.uuid;
        const o = this.bones,
            c = this.boneInverses;
        for (let u = 0, p = o.length; u < p; u++) {
            const m = o[u];
            i.bones.push(m.uuid);
            const g = c[u];
            i.boneInverses.push(g.toArray())
        }
        return i
    }
}
class InstancedBufferAttribute extends BufferAttribute {
    constructor(i, o, c, u = 1) {
        super(i, o, c), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = u
    }
    copy(i) {
        return super.copy(i), this.meshPerAttribute = i.meshPerAttribute, this
    }
    toJSON() {
        const i = super.toJSON();
        return i.meshPerAttribute = this.meshPerAttribute, i.isInstancedBufferAttribute = !0, i
    }
}
const _instanceLocalMatrix = new Matrix4,
    _instanceWorldMatrix = new Matrix4,
    _instanceIntersects = [],
    _box3 = new Box3,
    _identity = new Matrix4,
    _mesh$1 = new Mesh,
    _sphere$4 = new Sphere;
class InstancedMesh extends Mesh {
    constructor(i, o, c) {
        super(i, o), this.isInstancedMesh = !0, this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(c * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = c, this.boundingBox = null, this.boundingSphere = null;
        for (let u = 0; u < c; u++) this.setMatrixAt(u, _identity)
    }
    computeBoundingBox() {
        const i = this.geometry,
            o = this.count;
        this.boundingBox === null && (this.boundingBox = new Box3), i.boundingBox === null && i.computeBoundingBox(), this.boundingBox.makeEmpty();
        for (let c = 0; c < o; c++) this.getMatrixAt(c, _instanceLocalMatrix), _box3.copy(i.boundingBox).applyMatrix4(_instanceLocalMatrix), this.boundingBox.union(_box3)
    }
    computeBoundingSphere() {
        const i = this.geometry,
            o = this.count;
        this.boundingSphere === null && (this.boundingSphere = new Sphere), i.boundingSphere === null && i.computeBoundingSphere(), this.boundingSphere.makeEmpty();
        for (let c = 0; c < o; c++) this.getMatrixAt(c, _instanceLocalMatrix), _sphere$4.copy(i.boundingSphere).applyMatrix4(_instanceLocalMatrix), this.boundingSphere.union(_sphere$4)
    }
    copy(i, o) {
        return super.copy(i, o), this.instanceMatrix.copy(i.instanceMatrix), i.morphTexture !== null && (this.morphTexture = i.morphTexture.clone()), i.instanceColor !== null && (this.instanceColor = i.instanceColor.clone()), this.count = i.count, i.boundingBox !== null && (this.boundingBox = i.boundingBox.clone()), i.boundingSphere !== null && (this.boundingSphere = i.boundingSphere.clone()), this
    }
    getColorAt(i, o) {
        o.fromArray(this.instanceColor.array, i * 3)
    }
    getMatrixAt(i, o) {
        o.fromArray(this.instanceMatrix.array, i * 16)
    }
    getMorphAt(i, o) {
        const c = o.morphTargetInfluences,
            u = this.morphTexture.source.data.data,
            p = c.length + 1,
            m = i * p + 1;
        for (let g = 0; g < c.length; g++) c[g] = u[m + g]
    }
    raycast(i, o) {
        const c = this.matrixWorld,
            u = this.count;
        if (_mesh$1.geometry = this.geometry, _mesh$1.material = this.material, _mesh$1.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _sphere$4.copy(this.boundingSphere), _sphere$4.applyMatrix4(c), i.ray.intersectsSphere(_sphere$4) !== !1))
            for (let p = 0; p < u; p++) {
                this.getMatrixAt(p, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(c, _instanceLocalMatrix), _mesh$1.matrixWorld = _instanceWorldMatrix, _mesh$1.raycast(i, _instanceIntersects);
                for (let m = 0, g = _instanceIntersects.length; m < g; m++) {
                    const _ = _instanceIntersects[m];
                    _.instanceId = p, _.object = this, o.push(_)
                }
                _instanceIntersects.length = 0
            }
    }
    setColorAt(i, o) {
        this.instanceColor === null && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), o.toArray(this.instanceColor.array, i * 3)
    }
    setMatrixAt(i, o) {
        o.toArray(this.instanceMatrix.array, i * 16)
    }
    setMorphAt(i, o) {
        const c = o.morphTargetInfluences,
            u = c.length + 1;
        this.morphTexture === null && (this.morphTexture = new DataTexture(new Float32Array(u * this.count), u, this.count, RedFormat, FloatType));
        const p = this.morphTexture.source.data.data;
        let m = 0;
        for (let v = 0; v < c.length; v++) m += c[v];
        const g = this.geometry.morphTargetsRelative ? 1 : 1 - m,
            _ = u * i;
        p[_] = g, p.set(c, _ + 1)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null)
    }
}
const _vector1 = new Vector3$1,
    _vector2 = new Vector3$1,
    _normalMatrix = new Matrix3;
class Plane {
    constructor(i = new Vector3$1(1, 0, 0), o = 0) {
        this.isPlane = !0, this.normal = i, this.constant = o
    }
    set(i, o) {
        return this.normal.copy(i), this.constant = o, this
    }
    setComponents(i, o, c, u) {
        return this.normal.set(i, o, c), this.constant = u, this
    }
    setFromNormalAndCoplanarPoint(i, o) {
        return this.normal.copy(i), this.constant = -o.dot(this.normal), this
    }
    setFromCoplanarPoints(i, o, c) {
        const u = _vector1.subVectors(c, o).cross(_vector2.subVectors(i, o)).normalize();
        return this.setFromNormalAndCoplanarPoint(u, i), this
    }
    copy(i) {
        return this.normal.copy(i.normal), this.constant = i.constant, this
    }
    normalize() {
        const i = 1 / this.normal.length();
        return this.normal.multiplyScalar(i), this.constant *= i, this
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(i) {
        return this.normal.dot(i) + this.constant
    }
    distanceToSphere(i) {
        return this.distanceToPoint(i.center) - i.radius
    }
    projectPoint(i, o) {
        return o.copy(i).addScaledVector(this.normal, -this.distanceToPoint(i))
    }
    intersectLine(i, o) {
        const c = i.delta(_vector1),
            u = this.normal.dot(c);
        if (u === 0) return this.distanceToPoint(i.start) === 0 ? o.copy(i.start) : null;
        const p = -(i.start.dot(this.normal) + this.constant) / u;
        return p < 0 || p > 1 ? null : o.copy(i.start).addScaledVector(c, p)
    }
    intersectsLine(i) {
        const o = this.distanceToPoint(i.start),
            c = this.distanceToPoint(i.end);
        return o < 0 && c > 0 || c < 0 && o > 0
    }
    intersectsBox(i) {
        return i.intersectsPlane(this)
    }
    intersectsSphere(i) {
        return i.intersectsPlane(this)
    }
    coplanarPoint(i) {
        return i.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(i, o) {
        const c = o || _normalMatrix.getNormalMatrix(i),
            u = this.coplanarPoint(_vector1).applyMatrix4(i),
            p = this.normal.applyMatrix3(c).normalize();
        return this.constant = -u.dot(p), this
    }
    translate(i) {
        return this.constant -= i.dot(this.normal), this
    }
    equals(i) {
        return i.normal.equals(this.normal) && i.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _sphere$3 = new Sphere,
    _vector$6 = new Vector3$1;
class Frustum {
    constructor(i = new Plane, o = new Plane, c = new Plane, u = new Plane, p = new Plane, m = new Plane) {
        this.planes = [i, o, c, u, p, m]
    }
    set(i, o, c, u, p, m) {
        const g = this.planes;
        return g[0].copy(i), g[1].copy(o), g[2].copy(c), g[3].copy(u), g[4].copy(p), g[5].copy(m), this
    }
    copy(i) {
        const o = this.planes;
        for (let c = 0; c < 6; c++) o[c].copy(i.planes[c]);
        return this
    }
    setFromProjectionMatrix(i, o = WebGLCoordinateSystem) {
        const c = this.planes,
            u = i.elements,
            p = u[0],
            m = u[1],
            g = u[2],
            _ = u[3],
            v = u[4],
            x = u[5],
            y = u[6],
            b = u[7],
            S = u[8],
            C = u[9],
            E = u[10],
            P = u[11],
            w = u[12],
            T = u[13],
            M = u[14],
            A = u[15];
        if (c[0].setComponents(_ - p, b - v, P - S, A - w).normalize(), c[1].setComponents(_ + p, b + v, P + S, A + w).normalize(), c[2].setComponents(_ + m, b + x, P + C, A + T).normalize(), c[3].setComponents(_ - m, b - x, P - C, A - T).normalize(), c[4].setComponents(_ - g, b - y, P - E, A - M).normalize(), o === WebGLCoordinateSystem) c[5].setComponents(_ + g, b + y, P + E, A + M).normalize();
        else if (o === WebGPUCoordinateSystem) c[5].setComponents(g, y, E, M).normalize();
        else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + o);
        return this
    }
    intersectsObject(i) {
        if (i.boundingSphere !== void 0) i.boundingSphere === null && i.computeBoundingSphere(), _sphere$3.copy(i.boundingSphere).applyMatrix4(i.matrixWorld);
        else {
            const o = i.geometry;
            o.boundingSphere === null && o.computeBoundingSphere(), _sphere$3.copy(o.boundingSphere).applyMatrix4(i.matrixWorld)
        }
        return this.intersectsSphere(_sphere$3)
    }
    intersectsSprite(i) {
        return _sphere$3.center.set(0, 0, 0), _sphere$3.radius = .7071067811865476, _sphere$3.applyMatrix4(i.matrixWorld), this.intersectsSphere(_sphere$3)
    }
    intersectsSphere(i) {
        const o = this.planes,
            c = i.center,
            u = -i.radius;
        for (let p = 0; p < 6; p++)
            if (o[p].distanceToPoint(c) < u) return !1;
        return !0
    }
    intersectsBox(i) {
        const o = this.planes;
        for (let c = 0; c < 6; c++) {
            const u = o[c];
            if (_vector$6.x = u.normal.x > 0 ? i.max.x : i.min.x, _vector$6.y = u.normal.y > 0 ? i.max.y : i.min.y, _vector$6.z = u.normal.z > 0 ? i.max.z : i.min.z, u.distanceToPoint(_vector$6) < 0) return !1
        }
        return !0
    }
    containsPoint(i) {
        const o = this.planes;
        for (let c = 0; c < 6; c++)
            if (o[c].distanceToPoint(i) < 0) return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class LineBasicMaterial extends Material {
    constructor(i) {
        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Color(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(i)
    }
    copy(i) {
        return super.copy(i), this.color.copy(i.color), this.map = i.map, this.linewidth = i.linewidth, this.linecap = i.linecap, this.linejoin = i.linejoin, this.fog = i.fog, this
    }
}
const _vStart = new Vector3$1,
    _vEnd = new Vector3$1,
    _inverseMatrix$1 = new Matrix4,
    _ray$1 = new Ray,
    _sphere$1 = new Sphere,
    _intersectPointOnRay = new Vector3$1,
    _intersectPointOnSegment = new Vector3$1;
class Line extends Object3D {
    constructor(i = new BufferGeometry, o = new LineBasicMaterial) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = i, this.material = o, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
    }
    copy(i, o) {
        return super.copy(i, o), this.material = Array.isArray(i.material) ? i.material.slice() : i.material, this.geometry = i.geometry, this
    }
    computeLineDistances() {
        const i = this.geometry;
        if (i.index === null) {
            const o = i.attributes.position,
                c = [0];
            for (let u = 1, p = o.count; u < p; u++) _vStart.fromBufferAttribute(o, u - 1), _vEnd.fromBufferAttribute(o, u), c[u] = c[u - 1], c[u] += _vStart.distanceTo(_vEnd);
            i.setAttribute("lineDistance", new Float32BufferAttribute(c, 1))
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(i, o) {
        const c = this.geometry,
            u = this.matrixWorld,
            p = i.params.Line.threshold,
            m = c.drawRange;
        if (c.boundingSphere === null && c.computeBoundingSphere(), _sphere$1.copy(c.boundingSphere), _sphere$1.applyMatrix4(u), _sphere$1.radius += p, i.ray.intersectsSphere(_sphere$1) === !1) return;
        _inverseMatrix$1.copy(u).invert(), _ray$1.copy(i.ray).applyMatrix4(_inverseMatrix$1);
        const g = p / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            _ = g * g,
            v = this.isLineSegments ? 2 : 1,
            x = c.index,
            b = c.attributes.position;
        if (x !== null) {
            const S = Math.max(0, m.start),
                C = Math.min(x.count, m.start + m.count);
            for (let E = S, P = C - 1; E < P; E += v) {
                const w = x.getX(E),
                    T = x.getX(E + 1),
                    M = checkIntersection(this, i, _ray$1, _, w, T, E);
                M && o.push(M)
            }
            if (this.isLineLoop) {
                const E = x.getX(C - 1),
                    P = x.getX(S),
                    w = checkIntersection(this, i, _ray$1, _, E, P, C - 1);
                w && o.push(w)
            }
        } else {
            const S = Math.max(0, m.start),
                C = Math.min(b.count, m.start + m.count);
            for (let E = S, P = C - 1; E < P; E += v) {
                const w = checkIntersection(this, i, _ray$1, _, E, E + 1, E);
                w && o.push(w)
            }
            if (this.isLineLoop) {
                const E = checkIntersection(this, i, _ray$1, _, C - 1, S, C - 1);
                E && o.push(E)
            }
        }
    }
    updateMorphTargets() {
        const o = this.geometry.morphAttributes,
            c = Object.keys(o);
        if (c.length > 0) {
            const u = o[c[0]];
            if (u !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let p = 0, m = u.length; p < m; p++) {
                    const g = u[p].name || String(p);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[g] = p
                }
            }
        }
    }
}

function checkIntersection(l, i, o, c, u, p, m) {
    const g = l.geometry.attributes.position;
    if (_vStart.fromBufferAttribute(g, u), _vEnd.fromBufferAttribute(g, p), o.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment) > c) return;
    _intersectPointOnRay.applyMatrix4(l.matrixWorld);
    const v = i.ray.origin.distanceTo(_intersectPointOnRay);
    if (!(v < i.near || v > i.far)) return {
        distance: v,
        point: _intersectPointOnSegment.clone().applyMatrix4(l.matrixWorld),
        index: m,
        face: null,
        faceIndex: null,
        barycoord: null,
        object: l
    }
}
const _start = new Vector3$1,
    _end = new Vector3$1;
class LineSegments extends Line {
    constructor(i, o) {
        super(i, o), this.isLineSegments = !0, this.type = "LineSegments"
    }
    computeLineDistances() {
        const i = this.geometry;
        if (i.index === null) {
            const o = i.attributes.position,
                c = [];
            for (let u = 0, p = o.count; u < p; u += 2) _start.fromBufferAttribute(o, u), _end.fromBufferAttribute(o, u + 1), c[u] = u === 0 ? 0 : c[u - 1], c[u + 1] = c[u] + _start.distanceTo(_end);
            i.setAttribute("lineDistance", new Float32BufferAttribute(c, 1))
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class LineLoop extends Line {
    constructor(i, o) {
        super(i, o), this.isLineLoop = !0, this.type = "LineLoop"
    }
}
class PointsMaterial extends Material {
    constructor(i) {
        super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(i)
    }
    copy(i) {
        return super.copy(i), this.color.copy(i.color), this.map = i.map, this.alphaMap = i.alphaMap, this.size = i.size, this.sizeAttenuation = i.sizeAttenuation, this.fog = i.fog, this
    }
}
const _inverseMatrix = new Matrix4,
    _ray = new Ray,
    _sphere = new Sphere,
    _position$2 = new Vector3$1;
class Points extends Object3D {
    constructor(i = new BufferGeometry, o = new PointsMaterial) {
        super(), this.isPoints = !0, this.type = "Points", this.geometry = i, this.material = o, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
    }
    copy(i, o) {
        return super.copy(i, o), this.material = Array.isArray(i.material) ? i.material.slice() : i.material, this.geometry = i.geometry, this
    }
    raycast(i, o) {
        const c = this.geometry,
            u = this.matrixWorld,
            p = i.params.Points.threshold,
            m = c.drawRange;
        if (c.boundingSphere === null && c.computeBoundingSphere(), _sphere.copy(c.boundingSphere), _sphere.applyMatrix4(u), _sphere.radius += p, i.ray.intersectsSphere(_sphere) === !1) return;
        _inverseMatrix.copy(u).invert(), _ray.copy(i.ray).applyMatrix4(_inverseMatrix);
        const g = p / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            _ = g * g,
            v = c.index,
            y = c.attributes.position;
        if (v !== null) {
            const b = Math.max(0, m.start),
                S = Math.min(v.count, m.start + m.count);
            for (let C = b, E = S; C < E; C++) {
                const P = v.getX(C);
                _position$2.fromBufferAttribute(y, P), testPoint(_position$2, P, _, u, i, o, this)
            }
        } else {
            const b = Math.max(0, m.start),
                S = Math.min(y.count, m.start + m.count);
            for (let C = b, E = S; C < E; C++) _position$2.fromBufferAttribute(y, C), testPoint(_position$2, C, _, u, i, o, this)
        }
    }
    updateMorphTargets() {
        const o = this.geometry.morphAttributes,
            c = Object.keys(o);
        if (c.length > 0) {
            const u = o[c[0]];
            if (u !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let p = 0, m = u.length; p < m; p++) {
                    const g = u[p].name || String(p);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[g] = p
                }
            }
        }
    }
}

function testPoint(l, i, o, c, u, p, m) {
    const g = _ray.distanceSqToPoint(l);
    if (g < o) {
        const _ = new Vector3$1;
        _ray.closestPointToPoint(l, _), _.applyMatrix4(c);
        const v = u.ray.origin.distanceTo(_);
        if (v < u.near || v > u.far) return;
        p.push({
            distance: v,
            distanceToRay: Math.sqrt(g),
            point: _,
            index: i,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: m
        })
    }
}
class VideoTexture extends Texture {
    constructor(i, o, c, u, p = LinearFilter, m = LinearFilter, g, _, v) {
        super(i, o, c, u, p, m, g, _, v), this.isVideoTexture = !0, this.generateMipmaps = !1;
        const x = this;

        function y() {
            x.needsUpdate = !0, i.requestVideoFrameCallback(y)
        }
        "requestVideoFrameCallback" in i && i.requestVideoFrameCallback(y)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const i = this.image;
        "requestVideoFrameCallback" in i === !1 && i.readyState >= i.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class CanvasTexture extends Texture {
    constructor(i, o, c, u, p, m, g, _, v) {
        super(i, o, c, u, p, m, g, _, v), this.isCanvasTexture = !0, this.needsUpdate = !0
    }
}
class DepthTexture extends Texture {
    constructor(i, o, c = UnsignedIntType, u, p, m, g = NearestFilter, _ = NearestFilter, v, x = DepthFormat, y = 1) {
        if (x !== DepthFormat && x !== DepthStencilFormat) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        const b = {
            width: i,
            height: o,
            depth: y
        };
        super(b, u, p, m, g, _, x, c, v), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
    }
    copy(i) {
        return super.copy(i), this.source = new Source(Object.assign({}, i.image)), this.compareFunction = i.compareFunction, this
    }
    toJSON(i) {
        const o = super.toJSON(i);
        return this.compareFunction !== null && (o.compareFunction = this.compareFunction), o
    }
}
class PlaneGeometry extends BufferGeometry {
    constructor(i = 1, o = 1, c = 1, u = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: i,
            height: o,
            widthSegments: c,
            heightSegments: u
        };
        const p = i / 2,
            m = o / 2,
            g = Math.floor(c),
            _ = Math.floor(u),
            v = g + 1,
            x = _ + 1,
            y = i / g,
            b = o / _,
            S = [],
            C = [],
            E = [],
            P = [];
        for (let w = 0; w < x; w++) {
            const T = w * b - m;
            for (let M = 0; M < v; M++) {
                const A = M * y - p;
                C.push(A, -T, 0), E.push(0, 0, 1), P.push(M / g), P.push(1 - w / _)
            }
        }
        for (let w = 0; w < _; w++)
            for (let T = 0; T < g; T++) {
                const M = T + v * w,
                    A = T + v * (w + 1),
                    D = T + 1 + v * (w + 1),
                    R = T + 1 + v * w;
                S.push(M, A, R), S.push(A, D, R)
            }
        this.setIndex(S), this.setAttribute("position", new Float32BufferAttribute(C, 3)), this.setAttribute("normal", new Float32BufferAttribute(E, 3)), this.setAttribute("uv", new Float32BufferAttribute(P, 2))
    }
    copy(i) {
        return super.copy(i), this.parameters = Object.assign({}, i.parameters), this
    }
    static fromJSON(i) {
        return new PlaneGeometry(i.width, i.height, i.widthSegments, i.heightSegments)
    }
}
class MeshStandardMaterial extends Material {
    constructor(i) {
        super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = {
            STANDARD: ""
        }, this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler$1, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(i)
    }
    copy(i) {
        return super.copy(i), this.defines = {
            STANDARD: ""
        }, this.color.copy(i.color), this.roughness = i.roughness, this.metalness = i.metalness, this.map = i.map, this.lightMap = i.lightMap, this.lightMapIntensity = i.lightMapIntensity, this.aoMap = i.aoMap, this.aoMapIntensity = i.aoMapIntensity, this.emissive.copy(i.emissive), this.emissiveMap = i.emissiveMap, this.emissiveIntensity = i.emissiveIntensity, this.bumpMap = i.bumpMap, this.bumpScale = i.bumpScale, this.normalMap = i.normalMap, this.normalMapType = i.normalMapType, this.normalScale.copy(i.normalScale), this.displacementMap = i.displacementMap, this.displacementScale = i.displacementScale, this.displacementBias = i.displacementBias, this.roughnessMap = i.roughnessMap, this.metalnessMap = i.metalnessMap, this.alphaMap = i.alphaMap, this.envMap = i.envMap, this.envMapRotation.copy(i.envMapRotation), this.envMapIntensity = i.envMapIntensity, this.wireframe = i.wireframe, this.wireframeLinewidth = i.wireframeLinewidth, this.wireframeLinecap = i.wireframeLinecap, this.wireframeLinejoin = i.wireframeLinejoin, this.flatShading = i.flatShading, this.fog = i.fog, this
    }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
    constructor(i) {
        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
                return clamp$3(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(o) {
                this.ior = (1 + .4 * o) / (1 - .4 * o)
            }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Color(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Color(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Color(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(i)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(i) {
        this._anisotropy > 0 != i > 0 && this.version++, this._anisotropy = i
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(i) {
        this._clearcoat > 0 != i > 0 && this.version++, this._clearcoat = i
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(i) {
        this._iridescence > 0 != i > 0 && this.version++, this._iridescence = i
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(i) {
        this._dispersion > 0 != i > 0 && this.version++, this._dispersion = i
    }
    get sheen() {
        return this._sheen
    }
    set sheen(i) {
        this._sheen > 0 != i > 0 && this.version++, this._sheen = i
    }
    get transmission() {
        return this._transmission
    }
    set transmission(i) {
        this._transmission > 0 != i > 0 && this.version++, this._transmission = i
    }
    copy(i) {
        return super.copy(i), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.anisotropy = i.anisotropy, this.anisotropyRotation = i.anisotropyRotation, this.anisotropyMap = i.anisotropyMap, this.clearcoat = i.clearcoat, this.clearcoatMap = i.clearcoatMap, this.clearcoatRoughness = i.clearcoatRoughness, this.clearcoatRoughnessMap = i.clearcoatRoughnessMap, this.clearcoatNormalMap = i.clearcoatNormalMap, this.clearcoatNormalScale.copy(i.clearcoatNormalScale), this.dispersion = i.dispersion, this.ior = i.ior, this.iridescence = i.iridescence, this.iridescenceMap = i.iridescenceMap, this.iridescenceIOR = i.iridescenceIOR, this.iridescenceThicknessRange = [...i.iridescenceThicknessRange], this.iridescenceThicknessMap = i.iridescenceThicknessMap, this.sheen = i.sheen, this.sheenColor.copy(i.sheenColor), this.sheenColorMap = i.sheenColorMap, this.sheenRoughness = i.sheenRoughness, this.sheenRoughnessMap = i.sheenRoughnessMap, this.transmission = i.transmission, this.transmissionMap = i.transmissionMap, this.thickness = i.thickness, this.thicknessMap = i.thicknessMap, this.attenuationDistance = i.attenuationDistance, this.attenuationColor.copy(i.attenuationColor), this.specularIntensity = i.specularIntensity, this.specularIntensityMap = i.specularIntensityMap, this.specularColor.copy(i.specularColor), this.specularColorMap = i.specularColorMap, this
    }
}
class MeshDepthMaterial extends Material {
    constructor(i) {
        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(i)
    }
    copy(i) {
        return super.copy(i), this.depthPacking = i.depthPacking, this.map = i.map, this.alphaMap = i.alphaMap, this.displacementMap = i.displacementMap, this.displacementScale = i.displacementScale, this.displacementBias = i.displacementBias, this.wireframe = i.wireframe, this.wireframeLinewidth = i.wireframeLinewidth, this
    }
}
class MeshDistanceMaterial extends Material {
    constructor(i) {
        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(i)
    }
    copy(i) {
        return super.copy(i), this.map = i.map, this.alphaMap = i.alphaMap, this.displacementMap = i.displacementMap, this.displacementScale = i.displacementScale, this.displacementBias = i.displacementBias, this
    }
}

function convertArray(l, i) {
    return !l || l.constructor === i ? l : typeof i.BYTES_PER_ELEMENT == "number" ? new i(l) : Array.prototype.slice.call(l)
}

function isTypedArray(l) {
    return ArrayBuffer.isView(l) && !(l instanceof DataView)
}

function getKeyframeOrder(l) {
    function i(u, p) {
        return l[u] - l[p]
    }
    const o = l.length,
        c = new Array(o);
    for (let u = 0; u !== o; ++u) c[u] = u;
    return c.sort(i), c
}

function sortedArray(l, i, o) {
    const c = l.length,
        u = new l.constructor(c);
    for (let p = 0, m = 0; m !== c; ++p) {
        const g = o[p] * i;
        for (let _ = 0; _ !== i; ++_) u[m++] = l[g + _]
    }
    return u
}

function flattenJSON(l, i, o, c) {
    let u = 1,
        p = l[0];
    for (; p !== void 0 && p[c] === void 0;) p = l[u++];
    if (p === void 0) return;
    let m = p[c];
    if (m !== void 0)
        if (Array.isArray(m))
            do m = p[c], m !== void 0 && (i.push(p.time), o.push(...m)), p = l[u++]; while (p !== void 0);
        else if (m.toArray !== void 0)
        do m = p[c], m !== void 0 && (i.push(p.time), m.toArray(o, o.length)), p = l[u++]; while (p !== void 0);
    else
        do m = p[c], m !== void 0 && (i.push(p.time), o.push(m)), p = l[u++]; while (p !== void 0)
}
class Interpolant {
    constructor(i, o, c, u) {
        this.parameterPositions = i, this._cachedIndex = 0, this.resultBuffer = u !== void 0 ? u : new o.constructor(c), this.sampleValues = o, this.valueSize = c, this.settings = null, this.DefaultSettings_ = {}
    }
    evaluate(i) {
        const o = this.parameterPositions;
        let c = this._cachedIndex,
            u = o[c],
            p = o[c - 1];
        i: {
            e: {
                let m;t: {
                    n: if (!(i < u)) {
                        for (let g = c + 2;;) {
                            if (u === void 0) {
                                if (i < p) break n;
                                return c = o.length, this._cachedIndex = c, this.copySampleValue_(c - 1)
                            }
                            if (c === g) break;
                            if (p = u, u = o[++c], i < u) break e
                        }
                        m = o.length;
                        break t
                    }if (!(i >= p)) {
                        const g = o[1];
                        i < g && (c = 2, p = g);
                        for (let _ = c - 2;;) {
                            if (p === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (c === _) break;
                            if (u = p, p = o[--c - 1], i >= p) break e
                        }
                        m = c, c = 0;
                        break t
                    }
                    break i
                }
                for (; c < m;) {
                    const g = c + m >>> 1;
                    i < o[g] ? m = g : c = g + 1
                }
                if (u = o[c], p = o[c - 1], p === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (u === void 0) return c = o.length, this._cachedIndex = c, this.copySampleValue_(c - 1)
            }
            this._cachedIndex = c,
            this.intervalChanged_(c, p, u)
        }
        return this.interpolate_(c, p, i, u)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(i) {
        const o = this.resultBuffer,
            c = this.sampleValues,
            u = this.valueSize,
            p = i * u;
        for (let m = 0; m !== u; ++m) o[m] = c[p + m];
        return o
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
    constructor(i, o, c, u) {
        super(i, o, c, u), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        }
    }
    intervalChanged_(i, o, c) {
        const u = this.parameterPositions;
        let p = i - 2,
            m = i + 1,
            g = u[p],
            _ = u[m];
        if (g === void 0) switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
                p = i, g = 2 * o - c;
                break;
            case WrapAroundEnding:
                p = u.length - 2, g = o + u[p] - u[p + 1];
                break;
            default:
                p = i, g = c
        }
        if (_ === void 0) switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
                m = i, _ = 2 * c - o;
                break;
            case WrapAroundEnding:
                m = 1, _ = c + u[1] - u[0];
                break;
            default:
                m = i - 1, _ = o
        }
        const v = (c - o) * .5,
            x = this.valueSize;
        this._weightPrev = v / (o - g), this._weightNext = v / (_ - c), this._offsetPrev = p * x, this._offsetNext = m * x
    }
    interpolate_(i, o, c, u) {
        const p = this.resultBuffer,
            m = this.sampleValues,
            g = this.valueSize,
            _ = i * g,
            v = _ - g,
            x = this._offsetPrev,
            y = this._offsetNext,
            b = this._weightPrev,
            S = this._weightNext,
            C = (c - o) / (u - o),
            E = C * C,
            P = E * C,
            w = -b * P + 2 * b * E - b * C,
            T = (1 + b) * P + (-1.5 - 2 * b) * E + (-.5 + b) * C + 1,
            M = (-1 - S) * P + (1.5 + S) * E + .5 * C,
            A = S * P - S * E;
        for (let D = 0; D !== g; ++D) p[D] = w * m[x + D] + T * m[v + D] + M * m[_ + D] + A * m[y + D];
        return p
    }
}
class LinearInterpolant extends Interpolant {
    constructor(i, o, c, u) {
        super(i, o, c, u)
    }
    interpolate_(i, o, c, u) {
        const p = this.resultBuffer,
            m = this.sampleValues,
            g = this.valueSize,
            _ = i * g,
            v = _ - g,
            x = (c - o) / (u - o),
            y = 1 - x;
        for (let b = 0; b !== g; ++b) p[b] = m[v + b] * y + m[_ + b] * x;
        return p
    }
}
class DiscreteInterpolant extends Interpolant {
    constructor(i, o, c, u) {
        super(i, o, c, u)
    }
    interpolate_(i) {
        return this.copySampleValue_(i - 1)
    }
}
class KeyframeTrack {
    constructor(i, o, c, u) {
        if (i === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (o === void 0 || o.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + i);
        this.name = i, this.times = convertArray(o, this.TimeBufferType), this.values = convertArray(c, this.ValueBufferType), this.setInterpolation(u || this.DefaultInterpolation)
    }
    static toJSON(i) {
        const o = i.constructor;
        let c;
        if (o.toJSON !== this.toJSON) c = o.toJSON(i);
        else {
            c = {
                name: i.name,
                times: convertArray(i.times, Array),
                values: convertArray(i.values, Array)
            };
            const u = i.getInterpolation();
            u !== i.DefaultInterpolation && (c.interpolation = u)
        }
        return c.type = i.ValueTypeName, c
    }
    InterpolantFactoryMethodDiscrete(i) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), i)
    }
    InterpolantFactoryMethodLinear(i) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), i)
    }
    InterpolantFactoryMethodSmooth(i) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), i)
    }
    setInterpolation(i) {
        let o;
        switch (i) {
            case InterpolateDiscrete:
                o = this.InterpolantFactoryMethodDiscrete;
                break;
            case InterpolateLinear:
                o = this.InterpolantFactoryMethodLinear;
                break;
            case InterpolateSmooth:
                o = this.InterpolantFactoryMethodSmooth;
                break
        }
        if (o === void 0) {
            const c = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (i !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(c);
            return console.warn("THREE.KeyframeTrack:", c), this
        }
        return this.createInterpolant = o, this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(i) {
        if (i !== 0) {
            const o = this.times;
            for (let c = 0, u = o.length; c !== u; ++c) o[c] += i
        }
        return this
    }
    scale(i) {
        if (i !== 1) {
            const o = this.times;
            for (let c = 0, u = o.length; c !== u; ++c) o[c] *= i
        }
        return this
    }
    trim(i, o) {
        const c = this.times,
            u = c.length;
        let p = 0,
            m = u - 1;
        for (; p !== u && c[p] < i;) ++p;
        for (; m !== -1 && c[m] > o;) --m;
        if (++m, p !== 0 || m !== u) {
            p >= m && (m = Math.max(m, 1), p = m - 1);
            const g = this.getValueSize();
            this.times = c.slice(p, m), this.values = this.values.slice(p * g, m * g)
        }
        return this
    }
    validate() {
        let i = !0;
        const o = this.getValueSize();
        o - Math.floor(o) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), i = !1);
        const c = this.times,
            u = this.values,
            p = c.length;
        p === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), i = !1);
        let m = null;
        for (let g = 0; g !== p; g++) {
            const _ = c[g];
            if (typeof _ == "number" && isNaN(_)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, g, _), i = !1;
                break
            }
            if (m !== null && m > _) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, g, _, m), i = !1;
                break
            }
            m = _
        }
        if (u !== void 0 && isTypedArray(u))
            for (let g = 0, _ = u.length; g !== _; ++g) {
                const v = u[g];
                if (isNaN(v)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, g, v), i = !1;
                    break
                }
            }
        return i
    }
    optimize() {
        const i = this.times.slice(),
            o = this.values.slice(),
            c = this.getValueSize(),
            u = this.getInterpolation() === InterpolateSmooth,
            p = i.length - 1;
        let m = 1;
        for (let g = 1; g < p; ++g) {
            let _ = !1;
            const v = i[g],
                x = i[g + 1];
            if (v !== x && (g !== 1 || v !== i[0]))
                if (u) _ = !0;
                else {
                    const y = g * c,
                        b = y - c,
                        S = y + c;
                    for (let C = 0; C !== c; ++C) {
                        const E = o[y + C];
                        if (E !== o[b + C] || E !== o[S + C]) {
                            _ = !0;
                            break
                        }
                    }
                }
            if (_) {
                if (g !== m) {
                    i[m] = i[g];
                    const y = g * c,
                        b = m * c;
                    for (let S = 0; S !== c; ++S) o[b + S] = o[y + S]
                }++m
            }
        }
        if (p > 0) {
            i[m] = i[p];
            for (let g = p * c, _ = m * c, v = 0; v !== c; ++v) o[_ + v] = o[g + v];
            ++m
        }
        return m !== i.length ? (this.times = i.slice(0, m), this.values = o.slice(0, m * c)) : (this.times = i, this.values = o), this
    }
    clone() {
        const i = this.times.slice(),
            o = this.values.slice(),
            c = this.constructor,
            u = new c(this.name, i, o);
        return u.createInterpolant = this.createInterpolant, u
    }
}
KeyframeTrack.prototype.ValueTypeName = "";
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
    constructor(i, o, c) {
        super(i, o, c)
    }
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
    constructor(i, o, c, u) {
        super(i, o, c, u)
    }
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
    constructor(i, o, c, u) {
        super(i, o, c, u)
    }
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
    constructor(i, o, c, u) {
        super(i, o, c, u)
    }
    interpolate_(i, o, c, u) {
        const p = this.resultBuffer,
            m = this.sampleValues,
            g = this.valueSize,
            _ = (c - o) / (u - o);
        let v = i * g;
        for (let x = v + g; v !== x; v += 4) Quaternion$1.slerpFlat(p, 0, m, v - g, m, v, _);
        return p
    }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
    constructor(i, o, c, u) {
        super(i, o, c, u)
    }
    InterpolantFactoryMethodLinear(i) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), i)
    }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
    constructor(i, o, c) {
        super(i, o, c)
    }
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
    constructor(i, o, c, u) {
        super(i, o, c, u)
    }
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
    constructor(i = "", o = -1, c = [], u = NormalAnimationBlendMode) {
        this.name = i, this.tracks = c, this.duration = o, this.blendMode = u, this.uuid = generateUUID(), this.duration < 0 && this.resetDuration()
    }
    static parse(i) {
        const o = [],
            c = i.tracks,
            u = 1 / (i.fps || 1);
        for (let m = 0, g = c.length; m !== g; ++m) o.push(parseKeyframeTrack(c[m]).scale(u));
        const p = new this(i.name, i.duration, o, i.blendMode);
        return p.uuid = i.uuid, p
    }
    static toJSON(i) {
        const o = [],
            c = i.tracks,
            u = {
                name: i.name,
                duration: i.duration,
                tracks: o,
                uuid: i.uuid,
                blendMode: i.blendMode
            };
        for (let p = 0, m = c.length; p !== m; ++p) o.push(KeyframeTrack.toJSON(c[p]));
        return u
    }
    static CreateFromMorphTargetSequence(i, o, c, u) {
        const p = o.length,
            m = [];
        for (let g = 0; g < p; g++) {
            let _ = [],
                v = [];
            _.push((g + p - 1) % p, g, (g + 1) % p), v.push(0, 1, 0);
            const x = getKeyframeOrder(_);
            _ = sortedArray(_, 1, x), v = sortedArray(v, 1, x), !u && _[0] === 0 && (_.push(p), v.push(v[0])), m.push(new NumberKeyframeTrack(".morphTargetInfluences[" + o[g].name + "]", _, v).scale(1 / c))
        }
        return new this(i, -1, m)
    }
    static findByName(i, o) {
        let c = i;
        if (!Array.isArray(i)) {
            const u = i;
            c = u.geometry && u.geometry.animations || u.animations
        }
        for (let u = 0; u < c.length; u++)
            if (c[u].name === o) return c[u];
        return null
    }
    static CreateClipsFromMorphTargetSequences(i, o, c) {
        const u = {},
            p = /^([\w-]*?)([\d]+)$/;
        for (let g = 0, _ = i.length; g < _; g++) {
            const v = i[g],
                x = v.name.match(p);
            if (x && x.length > 1) {
                const y = x[1];
                let b = u[y];
                b || (u[y] = b = []), b.push(v)
            }
        }
        const m = [];
        for (const g in u) m.push(this.CreateFromMorphTargetSequence(g, u[g], o, c));
        return m
    }
    static parseAnimation(i, o) {
        if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !i) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const c = function(y, b, S, C, E) {
                if (S.length !== 0) {
                    const P = [],
                        w = [];
                    flattenJSON(S, P, w, C), P.length !== 0 && E.push(new y(b, P, w))
                }
            },
            u = [],
            p = i.name || "default",
            m = i.fps || 30,
            g = i.blendMode;
        let _ = i.length || -1;
        const v = i.hierarchy || [];
        for (let y = 0; y < v.length; y++) {
            const b = v[y].keys;
            if (!(!b || b.length === 0))
                if (b[0].morphTargets) {
                    const S = {};
                    let C;
                    for (C = 0; C < b.length; C++)
                        if (b[C].morphTargets)
                            for (let E = 0; E < b[C].morphTargets.length; E++) S[b[C].morphTargets[E]] = -1;
                    for (const E in S) {
                        const P = [],
                            w = [];
                        for (let T = 0; T !== b[C].morphTargets.length; ++T) {
                            const M = b[C];
                            P.push(M.time), w.push(M.morphTarget === E ? 1 : 0)
                        }
                        u.push(new NumberKeyframeTrack(".morphTargetInfluence[" + E + "]", P, w))
                    }
                    _ = S.length * m
                } else {
                    const S = ".bones[" + o[y].name + "]";
                    c(VectorKeyframeTrack, S + ".position", b, "pos", u), c(QuaternionKeyframeTrack, S + ".quaternion", b, "rot", u), c(VectorKeyframeTrack, S + ".scale", b, "scl", u)
                }
        }
        return u.length === 0 ? null : new this(p, _, u, g)
    }
    resetDuration() {
        const i = this.tracks;
        let o = 0;
        for (let c = 0, u = i.length; c !== u; ++c) {
            const p = this.tracks[c];
            o = Math.max(o, p.times[p.times.length - 1])
        }
        return this.duration = o, this
    }
    trim() {
        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].trim(0, this.duration);
        return this
    }
    validate() {
        let i = !0;
        for (let o = 0; o < this.tracks.length; o++) i = i && this.tracks[o].validate();
        return i
    }
    optimize() {
        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].optimize();
        return this
    }
    clone() {
        const i = [];
        for (let o = 0; o < this.tracks.length; o++) i.push(this.tracks[o].clone());
        return new this.constructor(this.name, this.duration, i, this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function getTrackTypeForValueTypeName(l) {
    switch (l.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return NumberKeyframeTrack;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return VectorKeyframeTrack;
        case "color":
            return ColorKeyframeTrack;
        case "quaternion":
            return QuaternionKeyframeTrack;
        case "bool":
        case "boolean":
            return BooleanKeyframeTrack;
        case "string":
            return StringKeyframeTrack
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + l)
}

function parseKeyframeTrack(l) {
    if (l.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const i = getTrackTypeForValueTypeName(l.type);
    if (l.times === void 0) {
        const o = [],
            c = [];
        flattenJSON(l.keys, o, c, "value"), l.times = o, l.values = c
    }
    return i.parse !== void 0 ? i.parse(l) : new i(l.name, l.times, l.values, l.interpolation)
}
const Cache = {
    enabled: !1,
    files: {},
    add: function(l, i) {
        this.enabled !== !1 && (this.files[l] = i)
    },
    get: function(l) {
        if (this.enabled !== !1) return this.files[l]
    },
    remove: function(l) {
        delete this.files[l]
    },
    clear: function() {
        this.files = {}
    }
};
class LoadingManager {
    constructor(i, o, c) {
        const u = this;
        let p = !1,
            m = 0,
            g = 0,
            _;
        const v = [];
        this.onStart = void 0, this.onLoad = i, this.onProgress = o, this.onError = c, this.itemStart = function(x) {
            g++, p === !1 && u.onStart !== void 0 && u.onStart(x, m, g), p = !0
        }, this.itemEnd = function(x) {
            m++, u.onProgress !== void 0 && u.onProgress(x, m, g), m === g && (p = !1, u.onLoad !== void 0 && u.onLoad())
        }, this.itemError = function(x) {
            u.onError !== void 0 && u.onError(x)
        }, this.resolveURL = function(x) {
            return _ ? _(x) : x
        }, this.setURLModifier = function(x) {
            return _ = x, this
        }, this.addHandler = function(x, y) {
            return v.push(x, y), this
        }, this.removeHandler = function(x) {
            const y = v.indexOf(x);
            return y !== -1 && v.splice(y, 2), this
        }, this.getHandler = function(x) {
            for (let y = 0, b = v.length; y < b; y += 2) {
                const S = v[y],
                    C = v[y + 1];
                if (S.global && (S.lastIndex = 0), S.test(x)) return C
            }
            return null
        }
    }
}
const DefaultLoadingManager = new LoadingManager;
class Loader {
    constructor(i) {
        this.manager = i !== void 0 ? i : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    load() {}
    loadAsync(i, o) {
        const c = this;
        return new Promise(function(u, p) {
            c.load(i, u, o, p)
        })
    }
    parse() {}
    setCrossOrigin(i) {
        return this.crossOrigin = i, this
    }
    setWithCredentials(i) {
        return this.withCredentials = i, this
    }
    setPath(i) {
        return this.path = i, this
    }
    setResourcePath(i) {
        return this.resourcePath = i, this
    }
    setRequestHeader(i) {
        return this.requestHeader = i, this
    }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
    constructor(i, o) {
        super(i), this.response = o
    }
}
class FileLoader extends Loader {
    constructor(i) {
        super(i), this.mimeType = "", this.responseType = ""
    }
    load(i, o, c, u) {
        i === void 0 && (i = ""), this.path !== void 0 && (i = this.path + i), i = this.manager.resolveURL(i);
        const p = Cache.get(i);
        if (p !== void 0) return this.manager.itemStart(i), setTimeout(() => {
            o && o(p), this.manager.itemEnd(i)
        }, 0), p;
        if (loading[i] !== void 0) {
            loading[i].push({
                onLoad: o,
                onProgress: c,
                onError: u
            });
            return
        }
        loading[i] = [], loading[i].push({
            onLoad: o,
            onProgress: c,
            onError: u
        });
        const m = new Request(i, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }),
            g = this.mimeType,
            _ = this.responseType;
        fetch(m).then(v => {
            if (v.status === 200 || v.status === 0) {
                if (v.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || v.body === void 0 || v.body.getReader === void 0) return v;
                const x = loading[i],
                    y = v.body.getReader(),
                    b = v.headers.get("X-File-Size") || v.headers.get("Content-Length"),
                    S = b ? parseInt(b) : 0,
                    C = S !== 0;
                let E = 0;
                const P = new ReadableStream({
                    start(w) {
                        T();

                        function T() {
                            y.read().then(({
                                done: M,
                                value: A
                            }) => {
                                if (M) w.close();
                                else {
                                    E += A.byteLength;
                                    const D = new ProgressEvent("progress", {
                                        lengthComputable: C,
                                        loaded: E,
                                        total: S
                                    });
                                    for (let R = 0, I = x.length; R < I; R++) {
                                        const k = x[R];
                                        k.onProgress && k.onProgress(D)
                                    }
                                    w.enqueue(A), T()
                                }
                            }, M => {
                                w.error(M)
                            })
                        }
                    }
                });
                return new Response(P)
            } else throw new HttpError(`fetch for "${v.url}" responded with ${v.status}: ${v.statusText}`, v)
        }).then(v => {
            switch (_) {
                case "arraybuffer":
                    return v.arrayBuffer();
                case "blob":
                    return v.blob();
                case "document":
                    return v.text().then(x => new DOMParser().parseFromString(x, g));
                case "json":
                    return v.json();
                default:
                    if (g === "") return v.text(); {
                        const y = /charset="?([^;"\s]*)"?/i.exec(g),
                            b = y && y[1] ? y[1].toLowerCase() : void 0,
                            S = new TextDecoder(b);
                        return v.arrayBuffer().then(C => S.decode(C))
                    }
            }
        }).then(v => {
            Cache.add(i, v);
            const x = loading[i];
            delete loading[i];
            for (let y = 0, b = x.length; y < b; y++) {
                const S = x[y];
                S.onLoad && S.onLoad(v)
            }
        }).catch(v => {
            const x = loading[i];
            if (x === void 0) throw this.manager.itemError(i), v;
            delete loading[i];
            for (let y = 0, b = x.length; y < b; y++) {
                const S = x[y];
                S.onError && S.onError(v)
            }
            this.manager.itemError(i)
        }).finally(() => {
            this.manager.itemEnd(i)
        }), this.manager.itemStart(i)
    }
    setResponseType(i) {
        return this.responseType = i, this
    }
    setMimeType(i) {
        return this.mimeType = i, this
    }
}
class ImageLoader extends Loader {
    constructor(i) {
        super(i)
    }
    load(i, o, c, u) {
        this.path !== void 0 && (i = this.path + i), i = this.manager.resolveURL(i);
        const p = this,
            m = Cache.get(i);
        if (m !== void 0) return p.manager.itemStart(i), setTimeout(function() {
            o && o(m), p.manager.itemEnd(i)
        }, 0), m;
        const g = createElementNS("img");

        function _() {
            x(), Cache.add(i, this), o && o(this), p.manager.itemEnd(i)
        }

        function v(y) {
            x(), u && u(y), p.manager.itemError(i), p.manager.itemEnd(i)
        }

        function x() {
            g.removeEventListener("load", _, !1), g.removeEventListener("error", v, !1)
        }
        return g.addEventListener("load", _, !1), g.addEventListener("error", v, !1), i.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (g.crossOrigin = this.crossOrigin), p.manager.itemStart(i), g.src = i, g
    }
}
class CubeTextureLoader extends Loader {
    constructor(i) {
        super(i)
    }
    load(i, o, c, u) {
        const p = new CubeTexture;
        p.colorSpace = SRGBColorSpace;
        const m = new ImageLoader(this.manager);
        m.setCrossOrigin(this.crossOrigin), m.setPath(this.path);
        let g = 0;

        function _(v) {
            m.load(i[v], function(x) {
                p.images[v] = x, g++, g === 6 && (p.needsUpdate = !0, o && o(p))
            }, void 0, u)
        }
        for (let v = 0; v < i.length; ++v) _(v);
        return p
    }
}
class TextureLoader extends Loader {
    constructor(i) {
        super(i)
    }
    load(i, o, c, u) {
        const p = new Texture,
            m = new ImageLoader(this.manager);
        return m.setCrossOrigin(this.crossOrigin), m.setPath(this.path), m.load(i, function(g) {
            p.image = g, p.needsUpdate = !0, o !== void 0 && o(p)
        }, c, u), p
    }
}
class Light extends Object3D {
    constructor(i, o = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new Color(i), this.intensity = o
    }
    dispose() {}
    copy(i, o) {
        return super.copy(i, o), this.color.copy(i.color), this.intensity = i.intensity, this
    }
    toJSON(i) {
        const o = super.toJSON(i);
        return o.object.color = this.color.getHex(), o.object.intensity = this.intensity, this.groundColor !== void 0 && (o.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (o.object.distance = this.distance), this.angle !== void 0 && (o.object.angle = this.angle), this.decay !== void 0 && (o.object.decay = this.decay), this.penumbra !== void 0 && (o.object.penumbra = this.penumbra), this.shadow !== void 0 && (o.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (o.object.target = this.target.uuid), o
    }
}
const _projScreenMatrix$1 = new Matrix4,
    _lightPositionWorld$1 = new Vector3$1,
    _lookTarget$1 = new Vector3$1;
class LightShadow {
    constructor(i) {
        this.camera = i, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vector2(512, 512), this.mapType = UnsignedByteType, this.map = null, this.mapPass = null, this.matrix = new Matrix4, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum, this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(i) {
        const o = this.camera,
            c = this.matrix;
        _lightPositionWorld$1.setFromMatrixPosition(i.matrixWorld), o.position.copy(_lightPositionWorld$1), _lookTarget$1.setFromMatrixPosition(i.target.matrixWorld), o.lookAt(_lookTarget$1), o.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(o.projectionMatrix, o.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1), c.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), c.multiply(_projScreenMatrix$1)
    }
    getViewport(i) {
        return this._viewports[i]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }
    copy(i) {
        return this.camera = i.camera.clone(), this.intensity = i.intensity, this.bias = i.bias, this.radius = i.radius, this.autoUpdate = i.autoUpdate, this.needsUpdate = i.needsUpdate, this.normalBias = i.normalBias, this.blurSamples = i.blurSamples, this.mapSize.copy(i.mapSize), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const i = {};
        return this.intensity !== 1 && (i.intensity = this.intensity), this.bias !== 0 && (i.bias = this.bias), this.normalBias !== 0 && (i.normalBias = this.normalBias), this.radius !== 1 && (i.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (i.mapSize = this.mapSize.toArray()), i.camera = this.camera.toJSON(!1).object, delete i.camera.matrix, i
    }
}
class SpotLightShadow extends LightShadow {
    constructor() {
        super(new PerspectiveCamera(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1
    }
    updateMatrices(i) {
        const o = this.camera,
            c = RAD2DEG * 2 * i.angle * this.focus,
            u = this.mapSize.width / this.mapSize.height * this.aspect,
            p = i.distance || o.far;
        (c !== o.fov || u !== o.aspect || p !== o.far) && (o.fov = c, o.aspect = u, o.far = p, o.updateProjectionMatrix()), super.updateMatrices(i)
    }
    copy(i) {
        return super.copy(i), this.focus = i.focus, this
    }
}
class SpotLight extends Light {
    constructor(i, o, c = 0, u = Math.PI / 3, p = 0, m = 2) {
        super(i, o), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D, this.distance = c, this.angle = u, this.penumbra = p, this.decay = m, this.map = null, this.shadow = new SpotLightShadow
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(i) {
        this.intensity = i / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(i, o) {
        return super.copy(i, o), this.distance = i.distance, this.angle = i.angle, this.penumbra = i.penumbra, this.decay = i.decay, this.target = i.target.clone(), this.shadow = i.shadow.clone(), this
    }
}
const _projScreenMatrix = new Matrix4,
    _lightPositionWorld = new Vector3$1,
    _lookTarget = new Vector3$1;
class PointLightShadow extends LightShadow {
    constructor() {
        super(new PerspectiveCamera(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new Vector3$1(1, 0, 0), new Vector3$1(-1, 0, 0), new Vector3$1(0, 0, 1), new Vector3$1(0, 0, -1), new Vector3$1(0, 1, 0), new Vector3$1(0, -1, 0)], this._cubeUps = [new Vector3$1(0, 1, 0), new Vector3$1(0, 1, 0), new Vector3$1(0, 1, 0), new Vector3$1(0, 1, 0), new Vector3$1(0, 0, 1), new Vector3$1(0, 0, -1)]
    }
    updateMatrices(i, o = 0) {
        const c = this.camera,
            u = this.matrix,
            p = i.distance || c.far;
        p !== c.far && (c.far = p, c.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(i.matrixWorld), c.position.copy(_lightPositionWorld), _lookTarget.copy(c.position), _lookTarget.add(this._cubeDirections[o]), c.up.copy(this._cubeUps[o]), c.lookAt(_lookTarget), c.updateMatrixWorld(), u.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix)
    }
}
class PointLight extends Light {
    constructor(i, o, c = 0, u = 2) {
        super(i, o), this.isPointLight = !0, this.type = "PointLight", this.distance = c, this.decay = u, this.shadow = new PointLightShadow
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(i) {
        this.intensity = i / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(i, o) {
        return super.copy(i, o), this.distance = i.distance, this.decay = i.decay, this.shadow = i.shadow.clone(), this
    }
}
class OrthographicCamera extends Camera {
    constructor(i = -1, o = 1, c = 1, u = -1, p = .1, m = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = i, this.right = o, this.top = c, this.bottom = u, this.near = p, this.far = m, this.updateProjectionMatrix()
    }
    copy(i, o) {
        return super.copy(i, o), this.left = i.left, this.right = i.right, this.top = i.top, this.bottom = i.bottom, this.near = i.near, this.far = i.far, this.zoom = i.zoom, this.view = i.view === null ? null : Object.assign({}, i.view), this
    }
    setViewOffset(i, o, c, u, p, m) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = i, this.view.fullHeight = o, this.view.offsetX = c, this.view.offsetY = u, this.view.width = p, this.view.height = m, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const i = (this.right - this.left) / (2 * this.zoom),
            o = (this.top - this.bottom) / (2 * this.zoom),
            c = (this.right + this.left) / 2,
            u = (this.top + this.bottom) / 2;
        let p = c - i,
            m = c + i,
            g = u + o,
            _ = u - o;
        if (this.view !== null && this.view.enabled) {
            const v = (this.right - this.left) / this.view.fullWidth / this.zoom,
                x = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            p += v * this.view.offsetX, m = p + v * this.view.width, g -= x * this.view.offsetY, _ = g - x * this.view.height
        }
        this.projectionMatrix.makeOrthographic(p, m, g, _, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(i) {
        const o = super.toJSON(i);
        return o.object.zoom = this.zoom, o.object.left = this.left, o.object.right = this.right, o.object.top = this.top, o.object.bottom = this.bottom, o.object.near = this.near, o.object.far = this.far, this.view !== null && (o.object.view = Object.assign({}, this.view)), o
    }
}
class DirectionalLightShadow extends LightShadow {
    constructor() {
        super(new OrthographicCamera(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
    }
}
class DirectionalLight extends Light {
    constructor(i, o) {
        super(i, o), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D, this.shadow = new DirectionalLightShadow
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(i) {
        return super.copy(i), this.target = i.target.clone(), this.shadow = i.shadow.clone(), this
    }
}
class LoaderUtils {
    static extractUrlBase(i) {
        const o = i.lastIndexOf("/");
        return o === -1 ? "./" : i.slice(0, o + 1)
    }
    static resolveURL(i, o) {
        return typeof i != "string" || i === "" ? "" : (/^https?:\/\//i.test(o) && /^\//.test(i) && (o = o.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(i) || /^data:.*,.*$/i.test(i) || /^blob:.*$/i.test(i) ? i : o + i)
    }
}
class InstancedBufferGeometry extends BufferGeometry {
    constructor() {
        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }
    copy(i) {
        return super.copy(i), this.instanceCount = i.instanceCount, this
    }
    toJSON() {
        const i = super.toJSON();
        return i.instanceCount = this.instanceCount, i.isInstancedBufferGeometry = !0, i
    }
}
const _errorMap = new WeakMap;
class ImageBitmapLoader extends Loader {
    constructor(i) {
        super(i), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(i) {
        return this.options = i, this
    }
    load(i, o, c, u) {
        i === void 0 && (i = ""), this.path !== void 0 && (i = this.path + i), i = this.manager.resolveURL(i);
        const p = this,
            m = Cache.get(i);
        if (m !== void 0) {
            if (p.manager.itemStart(i), m.then) {
                m.then(v => {
                    if (_errorMap.has(m) === !0) u && u(_errorMap.get(m)), p.manager.itemError(i), p.manager.itemEnd(i);
                    else return o && o(v), p.manager.itemEnd(i), v
                });
                return
            }
            return setTimeout(function() {
                o && o(m), p.manager.itemEnd(i)
            }, 0), m
        }
        const g = {};
        g.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", g.headers = this.requestHeader;
        const _ = fetch(i, g).then(function(v) {
            return v.blob()
        }).then(function(v) {
            return createImageBitmap(v, Object.assign(p.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(v) {
            return Cache.add(i, v), o && o(v), p.manager.itemEnd(i), v
        }).catch(function(v) {
            u && u(v), _errorMap.set(_, v), Cache.remove(i), p.manager.itemError(i), p.manager.itemEnd(i)
        });
        Cache.add(i, _), p.manager.itemStart(i)
    }
}
class ArrayCamera extends PerspectiveCamera {
    constructor(i = []) {
        super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = i
    }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/",
    _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"),
    _wordChar = "[^" + _RESERVED_CHARS_RE + "]",
    _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]",
    _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar),
    _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot),
    _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar),
    _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar),
    _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"),
    _supportedObjectNames = ["material", "materials", "bones", "map"];
class Composite {
    constructor(i, o, c) {
        const u = c || PropertyBinding.parseTrackName(o);
        this._targetGroup = i, this._bindings = i.subscribe_(o, u)
    }
    getValue(i, o) {
        this.bind();
        const c = this._targetGroup.nCachedObjects_,
            u = this._bindings[c];
        u !== void 0 && u.getValue(i, o)
    }
    setValue(i, o) {
        const c = this._bindings;
        for (let u = this._targetGroup.nCachedObjects_, p = c.length; u !== p; ++u) c[u].setValue(i, o)
    }
    bind() {
        const i = this._bindings;
        for (let o = this._targetGroup.nCachedObjects_, c = i.length; o !== c; ++o) i[o].bind()
    }
    unbind() {
        const i = this._bindings;
        for (let o = this._targetGroup.nCachedObjects_, c = i.length; o !== c; ++o) i[o].unbind()
    }
}
class PropertyBinding {
    constructor(i, o, c) {
        this.path = o, this.parsedPath = c || PropertyBinding.parseTrackName(o), this.node = PropertyBinding.findNode(i, this.parsedPath.nodeName), this.rootNode = i, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
    static create(i, o, c) {
        return i && i.isAnimationObjectGroup ? new PropertyBinding.Composite(i, o, c) : new PropertyBinding(i, o, c)
    }
    static sanitizeNodeName(i) {
        return i.replace(/\s/g, "_").replace(_reservedRe, "")
    }
    static parseTrackName(i) {
        const o = _trackRe.exec(i);
        if (o === null) throw new Error("PropertyBinding: Cannot parse trackName: " + i);
        const c = {
                nodeName: o[2],
                objectName: o[3],
                objectIndex: o[4],
                propertyName: o[5],
                propertyIndex: o[6]
            },
            u = c.nodeName && c.nodeName.lastIndexOf(".");
        if (u !== void 0 && u !== -1) {
            const p = c.nodeName.substring(u + 1);
            _supportedObjectNames.indexOf(p) !== -1 && (c.nodeName = c.nodeName.substring(0, u), c.objectName = p)
        }
        if (c.propertyName === null || c.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + i);
        return c
    }
    static findNode(i, o) {
        if (o === void 0 || o === "" || o === "." || o === -1 || o === i.name || o === i.uuid) return i;
        if (i.skeleton) {
            const c = i.skeleton.getBoneByName(o);
            if (c !== void 0) return c
        }
        if (i.children) {
            const c = function(p) {
                    for (let m = 0; m < p.length; m++) {
                        const g = p[m];
                        if (g.name === o || g.uuid === o) return g;
                        const _ = c(g.children);
                        if (_) return _
                    }
                    return null
                },
                u = c(i.children);
            if (u) return u
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(i, o) {
        i[o] = this.targetObject[this.propertyName]
    }
    _getValue_array(i, o) {
        const c = this.resolvedProperty;
        for (let u = 0, p = c.length; u !== p; ++u) i[o++] = c[u]
    }
    _getValue_arrayElement(i, o) {
        i[o] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(i, o) {
        this.resolvedProperty.toArray(i, o)
    }
    _setValue_direct(i, o) {
        this.targetObject[this.propertyName] = i[o]
    }
    _setValue_direct_setNeedsUpdate(i, o) {
        this.targetObject[this.propertyName] = i[o], this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(i, o) {
        this.targetObject[this.propertyName] = i[o], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(i, o) {
        const c = this.resolvedProperty;
        for (let u = 0, p = c.length; u !== p; ++u) c[u] = i[o++]
    }
    _setValue_array_setNeedsUpdate(i, o) {
        const c = this.resolvedProperty;
        for (let u = 0, p = c.length; u !== p; ++u) c[u] = i[o++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(i, o) {
        const c = this.resolvedProperty;
        for (let u = 0, p = c.length; u !== p; ++u) c[u] = i[o++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(i, o) {
        this.resolvedProperty[this.propertyIndex] = i[o]
    }
    _setValue_arrayElement_setNeedsUpdate(i, o) {
        this.resolvedProperty[this.propertyIndex] = i[o], this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(i, o) {
        this.resolvedProperty[this.propertyIndex] = i[o], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(i, o) {
        this.resolvedProperty.fromArray(i, o)
    }
    _setValue_fromArray_setNeedsUpdate(i, o) {
        this.resolvedProperty.fromArray(i, o), this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(i, o) {
        this.resolvedProperty.fromArray(i, o), this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(i, o) {
        this.bind(), this.getValue(i, o)
    }
    _setValue_unbound(i, o) {
        this.bind(), this.setValue(i, o)
    }
    bind() {
        let i = this.node;
        const o = this.parsedPath,
            c = o.objectName,
            u = o.propertyName;
        let p = o.propertyIndex;
        if (i || (i = PropertyBinding.findNode(this.rootNode, o.nodeName), this.node = i), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !i) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (c) {
            let v = o.objectIndex;
            switch (c) {
                case "materials":
                    if (!i.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!i.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return
                    }
                    i = i.material.materials;
                    break;
                case "bones":
                    if (!i.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return
                    }
                    i = i.skeleton.bones;
                    for (let x = 0; x < i.length; x++)
                        if (i[x].name === v) {
                            v = x;
                            break
                        }
                    break;
                case "map":
                    if ("map" in i) {
                        i = i.map;
                        break
                    }
                    if (!i.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!i.material.map) {
                        console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        return
                    }
                    i = i.material.map;
                    break;
                default:
                    if (i[c] === void 0) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return
                    }
                    i = i[c]
            }
            if (v !== void 0) {
                if (i[v] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, i);
                    return
                }
                i = i[v]
            }
        }
        const m = i[u];
        if (m === void 0) {
            const v = o.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + v + "." + u + " but it wasn't found.", i);
            return
        }
        let g = this.Versioning.None;
        this.targetObject = i, i.isMaterial === !0 ? g = this.Versioning.NeedsUpdate : i.isObject3D === !0 && (g = this.Versioning.MatrixWorldNeedsUpdate);
        let _ = this.BindingType.Direct;
        if (p !== void 0) {
            if (u === "morphTargetInfluences") {
                if (!i.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!i.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                i.morphTargetDictionary[p] !== void 0 && (p = i.morphTargetDictionary[p])
            }
            _ = this.BindingType.ArrayElement, this.resolvedProperty = m, this.propertyIndex = p
        } else m.fromArray !== void 0 && m.toArray !== void 0 ? (_ = this.BindingType.HasFromToArray, this.resolvedProperty = m) : Array.isArray(m) ? (_ = this.BindingType.EntireArray, this.resolvedProperty = m) : this.propertyName = u;
        this.getValue = this.GetterByBindingType[_], this.setValue = this.SetterByBindingTypeAndVersioning[_][g]
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
    [PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
    [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],
    [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
    [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
const _matrix = new Matrix4;
class Raycaster {
    constructor(i, o, c = 0, u = 1 / 0) {
        this.ray = new Ray(i, o), this.near = c, this.far = u, this.camera = null, this.layers = new Layers, this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(i, o) {
        this.ray.set(i, o)
    }
    setFromCamera(i, o) {
        o.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(o.matrixWorld), this.ray.direction.set(i.x, i.y, .5).unproject(o).sub(this.ray.origin).normalize(), this.camera = o) : o.isOrthographicCamera ? (this.ray.origin.set(i.x, i.y, (o.near + o.far) / (o.near - o.far)).unproject(o), this.ray.direction.set(0, 0, -1).transformDirection(o.matrixWorld), this.camera = o) : console.error("THREE.Raycaster: Unsupported camera type: " + o.type)
    }
    setFromXRController(i) {
        return _matrix.identity().extractRotation(i.matrixWorld), this.ray.origin.setFromMatrixPosition(i.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix), this
    }
    intersectObject(i, o = !0, c = []) {
        return intersect(i, this, c, o), c.sort(ascSort), c
    }
    intersectObjects(i, o = !0, c = []) {
        for (let u = 0, p = i.length; u < p; u++) intersect(i[u], this, c, o);
        return c.sort(ascSort), c
    }
}

function ascSort(l, i) {
    return l.distance - i.distance
}

function intersect(l, i, o, c) {
    let u = !0;
    if (l.layers.test(i.layers) && l.raycast(i, o) === !1 && (u = !1), u === !0 && c === !0) {
        const p = l.children;
        for (let m = 0, g = p.length; m < g; m++) intersect(p[m], i, o, !0)
    }
}

function getByteLength(l, i, o, c) {
    const u = getTextureTypeByteLength(c);
    switch (o) {
        case AlphaFormat:
            return l * i;
        case RedFormat:
            return l * i / u.components * u.byteLength;
        case RedIntegerFormat:
            return l * i / u.components * u.byteLength;
        case RGFormat:
            return l * i * 2 / u.components * u.byteLength;
        case RGIntegerFormat:
            return l * i * 2 / u.components * u.byteLength;
        case RGBFormat:
            return l * i * 3 / u.components * u.byteLength;
        case RGBAFormat:
            return l * i * 4 / u.components * u.byteLength;
        case RGBAIntegerFormat:
            return l * i * 4 / u.components * u.byteLength;
        case RGB_S3TC_DXT1_Format:
        case RGBA_S3TC_DXT1_Format:
            return Math.floor((l + 3) / 4) * Math.floor((i + 3) / 4) * 8;
        case RGBA_S3TC_DXT3_Format:
        case RGBA_S3TC_DXT5_Format:
            return Math.floor((l + 3) / 4) * Math.floor((i + 3) / 4) * 16;
        case RGB_PVRTC_2BPPV1_Format:
        case RGBA_PVRTC_2BPPV1_Format:
            return Math.max(l, 16) * Math.max(i, 8) / 4;
        case RGB_PVRTC_4BPPV1_Format:
        case RGBA_PVRTC_4BPPV1_Format:
            return Math.max(l, 8) * Math.max(i, 8) / 2;
        case RGB_ETC1_Format:
        case RGB_ETC2_Format:
            return Math.floor((l + 3) / 4) * Math.floor((i + 3) / 4) * 8;
        case RGBA_ETC2_EAC_Format:
            return Math.floor((l + 3) / 4) * Math.floor((i + 3) / 4) * 16;
        case RGBA_ASTC_4x4_Format:
            return Math.floor((l + 3) / 4) * Math.floor((i + 3) / 4) * 16;
        case RGBA_ASTC_5x4_Format:
            return Math.floor((l + 4) / 5) * Math.floor((i + 3) / 4) * 16;
        case RGBA_ASTC_5x5_Format:
            return Math.floor((l + 4) / 5) * Math.floor((i + 4) / 5) * 16;
        case RGBA_ASTC_6x5_Format:
            return Math.floor((l + 5) / 6) * Math.floor((i + 4) / 5) * 16;
        case RGBA_ASTC_6x6_Format:
            return Math.floor((l + 5) / 6) * Math.floor((i + 5) / 6) * 16;
        case RGBA_ASTC_8x5_Format:
            return Math.floor((l + 7) / 8) * Math.floor((i + 4) / 5) * 16;
        case RGBA_ASTC_8x6_Format:
            return Math.floor((l + 7) / 8) * Math.floor((i + 5) / 6) * 16;
        case RGBA_ASTC_8x8_Format:
            return Math.floor((l + 7) / 8) * Math.floor((i + 7) / 8) * 16;
        case RGBA_ASTC_10x5_Format:
            return Math.floor((l + 9) / 10) * Math.floor((i + 4) / 5) * 16;
        case RGBA_ASTC_10x6_Format:
            return Math.floor((l + 9) / 10) * Math.floor((i + 5) / 6) * 16;
        case RGBA_ASTC_10x8_Format:
            return Math.floor((l + 9) / 10) * Math.floor((i + 7) / 8) * 16;
        case RGBA_ASTC_10x10_Format:
            return Math.floor((l + 9) / 10) * Math.floor((i + 9) / 10) * 16;
        case RGBA_ASTC_12x10_Format:
            return Math.floor((l + 11) / 12) * Math.floor((i + 9) / 10) * 16;
        case RGBA_ASTC_12x12_Format:
            return Math.floor((l + 11) / 12) * Math.floor((i + 11) / 12) * 16;
        case RGBA_BPTC_Format:
        case RGB_BPTC_SIGNED_Format:
        case RGB_BPTC_UNSIGNED_Format:
            return Math.ceil(l / 4) * Math.ceil(i / 4) * 16;
        case RED_RGTC1_Format:
        case SIGNED_RED_RGTC1_Format:
            return Math.ceil(l / 4) * Math.ceil(i / 4) * 8;
        case RED_GREEN_RGTC2_Format:
        case SIGNED_RED_GREEN_RGTC2_Format:
            return Math.ceil(l / 4) * Math.ceil(i / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${o} format.`)
}

function getTextureTypeByteLength(l) {
    switch (l) {
        case UnsignedByteType:
        case ByteType:
            return {
                byteLength: 1,
                components: 1
            };
        case UnsignedShortType:
        case ShortType:
        case HalfFloatType:
            return {
                byteLength: 2,
                components: 1
            };
        case UnsignedShort4444Type:
        case UnsignedShort5551Type:
            return {
                byteLength: 2,
                components: 4
            };
        case UnsignedIntType:
        case IntType:
        case FloatType:
            return {
                byteLength: 4,
                components: 1
            };
        case UnsignedInt5999Type:
            return {
                byteLength: 4,
                components: 3
            }
    }
    throw new Error(`Unknown texture type ${l}.`)
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: REVISION
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function WebGLAnimation() {
    let l = null,
        i = !1,
        o = null,
        c = null;

    function u(p, m) {
        o(p, m), c = l.requestAnimationFrame(u)
    }
    return {
        start: function() {
            i !== !0 && o !== null && (c = l.requestAnimationFrame(u), i = !0)
        },
        stop: function() {
            l.cancelAnimationFrame(c), i = !1
        },
        setAnimationLoop: function(p) {
            o = p
        },
        setContext: function(p) {
            l = p
        }
    }
}

function WebGLAttributes(l) {
    const i = new WeakMap;

    function o(g, _) {
        const v = g.array,
            x = g.usage,
            y = v.byteLength,
            b = l.createBuffer();
        l.bindBuffer(_, b), l.bufferData(_, v, x), g.onUploadCallback();
        let S;
        if (v instanceof Float32Array) S = l.FLOAT;
        else if (v instanceof Uint16Array) g.isFloat16BufferAttribute ? S = l.HALF_FLOAT : S = l.UNSIGNED_SHORT;
        else if (v instanceof Int16Array) S = l.SHORT;
        else if (v instanceof Uint32Array) S = l.UNSIGNED_INT;
        else if (v instanceof Int32Array) S = l.INT;
        else if (v instanceof Int8Array) S = l.BYTE;
        else if (v instanceof Uint8Array) S = l.UNSIGNED_BYTE;
        else if (v instanceof Uint8ClampedArray) S = l.UNSIGNED_BYTE;
        else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + v);
        return {
            buffer: b,
            type: S,
            bytesPerElement: v.BYTES_PER_ELEMENT,
            version: g.version,
            size: y
        }
    }

    function c(g, _, v) {
        const x = _.array,
            y = _.updateRanges;
        if (l.bindBuffer(v, g), y.length === 0) l.bufferSubData(v, 0, x);
        else {
            y.sort((S, C) => S.start - C.start);
            let b = 0;
            for (let S = 1; S < y.length; S++) {
                const C = y[b],
                    E = y[S];
                E.start <= C.start + C.count + 1 ? C.count = Math.max(C.count, E.start + E.count - C.start) : (++b, y[b] = E)
            }
            y.length = b + 1;
            for (let S = 0, C = y.length; S < C; S++) {
                const E = y[S];
                l.bufferSubData(v, E.start * x.BYTES_PER_ELEMENT, x, E.start, E.count)
            }
            _.clearUpdateRanges()
        }
        _.onUploadCallback()
    }

    function u(g) {
        return g.isInterleavedBufferAttribute && (g = g.data), i.get(g)
    }

    function p(g) {
        g.isInterleavedBufferAttribute && (g = g.data);
        const _ = i.get(g);
        _ && (l.deleteBuffer(_.buffer), i.delete(g))
    }

    function m(g, _) {
        if (g.isInterleavedBufferAttribute && (g = g.data), g.isGLBufferAttribute) {
            const x = i.get(g);
            (!x || x.version < g.version) && i.set(g, {
                buffer: g.buffer,
                type: g.type,
                bytesPerElement: g.elementSize,
                version: g.version
            });
            return
        }
        const v = i.get(g);
        if (v === void 0) i.set(g, o(g, _));
        else if (v.version < g.version) {
            if (v.size !== g.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            c(v.buffer, g, _), v.version = g.version
        }
    }
    return {
        get: u,
        remove: p,
        update: m
    }
}
var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
    alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
    alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
    alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    alphatest_fragment = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
    alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    batching_pars_vertex = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
    batching_vertex = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
    begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
    beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
    iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
    clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
    color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
    common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
    cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
    emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    colorspace_pars_fragment = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
    envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
    envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
    lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
    lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
    logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
    map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
    map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    morphinstance_vertex = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
    morphcolor_vertex = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
    morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
    morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
    normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
    normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
    clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
    clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
    clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
    iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    opaque_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
    premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
    shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
    shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
    skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
    transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
    uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
    worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    vertex$e = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
    vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    vertex$a = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    vertex$2 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    ShaderChunk = {
        alphahash_fragment,
        alphahash_pars_fragment,
        alphamap_fragment,
        alphamap_pars_fragment,
        alphatest_fragment,
        alphatest_pars_fragment,
        aomap_fragment,
        aomap_pars_fragment,
        batching_pars_vertex,
        batching_vertex,
        begin_vertex,
        beginnormal_vertex,
        bsdfs,
        iridescence_fragment,
        bumpmap_pars_fragment,
        clipping_planes_fragment,
        clipping_planes_pars_fragment,
        clipping_planes_pars_vertex,
        clipping_planes_vertex,
        color_fragment,
        color_pars_fragment,
        color_pars_vertex,
        color_vertex,
        common,
        cube_uv_reflection_fragment,
        defaultnormal_vertex,
        displacementmap_pars_vertex,
        displacementmap_vertex,
        emissivemap_fragment,
        emissivemap_pars_fragment,
        colorspace_fragment,
        colorspace_pars_fragment,
        envmap_fragment,
        envmap_common_pars_fragment,
        envmap_pars_fragment,
        envmap_pars_vertex,
        envmap_physical_pars_fragment,
        envmap_vertex,
        fog_vertex,
        fog_pars_vertex,
        fog_fragment,
        fog_pars_fragment,
        gradientmap_pars_fragment,
        lightmap_pars_fragment,
        lights_lambert_fragment,
        lights_lambert_pars_fragment,
        lights_pars_begin,
        lights_toon_fragment,
        lights_toon_pars_fragment,
        lights_phong_fragment,
        lights_phong_pars_fragment,
        lights_physical_fragment,
        lights_physical_pars_fragment,
        lights_fragment_begin,
        lights_fragment_maps,
        lights_fragment_end,
        logdepthbuf_fragment,
        logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex,
        logdepthbuf_vertex,
        map_fragment,
        map_pars_fragment,
        map_particle_fragment,
        map_particle_pars_fragment,
        metalnessmap_fragment,
        metalnessmap_pars_fragment,
        morphinstance_vertex,
        morphcolor_vertex,
        morphnormal_vertex,
        morphtarget_pars_vertex,
        morphtarget_vertex,
        normal_fragment_begin,
        normal_fragment_maps,
        normal_pars_fragment,
        normal_pars_vertex,
        normal_vertex,
        normalmap_pars_fragment,
        clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps,
        clearcoat_pars_fragment,
        iridescence_pars_fragment,
        opaque_fragment,
        packing,
        premultiplied_alpha_fragment,
        project_vertex,
        dithering_fragment,
        dithering_pars_fragment,
        roughnessmap_fragment,
        roughnessmap_pars_fragment,
        shadowmap_pars_fragment,
        shadowmap_pars_vertex,
        shadowmap_vertex,
        shadowmask_pars_fragment,
        skinbase_vertex,
        skinning_pars_vertex,
        skinning_vertex,
        skinnormal_vertex,
        specularmap_fragment,
        specularmap_pars_fragment,
        tonemapping_fragment,
        tonemapping_pars_fragment,
        transmission_fragment,
        transmission_pars_fragment,
        uv_pars_fragment,
        uv_pars_vertex,
        uv_vertex,
        worldpos_vertex,
        background_vert: vertex$h,
        background_frag: fragment$h,
        backgroundCube_vert: vertex$g,
        backgroundCube_frag: fragment$g,
        cube_vert: vertex$f,
        cube_frag: fragment$f,
        depth_vert: vertex$e,
        depth_frag: fragment$e,
        distanceRGBA_vert: vertex$d,
        distanceRGBA_frag: fragment$d,
        equirect_vert: vertex$c,
        equirect_frag: fragment$c,
        linedashed_vert: vertex$b,
        linedashed_frag: fragment$b,
        meshbasic_vert: vertex$a,
        meshbasic_frag: fragment$a,
        meshlambert_vert: vertex$9,
        meshlambert_frag: fragment$9,
        meshmatcap_vert: vertex$8,
        meshmatcap_frag: fragment$8,
        meshnormal_vert: vertex$7,
        meshnormal_frag: fragment$7,
        meshphong_vert: vertex$6,
        meshphong_frag: fragment$6,
        meshphysical_vert: vertex$5,
        meshphysical_frag: fragment$5,
        meshtoon_vert: vertex$4,
        meshtoon_frag: fragment$4,
        points_vert: vertex$3,
        points_frag: fragment$3,
        shadow_vert: vertex$2,
        shadow_frag: fragment$2,
        sprite_vert: vertex$1,
        sprite_frag: fragment$1
    },
    UniformsLib$1 = {
        common: {
            diffuse: {
                value: new Color(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Matrix3
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Matrix3
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new Matrix3
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new Matrix3
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new Matrix3
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new Matrix3
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new Matrix3
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new Matrix3
            },
            normalScale: {
                value: new Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new Matrix3
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new Matrix3
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new Matrix3
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new Matrix3
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Color(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Matrix3
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Matrix3
            }
        },
        sprite: {
            diffuse: {
                value: new Color(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Vector2(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Matrix3
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Matrix3
            },
            alphaTest: {
                value: 0
            }
        }
    },
    ShaderLib = {
        basic: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.specularmap, UniformsLib$1.envmap, UniformsLib$1.aomap, UniformsLib$1.lightmap, UniformsLib$1.fog]),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.specularmap, UniformsLib$1.envmap, UniformsLib$1.aomap, UniformsLib$1.lightmap, UniformsLib$1.emissivemap, UniformsLib$1.bumpmap, UniformsLib$1.normalmap, UniformsLib$1.displacementmap, UniformsLib$1.fog, UniformsLib$1.lights, {
                emissive: {
                    value: new Color(0)
                }
            }]),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.specularmap, UniformsLib$1.envmap, UniformsLib$1.aomap, UniformsLib$1.lightmap, UniformsLib$1.emissivemap, UniformsLib$1.bumpmap, UniformsLib$1.normalmap, UniformsLib$1.displacementmap, UniformsLib$1.fog, UniformsLib$1.lights, {
                emissive: {
                    value: new Color(0)
                },
                specular: {
                    value: new Color(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.envmap, UniformsLib$1.aomap, UniformsLib$1.lightmap, UniformsLib$1.emissivemap, UniformsLib$1.bumpmap, UniformsLib$1.normalmap, UniformsLib$1.displacementmap, UniformsLib$1.roughnessmap, UniformsLib$1.metalnessmap, UniformsLib$1.fog, UniformsLib$1.lights, {
                emissive: {
                    value: new Color(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        },
        toon: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.aomap, UniformsLib$1.lightmap, UniformsLib$1.emissivemap, UniformsLib$1.bumpmap, UniformsLib$1.normalmap, UniformsLib$1.displacementmap, UniformsLib$1.gradientmap, UniformsLib$1.fog, UniformsLib$1.lights, {
                emissive: {
                    value: new Color(0)
                }
            }]),
            vertexShader: ShaderChunk.meshtoon_vert,
            fragmentShader: ShaderChunk.meshtoon_frag
        },
        matcap: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.bumpmap, UniformsLib$1.normalmap, UniformsLib$1.displacementmap, UniformsLib$1.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: ShaderChunk.meshmatcap_vert,
            fragmentShader: ShaderChunk.meshmatcap_frag
        },
        points: {
            uniforms: mergeUniforms([UniformsLib$1.points, UniformsLib$1.fog]),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.displacementmap]),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.bumpmap, UniformsLib$1.normalmap, UniformsLib$1.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: ShaderChunk.meshnormal_vert,
            fragmentShader: ShaderChunk.meshnormal_frag
        },
        sprite: {
            uniforms: mergeUniforms([UniformsLib$1.sprite, UniformsLib$1.fog]),
            vertexShader: ShaderChunk.sprite_vert,
            fragmentShader: ShaderChunk.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Matrix3
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: ShaderChunk.background_vert,
            fragmentShader: ShaderChunk.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new Matrix3
                }
            },
            vertexShader: ShaderChunk.backgroundCube_vert,
            fragmentShader: ShaderChunk.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: mergeUniforms([UniformsLib$1.common, UniformsLib$1.displacementmap, {
                referencePosition: {
                    value: new Vector3$1
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
            uniforms: mergeUniforms([UniformsLib$1.lights, UniformsLib$1.fog, {
                color: {
                    value: new Color(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
        }
    };
ShaderLib.physical = {
    uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new Matrix3
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new Matrix3
        },
        clearcoatNormalScale: {
            value: new Vector2(1, 1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new Matrix3
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new Matrix3
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new Matrix3
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Color(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new Matrix3
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new Matrix3
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new Matrix3
        },
        transmissionSamplerSize: {
            value: new Vector2
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new Matrix3
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Color(0)
        },
        specularColor: {
            value: new Color(1, 1, 1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new Matrix3
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new Matrix3
        },
        anisotropyVector: {
            value: new Vector2
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new Matrix3
        }
    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
const _rgb = {
        r: 0,
        b: 0,
        g: 0
    },
    _e1$1 = new Euler$1,
    _m1$1 = new Matrix4;

function WebGLBackground(l, i, o, c, u, p, m) {
    const g = new Color(0);
    let _ = p === !0 ? 0 : 1,
        v, x, y = null,
        b = 0,
        S = null;

    function C(M) {
        let A = M.isScene === !0 ? M.background : null;
        return A && A.isTexture && (A = (M.backgroundBlurriness > 0 ? o : i).get(A)), A
    }

    function E(M) {
        let A = !1;
        const D = C(M);
        D === null ? w(g, _) : D && D.isColor && (w(D, 1), A = !0);
        const R = l.xr.getEnvironmentBlendMode();
        R === "additive" ? c.buffers.color.setClear(0, 0, 0, 1, m) : R === "alpha-blend" && c.buffers.color.setClear(0, 0, 0, 0, m), (l.autoClear || A) && (c.buffers.depth.setTest(!0), c.buffers.depth.setMask(!0), c.buffers.color.setMask(!0), l.clear(l.autoClearColor, l.autoClearDepth, l.autoClearStencil))
    }

    function P(M, A) {
        const D = C(A);
        D && (D.isCubeTexture || D.mapping === CubeUVReflectionMapping) ? (x === void 0 && (x = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })), x.geometry.deleteAttribute("normal"), x.geometry.deleteAttribute("uv"), x.onBeforeRender = function(R, I, k) {
            this.matrixWorld.copyPosition(k.matrixWorld)
        }, Object.defineProperty(x.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }), u.update(x)), _e1$1.copy(A.backgroundRotation), _e1$1.x *= -1, _e1$1.y *= -1, _e1$1.z *= -1, D.isCubeTexture && D.isRenderTargetTexture === !1 && (_e1$1.y *= -1, _e1$1.z *= -1), x.material.uniforms.envMap.value = D, x.material.uniforms.flipEnvMap.value = D.isCubeTexture && D.isRenderTargetTexture === !1 ? -1 : 1, x.material.uniforms.backgroundBlurriness.value = A.backgroundBlurriness, x.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, x.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)), x.material.toneMapped = ColorManagement.getTransfer(D.colorSpace) !== SRGBTransfer, (y !== D || b !== D.version || S !== l.toneMapping) && (x.material.needsUpdate = !0, y = D, b = D.version, S = l.toneMapping), x.layers.enableAll(), M.unshift(x, x.geometry, x.material, 0, 0, null)) : D && D.isTexture && (v === void 0 && (v = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })), v.geometry.deleteAttribute("normal"), Object.defineProperty(v.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }), u.update(v)), v.material.uniforms.t2D.value = D, v.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, v.material.toneMapped = ColorManagement.getTransfer(D.colorSpace) !== SRGBTransfer, D.matrixAutoUpdate === !0 && D.updateMatrix(), v.material.uniforms.uvTransform.value.copy(D.matrix), (y !== D || b !== D.version || S !== l.toneMapping) && (v.material.needsUpdate = !0, y = D, b = D.version, S = l.toneMapping), v.layers.enableAll(), M.unshift(v, v.geometry, v.material, 0, 0, null))
    }

    function w(M, A) {
        M.getRGB(_rgb, getUnlitUniformColorSpace(l)), c.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, A, m)
    }

    function T() {
        x !== void 0 && (x.geometry.dispose(), x.material.dispose(), x = void 0), v !== void 0 && (v.geometry.dispose(), v.material.dispose(), v = void 0)
    }
    return {
        getClearColor: function() {
            return g
        },
        setClearColor: function(M, A = 1) {
            g.set(M), _ = A, w(g, _)
        },
        getClearAlpha: function() {
            return _
        },
        setClearAlpha: function(M) {
            _ = M, w(g, _)
        },
        render: E,
        addToRenderList: P,
        dispose: T
    }
}

function WebGLBindingStates(l, i) {
    const o = l.getParameter(l.MAX_VERTEX_ATTRIBS),
        c = {},
        u = b(null);
    let p = u,
        m = !1;

    function g(V, B, U, H, Q) {
        let Y = !1;
        const O = y(H, U, B);
        p !== O && (p = O, v(p.object)), Y = S(V, H, U, Q), Y && C(V, H, U, Q), Q !== null && i.update(Q, l.ELEMENT_ARRAY_BUFFER), (Y || m) && (m = !1, A(V, B, U, H), Q !== null && l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, i.get(Q).buffer))
    }

    function _() {
        return l.createVertexArray()
    }

    function v(V) {
        return l.bindVertexArray(V)
    }

    function x(V) {
        return l.deleteVertexArray(V)
    }

    function y(V, B, U) {
        const H = U.wireframe === !0;
        let Q = c[V.id];
        Q === void 0 && (Q = {}, c[V.id] = Q);
        let Y = Q[B.id];
        Y === void 0 && (Y = {}, Q[B.id] = Y);
        let O = Y[H];
        return O === void 0 && (O = b(_()), Y[H] = O), O
    }

    function b(V) {
        const B = [],
            U = [],
            H = [];
        for (let Q = 0; Q < o; Q++) B[Q] = 0, U[Q] = 0, H[Q] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: B,
            enabledAttributes: U,
            attributeDivisors: H,
            object: V,
            attributes: {},
            index: null
        }
    }

    function S(V, B, U, H) {
        const Q = p.attributes,
            Y = B.attributes;
        let O = 0;
        const G = U.getAttributes();
        for (const L in G)
            if (G[L].location >= 0) {
                const K = Q[L];
                let Z = Y[L];
                if (Z === void 0 && (L === "instanceMatrix" && V.instanceMatrix && (Z = V.instanceMatrix), L === "instanceColor" && V.instanceColor && (Z = V.instanceColor)), K === void 0 || K.attribute !== Z || Z && K.data !== Z.data) return !0;
                O++
            }
        return p.attributesNum !== O || p.index !== H
    }

    function C(V, B, U, H) {
        const Q = {},
            Y = B.attributes;
        let O = 0;
        const G = U.getAttributes();
        for (const L in G)
            if (G[L].location >= 0) {
                let K = Y[L];
                K === void 0 && (L === "instanceMatrix" && V.instanceMatrix && (K = V.instanceMatrix), L === "instanceColor" && V.instanceColor && (K = V.instanceColor));
                const Z = {};
                Z.attribute = K, K && K.data && (Z.data = K.data), Q[L] = Z, O++
            }
        p.attributes = Q, p.attributesNum = O, p.index = H
    }

    function E() {
        const V = p.newAttributes;
        for (let B = 0, U = V.length; B < U; B++) V[B] = 0
    }

    function P(V) {
        w(V, 0)
    }

    function w(V, B) {
        const U = p.newAttributes,
            H = p.enabledAttributes,
            Q = p.attributeDivisors;
        U[V] = 1, H[V] === 0 && (l.enableVertexAttribArray(V), H[V] = 1), Q[V] !== B && (l.vertexAttribDivisor(V, B), Q[V] = B)
    }

    function T() {
        const V = p.newAttributes,
            B = p.enabledAttributes;
        for (let U = 0, H = B.length; U < H; U++) B[U] !== V[U] && (l.disableVertexAttribArray(U), B[U] = 0)
    }

    function M(V, B, U, H, Q, Y, O) {
        O === !0 ? l.vertexAttribIPointer(V, B, U, Q, Y) : l.vertexAttribPointer(V, B, U, H, Q, Y)
    }

    function A(V, B, U, H) {
        E();
        const Q = H.attributes,
            Y = U.getAttributes(),
            O = B.defaultAttributeValues;
        for (const G in Y) {
            const L = Y[G];
            if (L.location >= 0) {
                let N = Q[G];
                if (N === void 0 && (G === "instanceMatrix" && V.instanceMatrix && (N = V.instanceMatrix), G === "instanceColor" && V.instanceColor && (N = V.instanceColor)), N !== void 0) {
                    const K = N.normalized,
                        Z = N.itemSize,
                        he = i.get(N);
                    if (he === void 0) continue;
                    const we = he.buffer,
                        ie = he.type,
                        _e = he.bytesPerElement,
                        Te = ie === l.INT || ie === l.UNSIGNED_INT || N.gpuType === IntType;
                    if (N.isInterleavedBufferAttribute) {
                        const Me = N.data,
                            Pe = Me.stride,
                            be = N.offset;
                        if (Me.isInstancedInterleavedBuffer) {
                            for (let Be = 0; Be < L.locationSize; Be++) w(L.location + Be, Me.meshPerAttribute);
                            V.isInstancedMesh !== !0 && H._maxInstanceCount === void 0 && (H._maxInstanceCount = Me.meshPerAttribute * Me.count)
                        } else
                            for (let Be = 0; Be < L.locationSize; Be++) P(L.location + Be);
                        l.bindBuffer(l.ARRAY_BUFFER, we);
                        for (let Be = 0; Be < L.locationSize; Be++) M(L.location + Be, Z / L.locationSize, ie, K, Pe * _e, (be + Z / L.locationSize * Be) * _e, Te)
                    } else {
                        if (N.isInstancedBufferAttribute) {
                            for (let Me = 0; Me < L.locationSize; Me++) w(L.location + Me, N.meshPerAttribute);
                            V.isInstancedMesh !== !0 && H._maxInstanceCount === void 0 && (H._maxInstanceCount = N.meshPerAttribute * N.count)
                        } else
                            for (let Me = 0; Me < L.locationSize; Me++) P(L.location + Me);
                        l.bindBuffer(l.ARRAY_BUFFER, we);
                        for (let Me = 0; Me < L.locationSize; Me++) M(L.location + Me, Z / L.locationSize, ie, K, Z * _e, Z / L.locationSize * Me * _e, Te)
                    }
                } else if (O !== void 0) {
                    const K = O[G];
                    if (K !== void 0) switch (K.length) {
                        case 2:
                            l.vertexAttrib2fv(L.location, K);
                            break;
                        case 3:
                            l.vertexAttrib3fv(L.location, K);
                            break;
                        case 4:
                            l.vertexAttrib4fv(L.location, K);
                            break;
                        default:
                            l.vertexAttrib1fv(L.location, K)
                    }
                }
            }
        }
        T()
    }

    function D() {
        k();
        for (const V in c) {
            const B = c[V];
            for (const U in B) {
                const H = B[U];
                for (const Q in H) x(H[Q].object), delete H[Q];
                delete B[U]
            }
            delete c[V]
        }
    }

    function R(V) {
        if (c[V.id] === void 0) return;
        const B = c[V.id];
        for (const U in B) {
            const H = B[U];
            for (const Q in H) x(H[Q].object), delete H[Q];
            delete B[U]
        }
        delete c[V.id]
    }

    function I(V) {
        for (const B in c) {
            const U = c[B];
            if (U[V.id] === void 0) continue;
            const H = U[V.id];
            for (const Q in H) x(H[Q].object), delete H[Q];
            delete U[V.id]
        }
    }

    function k() {
        F(), m = !0, p !== u && (p = u, v(p.object))
    }

    function F() {
        u.geometry = null, u.program = null, u.wireframe = !1
    }
    return {
        setup: g,
        reset: k,
        resetDefaultState: F,
        dispose: D,
        releaseStatesOfGeometry: R,
        releaseStatesOfProgram: I,
        initAttributes: E,
        enableAttribute: P,
        disableUnusedAttributes: T
    }
}

function WebGLBufferRenderer(l, i, o) {
    let c;

    function u(v) {
        c = v
    }

    function p(v, x) {
        l.drawArrays(c, v, x), o.update(x, c, 1)
    }

    function m(v, x, y) {
        y !== 0 && (l.drawArraysInstanced(c, v, x, y), o.update(x, c, y))
    }

    function g(v, x, y) {
        if (y === 0) return;
        i.get("WEBGL_multi_draw").multiDrawArraysWEBGL(c, v, 0, x, 0, y);
        let S = 0;
        for (let C = 0; C < y; C++) S += x[C];
        o.update(S, c, 1)
    }

    function _(v, x, y, b) {
        if (y === 0) return;
        const S = i.get("WEBGL_multi_draw");
        if (S === null)
            for (let C = 0; C < v.length; C++) m(v[C], x[C], b[C]);
        else {
            S.multiDrawArraysInstancedWEBGL(c, v, 0, x, 0, b, 0, y);
            let C = 0;
            for (let E = 0; E < y; E++) C += x[E] * b[E];
            o.update(C, c, 1)
        }
    }
    this.setMode = u, this.render = p, this.renderInstances = m, this.renderMultiDraw = g, this.renderMultiDrawInstances = _
}

function WebGLCapabilities(l, i, o, c) {
    let u;

    function p() {
        if (u !== void 0) return u;
        if (i.has("EXT_texture_filter_anisotropic") === !0) {
            const I = i.get("EXT_texture_filter_anisotropic");
            u = l.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else u = 0;
        return u
    }

    function m(I) {
        return !(I !== RGBAFormat && c.convert(I) !== l.getParameter(l.IMPLEMENTATION_COLOR_READ_FORMAT))
    }

    function g(I) {
        const k = I === HalfFloatType && (i.has("EXT_color_buffer_half_float") || i.has("EXT_color_buffer_float"));
        return !(I !== UnsignedByteType && c.convert(I) !== l.getParameter(l.IMPLEMENTATION_COLOR_READ_TYPE) && I !== FloatType && !k)
    }

    function _(I) {
        if (I === "highp") {
            if (l.getShaderPrecisionFormat(l.VERTEX_SHADER, l.HIGH_FLOAT).precision > 0 && l.getShaderPrecisionFormat(l.FRAGMENT_SHADER, l.HIGH_FLOAT).precision > 0) return "highp";
            I = "mediump"
        }
        return I === "mediump" && l.getShaderPrecisionFormat(l.VERTEX_SHADER, l.MEDIUM_FLOAT).precision > 0 && l.getShaderPrecisionFormat(l.FRAGMENT_SHADER, l.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let v = o.precision !== void 0 ? o.precision : "highp";
    const x = _(v);
    x !== v && (console.warn("THREE.WebGLRenderer:", v, "not supported, using", x, "instead."), v = x);
    const y = o.logarithmicDepthBuffer === !0,
        b = o.reverseDepthBuffer === !0 && i.has("EXT_clip_control"),
        S = l.getParameter(l.MAX_TEXTURE_IMAGE_UNITS),
        C = l.getParameter(l.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        E = l.getParameter(l.MAX_TEXTURE_SIZE),
        P = l.getParameter(l.MAX_CUBE_MAP_TEXTURE_SIZE),
        w = l.getParameter(l.MAX_VERTEX_ATTRIBS),
        T = l.getParameter(l.MAX_VERTEX_UNIFORM_VECTORS),
        M = l.getParameter(l.MAX_VARYING_VECTORS),
        A = l.getParameter(l.MAX_FRAGMENT_UNIFORM_VECTORS),
        D = C > 0,
        R = l.getParameter(l.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: p,
        getMaxPrecision: _,
        textureFormatReadable: m,
        textureTypeReadable: g,
        precision: v,
        logarithmicDepthBuffer: y,
        reverseDepthBuffer: b,
        maxTextures: S,
        maxVertexTextures: C,
        maxTextureSize: E,
        maxCubemapSize: P,
        maxAttributes: w,
        maxVertexUniforms: T,
        maxVaryings: M,
        maxFragmentUniforms: A,
        vertexTextures: D,
        maxSamples: R
    }
}

function WebGLClipping(l) {
    const i = this;
    let o = null,
        c = 0,
        u = !1,
        p = !1;
    const m = new Plane,
        g = new Matrix3,
        _ = {
            value: null,
            needsUpdate: !1
        };
    this.uniform = _, this.numPlanes = 0, this.numIntersection = 0, this.init = function(y, b) {
        const S = y.length !== 0 || b || c !== 0 || u;
        return u = b, c = y.length, S
    }, this.beginShadows = function() {
        p = !0, x(null)
    }, this.endShadows = function() {
        p = !1
    }, this.setGlobalState = function(y, b) {
        o = x(y, b, 0)
    }, this.setState = function(y, b, S) {
        const C = y.clippingPlanes,
            E = y.clipIntersection,
            P = y.clipShadows,
            w = l.get(y);
        if (!u || C === null || C.length === 0 || p && !P) p ? x(null) : v();
        else {
            const T = p ? 0 : c,
                M = T * 4;
            let A = w.clippingState || null;
            _.value = A, A = x(C, b, M, S);
            for (let D = 0; D !== M; ++D) A[D] = o[D];
            w.clippingState = A, this.numIntersection = E ? this.numPlanes : 0, this.numPlanes += T
        }
    };

    function v() {
        _.value !== o && (_.value = o, _.needsUpdate = c > 0), i.numPlanes = c, i.numIntersection = 0
    }

    function x(y, b, S, C) {
        const E = y !== null ? y.length : 0;
        let P = null;
        if (E !== 0) {
            if (P = _.value, C !== !0 || P === null) {
                const w = S + E * 4,
                    T = b.matrixWorldInverse;
                g.getNormalMatrix(T), (P === null || P.length < w) && (P = new Float32Array(w));
                for (let M = 0, A = S; M !== E; ++M, A += 4) m.copy(y[M]).applyMatrix4(T, g), m.normal.toArray(P, A), P[A + 3] = m.constant
            }
            _.value = P, _.needsUpdate = !0
        }
        return i.numPlanes = E, i.numIntersection = 0, P
    }
}

function WebGLCubeMaps(l) {
    let i = new WeakMap;

    function o(m, g) {
        return g === EquirectangularReflectionMapping ? m.mapping = CubeReflectionMapping : g === EquirectangularRefractionMapping && (m.mapping = CubeRefractionMapping), m
    }

    function c(m) {
        if (m && m.isTexture) {
            const g = m.mapping;
            if (g === EquirectangularReflectionMapping || g === EquirectangularRefractionMapping)
                if (i.has(m)) {
                    const _ = i.get(m).texture;
                    return o(_, m.mapping)
                } else {
                    const _ = m.image;
                    if (_ && _.height > 0) {
                        const v = new WebGLCubeRenderTarget(_.height);
                        return v.fromEquirectangularTexture(l, m), i.set(m, v), m.addEventListener("dispose", u), o(v.texture, m.mapping)
                    } else return null
                }
        }
        return m
    }

    function u(m) {
        const g = m.target;
        g.removeEventListener("dispose", u);
        const _ = i.get(g);
        _ !== void 0 && (i.delete(g), _.dispose())
    }

    function p() {
        i = new WeakMap
    }
    return {
        get: c,
        dispose: p
    }
}
const LOD_MIN = 4,
    EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582],
    MAX_SAMPLES = 20,
    _flatCamera = new OrthographicCamera,
    _clearColor = new Color;
let _oldTarget = null,
    _oldActiveCubeFace = 0,
    _oldActiveMipmapLevel = 0,
    _oldXrEnabled = !1;
const PHI = (1 + Math.sqrt(5)) / 2,
    INV_PHI = 1 / PHI,
    _axisDirections = [new Vector3$1(-PHI, INV_PHI, 0), new Vector3$1(PHI, INV_PHI, 0), new Vector3$1(-INV_PHI, 0, PHI), new Vector3$1(INV_PHI, 0, PHI), new Vector3$1(0, PHI, -INV_PHI), new Vector3$1(0, PHI, INV_PHI), new Vector3$1(-1, 1, -1), new Vector3$1(1, 1, -1), new Vector3$1(-1, 1, 1), new Vector3$1(1, 1, 1)],
    _origin = new Vector3$1;
class PMREMGenerator {
    constructor(i) {
        this._renderer = i, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
    }
    fromScene(i, o = 0, c = .1, u = 100, p = {}) {
        const {
            size: m = 256,
            position: g = _origin
        } = p;
        _oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(m);
        const _ = this._allocateTargets();
        return _.depthBuffer = !0, this._sceneToCubeUV(i, c, u, _, g), o > 0 && this._blur(_, 0, 0, o), this._applyPMREM(_), this._cleanup(_), _
    }
    fromEquirectangular(i, o = null) {
        return this._fromTexture(i, o)
    }
    fromCubemap(i, o = null) {
        return this._fromTexture(i, o)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial(), this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial(), this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(i) {
        this._lodMax = Math.floor(Math.log2(i)), this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let i = 0; i < this._lodPlanes.length; i++) this._lodPlanes[i].dispose()
    }
    _cleanup(i) {
        this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel), this._renderer.xr.enabled = _oldXrEnabled, i.scissorTest = !1, _setViewport(i, 0, 0, i.width, i.height)
    }
    _fromTexture(i, o) {
        i.mapping === CubeReflectionMapping || i.mapping === CubeRefractionMapping ? this._setSize(i.image.length === 0 ? 16 : i.image[0].width || i.image[0].image.width) : this._setSize(i.image.width / 4), _oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
        const c = o || this._allocateTargets();
        return this._textureToCubeUV(i, c), this._applyPMREM(c), this._cleanup(c), c
    }
    _allocateTargets() {
        const i = 3 * Math.max(this._cubeSize, 112),
            o = 4 * this._cubeSize,
            c = {
                magFilter: LinearFilter,
                minFilter: LinearFilter,
                generateMipmaps: !1,
                type: HalfFloatType,
                format: RGBAFormat,
                colorSpace: LinearSRGBColorSpace,
                depthBuffer: !1
            },
            u = _createRenderTarget(i, o, c);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== i || this._pingPongRenderTarget.height !== o) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = _createRenderTarget(i, o, c);
            const {
                _lodMax: p
            } = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas
            } = _createPlanes(p)), this._blurMaterial = _getBlurShader(p, i, o)
        }
        return u
    }
    _compileMaterial(i) {
        const o = new Mesh(this._lodPlanes[0], i);
        this._renderer.compile(o, _flatCamera)
    }
    _sceneToCubeUV(i, o, c, u, p) {
        const _ = new PerspectiveCamera(90, 1, o, c),
            v = [1, -1, 1, 1, 1, 1],
            x = [1, 1, 1, -1, -1, -1],
            y = this._renderer,
            b = y.autoClear,
            S = y.toneMapping;
        y.getClearColor(_clearColor), y.toneMapping = NoToneMapping, y.autoClear = !1;
        const C = new MeshBasicMaterial({
                name: "PMREM.Background",
                side: BackSide,
                depthWrite: !1,
                depthTest: !1
            }),
            E = new Mesh(new BoxGeometry, C);
        let P = !1;
        const w = i.background;
        w ? w.isColor && (C.color.copy(w), i.background = null, P = !0) : (C.color.copy(_clearColor), P = !0);
        for (let T = 0; T < 6; T++) {
            const M = T % 3;
            M === 0 ? (_.up.set(0, v[T], 0), _.position.set(p.x, p.y, p.z), _.lookAt(p.x + x[T], p.y, p.z)) : M === 1 ? (_.up.set(0, 0, v[T]), _.position.set(p.x, p.y, p.z), _.lookAt(p.x, p.y + x[T], p.z)) : (_.up.set(0, v[T], 0), _.position.set(p.x, p.y, p.z), _.lookAt(p.x, p.y, p.z + x[T]));
            const A = this._cubeSize;
            _setViewport(u, M * A, T > 2 ? A : 0, A, A), y.setRenderTarget(u), P && y.render(E, _), y.render(i, _)
        }
        E.geometry.dispose(), E.material.dispose(), y.toneMapping = S, y.autoClear = b, i.background = w
    }
    _textureToCubeUV(i, o) {
        const c = this._renderer,
            u = i.mapping === CubeReflectionMapping || i.mapping === CubeRefractionMapping;
        u ? (this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial()), this._cubemapMaterial.uniforms.flipEnvMap.value = i.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial());
        const p = u ? this._cubemapMaterial : this._equirectMaterial,
            m = new Mesh(this._lodPlanes[0], p),
            g = p.uniforms;
        g.envMap.value = i;
        const _ = this._cubeSize;
        _setViewport(o, 0, 0, 3 * _, 2 * _), c.setRenderTarget(o), c.render(m, _flatCamera)
    }
    _applyPMREM(i) {
        const o = this._renderer,
            c = o.autoClear;
        o.autoClear = !1;
        const u = this._lodPlanes.length;
        for (let p = 1; p < u; p++) {
            const m = Math.sqrt(this._sigmas[p] * this._sigmas[p] - this._sigmas[p - 1] * this._sigmas[p - 1]),
                g = _axisDirections[(u - p - 1) % _axisDirections.length];
            this._blur(i, p - 1, p, m, g)
        }
        o.autoClear = c
    }
    _blur(i, o, c, u, p) {
        const m = this._pingPongRenderTarget;
        this._halfBlur(i, m, o, c, u, "latitudinal", p), this._halfBlur(m, i, c, c, u, "longitudinal", p)
    }
    _halfBlur(i, o, c, u, p, m, g) {
        const _ = this._renderer,
            v = this._blurMaterial;
        m !== "latitudinal" && m !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const x = 3,
            y = new Mesh(this._lodPlanes[u], v),
            b = v.uniforms,
            S = this._sizeLods[c] - 1,
            C = isFinite(p) ? Math.PI / (2 * S) : 2 * Math.PI / (2 * MAX_SAMPLES - 1),
            E = p / C,
            P = isFinite(p) ? 1 + Math.floor(x * E) : MAX_SAMPLES;
        P > MAX_SAMPLES && console.warn(`sigmaRadians, ${p}, is too large and will clip, as it requested ${P} samples when the maximum is set to ${MAX_SAMPLES}`);
        const w = [];
        let T = 0;
        for (let I = 0; I < MAX_SAMPLES; ++I) {
            const k = I / E,
                F = Math.exp(-k * k / 2);
            w.push(F), I === 0 ? T += F : I < P && (T += 2 * F)
        }
        for (let I = 0; I < w.length; I++) w[I] = w[I] / T;
        b.envMap.value = i.texture, b.samples.value = P, b.weights.value = w, b.latitudinal.value = m === "latitudinal", g && (b.poleAxis.value = g);
        const {
            _lodMax: M
        } = this;
        b.dTheta.value = C, b.mipInt.value = M - c;
        const A = this._sizeLods[u],
            D = 3 * A * (u > M - LOD_MIN ? u - M + LOD_MIN : 0),
            R = 4 * (this._cubeSize - A);
        _setViewport(o, D, R, 3 * A, 2 * A), _.setRenderTarget(o), _.render(y, _flatCamera)
    }
}

function _createPlanes(l) {
    const i = [],
        o = [],
        c = [];
    let u = l;
    const p = l - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let m = 0; m < p; m++) {
        const g = Math.pow(2, u);
        o.push(g);
        let _ = 1 / g;
        m > l - LOD_MIN ? _ = EXTRA_LOD_SIGMA[m - l + LOD_MIN - 1] : m === 0 && (_ = 0), c.push(_);
        const v = 1 / (g - 2),
            x = -v,
            y = 1 + v,
            b = [x, x, y, x, y, y, x, x, y, y, x, y],
            S = 6,
            C = 6,
            E = 3,
            P = 2,
            w = 1,
            T = new Float32Array(E * C * S),
            M = new Float32Array(P * C * S),
            A = new Float32Array(w * C * S);
        for (let R = 0; R < S; R++) {
            const I = R % 3 * 2 / 3 - 1,
                k = R > 2 ? 0 : -1,
                F = [I, k, 0, I + 2 / 3, k, 0, I + 2 / 3, k + 1, 0, I, k, 0, I + 2 / 3, k + 1, 0, I, k + 1, 0];
            T.set(F, E * C * R), M.set(b, P * C * R);
            const V = [R, R, R, R, R, R];
            A.set(V, w * C * R)
        }
        const D = new BufferGeometry;
        D.setAttribute("position", new BufferAttribute(T, E)), D.setAttribute("uv", new BufferAttribute(M, P)), D.setAttribute("faceIndex", new BufferAttribute(A, w)), i.push(D), u > LOD_MIN && u--
    }
    return {
        lodPlanes: i,
        sizeLods: o,
        sigmas: c
    }
}

function _createRenderTarget(l, i, o) {
    const c = new WebGLRenderTarget(l, i, o);
    return c.texture.mapping = CubeUVReflectionMapping, c.texture.name = "PMREM.cubeUv", c.scissorTest = !0, c
}

function _setViewport(l, i, o, c, u) {
    l.viewport.set(i, o, c, u), l.scissor.set(i, o, c, u)
}

function _getBlurShader(l, i, o) {
    const c = new Float32Array(MAX_SAMPLES),
        u = new Vector3$1(0, 1, 0);
    return new ShaderMaterial({
        name: "SphericalGaussianBlur",
        defines: {
            n: MAX_SAMPLES,
            CUBEUV_TEXEL_WIDTH: 1 / i,
            CUBEUV_TEXEL_HEIGHT: 1 / o,
            CUBEUV_MAX_MIP: `${l}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: c
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: u
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}

function _getEquirectMaterial() {
    return new ShaderMaterial({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}

function _getCubemapMaterial() {
    return new ShaderMaterial({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}

function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function WebGLCubeUVMaps(l) {
    let i = new WeakMap,
        o = null;

    function c(g) {
        if (g && g.isTexture) {
            const _ = g.mapping,
                v = _ === EquirectangularReflectionMapping || _ === EquirectangularRefractionMapping,
                x = _ === CubeReflectionMapping || _ === CubeRefractionMapping;
            if (v || x) {
                let y = i.get(g);
                const b = y !== void 0 ? y.texture.pmremVersion : 0;
                if (g.isRenderTargetTexture && g.pmremVersion !== b) return o === null && (o = new PMREMGenerator(l)), y = v ? o.fromEquirectangular(g, y) : o.fromCubemap(g, y), y.texture.pmremVersion = g.pmremVersion, i.set(g, y), y.texture;
                if (y !== void 0) return y.texture; {
                    const S = g.image;
                    return v && S && S.height > 0 || x && S && u(S) ? (o === null && (o = new PMREMGenerator(l)), y = v ? o.fromEquirectangular(g) : o.fromCubemap(g), y.texture.pmremVersion = g.pmremVersion, i.set(g, y), g.addEventListener("dispose", p), y.texture) : null
                }
            }
        }
        return g
    }

    function u(g) {
        let _ = 0;
        const v = 6;
        for (let x = 0; x < v; x++) g[x] !== void 0 && _++;
        return _ === v
    }

    function p(g) {
        const _ = g.target;
        _.removeEventListener("dispose", p);
        const v = i.get(_);
        v !== void 0 && (i.delete(_), v.dispose())
    }

    function m() {
        i = new WeakMap, o !== null && (o.dispose(), o = null)
    }
    return {
        get: c,
        dispose: m
    }
}

function WebGLExtensions(l) {
    const i = {};

    function o(c) {
        if (i[c] !== void 0) return i[c];
        let u;
        switch (c) {
            case "WEBGL_depth_texture":
                u = l.getExtension("WEBGL_depth_texture") || l.getExtension("MOZ_WEBGL_depth_texture") || l.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                u = l.getExtension("EXT_texture_filter_anisotropic") || l.getExtension("MOZ_EXT_texture_filter_anisotropic") || l.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                u = l.getExtension("WEBGL_compressed_texture_s3tc") || l.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || l.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                u = l.getExtension("WEBGL_compressed_texture_pvrtc") || l.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                u = l.getExtension(c)
        }
        return i[c] = u, u
    }
    return {
        has: function(c) {
            return o(c) !== null
        },
        init: function() {
            o("EXT_color_buffer_float"), o("WEBGL_clip_cull_distance"), o("OES_texture_float_linear"), o("EXT_color_buffer_half_float"), o("WEBGL_multisampled_render_to_texture"), o("WEBGL_render_shared_exponent")
        },
        get: function(c) {
            const u = o(c);
            return u === null && warnOnce("THREE.WebGLRenderer: " + c + " extension not supported."), u
        }
    }
}

function WebGLGeometries(l, i, o, c) {
    const u = {},
        p = new WeakMap;

    function m(y) {
        const b = y.target;
        b.index !== null && i.remove(b.index);
        for (const C in b.attributes) i.remove(b.attributes[C]);
        b.removeEventListener("dispose", m), delete u[b.id];
        const S = p.get(b);
        S && (i.remove(S), p.delete(b)), c.releaseStatesOfGeometry(b), b.isInstancedBufferGeometry === !0 && delete b._maxInstanceCount, o.memory.geometries--
    }

    function g(y, b) {
        return u[b.id] === !0 || (b.addEventListener("dispose", m), u[b.id] = !0, o.memory.geometries++), b
    }

    function _(y) {
        const b = y.attributes;
        for (const S in b) i.update(b[S], l.ARRAY_BUFFER)
    }

    function v(y) {
        const b = [],
            S = y.index,
            C = y.attributes.position;
        let E = 0;
        if (S !== null) {
            const T = S.array;
            E = S.version;
            for (let M = 0, A = T.length; M < A; M += 3) {
                const D = T[M + 0],
                    R = T[M + 1],
                    I = T[M + 2];
                b.push(D, R, R, I, I, D)
            }
        } else if (C !== void 0) {
            const T = C.array;
            E = C.version;
            for (let M = 0, A = T.length / 3 - 1; M < A; M += 3) {
                const D = M + 0,
                    R = M + 1,
                    I = M + 2;
                b.push(D, R, R, I, I, D)
            }
        } else return;
        const P = new(arrayNeedsUint32(b) ? Uint32BufferAttribute : Uint16BufferAttribute)(b, 1);
        P.version = E;
        const w = p.get(y);
        w && i.remove(w), p.set(y, P)
    }

    function x(y) {
        const b = p.get(y);
        if (b) {
            const S = y.index;
            S !== null && b.version < S.version && v(y)
        } else v(y);
        return p.get(y)
    }
    return {
        get: g,
        update: _,
        getWireframeAttribute: x
    }
}

function WebGLIndexedBufferRenderer(l, i, o) {
    let c;

    function u(b) {
        c = b
    }
    let p, m;

    function g(b) {
        p = b.type, m = b.bytesPerElement
    }

    function _(b, S) {
        l.drawElements(c, S, p, b * m), o.update(S, c, 1)
    }

    function v(b, S, C) {
        C !== 0 && (l.drawElementsInstanced(c, S, p, b * m, C), o.update(S, c, C))
    }

    function x(b, S, C) {
        if (C === 0) return;
        i.get("WEBGL_multi_draw").multiDrawElementsWEBGL(c, S, 0, p, b, 0, C);
        let P = 0;
        for (let w = 0; w < C; w++) P += S[w];
        o.update(P, c, 1)
    }

    function y(b, S, C, E) {
        if (C === 0) return;
        const P = i.get("WEBGL_multi_draw");
        if (P === null)
            for (let w = 0; w < b.length; w++) v(b[w] / m, S[w], E[w]);
        else {
            P.multiDrawElementsInstancedWEBGL(c, S, 0, p, b, 0, E, 0, C);
            let w = 0;
            for (let T = 0; T < C; T++) w += S[T] * E[T];
            o.update(w, c, 1)
        }
    }
    this.setMode = u, this.setIndex = g, this.render = _, this.renderInstances = v, this.renderMultiDraw = x, this.renderMultiDrawInstances = y
}

function WebGLInfo(l) {
    const i = {
            geometries: 0,
            textures: 0
        },
        o = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };

    function c(p, m, g) {
        switch (o.calls++, m) {
            case l.TRIANGLES:
                o.triangles += g * (p / 3);
                break;
            case l.LINES:
                o.lines += g * (p / 2);
                break;
            case l.LINE_STRIP:
                o.lines += g * (p - 1);
                break;
            case l.LINE_LOOP:
                o.lines += g * p;
                break;
            case l.POINTS:
                o.points += g * p;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", m);
                break
        }
    }

    function u() {
        o.calls = 0, o.triangles = 0, o.points = 0, o.lines = 0
    }
    return {
        memory: i,
        render: o,
        programs: null,
        autoReset: !0,
        reset: u,
        update: c
    }
}

function WebGLMorphtargets(l, i, o) {
    const c = new WeakMap,
        u = new Vector4;

    function p(m, g, _) {
        const v = m.morphTargetInfluences,
            x = g.morphAttributes.position || g.morphAttributes.normal || g.morphAttributes.color,
            y = x !== void 0 ? x.length : 0;
        let b = c.get(g);
        if (b === void 0 || b.count !== y) {
            let F = function() {
                I.dispose(), c.delete(g), g.removeEventListener("dispose", F)
            };
            b !== void 0 && b.texture.dispose();
            const S = g.morphAttributes.position !== void 0,
                C = g.morphAttributes.normal !== void 0,
                E = g.morphAttributes.color !== void 0,
                P = g.morphAttributes.position || [],
                w = g.morphAttributes.normal || [],
                T = g.morphAttributes.color || [];
            let M = 0;
            S === !0 && (M = 1), C === !0 && (M = 2), E === !0 && (M = 3);
            let A = g.attributes.position.count * M,
                D = 1;
            A > i.maxTextureSize && (D = Math.ceil(A / i.maxTextureSize), A = i.maxTextureSize);
            const R = new Float32Array(A * D * 4 * y),
                I = new DataArrayTexture(R, A, D, y);
            I.type = FloatType, I.needsUpdate = !0;
            const k = M * 4;
            for (let V = 0; V < y; V++) {
                const B = P[V],
                    U = w[V],
                    H = T[V],
                    Q = A * D * 4 * V;
                for (let Y = 0; Y < B.count; Y++) {
                    const O = Y * k;
                    S === !0 && (u.fromBufferAttribute(B, Y), R[Q + O + 0] = u.x, R[Q + O + 1] = u.y, R[Q + O + 2] = u.z, R[Q + O + 3] = 0), C === !0 && (u.fromBufferAttribute(U, Y), R[Q + O + 4] = u.x, R[Q + O + 5] = u.y, R[Q + O + 6] = u.z, R[Q + O + 7] = 0), E === !0 && (u.fromBufferAttribute(H, Y), R[Q + O + 8] = u.x, R[Q + O + 9] = u.y, R[Q + O + 10] = u.z, R[Q + O + 11] = H.itemSize === 4 ? u.w : 1)
                }
            }
            b = {
                count: y,
                texture: I,
                size: new Vector2(A, D)
            }, c.set(g, b), g.addEventListener("dispose", F)
        }
        if (m.isInstancedMesh === !0 && m.morphTexture !== null) _.getUniforms().setValue(l, "morphTexture", m.morphTexture, o);
        else {
            let S = 0;
            for (let E = 0; E < v.length; E++) S += v[E];
            const C = g.morphTargetsRelative ? 1 : 1 - S;
            _.getUniforms().setValue(l, "morphTargetBaseInfluence", C), _.getUniforms().setValue(l, "morphTargetInfluences", v)
        }
        _.getUniforms().setValue(l, "morphTargetsTexture", b.texture, o), _.getUniforms().setValue(l, "morphTargetsTextureSize", b.size)
    }
    return {
        update: p
    }
}

function WebGLObjects(l, i, o, c) {
    let u = new WeakMap;

    function p(_) {
        const v = c.render.frame,
            x = _.geometry,
            y = i.get(_, x);
        if (u.get(y) !== v && (i.update(y), u.set(y, v)), _.isInstancedMesh && (_.hasEventListener("dispose", g) === !1 && _.addEventListener("dispose", g), u.get(_) !== v && (o.update(_.instanceMatrix, l.ARRAY_BUFFER), _.instanceColor !== null && o.update(_.instanceColor, l.ARRAY_BUFFER), u.set(_, v))), _.isSkinnedMesh) {
            const b = _.skeleton;
            u.get(b) !== v && (b.update(), u.set(b, v))
        }
        return y
    }

    function m() {
        u = new WeakMap
    }

    function g(_) {
        const v = _.target;
        v.removeEventListener("dispose", g), o.remove(v.instanceMatrix), v.instanceColor !== null && o.remove(v.instanceColor)
    }
    return {
        update: p,
        dispose: m
    }
}
const emptyTexture = new Texture,
    emptyShadowTexture = new DepthTexture(1, 1),
    emptyArrayTexture = new DataArrayTexture,
    empty3dTexture = new Data3DTexture,
    emptyCubeTexture = new CubeTexture,
    arrayCacheF32 = [],
    arrayCacheI32 = [],
    mat4array = new Float32Array(16),
    mat3array = new Float32Array(9),
    mat2array = new Float32Array(4);

function flatten(l, i, o) {
    const c = l[0];
    if (c <= 0 || c > 0) return l;
    const u = i * o;
    let p = arrayCacheF32[u];
    if (p === void 0 && (p = new Float32Array(u), arrayCacheF32[u] = p), i !== 0) {
        c.toArray(p, 0);
        for (let m = 1, g = 0; m !== i; ++m) g += o, l[m].toArray(p, g)
    }
    return p
}

function arraysEqual(l, i) {
    if (l.length !== i.length) return !1;
    for (let o = 0, c = l.length; o < c; o++)
        if (l[o] !== i[o]) return !1;
    return !0
}

function copyArray(l, i) {
    for (let o = 0, c = i.length; o < c; o++) l[o] = i[o]
}

function allocTexUnits(l, i) {
    let o = arrayCacheI32[i];
    o === void 0 && (o = new Int32Array(i), arrayCacheI32[i] = o);
    for (let c = 0; c !== i; ++c) o[c] = l.allocateTextureUnit();
    return o
}

function setValueV1f(l, i) {
    const o = this.cache;
    o[0] !== i && (l.uniform1f(this.addr, i), o[0] = i)
}

function setValueV2f(l, i) {
    const o = this.cache;
    if (i.x !== void 0)(o[0] !== i.x || o[1] !== i.y) && (l.uniform2f(this.addr, i.x, i.y), o[0] = i.x, o[1] = i.y);
    else {
        if (arraysEqual(o, i)) return;
        l.uniform2fv(this.addr, i), copyArray(o, i)
    }
}

function setValueV3f(l, i) {
    const o = this.cache;
    if (i.x !== void 0)(o[0] !== i.x || o[1] !== i.y || o[2] !== i.z) && (l.uniform3f(this.addr, i.x, i.y, i.z), o[0] = i.x, o[1] = i.y, o[2] = i.z);
    else if (i.r !== void 0)(o[0] !== i.r || o[1] !== i.g || o[2] !== i.b) && (l.uniform3f(this.addr, i.r, i.g, i.b), o[0] = i.r, o[1] = i.g, o[2] = i.b);
    else {
        if (arraysEqual(o, i)) return;
        l.uniform3fv(this.addr, i), copyArray(o, i)
    }
}

function setValueV4f(l, i) {
    const o = this.cache;
    if (i.x !== void 0)(o[0] !== i.x || o[1] !== i.y || o[2] !== i.z || o[3] !== i.w) && (l.uniform4f(this.addr, i.x, i.y, i.z, i.w), o[0] = i.x, o[1] = i.y, o[2] = i.z, o[3] = i.w);
    else {
        if (arraysEqual(o, i)) return;
        l.uniform4fv(this.addr, i), copyArray(o, i)
    }
}

function setValueM2(l, i) {
    const o = this.cache,
        c = i.elements;
    if (c === void 0) {
        if (arraysEqual(o, i)) return;
        l.uniformMatrix2fv(this.addr, !1, i), copyArray(o, i)
    } else {
        if (arraysEqual(o, c)) return;
        mat2array.set(c), l.uniformMatrix2fv(this.addr, !1, mat2array), copyArray(o, c)
    }
}

function setValueM3(l, i) {
    const o = this.cache,
        c = i.elements;
    if (c === void 0) {
        if (arraysEqual(o, i)) return;
        l.uniformMatrix3fv(this.addr, !1, i), copyArray(o, i)
    } else {
        if (arraysEqual(o, c)) return;
        mat3array.set(c), l.uniformMatrix3fv(this.addr, !1, mat3array), copyArray(o, c)
    }
}

function setValueM4(l, i) {
    const o = this.cache,
        c = i.elements;
    if (c === void 0) {
        if (arraysEqual(o, i)) return;
        l.uniformMatrix4fv(this.addr, !1, i), copyArray(o, i)
    } else {
        if (arraysEqual(o, c)) return;
        mat4array.set(c), l.uniformMatrix4fv(this.addr, !1, mat4array), copyArray(o, c)
    }
}

function setValueV1i(l, i) {
    const o = this.cache;
    o[0] !== i && (l.uniform1i(this.addr, i), o[0] = i)
}

function setValueV2i(l, i) {
    const o = this.cache;
    if (i.x !== void 0)(o[0] !== i.x || o[1] !== i.y) && (l.uniform2i(this.addr, i.x, i.y), o[0] = i.x, o[1] = i.y);
    else {
        if (arraysEqual(o, i)) return;
        l.uniform2iv(this.addr, i), copyArray(o, i)
    }
}

function setValueV3i(l, i) {
    const o = this.cache;
    if (i.x !== void 0)(o[0] !== i.x || o[1] !== i.y || o[2] !== i.z) && (l.uniform3i(this.addr, i.x, i.y, i.z), o[0] = i.x, o[1] = i.y, o[2] = i.z);
    else {
        if (arraysEqual(o, i)) return;
        l.uniform3iv(this.addr, i), copyArray(o, i)
    }
}

function setValueV4i(l, i) {
    const o = this.cache;
    if (i.x !== void 0)(o[0] !== i.x || o[1] !== i.y || o[2] !== i.z || o[3] !== i.w) && (l.uniform4i(this.addr, i.x, i.y, i.z, i.w), o[0] = i.x, o[1] = i.y, o[2] = i.z, o[3] = i.w);
    else {
        if (arraysEqual(o, i)) return;
        l.uniform4iv(this.addr, i), copyArray(o, i)
    }
}

function setValueV1ui(l, i) {
    const o = this.cache;
    o[0] !== i && (l.uniform1ui(this.addr, i), o[0] = i)
}

function setValueV2ui(l, i) {
    const o = this.cache;
    if (i.x !== void 0)(o[0] !== i.x || o[1] !== i.y) && (l.uniform2ui(this.addr, i.x, i.y), o[0] = i.x, o[1] = i.y);
    else {
        if (arraysEqual(o, i)) return;
        l.uniform2uiv(this.addr, i), copyArray(o, i)
    }
}

function setValueV3ui(l, i) {
    const o = this.cache;
    if (i.x !== void 0)(o[0] !== i.x || o[1] !== i.y || o[2] !== i.z) && (l.uniform3ui(this.addr, i.x, i.y, i.z), o[0] = i.x, o[1] = i.y, o[2] = i.z);
    else {
        if (arraysEqual(o, i)) return;
        l.uniform3uiv(this.addr, i), copyArray(o, i)
    }
}

function setValueV4ui(l, i) {
    const o = this.cache;
    if (i.x !== void 0)(o[0] !== i.x || o[1] !== i.y || o[2] !== i.z || o[3] !== i.w) && (l.uniform4ui(this.addr, i.x, i.y, i.z, i.w), o[0] = i.x, o[1] = i.y, o[2] = i.z, o[3] = i.w);
    else {
        if (arraysEqual(o, i)) return;
        l.uniform4uiv(this.addr, i), copyArray(o, i)
    }
}

function setValueT1(l, i, o) {
    const c = this.cache,
        u = o.allocateTextureUnit();
    c[0] !== u && (l.uniform1i(this.addr, u), c[0] = u);
    let p;
    this.type === l.SAMPLER_2D_SHADOW ? (emptyShadowTexture.compareFunction = LessEqualCompare, p = emptyShadowTexture) : p = emptyTexture, o.setTexture2D(i || p, u)
}

function setValueT3D1(l, i, o) {
    const c = this.cache,
        u = o.allocateTextureUnit();
    c[0] !== u && (l.uniform1i(this.addr, u), c[0] = u), o.setTexture3D(i || empty3dTexture, u)
}

function setValueT6(l, i, o) {
    const c = this.cache,
        u = o.allocateTextureUnit();
    c[0] !== u && (l.uniform1i(this.addr, u), c[0] = u), o.setTextureCube(i || emptyCubeTexture, u)
}

function setValueT2DArray1(l, i, o) {
    const c = this.cache,
        u = o.allocateTextureUnit();
    c[0] !== u && (l.uniform1i(this.addr, u), c[0] = u), o.setTexture2DArray(i || emptyArrayTexture, u)
}

function getSingularSetter(l) {
    switch (l) {
        case 5126:
            return setValueV1f;
        case 35664:
            return setValueV2f;
        case 35665:
            return setValueV3f;
        case 35666:
            return setValueV4f;
        case 35674:
            return setValueM2;
        case 35675:
            return setValueM3;
        case 35676:
            return setValueM4;
        case 5124:
        case 35670:
            return setValueV1i;
        case 35667:
        case 35671:
            return setValueV2i;
        case 35668:
        case 35672:
            return setValueV3i;
        case 35669:
        case 35673:
            return setValueV4i;
        case 5125:
            return setValueV1ui;
        case 36294:
            return setValueV2ui;
        case 36295:
            return setValueV3ui;
        case 36296:
            return setValueV4ui;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1;
        case 35679:
        case 36299:
        case 36307:
            return setValueT3D1;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return setValueT2DArray1
    }
}

function setValueV1fArray(l, i) {
    l.uniform1fv(this.addr, i)
}

function setValueV2fArray(l, i) {
    const o = flatten(i, this.size, 2);
    l.uniform2fv(this.addr, o)
}

function setValueV3fArray(l, i) {
    const o = flatten(i, this.size, 3);
    l.uniform3fv(this.addr, o)
}

function setValueV4fArray(l, i) {
    const o = flatten(i, this.size, 4);
    l.uniform4fv(this.addr, o)
}

function setValueM2Array(l, i) {
    const o = flatten(i, this.size, 4);
    l.uniformMatrix2fv(this.addr, !1, o)
}

function setValueM3Array(l, i) {
    const o = flatten(i, this.size, 9);
    l.uniformMatrix3fv(this.addr, !1, o)
}

function setValueM4Array(l, i) {
    const o = flatten(i, this.size, 16);
    l.uniformMatrix4fv(this.addr, !1, o)
}

function setValueV1iArray(l, i) {
    l.uniform1iv(this.addr, i)
}

function setValueV2iArray(l, i) {
    l.uniform2iv(this.addr, i)
}

function setValueV3iArray(l, i) {
    l.uniform3iv(this.addr, i)
}

function setValueV4iArray(l, i) {
    l.uniform4iv(this.addr, i)
}

function setValueV1uiArray(l, i) {
    l.uniform1uiv(this.addr, i)
}

function setValueV2uiArray(l, i) {
    l.uniform2uiv(this.addr, i)
}

function setValueV3uiArray(l, i) {
    l.uniform3uiv(this.addr, i)
}

function setValueV4uiArray(l, i) {
    l.uniform4uiv(this.addr, i)
}

function setValueT1Array(l, i, o) {
    const c = this.cache,
        u = i.length,
        p = allocTexUnits(o, u);
    arraysEqual(c, p) || (l.uniform1iv(this.addr, p), copyArray(c, p));
    for (let m = 0; m !== u; ++m) o.setTexture2D(i[m] || emptyTexture, p[m])
}

function setValueT3DArray(l, i, o) {
    const c = this.cache,
        u = i.length,
        p = allocTexUnits(o, u);
    arraysEqual(c, p) || (l.uniform1iv(this.addr, p), copyArray(c, p));
    for (let m = 0; m !== u; ++m) o.setTexture3D(i[m] || empty3dTexture, p[m])
}

function setValueT6Array(l, i, o) {
    const c = this.cache,
        u = i.length,
        p = allocTexUnits(o, u);
    arraysEqual(c, p) || (l.uniform1iv(this.addr, p), copyArray(c, p));
    for (let m = 0; m !== u; ++m) o.setTextureCube(i[m] || emptyCubeTexture, p[m])
}

function setValueT2DArrayArray(l, i, o) {
    const c = this.cache,
        u = i.length,
        p = allocTexUnits(o, u);
    arraysEqual(c, p) || (l.uniform1iv(this.addr, p), copyArray(c, p));
    for (let m = 0; m !== u; ++m) o.setTexture2DArray(i[m] || emptyArrayTexture, p[m])
}

function getPureArraySetter(l) {
    switch (l) {
        case 5126:
            return setValueV1fArray;
        case 35664:
            return setValueV2fArray;
        case 35665:
            return setValueV3fArray;
        case 35666:
            return setValueV4fArray;
        case 35674:
            return setValueM2Array;
        case 35675:
            return setValueM3Array;
        case 35676:
            return setValueM4Array;
        case 5124:
        case 35670:
            return setValueV1iArray;
        case 35667:
        case 35671:
            return setValueV2iArray;
        case 35668:
        case 35672:
            return setValueV3iArray;
        case 35669:
        case 35673:
            return setValueV4iArray;
        case 5125:
            return setValueV1uiArray;
        case 36294:
            return setValueV2uiArray;
        case 36295:
            return setValueV3uiArray;
        case 36296:
            return setValueV4uiArray;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1Array;
        case 35679:
        case 36299:
        case 36307:
            return setValueT3DArray;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6Array;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return setValueT2DArrayArray
    }
}
class SingleUniform {
    constructor(i, o, c) {
        this.id = i, this.addr = c, this.cache = [], this.type = o.type, this.setValue = getSingularSetter(o.type)
    }
}
class PureArrayUniform {
    constructor(i, o, c) {
        this.id = i, this.addr = c, this.cache = [], this.type = o.type, this.size = o.size, this.setValue = getPureArraySetter(o.type)
    }
}
class StructuredUniform {
    constructor(i) {
        this.id = i, this.seq = [], this.map = {}
    }
    setValue(i, o, c) {
        const u = this.seq;
        for (let p = 0, m = u.length; p !== m; ++p) {
            const g = u[p];
            g.setValue(i, o[g.id], c)
        }
    }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;

function addUniform(l, i) {
    l.seq.push(i), l.map[i.id] = i
}

function parseUniform(l, i, o) {
    const c = l.name,
        u = c.length;
    for (RePathPart.lastIndex = 0;;) {
        const p = RePathPart.exec(c),
            m = RePathPart.lastIndex;
        let g = p[1];
        const _ = p[2] === "]",
            v = p[3];
        if (_ && (g = g | 0), v === void 0 || v === "[" && m + 2 === u) {
            addUniform(o, v === void 0 ? new SingleUniform(g, l, i) : new PureArrayUniform(g, l, i));
            break
        } else {
            let y = o.map[g];
            y === void 0 && (y = new StructuredUniform(g), addUniform(o, y)), o = y
        }
    }
}
class WebGLUniforms {
    constructor(i, o) {
        this.seq = [], this.map = {};
        const c = i.getProgramParameter(o, i.ACTIVE_UNIFORMS);
        for (let u = 0; u < c; ++u) {
            const p = i.getActiveUniform(o, u),
                m = i.getUniformLocation(o, p.name);
            parseUniform(p, m, this)
        }
    }
    setValue(i, o, c, u) {
        const p = this.map[o];
        p !== void 0 && p.setValue(i, c, u)
    }
    setOptional(i, o, c) {
        const u = o[c];
        u !== void 0 && this.setValue(i, c, u)
    }
    static upload(i, o, c, u) {
        for (let p = 0, m = o.length; p !== m; ++p) {
            const g = o[p],
                _ = c[g.id];
            _.needsUpdate !== !1 && g.setValue(i, _.value, u)
        }
    }
    static seqWithValue(i, o) {
        const c = [];
        for (let u = 0, p = i.length; u !== p; ++u) {
            const m = i[u];
            m.id in o && c.push(m)
        }
        return c
    }
}

function WebGLShader(l, i, o) {
    const c = l.createShader(i);
    return l.shaderSource(c, o), l.compileShader(c), c
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;

function handleSource(l, i) {
    const o = l.split(`
`),
        c = [],
        u = Math.max(i - 6, 0),
        p = Math.min(i + 6, o.length);
    for (let m = u; m < p; m++) {
        const g = m + 1;
        c.push(`${g===i?">":" "} ${g}: ${o[m]}`)
    }
    return c.join(`
`)
}
const _m0 = new Matrix3;

function getEncodingComponents(l) {
    ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, l);
    const i = `mat3( ${_m0.elements.map(o=>o.toFixed(4))} )`;
    switch (ColorManagement.getTransfer(l)) {
        case LinearTransfer:
            return [i, "LinearTransferOETF"];
        case SRGBTransfer:
            return [i, "sRGBTransferOETF"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported color space: ", l), [i, "LinearTransferOETF"]
    }
}

function getShaderErrors(l, i, o) {
    const c = l.getShaderParameter(i, l.COMPILE_STATUS),
        u = l.getShaderInfoLog(i).trim();
    if (c && u === "") return "";
    const p = /ERROR: 0:(\d+)/.exec(u);
    if (p) {
        const m = parseInt(p[1]);
        return o.toUpperCase() + `

` + u + `

` + handleSource(l.getShaderSource(i), m)
    } else return u
}

function getTexelEncodingFunction(l, i) {
    const o = getEncodingComponents(i);
    return [`vec4 ${l}( vec4 value ) {`, `	return ${o[1]}( vec4( value.rgb * ${o[0]}, value.a ) );`, "}"].join(`
`)
}

function getToneMappingFunction(l, i) {
    let o;
    switch (i) {
        case LinearToneMapping:
            o = "Linear";
            break;
        case ReinhardToneMapping:
            o = "Reinhard";
            break;
        case CineonToneMapping:
            o = "Cineon";
            break;
        case ACESFilmicToneMapping:
            o = "ACESFilmic";
            break;
        case AgXToneMapping:
            o = "AgX";
            break;
        case NeutralToneMapping:
            o = "Neutral";
            break;
        case CustomToneMapping:
            o = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", i), o = "Linear"
    }
    return "vec3 " + l + "( vec3 color ) { return " + o + "ToneMapping( color ); }"
}
const _v0 = new Vector3$1;

function getLuminanceFunction() {
    ColorManagement.getLuminanceCoefficients(_v0);
    const l = _v0.x.toFixed(4),
        i = _v0.y.toFixed(4),
        o = _v0.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${l}, ${i}, ${o} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}

function generateVertexExtensions(l) {
    return [l.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", l.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(filterEmptyLine).join(`
`)
}

function generateDefines(l) {
    const i = [];
    for (const o in l) {
        const c = l[o];
        c !== !1 && i.push("#define " + o + " " + c)
    }
    return i.join(`
`)
}

function fetchAttributeLocations(l, i) {
    const o = {},
        c = l.getProgramParameter(i, l.ACTIVE_ATTRIBUTES);
    for (let u = 0; u < c; u++) {
        const p = l.getActiveAttrib(i, u),
            m = p.name;
        let g = 1;
        p.type === l.FLOAT_MAT2 && (g = 2), p.type === l.FLOAT_MAT3 && (g = 3), p.type === l.FLOAT_MAT4 && (g = 4), o[m] = {
            type: p.type,
            location: l.getAttribLocation(i, m),
            locationSize: g
        }
    }
    return o
}

function filterEmptyLine(l) {
    return l !== ""
}

function replaceLightNums(l, i) {
    const o = i.numSpotLightShadows + i.numSpotLightMaps - i.numSpotLightShadowsWithMaps;
    return l.replace(/NUM_DIR_LIGHTS/g, i.numDirLights).replace(/NUM_SPOT_LIGHTS/g, i.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, i.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, o).replace(/NUM_RECT_AREA_LIGHTS/g, i.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, i.numPointLights).replace(/NUM_HEMI_LIGHTS/g, i.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, i.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, i.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, i.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, i.numPointLightShadows)
}

function replaceClippingPlaneNums(l, i) {
    return l.replace(/NUM_CLIPPING_PLANES/g, i.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, i.numClippingPlanes - i.numClipIntersection)
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes(l) {
    return l.replace(includePattern, includeReplacer)
}
const shaderChunkMap = new Map;

function includeReplacer(l, i) {
    let o = ShaderChunk[i];
    if (o === void 0) {
        const c = shaderChunkMap.get(i);
        if (c !== void 0) o = ShaderChunk[c], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', i, c);
        else throw new Error("Can not resolve #include <" + i + ">")
    }
    return resolveIncludes(o)
}
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops(l) {
    return l.replace(unrollLoopPattern, loopReplacer)
}

function loopReplacer(l, i, o, c) {
    let u = "";
    for (let p = parseInt(i); p < parseInt(o); p++) u += c.replace(/\[\s*i\s*\]/g, "[ " + p + " ]").replace(/UNROLLED_LOOP_INDEX/g, p);
    return u
}

function generatePrecision(l) {
    let i = `precision ${l.precision} float;
	precision ${l.precision} int;
	precision ${l.precision} sampler2D;
	precision ${l.precision} samplerCube;
	precision ${l.precision} sampler3D;
	precision ${l.precision} sampler2DArray;
	precision ${l.precision} sampler2DShadow;
	precision ${l.precision} samplerCubeShadow;
	precision ${l.precision} sampler2DArrayShadow;
	precision ${l.precision} isampler2D;
	precision ${l.precision} isampler3D;
	precision ${l.precision} isamplerCube;
	precision ${l.precision} isampler2DArray;
	precision ${l.precision} usampler2D;
	precision ${l.precision} usampler3D;
	precision ${l.precision} usamplerCube;
	precision ${l.precision} usampler2DArray;
	`;
    return l.precision === "highp" ? i += `
#define HIGH_PRECISION` : l.precision === "mediump" ? i += `
#define MEDIUM_PRECISION` : l.precision === "lowp" && (i += `
#define LOW_PRECISION`), i
}

function generateShadowMapTypeDefine(l) {
    let i = "SHADOWMAP_TYPE_BASIC";
    return l.shadowMapType === PCFShadowMap ? i = "SHADOWMAP_TYPE_PCF" : l.shadowMapType === PCFSoftShadowMap ? i = "SHADOWMAP_TYPE_PCF_SOFT" : l.shadowMapType === VSMShadowMap && (i = "SHADOWMAP_TYPE_VSM"), i
}

function generateEnvMapTypeDefine(l) {
    let i = "ENVMAP_TYPE_CUBE";
    if (l.envMap) switch (l.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            i = "ENVMAP_TYPE_CUBE";
            break;
        case CubeUVReflectionMapping:
            i = "ENVMAP_TYPE_CUBE_UV";
            break
    }
    return i
}

function generateEnvMapModeDefine(l) {
    let i = "ENVMAP_MODE_REFLECTION";
    if (l.envMap) switch (l.envMapMode) {
        case CubeRefractionMapping:
            i = "ENVMAP_MODE_REFRACTION";
            break
    }
    return i
}

function generateEnvMapBlendingDefine(l) {
    let i = "ENVMAP_BLENDING_NONE";
    if (l.envMap) switch (l.combine) {
        case MultiplyOperation:
            i = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case MixOperation:
            i = "ENVMAP_BLENDING_MIX";
            break;
        case AddOperation:
            i = "ENVMAP_BLENDING_ADD";
            break
    }
    return i
}

function generateCubeUVSize(l) {
    const i = l.envMapCubeUVHeight;
    if (i === null) return null;
    const o = Math.log2(i) - 2,
        c = 1 / i;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, o), 7 * 16)),
        texelHeight: c,
        maxMip: o
    }
}

function WebGLProgram(l, i, o, c) {
    const u = l.getContext(),
        p = o.defines;
    let m = o.vertexShader,
        g = o.fragmentShader;
    const _ = generateShadowMapTypeDefine(o),
        v = generateEnvMapTypeDefine(o),
        x = generateEnvMapModeDefine(o),
        y = generateEnvMapBlendingDefine(o),
        b = generateCubeUVSize(o),
        S = generateVertexExtensions(o),
        C = generateDefines(p),
        E = u.createProgram();
    let P, w, T = o.glslVersion ? "#version " + o.glslVersion + `
` : "";
    o.isRawShaderMaterial ? (P = ["#define SHADER_TYPE " + o.shaderType, "#define SHADER_NAME " + o.shaderName, C].filter(filterEmptyLine).join(`
`), P.length > 0 && (P += `
`), w = ["#define SHADER_TYPE " + o.shaderType, "#define SHADER_NAME " + o.shaderName, C].filter(filterEmptyLine).join(`
`), w.length > 0 && (w += `
`)) : (P = [generatePrecision(o), "#define SHADER_TYPE " + o.shaderType, "#define SHADER_NAME " + o.shaderName, C, o.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", o.batching ? "#define USE_BATCHING" : "", o.batchingColor ? "#define USE_BATCHING_COLOR" : "", o.instancing ? "#define USE_INSTANCING" : "", o.instancingColor ? "#define USE_INSTANCING_COLOR" : "", o.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + x : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", o.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", o.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.anisotropy ? "#define USE_ANISOTROPY" : "", o.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", o.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", o.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", o.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", o.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.alphaHash ? "#define USE_ALPHAHASH" : "", o.transmission ? "#define USE_TRANSMISSION" : "", o.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", o.thicknessMap ? "#define USE_THICKNESSMAP" : "", o.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", o.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", o.mapUv ? "#define MAP_UV " + o.mapUv : "", o.alphaMapUv ? "#define ALPHAMAP_UV " + o.alphaMapUv : "", o.lightMapUv ? "#define LIGHTMAP_UV " + o.lightMapUv : "", o.aoMapUv ? "#define AOMAP_UV " + o.aoMapUv : "", o.emissiveMapUv ? "#define EMISSIVEMAP_UV " + o.emissiveMapUv : "", o.bumpMapUv ? "#define BUMPMAP_UV " + o.bumpMapUv : "", o.normalMapUv ? "#define NORMALMAP_UV " + o.normalMapUv : "", o.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + o.displacementMapUv : "", o.metalnessMapUv ? "#define METALNESSMAP_UV " + o.metalnessMapUv : "", o.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + o.roughnessMapUv : "", o.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + o.anisotropyMapUv : "", o.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + o.clearcoatMapUv : "", o.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + o.clearcoatNormalMapUv : "", o.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + o.clearcoatRoughnessMapUv : "", o.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + o.iridescenceMapUv : "", o.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + o.iridescenceThicknessMapUv : "", o.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + o.sheenColorMapUv : "", o.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + o.sheenRoughnessMapUv : "", o.specularMapUv ? "#define SPECULARMAP_UV " + o.specularMapUv : "", o.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + o.specularColorMapUv : "", o.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + o.specularIntensityMapUv : "", o.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + o.transmissionMapUv : "", o.thicknessMapUv ? "#define THICKNESSMAP_UV " + o.thicknessMapUv : "", o.vertexTangents && o.flatShading === !1 ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", o.vertexUv1s ? "#define USE_UV1" : "", o.vertexUv2s ? "#define USE_UV2" : "", o.vertexUv3s ? "#define USE_UV3" : "", o.pointsUvs ? "#define USE_POINTS_UV" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && o.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", o.morphColors ? "#define USE_MORPHCOLORS" : "", o.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + o.morphTextureStride : "", o.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + o.morphTargetsCount : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + _ : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(filterEmptyLine).join(`
`), w = [generatePrecision(o), "#define SHADER_TYPE " + o.shaderType, "#define SHADER_NAME " + o.shaderName, C, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + v : "", o.envMap ? "#define " + x : "", o.envMap ? "#define " + y : "", b ? "#define CUBEUV_TEXEL_WIDTH " + b.texelWidth : "", b ? "#define CUBEUV_TEXEL_HEIGHT " + b.texelHeight : "", b ? "#define CUBEUV_MAX_MIP " + b.maxMip + ".0" : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", o.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.anisotropy ? "#define USE_ANISOTROPY" : "", o.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", o.clearcoat ? "#define USE_CLEARCOAT" : "", o.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", o.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.dispersion ? "#define USE_DISPERSION" : "", o.iridescence ? "#define USE_IRIDESCENCE" : "", o.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", o.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", o.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.alphaTest ? "#define USE_ALPHATEST" : "", o.alphaHash ? "#define USE_ALPHAHASH" : "", o.sheen ? "#define USE_SHEEN" : "", o.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", o.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", o.transmission ? "#define USE_TRANSMISSION" : "", o.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", o.thicknessMap ? "#define USE_THICKNESSMAP" : "", o.vertexTangents && o.flatShading === !1 ? "#define USE_TANGENT" : "", o.vertexColors || o.instancingColor || o.batchingColor ? "#define USE_COLOR" : "", o.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", o.vertexUv1s ? "#define USE_UV1" : "", o.vertexUv2s ? "#define USE_UV2" : "", o.vertexUv3s ? "#define USE_UV3" : "", o.pointsUvs ? "#define USE_POINTS_UV" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + _ : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", o.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", o.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", o.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", o.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", o.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.opaque ? "#define OPAQUE" : "", ShaderChunk.colorspace_pars_fragment, getTexelEncodingFunction("linearToOutputTexel", o.outputColorSpace), getLuminanceFunction(), o.useDepthPacking ? "#define DEPTH_PACKING " + o.depthPacking : "", `
`].filter(filterEmptyLine).join(`
`)), m = resolveIncludes(m), m = replaceLightNums(m, o), m = replaceClippingPlaneNums(m, o), g = resolveIncludes(g), g = replaceLightNums(g, o), g = replaceClippingPlaneNums(g, o), m = unrollLoops(m), g = unrollLoops(g), o.isRawShaderMaterial !== !0 && (T = `#version 300 es
`, P = [S, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + P, w = ["#define varying in", o.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", o.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + w);
    const M = T + P + m,
        A = T + w + g,
        D = WebGLShader(u, u.VERTEX_SHADER, M),
        R = WebGLShader(u, u.FRAGMENT_SHADER, A);
    u.attachShader(E, D), u.attachShader(E, R), o.index0AttributeName !== void 0 ? u.bindAttribLocation(E, 0, o.index0AttributeName) : o.morphTargets === !0 && u.bindAttribLocation(E, 0, "position"), u.linkProgram(E);

    function I(B) {
        if (l.debug.checkShaderErrors) {
            const U = u.getProgramInfoLog(E).trim(),
                H = u.getShaderInfoLog(D).trim(),
                Q = u.getShaderInfoLog(R).trim();
            let Y = !0,
                O = !0;
            if (u.getProgramParameter(E, u.LINK_STATUS) === !1)
                if (Y = !1, typeof l.debug.onShaderError == "function") l.debug.onShaderError(u, E, D, R);
                else {
                    const G = getShaderErrors(u, D, "vertex"),
                        L = getShaderErrors(u, R, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + u.getError() + " - VALIDATE_STATUS " + u.getProgramParameter(E, u.VALIDATE_STATUS) + `

Material Name: ` + B.name + `
Material Type: ` + B.type + `

Program Info Log: ` + U + `
` + G + `
` + L)
                }
            else U !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", U) : (H === "" || Q === "") && (O = !1);
            O && (B.diagnostics = {
                runnable: Y,
                programLog: U,
                vertexShader: {
                    log: H,
                    prefix: P
                },
                fragmentShader: {
                    log: Q,
                    prefix: w
                }
            })
        }
        u.deleteShader(D), u.deleteShader(R), k = new WebGLUniforms(u, E), F = fetchAttributeLocations(u, E)
    }
    let k;
    this.getUniforms = function() {
        return k === void 0 && I(this), k
    };
    let F;
    this.getAttributes = function() {
        return F === void 0 && I(this), F
    };
    let V = o.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return V === !1 && (V = u.getProgramParameter(E, COMPLETION_STATUS_KHR)), V
    }, this.destroy = function() {
        c.releaseStatesOfProgram(this), u.deleteProgram(E), this.program = void 0
    }, this.type = o.shaderType, this.name = o.shaderName, this.id = programIdCount++, this.cacheKey = i, this.usedTimes = 1, this.program = E, this.vertexShader = D, this.fragmentShader = R, this
}
let _id = 0;
class WebGLShaderCache {
    constructor() {
        this.shaderCache = new Map, this.materialCache = new Map
    }
    update(i) {
        const o = i.vertexShader,
            c = i.fragmentShader,
            u = this._getShaderStage(o),
            p = this._getShaderStage(c),
            m = this._getShaderCacheForMaterial(i);
        return m.has(u) === !1 && (m.add(u), u.usedTimes++), m.has(p) === !1 && (m.add(p), p.usedTimes++), this
    }
    remove(i) {
        const o = this.materialCache.get(i);
        for (const c of o) c.usedTimes--, c.usedTimes === 0 && this.shaderCache.delete(c.code);
        return this.materialCache.delete(i), this
    }
    getVertexShaderID(i) {
        return this._getShaderStage(i.vertexShader).id
    }
    getFragmentShaderID(i) {
        return this._getShaderStage(i.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear()
    }
    _getShaderCacheForMaterial(i) {
        const o = this.materialCache;
        let c = o.get(i);
        return c === void 0 && (c = new Set, o.set(i, c)), c
    }
    _getShaderStage(i) {
        const o = this.shaderCache;
        let c = o.get(i);
        return c === void 0 && (c = new WebGLShaderStage(i), o.set(i, c)), c
    }
}
class WebGLShaderStage {
    constructor(i) {
        this.id = _id++, this.code = i, this.usedTimes = 0
    }
}

function WebGLPrograms(l, i, o, c, u, p, m) {
    const g = new Layers,
        _ = new WebGLShaderCache,
        v = new Set,
        x = [],
        y = u.logarithmicDepthBuffer,
        b = u.vertexTextures;
    let S = u.precision;
    const C = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };

    function E(F) {
        return v.add(F), F === 0 ? "uv" : `uv${F}`
    }

    function P(F, V, B, U, H) {
        const Q = U.fog,
            Y = H.geometry,
            O = F.isMeshStandardMaterial ? U.environment : null,
            G = (F.isMeshStandardMaterial ? o : i).get(F.envMap || O),
            L = G && G.mapping === CubeUVReflectionMapping ? G.image.height : null,
            N = C[F.type];
        F.precision !== null && (S = u.getMaxPrecision(F.precision), S !== F.precision && console.warn("THREE.WebGLProgram.getParameters:", F.precision, "not supported, using", S, "instead."));
        const K = Y.morphAttributes.position || Y.morphAttributes.normal || Y.morphAttributes.color,
            Z = K !== void 0 ? K.length : 0;
        let he = 0;
        Y.morphAttributes.position !== void 0 && (he = 1), Y.morphAttributes.normal !== void 0 && (he = 2), Y.morphAttributes.color !== void 0 && (he = 3);
        let we, ie, _e, Te;
        if (N) {
            const It = ShaderLib[N];
            we = It.vertexShader, ie = It.fragmentShader
        } else we = F.vertexShader, ie = F.fragmentShader, _.update(F), _e = _.getVertexShaderID(F), Te = _.getFragmentShaderID(F);
        const Me = l.getRenderTarget(),
            Pe = l.state.buffers.depth.getReversed(),
            be = H.isInstancedMesh === !0,
            Be = H.isBatchedMesh === !0,
            De = !!F.map,
            We = !!F.matcap,
            Re = !!G,
            q = !!F.aoMap,
            At = !!F.lightMap,
            dt = !!F.bumpMap,
            tt = !!F.normalMap,
            ke = !!F.displacementMap,
            ot = !!F.emissiveMap,
            ze = !!F.metalnessMap,
            Ie = !!F.roughnessMap,
            Dt = F.anisotropy > 0,
            J = F.clearcoat > 0,
            $ = F.dispersion > 0,
            ae = F.iridescence > 0,
            ge = F.sheen > 0,
            ye = F.transmission > 0,
            fe = Dt && !!F.anisotropyMap,
            Ke = J && !!F.clearcoatMap,
            Le = J && !!F.clearcoatNormalMap,
            Oe = J && !!F.clearcoatRoughnessMap,
            Ze = ae && !!F.iridescenceMap,
            Se = ae && !!F.iridescenceThicknessMap,
            qe = ge && !!F.sheenColorMap,
            Je = ge && !!F.sheenRoughnessMap,
            it = !!F.specularMap,
            Fe = !!F.specularColorMap,
            ct = !!F.specularIntensityMap,
            te = ye && !!F.transmissionMap,
            Ve = ye && !!F.thicknessMap,
            Ce = !!F.gradientMap,
            Xe = !!F.alphaMap,
            Ee = F.alphaTest > 0,
            ve = !!F.alphaHash,
            Ye = !!F.extensions;
        let et = NoToneMapping;
        F.toneMapped && (Me === null || Me.isXRRenderTarget === !0) && (et = l.toneMapping);
        const kt = {
            shaderID: N,
            shaderType: F.type,
            shaderName: F.name,
            vertexShader: we,
            fragmentShader: ie,
            defines: F.defines,
            customVertexShaderID: _e,
            customFragmentShaderID: Te,
            isRawShaderMaterial: F.isRawShaderMaterial === !0,
            glslVersion: F.glslVersion,
            precision: S,
            batching: Be,
            batchingColor: Be && H._colorsTexture !== null,
            instancing: be,
            instancingColor: be && H.instanceColor !== null,
            instancingMorph: be && H.morphTexture !== null,
            supportsVertexTextures: b,
            outputColorSpace: Me === null ? l.outputColorSpace : Me.isXRRenderTarget === !0 ? Me.texture.colorSpace : LinearSRGBColorSpace,
            alphaToCoverage: !!F.alphaToCoverage,
            map: De,
            matcap: We,
            envMap: Re,
            envMapMode: Re && G.mapping,
            envMapCubeUVHeight: L,
            aoMap: q,
            lightMap: At,
            bumpMap: dt,
            normalMap: tt,
            displacementMap: b && ke,
            emissiveMap: ot,
            normalMapObjectSpace: tt && F.normalMapType === ObjectSpaceNormalMap,
            normalMapTangentSpace: tt && F.normalMapType === TangentSpaceNormalMap,
            metalnessMap: ze,
            roughnessMap: Ie,
            anisotropy: Dt,
            anisotropyMap: fe,
            clearcoat: J,
            clearcoatMap: Ke,
            clearcoatNormalMap: Le,
            clearcoatRoughnessMap: Oe,
            dispersion: $,
            iridescence: ae,
            iridescenceMap: Ze,
            iridescenceThicknessMap: Se,
            sheen: ge,
            sheenColorMap: qe,
            sheenRoughnessMap: Je,
            specularMap: it,
            specularColorMap: Fe,
            specularIntensityMap: ct,
            transmission: ye,
            transmissionMap: te,
            thicknessMap: Ve,
            gradientMap: Ce,
            opaque: F.transparent === !1 && F.blending === NormalBlending && F.alphaToCoverage === !1,
            alphaMap: Xe,
            alphaTest: Ee,
            alphaHash: ve,
            combine: F.combine,
            mapUv: De && E(F.map.channel),
            aoMapUv: q && E(F.aoMap.channel),
            lightMapUv: At && E(F.lightMap.channel),
            bumpMapUv: dt && E(F.bumpMap.channel),
            normalMapUv: tt && E(F.normalMap.channel),
            displacementMapUv: ke && E(F.displacementMap.channel),
            emissiveMapUv: ot && E(F.emissiveMap.channel),
            metalnessMapUv: ze && E(F.metalnessMap.channel),
            roughnessMapUv: Ie && E(F.roughnessMap.channel),
            anisotropyMapUv: fe && E(F.anisotropyMap.channel),
            clearcoatMapUv: Ke && E(F.clearcoatMap.channel),
            clearcoatNormalMapUv: Le && E(F.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Oe && E(F.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Ze && E(F.iridescenceMap.channel),
            iridescenceThicknessMapUv: Se && E(F.iridescenceThicknessMap.channel),
            sheenColorMapUv: qe && E(F.sheenColorMap.channel),
            sheenRoughnessMapUv: Je && E(F.sheenRoughnessMap.channel),
            specularMapUv: it && E(F.specularMap.channel),
            specularColorMapUv: Fe && E(F.specularColorMap.channel),
            specularIntensityMapUv: ct && E(F.specularIntensityMap.channel),
            transmissionMapUv: te && E(F.transmissionMap.channel),
            thicknessMapUv: Ve && E(F.thicknessMap.channel),
            alphaMapUv: Xe && E(F.alphaMap.channel),
            vertexTangents: !!Y.attributes.tangent && (tt || Dt),
            vertexColors: F.vertexColors,
            vertexAlphas: F.vertexColors === !0 && !!Y.attributes.color && Y.attributes.color.itemSize === 4,
            pointsUvs: H.isPoints === !0 && !!Y.attributes.uv && (De || Xe),
            fog: !!Q,
            useFog: F.fog === !0,
            fogExp2: !!Q && Q.isFogExp2,
            flatShading: F.flatShading === !0,
            sizeAttenuation: F.sizeAttenuation === !0,
            logarithmicDepthBuffer: y,
            reverseDepthBuffer: Pe,
            skinning: H.isSkinnedMesh === !0,
            morphTargets: Y.morphAttributes.position !== void 0,
            morphNormals: Y.morphAttributes.normal !== void 0,
            morphColors: Y.morphAttributes.color !== void 0,
            morphTargetsCount: Z,
            morphTextureStride: he,
            numDirLights: V.directional.length,
            numPointLights: V.point.length,
            numSpotLights: V.spot.length,
            numSpotLightMaps: V.spotLightMap.length,
            numRectAreaLights: V.rectArea.length,
            numHemiLights: V.hemi.length,
            numDirLightShadows: V.directionalShadowMap.length,
            numPointLightShadows: V.pointShadowMap.length,
            numSpotLightShadows: V.spotShadowMap.length,
            numSpotLightShadowsWithMaps: V.numSpotLightShadowsWithMaps,
            numLightProbes: V.numLightProbes,
            numClippingPlanes: m.numPlanes,
            numClipIntersection: m.numIntersection,
            dithering: F.dithering,
            shadowMapEnabled: l.shadowMap.enabled && B.length > 0,
            shadowMapType: l.shadowMap.type,
            toneMapping: et,
            decodeVideoTexture: De && F.map.isVideoTexture === !0 && ColorManagement.getTransfer(F.map.colorSpace) === SRGBTransfer,
            decodeVideoTextureEmissive: ot && F.emissiveMap.isVideoTexture === !0 && ColorManagement.getTransfer(F.emissiveMap.colorSpace) === SRGBTransfer,
            premultipliedAlpha: F.premultipliedAlpha,
            doubleSided: F.side === DoubleSide,
            flipSided: F.side === BackSide,
            useDepthPacking: F.depthPacking >= 0,
            depthPacking: F.depthPacking || 0,
            index0AttributeName: F.index0AttributeName,
            extensionClipCullDistance: Ye && F.extensions.clipCullDistance === !0 && c.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Ye && F.extensions.multiDraw === !0 || Be) && c.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: c.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: F.customProgramCacheKey()
        };
        return kt.vertexUv1s = v.has(1), kt.vertexUv2s = v.has(2), kt.vertexUv3s = v.has(3), v.clear(), kt
    }

    function w(F) {
        const V = [];
        if (F.shaderID ? V.push(F.shaderID) : (V.push(F.customVertexShaderID), V.push(F.customFragmentShaderID)), F.defines !== void 0)
            for (const B in F.defines) V.push(B), V.push(F.defines[B]);
        return F.isRawShaderMaterial === !1 && (T(V, F), M(V, F), V.push(l.outputColorSpace)), V.push(F.customProgramCacheKey), V.join()
    }

    function T(F, V) {
        F.push(V.precision), F.push(V.outputColorSpace), F.push(V.envMapMode), F.push(V.envMapCubeUVHeight), F.push(V.mapUv), F.push(V.alphaMapUv), F.push(V.lightMapUv), F.push(V.aoMapUv), F.push(V.bumpMapUv), F.push(V.normalMapUv), F.push(V.displacementMapUv), F.push(V.emissiveMapUv), F.push(V.metalnessMapUv), F.push(V.roughnessMapUv), F.push(V.anisotropyMapUv), F.push(V.clearcoatMapUv), F.push(V.clearcoatNormalMapUv), F.push(V.clearcoatRoughnessMapUv), F.push(V.iridescenceMapUv), F.push(V.iridescenceThicknessMapUv), F.push(V.sheenColorMapUv), F.push(V.sheenRoughnessMapUv), F.push(V.specularMapUv), F.push(V.specularColorMapUv), F.push(V.specularIntensityMapUv), F.push(V.transmissionMapUv), F.push(V.thicknessMapUv), F.push(V.combine), F.push(V.fogExp2), F.push(V.sizeAttenuation), F.push(V.morphTargetsCount), F.push(V.morphAttributeCount), F.push(V.numDirLights), F.push(V.numPointLights), F.push(V.numSpotLights), F.push(V.numSpotLightMaps), F.push(V.numHemiLights), F.push(V.numRectAreaLights), F.push(V.numDirLightShadows), F.push(V.numPointLightShadows), F.push(V.numSpotLightShadows), F.push(V.numSpotLightShadowsWithMaps), F.push(V.numLightProbes), F.push(V.shadowMapType), F.push(V.toneMapping), F.push(V.numClippingPlanes), F.push(V.numClipIntersection), F.push(V.depthPacking)
    }

    function M(F, V) {
        g.disableAll(), V.supportsVertexTextures && g.enable(0), V.instancing && g.enable(1), V.instancingColor && g.enable(2), V.instancingMorph && g.enable(3), V.matcap && g.enable(4), V.envMap && g.enable(5), V.normalMapObjectSpace && g.enable(6), V.normalMapTangentSpace && g.enable(7), V.clearcoat && g.enable(8), V.iridescence && g.enable(9), V.alphaTest && g.enable(10), V.vertexColors && g.enable(11), V.vertexAlphas && g.enable(12), V.vertexUv1s && g.enable(13), V.vertexUv2s && g.enable(14), V.vertexUv3s && g.enable(15), V.vertexTangents && g.enable(16), V.anisotropy && g.enable(17), V.alphaHash && g.enable(18), V.batching && g.enable(19), V.dispersion && g.enable(20), V.batchingColor && g.enable(21), F.push(g.mask), g.disableAll(), V.fog && g.enable(0), V.useFog && g.enable(1), V.flatShading && g.enable(2), V.logarithmicDepthBuffer && g.enable(3), V.reverseDepthBuffer && g.enable(4), V.skinning && g.enable(5), V.morphTargets && g.enable(6), V.morphNormals && g.enable(7), V.morphColors && g.enable(8), V.premultipliedAlpha && g.enable(9), V.shadowMapEnabled && g.enable(10), V.doubleSided && g.enable(11), V.flipSided && g.enable(12), V.useDepthPacking && g.enable(13), V.dithering && g.enable(14), V.transmission && g.enable(15), V.sheen && g.enable(16), V.opaque && g.enable(17), V.pointsUvs && g.enable(18), V.decodeVideoTexture && g.enable(19), V.decodeVideoTextureEmissive && g.enable(20), V.alphaToCoverage && g.enable(21), F.push(g.mask)
    }

    function A(F) {
        const V = C[F.type];
        let B;
        if (V) {
            const U = ShaderLib[V];
            B = UniformsUtils.clone(U.uniforms)
        } else B = F.uniforms;
        return B
    }

    function D(F, V) {
        let B;
        for (let U = 0, H = x.length; U < H; U++) {
            const Q = x[U];
            if (Q.cacheKey === V) {
                B = Q, ++B.usedTimes;
                break
            }
        }
        return B === void 0 && (B = new WebGLProgram(l, V, F, p), x.push(B)), B
    }

    function R(F) {
        if (--F.usedTimes === 0) {
            const V = x.indexOf(F);
            x[V] = x[x.length - 1], x.pop(), F.destroy()
        }
    }

    function I(F) {
        _.remove(F)
    }

    function k() {
        _.dispose()
    }
    return {
        getParameters: P,
        getProgramCacheKey: w,
        getUniforms: A,
        acquireProgram: D,
        releaseProgram: R,
        releaseShaderCache: I,
        programs: x,
        dispose: k
    }
}

function WebGLProperties() {
    let l = new WeakMap;

    function i(m) {
        return l.has(m)
    }

    function o(m) {
        let g = l.get(m);
        return g === void 0 && (g = {}, l.set(m, g)), g
    }

    function c(m) {
        l.delete(m)
    }

    function u(m, g, _) {
        l.get(m)[g] = _
    }

    function p() {
        l = new WeakMap
    }
    return {
        has: i,
        get: o,
        remove: c,
        update: u,
        dispose: p
    }
}

function painterSortStable(l, i) {
    return l.groupOrder !== i.groupOrder ? l.groupOrder - i.groupOrder : l.renderOrder !== i.renderOrder ? l.renderOrder - i.renderOrder : l.material.id !== i.material.id ? l.material.id - i.material.id : l.z !== i.z ? l.z - i.z : l.id - i.id
}

function reversePainterSortStable(l, i) {
    return l.groupOrder !== i.groupOrder ? l.groupOrder - i.groupOrder : l.renderOrder !== i.renderOrder ? l.renderOrder - i.renderOrder : l.z !== i.z ? i.z - l.z : l.id - i.id
}

function WebGLRenderList() {
    const l = [];
    let i = 0;
    const o = [],
        c = [],
        u = [];

    function p() {
        i = 0, o.length = 0, c.length = 0, u.length = 0
    }

    function m(y, b, S, C, E, P) {
        let w = l[i];
        return w === void 0 ? (w = {
            id: y.id,
            object: y,
            geometry: b,
            material: S,
            groupOrder: C,
            renderOrder: y.renderOrder,
            z: E,
            group: P
        }, l[i] = w) : (w.id = y.id, w.object = y, w.geometry = b, w.material = S, w.groupOrder = C, w.renderOrder = y.renderOrder, w.z = E, w.group = P), i++, w
    }

    function g(y, b, S, C, E, P) {
        const w = m(y, b, S, C, E, P);
        S.transmission > 0 ? c.push(w) : S.transparent === !0 ? u.push(w) : o.push(w)
    }

    function _(y, b, S, C, E, P) {
        const w = m(y, b, S, C, E, P);
        S.transmission > 0 ? c.unshift(w) : S.transparent === !0 ? u.unshift(w) : o.unshift(w)
    }

    function v(y, b) {
        o.length > 1 && o.sort(y || painterSortStable), c.length > 1 && c.sort(b || reversePainterSortStable), u.length > 1 && u.sort(b || reversePainterSortStable)
    }

    function x() {
        for (let y = i, b = l.length; y < b; y++) {
            const S = l[y];
            if (S.id === null) break;
            S.id = null, S.object = null, S.geometry = null, S.material = null, S.group = null
        }
    }
    return {
        opaque: o,
        transmissive: c,
        transparent: u,
        init: p,
        push: g,
        unshift: _,
        finish: x,
        sort: v
    }
}

function WebGLRenderLists() {
    let l = new WeakMap;

    function i(c, u) {
        const p = l.get(c);
        let m;
        return p === void 0 ? (m = new WebGLRenderList, l.set(c, [m])) : u >= p.length ? (m = new WebGLRenderList, p.push(m)) : m = p[u], m
    }

    function o() {
        l = new WeakMap
    }
    return {
        get: i,
        dispose: o
    }
}

function UniformsCache() {
    const l = {};
    return {
        get: function(i) {
            if (l[i.id] !== void 0) return l[i.id];
            let o;
            switch (i.type) {
                case "DirectionalLight":
                    o = {
                        direction: new Vector3$1,
                        color: new Color
                    };
                    break;
                case "SpotLight":
                    o = {
                        position: new Vector3$1,
                        direction: new Vector3$1,
                        color: new Color,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    o = {
                        position: new Vector3$1,
                        color: new Color,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    o = {
                        direction: new Vector3$1,
                        skyColor: new Color,
                        groundColor: new Color
                    };
                    break;
                case "RectAreaLight":
                    o = {
                        color: new Color,
                        position: new Vector3$1,
                        halfWidth: new Vector3$1,
                        halfHeight: new Vector3$1
                    };
                    break
            }
            return l[i.id] = o, o
        }
    }
}

function ShadowUniformsCache() {
    const l = {};
    return {
        get: function(i) {
            if (l[i.id] !== void 0) return l[i.id];
            let o;
            switch (i.type) {
                case "DirectionalLight":
                    o = {
                        shadowIntensity: 1,
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2
                    };
                    break;
                case "SpotLight":
                    o = {
                        shadowIntensity: 1,
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2
                    };
                    break;
                case "PointLight":
                    o = {
                        shadowIntensity: 1,
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break
            }
            return l[i.id] = o, o
        }
    }
}
let nextVersion = 0;

function shadowCastingAndTexturingLightsFirst(l, i) {
    return (i.castShadow ? 2 : 0) - (l.castShadow ? 2 : 0) + (i.map ? 1 : 0) - (l.map ? 1 : 0)
}

function WebGLLights(l) {
    const i = new UniformsCache,
        o = ShadowUniformsCache(),
        c = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
    for (let v = 0; v < 9; v++) c.probe.push(new Vector3$1);
    const u = new Vector3$1,
        p = new Matrix4,
        m = new Matrix4;

    function g(v) {
        let x = 0,
            y = 0,
            b = 0;
        for (let F = 0; F < 9; F++) c.probe[F].set(0, 0, 0);
        let S = 0,
            C = 0,
            E = 0,
            P = 0,
            w = 0,
            T = 0,
            M = 0,
            A = 0,
            D = 0,
            R = 0,
            I = 0;
        v.sort(shadowCastingAndTexturingLightsFirst);
        for (let F = 0, V = v.length; F < V; F++) {
            const B = v[F],
                U = B.color,
                H = B.intensity,
                Q = B.distance,
                Y = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
            if (B.isAmbientLight) x += U.r * H, y += U.g * H, b += U.b * H;
            else if (B.isLightProbe) {
                for (let O = 0; O < 9; O++) c.probe[O].addScaledVector(B.sh.coefficients[O], H);
                I++
            } else if (B.isDirectionalLight) {
                const O = i.get(B);
                if (O.color.copy(B.color).multiplyScalar(B.intensity), B.castShadow) {
                    const G = B.shadow,
                        L = o.get(B);
                    L.shadowIntensity = G.intensity, L.shadowBias = G.bias, L.shadowNormalBias = G.normalBias, L.shadowRadius = G.radius, L.shadowMapSize = G.mapSize, c.directionalShadow[S] = L, c.directionalShadowMap[S] = Y, c.directionalShadowMatrix[S] = B.shadow.matrix, T++
                }
                c.directional[S] = O, S++
            } else if (B.isSpotLight) {
                const O = i.get(B);
                O.position.setFromMatrixPosition(B.matrixWorld), O.color.copy(U).multiplyScalar(H), O.distance = Q, O.coneCos = Math.cos(B.angle), O.penumbraCos = Math.cos(B.angle * (1 - B.penumbra)), O.decay = B.decay, c.spot[E] = O;
                const G = B.shadow;
                if (B.map && (c.spotLightMap[D] = B.map, D++, G.updateMatrices(B), B.castShadow && R++), c.spotLightMatrix[E] = G.matrix, B.castShadow) {
                    const L = o.get(B);
                    L.shadowIntensity = G.intensity, L.shadowBias = G.bias, L.shadowNormalBias = G.normalBias, L.shadowRadius = G.radius, L.shadowMapSize = G.mapSize, c.spotShadow[E] = L, c.spotShadowMap[E] = Y, A++
                }
                E++
            } else if (B.isRectAreaLight) {
                const O = i.get(B);
                O.color.copy(U).multiplyScalar(H), O.halfWidth.set(B.width * .5, 0, 0), O.halfHeight.set(0, B.height * .5, 0), c.rectArea[P] = O, P++
            } else if (B.isPointLight) {
                const O = i.get(B);
                if (O.color.copy(B.color).multiplyScalar(B.intensity), O.distance = B.distance, O.decay = B.decay, B.castShadow) {
                    const G = B.shadow,
                        L = o.get(B);
                    L.shadowIntensity = G.intensity, L.shadowBias = G.bias, L.shadowNormalBias = G.normalBias, L.shadowRadius = G.radius, L.shadowMapSize = G.mapSize, L.shadowCameraNear = G.camera.near, L.shadowCameraFar = G.camera.far, c.pointShadow[C] = L, c.pointShadowMap[C] = Y, c.pointShadowMatrix[C] = B.shadow.matrix, M++
                }
                c.point[C] = O, C++
            } else if (B.isHemisphereLight) {
                const O = i.get(B);
                O.skyColor.copy(B.color).multiplyScalar(H), O.groundColor.copy(B.groundColor).multiplyScalar(H), c.hemi[w] = O, w++
            }
        }
        P > 0 && (l.has("OES_texture_float_linear") === !0 ? (c.rectAreaLTC1 = UniformsLib$1.LTC_FLOAT_1, c.rectAreaLTC2 = UniformsLib$1.LTC_FLOAT_2) : (c.rectAreaLTC1 = UniformsLib$1.LTC_HALF_1, c.rectAreaLTC2 = UniformsLib$1.LTC_HALF_2)), c.ambient[0] = x, c.ambient[1] = y, c.ambient[2] = b;
        const k = c.hash;
        (k.directionalLength !== S || k.pointLength !== C || k.spotLength !== E || k.rectAreaLength !== P || k.hemiLength !== w || k.numDirectionalShadows !== T || k.numPointShadows !== M || k.numSpotShadows !== A || k.numSpotMaps !== D || k.numLightProbes !== I) && (c.directional.length = S, c.spot.length = E, c.rectArea.length = P, c.point.length = C, c.hemi.length = w, c.directionalShadow.length = T, c.directionalShadowMap.length = T, c.pointShadow.length = M, c.pointShadowMap.length = M, c.spotShadow.length = A, c.spotShadowMap.length = A, c.directionalShadowMatrix.length = T, c.pointShadowMatrix.length = M, c.spotLightMatrix.length = A + D - R, c.spotLightMap.length = D, c.numSpotLightShadowsWithMaps = R, c.numLightProbes = I, k.directionalLength = S, k.pointLength = C, k.spotLength = E, k.rectAreaLength = P, k.hemiLength = w, k.numDirectionalShadows = T, k.numPointShadows = M, k.numSpotShadows = A, k.numSpotMaps = D, k.numLightProbes = I, c.version = nextVersion++)
    }

    function _(v, x) {
        let y = 0,
            b = 0,
            S = 0,
            C = 0,
            E = 0;
        const P = x.matrixWorldInverse;
        for (let w = 0, T = v.length; w < T; w++) {
            const M = v[w];
            if (M.isDirectionalLight) {
                const A = c.directional[y];
                A.direction.setFromMatrixPosition(M.matrixWorld), u.setFromMatrixPosition(M.target.matrixWorld), A.direction.sub(u), A.direction.transformDirection(P), y++
            } else if (M.isSpotLight) {
                const A = c.spot[S];
                A.position.setFromMatrixPosition(M.matrixWorld), A.position.applyMatrix4(P), A.direction.setFromMatrixPosition(M.matrixWorld), u.setFromMatrixPosition(M.target.matrixWorld), A.direction.sub(u), A.direction.transformDirection(P), S++
            } else if (M.isRectAreaLight) {
                const A = c.rectArea[C];
                A.position.setFromMatrixPosition(M.matrixWorld), A.position.applyMatrix4(P), m.identity(), p.copy(M.matrixWorld), p.premultiply(P), m.extractRotation(p), A.halfWidth.set(M.width * .5, 0, 0), A.halfHeight.set(0, M.height * .5, 0), A.halfWidth.applyMatrix4(m), A.halfHeight.applyMatrix4(m), C++
            } else if (M.isPointLight) {
                const A = c.point[b];
                A.position.setFromMatrixPosition(M.matrixWorld), A.position.applyMatrix4(P), b++
            } else if (M.isHemisphereLight) {
                const A = c.hemi[E];
                A.direction.setFromMatrixPosition(M.matrixWorld), A.direction.transformDirection(P), E++
            }
        }
    }
    return {
        setup: g,
        setupView: _,
        state: c
    }
}

function WebGLRenderState(l) {
    const i = new WebGLLights(l),
        o = [],
        c = [];

    function u(x) {
        v.camera = x, o.length = 0, c.length = 0
    }

    function p(x) {
        o.push(x)
    }

    function m(x) {
        c.push(x)
    }

    function g() {
        i.setup(o)
    }

    function _(x) {
        i.setupView(o, x)
    }
    const v = {
        lightsArray: o,
        shadowsArray: c,
        camera: null,
        lights: i,
        transmissionRenderTarget: {}
    };
    return {
        init: u,
        state: v,
        setupLights: g,
        setupLightsView: _,
        pushLight: p,
        pushShadow: m
    }
}

function WebGLRenderStates(l) {
    let i = new WeakMap;

    function o(u, p = 0) {
        const m = i.get(u);
        let g;
        return m === void 0 ? (g = new WebGLRenderState(l), i.set(u, [g])) : p >= m.length ? (g = new WebGLRenderState(l), m.push(g)) : g = m[p], g
    }

    function c() {
        i = new WeakMap
    }
    return {
        get: o,
        dispose: c
    }
}
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function WebGLShadowMap(l, i, o) {
    let c = new Frustum;
    const u = new Vector2,
        p = new Vector2,
        m = new Vector4,
        g = new MeshDepthMaterial({
            depthPacking: RGBADepthPacking
        }),
        _ = new MeshDistanceMaterial,
        v = {},
        x = o.maxTextureSize,
        y = {
            [FrontSide]: BackSide,
            [BackSide]: FrontSide,
            [DoubleSide]: DoubleSide
        },
        b = new ShaderMaterial({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Vector2
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: vertex,
            fragmentShader: fragment
        }),
        S = b.clone();
    S.defines.HORIZONTAL_PASS = 1;
    const C = new BufferGeometry;
    C.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const E = new Mesh(C, b),
        P = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap;
    let w = this.type;
    this.render = function(R, I, k) {
        if (P.enabled === !1 || P.autoUpdate === !1 && P.needsUpdate === !1 || R.length === 0) return;
        const F = l.getRenderTarget(),
            V = l.getActiveCubeFace(),
            B = l.getActiveMipmapLevel(),
            U = l.state;
        U.setBlending(NoBlending), U.buffers.color.setClear(1, 1, 1, 1), U.buffers.depth.setTest(!0), U.setScissorTest(!1);
        const H = w !== VSMShadowMap && this.type === VSMShadowMap,
            Q = w === VSMShadowMap && this.type !== VSMShadowMap;
        for (let Y = 0, O = R.length; Y < O; Y++) {
            const G = R[Y],
                L = G.shadow;
            if (L === void 0) {
                console.warn("THREE.WebGLShadowMap:", G, "has no shadow.");
                continue
            }
            if (L.autoUpdate === !1 && L.needsUpdate === !1) continue;
            u.copy(L.mapSize);
            const N = L.getFrameExtents();
            if (u.multiply(N), p.copy(L.mapSize), (u.x > x || u.y > x) && (u.x > x && (p.x = Math.floor(x / N.x), u.x = p.x * N.x, L.mapSize.x = p.x), u.y > x && (p.y = Math.floor(x / N.y), u.y = p.y * N.y, L.mapSize.y = p.y)), L.map === null || H === !0 || Q === !0) {
                const Z = this.type !== VSMShadowMap ? {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter
                } : {};
                L.map !== null && L.map.dispose(), L.map = new WebGLRenderTarget(u.x, u.y, Z), L.map.texture.name = G.name + ".shadowMap", L.camera.updateProjectionMatrix()
            }
            l.setRenderTarget(L.map), l.clear();
            const K = L.getViewportCount();
            for (let Z = 0; Z < K; Z++) {
                const he = L.getViewport(Z);
                m.set(p.x * he.x, p.y * he.y, p.x * he.z, p.y * he.w), U.viewport(m), L.updateMatrices(G, Z), c = L.getFrustum(), A(I, k, L.camera, G, this.type)
            }
            L.isPointLightShadow !== !0 && this.type === VSMShadowMap && T(L, k), L.needsUpdate = !1
        }
        w = this.type, P.needsUpdate = !1, l.setRenderTarget(F, V, B)
    };

    function T(R, I) {
        const k = i.update(E);
        b.defines.VSM_SAMPLES !== R.blurSamples && (b.defines.VSM_SAMPLES = R.blurSamples, S.defines.VSM_SAMPLES = R.blurSamples, b.needsUpdate = !0, S.needsUpdate = !0), R.mapPass === null && (R.mapPass = new WebGLRenderTarget(u.x, u.y)), b.uniforms.shadow_pass.value = R.map.texture, b.uniforms.resolution.value = R.mapSize, b.uniforms.radius.value = R.radius, l.setRenderTarget(R.mapPass), l.clear(), l.renderBufferDirect(I, null, k, b, E, null), S.uniforms.shadow_pass.value = R.mapPass.texture, S.uniforms.resolution.value = R.mapSize, S.uniforms.radius.value = R.radius, l.setRenderTarget(R.map), l.clear(), l.renderBufferDirect(I, null, k, S, E, null)
    }

    function M(R, I, k, F) {
        let V = null;
        const B = k.isPointLight === !0 ? R.customDistanceMaterial : R.customDepthMaterial;
        if (B !== void 0) V = B;
        else if (V = k.isPointLight === !0 ? _ : g, l.localClippingEnabled && I.clipShadows === !0 && Array.isArray(I.clippingPlanes) && I.clippingPlanes.length !== 0 || I.displacementMap && I.displacementScale !== 0 || I.alphaMap && I.alphaTest > 0 || I.map && I.alphaTest > 0 || I.alphaToCoverage === !0) {
            const U = V.uuid,
                H = I.uuid;
            let Q = v[U];
            Q === void 0 && (Q = {}, v[U] = Q);
            let Y = Q[H];
            Y === void 0 && (Y = V.clone(), Q[H] = Y, I.addEventListener("dispose", D)), V = Y
        }
        if (V.visible = I.visible, V.wireframe = I.wireframe, F === VSMShadowMap ? V.side = I.shadowSide !== null ? I.shadowSide : I.side : V.side = I.shadowSide !== null ? I.shadowSide : y[I.side], V.alphaMap = I.alphaMap, V.alphaTest = I.alphaToCoverage === !0 ? .5 : I.alphaTest, V.map = I.map, V.clipShadows = I.clipShadows, V.clippingPlanes = I.clippingPlanes, V.clipIntersection = I.clipIntersection, V.displacementMap = I.displacementMap, V.displacementScale = I.displacementScale, V.displacementBias = I.displacementBias, V.wireframeLinewidth = I.wireframeLinewidth, V.linewidth = I.linewidth, k.isPointLight === !0 && V.isMeshDistanceMaterial === !0) {
            const U = l.properties.get(V);
            U.light = k
        }
        return V
    }

    function A(R, I, k, F, V) {
        if (R.visible === !1) return;
        if (R.layers.test(I.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && V === VSMShadowMap) && (!R.frustumCulled || c.intersectsObject(R))) {
            R.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, R.matrixWorld);
            const H = i.update(R),
                Q = R.material;
            if (Array.isArray(Q)) {
                const Y = H.groups;
                for (let O = 0, G = Y.length; O < G; O++) {
                    const L = Y[O],
                        N = Q[L.materialIndex];
                    if (N && N.visible) {
                        const K = M(R, N, F, V);
                        R.onBeforeShadow(l, R, I, k, H, K, L), l.renderBufferDirect(k, null, H, K, R, L), R.onAfterShadow(l, R, I, k, H, K, L)
                    }
                }
            } else if (Q.visible) {
                const Y = M(R, Q, F, V);
                R.onBeforeShadow(l, R, I, k, H, Y, null), l.renderBufferDirect(k, null, H, Y, R, null), R.onAfterShadow(l, R, I, k, H, Y, null)
            }
        }
        const U = R.children;
        for (let H = 0, Q = U.length; H < Q; H++) A(U[H], I, k, F, V)
    }

    function D(R) {
        R.target.removeEventListener("dispose", D);
        for (const k in v) {
            const F = v[k],
                V = R.target.uuid;
            V in F && (F[V].dispose(), delete F[V])
        }
    }
}
const reversedFuncs = {
    [NeverDepth]: AlwaysDepth,
    [LessDepth]: GreaterDepth,
    [EqualDepth]: NotEqualDepth,
    [LessEqualDepth]: GreaterEqualDepth,
    [AlwaysDepth]: NeverDepth,
    [GreaterDepth]: LessDepth,
    [NotEqualDepth]: EqualDepth,
    [GreaterEqualDepth]: LessEqualDepth
};

function WebGLState(l, i) {
    function o() {
        let te = !1;
        const Ve = new Vector4;
        let Ce = null;
        const Xe = new Vector4(0, 0, 0, 0);
        return {
            setMask: function(Ee) {
                Ce !== Ee && !te && (l.colorMask(Ee, Ee, Ee, Ee), Ce = Ee)
            },
            setLocked: function(Ee) {
                te = Ee
            },
            setClear: function(Ee, ve, Ye, et, kt) {
                kt === !0 && (Ee *= et, ve *= et, Ye *= et), Ve.set(Ee, ve, Ye, et), Xe.equals(Ve) === !1 && (l.clearColor(Ee, ve, Ye, et), Xe.copy(Ve))
            },
            reset: function() {
                te = !1, Ce = null, Xe.set(-1, 0, 0, 0)
            }
        }
    }

    function c() {
        let te = !1,
            Ve = !1,
            Ce = null,
            Xe = null,
            Ee = null;
        return {
            setReversed: function(ve) {
                if (Ve !== ve) {
                    const Ye = i.get("EXT_clip_control");
                    ve ? Ye.clipControlEXT(Ye.LOWER_LEFT_EXT, Ye.ZERO_TO_ONE_EXT) : Ye.clipControlEXT(Ye.LOWER_LEFT_EXT, Ye.NEGATIVE_ONE_TO_ONE_EXT), Ve = ve;
                    const et = Ee;
                    Ee = null, this.setClear(et)
                }
            },
            getReversed: function() {
                return Ve
            },
            setTest: function(ve) {
                ve ? Me(l.DEPTH_TEST) : Pe(l.DEPTH_TEST)
            },
            setMask: function(ve) {
                Ce !== ve && !te && (l.depthMask(ve), Ce = ve)
            },
            setFunc: function(ve) {
                if (Ve && (ve = reversedFuncs[ve]), Xe !== ve) {
                    switch (ve) {
                        case NeverDepth:
                            l.depthFunc(l.NEVER);
                            break;
                        case AlwaysDepth:
                            l.depthFunc(l.ALWAYS);
                            break;
                        case LessDepth:
                            l.depthFunc(l.LESS);
                            break;
                        case LessEqualDepth:
                            l.depthFunc(l.LEQUAL);
                            break;
                        case EqualDepth:
                            l.depthFunc(l.EQUAL);
                            break;
                        case GreaterEqualDepth:
                            l.depthFunc(l.GEQUAL);
                            break;
                        case GreaterDepth:
                            l.depthFunc(l.GREATER);
                            break;
                        case NotEqualDepth:
                            l.depthFunc(l.NOTEQUAL);
                            break;
                        default:
                            l.depthFunc(l.LEQUAL)
                    }
                    Xe = ve
                }
            },
            setLocked: function(ve) {
                te = ve
            },
            setClear: function(ve) {
                Ee !== ve && (Ve && (ve = 1 - ve), l.clearDepth(ve), Ee = ve)
            },
            reset: function() {
                te = !1, Ce = null, Xe = null, Ee = null, Ve = !1
            }
        }
    }

    function u() {
        let te = !1,
            Ve = null,
            Ce = null,
            Xe = null,
            Ee = null,
            ve = null,
            Ye = null,
            et = null,
            kt = null;
        return {
            setTest: function(It) {
                te || (It ? Me(l.STENCIL_TEST) : Pe(l.STENCIL_TEST))
            },
            setMask: function(It) {
                Ve !== It && !te && (l.stencilMask(It), Ve = It)
            },
            setFunc: function(It, Ii, Ki) {
                (Ce !== It || Xe !== Ii || Ee !== Ki) && (l.stencilFunc(It, Ii, Ki), Ce = It, Xe = Ii, Ee = Ki)
            },
            setOp: function(It, Ii, Ki) {
                (ve !== It || Ye !== Ii || et !== Ki) && (l.stencilOp(It, Ii, Ki), ve = It, Ye = Ii, et = Ki)
            },
            setLocked: function(It) {
                te = It
            },
            setClear: function(It) {
                kt !== It && (l.clearStencil(It), kt = It)
            },
            reset: function() {
                te = !1, Ve = null, Ce = null, Xe = null, Ee = null, ve = null, Ye = null, et = null, kt = null
            }
        }
    }
    const p = new o,
        m = new c,
        g = new u,
        _ = new WeakMap,
        v = new WeakMap;
    let x = {},
        y = {},
        b = new WeakMap,
        S = [],
        C = null,
        E = !1,
        P = null,
        w = null,
        T = null,
        M = null,
        A = null,
        D = null,
        R = null,
        I = new Color(0, 0, 0),
        k = 0,
        F = !1,
        V = null,
        B = null,
        U = null,
        H = null,
        Q = null;
    const Y = l.getParameter(l.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let O = !1,
        G = 0;
    const L = l.getParameter(l.VERSION);
    L.indexOf("WebGL") !== -1 ? (G = parseFloat(/^WebGL (\d)/.exec(L)[1]), O = G >= 1) : L.indexOf("OpenGL ES") !== -1 && (G = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), O = G >= 2);
    let N = null,
        K = {};
    const Z = l.getParameter(l.SCISSOR_BOX),
        he = l.getParameter(l.VIEWPORT),
        we = new Vector4().fromArray(Z),
        ie = new Vector4().fromArray(he);

    function _e(te, Ve, Ce, Xe) {
        const Ee = new Uint8Array(4),
            ve = l.createTexture();
        l.bindTexture(te, ve), l.texParameteri(te, l.TEXTURE_MIN_FILTER, l.NEAREST), l.texParameteri(te, l.TEXTURE_MAG_FILTER, l.NEAREST);
        for (let Ye = 0; Ye < Ce; Ye++) te === l.TEXTURE_3D || te === l.TEXTURE_2D_ARRAY ? l.texImage3D(Ve, 0, l.RGBA, 1, 1, Xe, 0, l.RGBA, l.UNSIGNED_BYTE, Ee) : l.texImage2D(Ve + Ye, 0, l.RGBA, 1, 1, 0, l.RGBA, l.UNSIGNED_BYTE, Ee);
        return ve
    }
    const Te = {};
    Te[l.TEXTURE_2D] = _e(l.TEXTURE_2D, l.TEXTURE_2D, 1), Te[l.TEXTURE_CUBE_MAP] = _e(l.TEXTURE_CUBE_MAP, l.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Te[l.TEXTURE_2D_ARRAY] = _e(l.TEXTURE_2D_ARRAY, l.TEXTURE_2D_ARRAY, 1, 1), Te[l.TEXTURE_3D] = _e(l.TEXTURE_3D, l.TEXTURE_3D, 1, 1), p.setClear(0, 0, 0, 1), m.setClear(1), g.setClear(0), Me(l.DEPTH_TEST), m.setFunc(LessEqualDepth), dt(!1), tt(CullFaceBack), Me(l.CULL_FACE), q(NoBlending);

    function Me(te) {
        x[te] !== !0 && (l.enable(te), x[te] = !0)
    }

    function Pe(te) {
        x[te] !== !1 && (l.disable(te), x[te] = !1)
    }

    function be(te, Ve) {
        return y[te] !== Ve ? (l.bindFramebuffer(te, Ve), y[te] = Ve, te === l.DRAW_FRAMEBUFFER && (y[l.FRAMEBUFFER] = Ve), te === l.FRAMEBUFFER && (y[l.DRAW_FRAMEBUFFER] = Ve), !0) : !1
    }

    function Be(te, Ve) {
        let Ce = S,
            Xe = !1;
        if (te) {
            Ce = b.get(Ve), Ce === void 0 && (Ce = [], b.set(Ve, Ce));
            const Ee = te.textures;
            if (Ce.length !== Ee.length || Ce[0] !== l.COLOR_ATTACHMENT0) {
                for (let ve = 0, Ye = Ee.length; ve < Ye; ve++) Ce[ve] = l.COLOR_ATTACHMENT0 + ve;
                Ce.length = Ee.length, Xe = !0
            }
        } else Ce[0] !== l.BACK && (Ce[0] = l.BACK, Xe = !0);
        Xe && l.drawBuffers(Ce)
    }

    function De(te) {
        return C !== te ? (l.useProgram(te), C = te, !0) : !1
    }
    const We = {
        [AddEquation]: l.FUNC_ADD,
        [SubtractEquation]: l.FUNC_SUBTRACT,
        [ReverseSubtractEquation]: l.FUNC_REVERSE_SUBTRACT
    };
    We[MinEquation] = l.MIN, We[MaxEquation] = l.MAX;
    const Re = {
        [ZeroFactor]: l.ZERO,
        [OneFactor]: l.ONE,
        [SrcColorFactor]: l.SRC_COLOR,
        [SrcAlphaFactor]: l.SRC_ALPHA,
        [SrcAlphaSaturateFactor]: l.SRC_ALPHA_SATURATE,
        [DstColorFactor]: l.DST_COLOR,
        [DstAlphaFactor]: l.DST_ALPHA,
        [OneMinusSrcColorFactor]: l.ONE_MINUS_SRC_COLOR,
        [OneMinusSrcAlphaFactor]: l.ONE_MINUS_SRC_ALPHA,
        [OneMinusDstColorFactor]: l.ONE_MINUS_DST_COLOR,
        [OneMinusDstAlphaFactor]: l.ONE_MINUS_DST_ALPHA,
        [ConstantColorFactor]: l.CONSTANT_COLOR,
        [OneMinusConstantColorFactor]: l.ONE_MINUS_CONSTANT_COLOR,
        [ConstantAlphaFactor]: l.CONSTANT_ALPHA,
        [OneMinusConstantAlphaFactor]: l.ONE_MINUS_CONSTANT_ALPHA
    };

    function q(te, Ve, Ce, Xe, Ee, ve, Ye, et, kt, It) {
        if (te === NoBlending) {
            E === !0 && (Pe(l.BLEND), E = !1);
            return
        }
        if (E === !1 && (Me(l.BLEND), E = !0), te !== CustomBlending) {
            if (te !== P || It !== F) {
                if ((w !== AddEquation || A !== AddEquation) && (l.blendEquation(l.FUNC_ADD), w = AddEquation, A = AddEquation), It) switch (te) {
                    case NormalBlending:
                        l.blendFuncSeparate(l.ONE, l.ONE_MINUS_SRC_ALPHA, l.ONE, l.ONE_MINUS_SRC_ALPHA);
                        break;
                    case AdditiveBlending:
                        l.blendFunc(l.ONE, l.ONE);
                        break;
                    case SubtractiveBlending:
                        l.blendFuncSeparate(l.ZERO, l.ONE_MINUS_SRC_COLOR, l.ZERO, l.ONE);
                        break;
                    case MultiplyBlending:
                        l.blendFuncSeparate(l.ZERO, l.SRC_COLOR, l.ZERO, l.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", te);
                        break
                } else switch (te) {
                    case NormalBlending:
                        l.blendFuncSeparate(l.SRC_ALPHA, l.ONE_MINUS_SRC_ALPHA, l.ONE, l.ONE_MINUS_SRC_ALPHA);
                        break;
                    case AdditiveBlending:
                        l.blendFunc(l.SRC_ALPHA, l.ONE);
                        break;
                    case SubtractiveBlending:
                        l.blendFuncSeparate(l.ZERO, l.ONE_MINUS_SRC_COLOR, l.ZERO, l.ONE);
                        break;
                    case MultiplyBlending:
                        l.blendFunc(l.ZERO, l.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", te);
                        break
                }
                T = null, M = null, D = null, R = null, I.set(0, 0, 0), k = 0, P = te, F = It
            }
            return
        }
        Ee = Ee || Ve, ve = ve || Ce, Ye = Ye || Xe, (Ve !== w || Ee !== A) && (l.blendEquationSeparate(We[Ve], We[Ee]), w = Ve, A = Ee), (Ce !== T || Xe !== M || ve !== D || Ye !== R) && (l.blendFuncSeparate(Re[Ce], Re[Xe], Re[ve], Re[Ye]), T = Ce, M = Xe, D = ve, R = Ye), (et.equals(I) === !1 || kt !== k) && (l.blendColor(et.r, et.g, et.b, kt), I.copy(et), k = kt), P = te, F = !1
    }

    function At(te, Ve) {
        te.side === DoubleSide ? Pe(l.CULL_FACE) : Me(l.CULL_FACE);
        let Ce = te.side === BackSide;
        Ve && (Ce = !Ce), dt(Ce), te.blending === NormalBlending && te.transparent === !1 ? q(NoBlending) : q(te.blending, te.blendEquation, te.blendSrc, te.blendDst, te.blendEquationAlpha, te.blendSrcAlpha, te.blendDstAlpha, te.blendColor, te.blendAlpha, te.premultipliedAlpha), m.setFunc(te.depthFunc), m.setTest(te.depthTest), m.setMask(te.depthWrite), p.setMask(te.colorWrite);
        const Xe = te.stencilWrite;
        g.setTest(Xe), Xe && (g.setMask(te.stencilWriteMask), g.setFunc(te.stencilFunc, te.stencilRef, te.stencilFuncMask), g.setOp(te.stencilFail, te.stencilZFail, te.stencilZPass)), ot(te.polygonOffset, te.polygonOffsetFactor, te.polygonOffsetUnits), te.alphaToCoverage === !0 ? Me(l.SAMPLE_ALPHA_TO_COVERAGE) : Pe(l.SAMPLE_ALPHA_TO_COVERAGE)
    }

    function dt(te) {
        V !== te && (te ? l.frontFace(l.CW) : l.frontFace(l.CCW), V = te)
    }

    function tt(te) {
        te !== CullFaceNone ? (Me(l.CULL_FACE), te !== B && (te === CullFaceBack ? l.cullFace(l.BACK) : te === CullFaceFront ? l.cullFace(l.FRONT) : l.cullFace(l.FRONT_AND_BACK))) : Pe(l.CULL_FACE), B = te
    }

    function ke(te) {
        te !== U && (O && l.lineWidth(te), U = te)
    }

    function ot(te, Ve, Ce) {
        te ? (Me(l.POLYGON_OFFSET_FILL), (H !== Ve || Q !== Ce) && (l.polygonOffset(Ve, Ce), H = Ve, Q = Ce)) : Pe(l.POLYGON_OFFSET_FILL)
    }

    function ze(te) {
        te ? Me(l.SCISSOR_TEST) : Pe(l.SCISSOR_TEST)
    }

    function Ie(te) {
        te === void 0 && (te = l.TEXTURE0 + Y - 1), N !== te && (l.activeTexture(te), N = te)
    }

    function Dt(te, Ve, Ce) {
        Ce === void 0 && (N === null ? Ce = l.TEXTURE0 + Y - 1 : Ce = N);
        let Xe = K[Ce];
        Xe === void 0 && (Xe = {
            type: void 0,
            texture: void 0
        }, K[Ce] = Xe), (Xe.type !== te || Xe.texture !== Ve) && (N !== Ce && (l.activeTexture(Ce), N = Ce), l.bindTexture(te, Ve || Te[te]), Xe.type = te, Xe.texture = Ve)
    }

    function J() {
        const te = K[N];
        te !== void 0 && te.type !== void 0 && (l.bindTexture(te.type, null), te.type = void 0, te.texture = void 0)
    }

    function $() {
        try {
            l.compressedTexImage2D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function ae() {
        try {
            l.compressedTexImage3D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function ge() {
        try {
            l.texSubImage2D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function ye() {
        try {
            l.texSubImage3D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function fe() {
        try {
            l.compressedTexSubImage2D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function Ke() {
        try {
            l.compressedTexSubImage3D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function Le() {
        try {
            l.texStorage2D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function Oe() {
        try {
            l.texStorage3D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function Ze() {
        try {
            l.texImage2D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function Se() {
        try {
            l.texImage3D(...arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }

    function qe(te) {
        we.equals(te) === !1 && (l.scissor(te.x, te.y, te.z, te.w), we.copy(te))
    }

    function Je(te) {
        ie.equals(te) === !1 && (l.viewport(te.x, te.y, te.z, te.w), ie.copy(te))
    }

    function it(te, Ve) {
        let Ce = v.get(Ve);
        Ce === void 0 && (Ce = new WeakMap, v.set(Ve, Ce));
        let Xe = Ce.get(te);
        Xe === void 0 && (Xe = l.getUniformBlockIndex(Ve, te.name), Ce.set(te, Xe))
    }

    function Fe(te, Ve) {
        const Xe = v.get(Ve).get(te);
        _.get(Ve) !== Xe && (l.uniformBlockBinding(Ve, Xe, te.__bindingPointIndex), _.set(Ve, Xe))
    }

    function ct() {
        l.disable(l.BLEND), l.disable(l.CULL_FACE), l.disable(l.DEPTH_TEST), l.disable(l.POLYGON_OFFSET_FILL), l.disable(l.SCISSOR_TEST), l.disable(l.STENCIL_TEST), l.disable(l.SAMPLE_ALPHA_TO_COVERAGE), l.blendEquation(l.FUNC_ADD), l.blendFunc(l.ONE, l.ZERO), l.blendFuncSeparate(l.ONE, l.ZERO, l.ONE, l.ZERO), l.blendColor(0, 0, 0, 0), l.colorMask(!0, !0, !0, !0), l.clearColor(0, 0, 0, 0), l.depthMask(!0), l.depthFunc(l.LESS), m.setReversed(!1), l.clearDepth(1), l.stencilMask(4294967295), l.stencilFunc(l.ALWAYS, 0, 4294967295), l.stencilOp(l.KEEP, l.KEEP, l.KEEP), l.clearStencil(0), l.cullFace(l.BACK), l.frontFace(l.CCW), l.polygonOffset(0, 0), l.activeTexture(l.TEXTURE0), l.bindFramebuffer(l.FRAMEBUFFER, null), l.bindFramebuffer(l.DRAW_FRAMEBUFFER, null), l.bindFramebuffer(l.READ_FRAMEBUFFER, null), l.useProgram(null), l.lineWidth(1), l.scissor(0, 0, l.canvas.width, l.canvas.height), l.viewport(0, 0, l.canvas.width, l.canvas.height), x = {}, N = null, K = {}, y = {}, b = new WeakMap, S = [], C = null, E = !1, P = null, w = null, T = null, M = null, A = null, D = null, R = null, I = new Color(0, 0, 0), k = 0, F = !1, V = null, B = null, U = null, H = null, Q = null, we.set(0, 0, l.canvas.width, l.canvas.height), ie.set(0, 0, l.canvas.width, l.canvas.height), p.reset(), m.reset(), g.reset()
    }
    return {
        buffers: {
            color: p,
            depth: m,
            stencil: g
        },
        enable: Me,
        disable: Pe,
        bindFramebuffer: be,
        drawBuffers: Be,
        useProgram: De,
        setBlending: q,
        setMaterial: At,
        setFlipSided: dt,
        setCullFace: tt,
        setLineWidth: ke,
        setPolygonOffset: ot,
        setScissorTest: ze,
        activeTexture: Ie,
        bindTexture: Dt,
        unbindTexture: J,
        compressedTexImage2D: $,
        compressedTexImage3D: ae,
        texImage2D: Ze,
        texImage3D: Se,
        updateUBOMapping: it,
        uniformBlockBinding: Fe,
        texStorage2D: Le,
        texStorage3D: Oe,
        texSubImage2D: ge,
        texSubImage3D: ye,
        compressedTexSubImage2D: fe,
        compressedTexSubImage3D: Ke,
        scissor: qe,
        viewport: Je,
        reset: ct
    }
}

function WebGLTextures(l, i, o, c, u, p, m) {
    const g = i.has("WEBGL_multisampled_render_to_texture") ? i.get("WEBGL_multisampled_render_to_texture") : null,
        _ = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
        v = new Vector2,
        x = new WeakMap;
    let y;
    const b = new WeakMap;
    let S = !1;
    try {
        S = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
    } catch {}

    function C(J, $) {
        return S ? new OffscreenCanvas(J, $) : createElementNS("canvas")
    }

    function E(J, $, ae) {
        let ge = 1;
        const ye = Dt(J);
        if ((ye.width > ae || ye.height > ae) && (ge = ae / Math.max(ye.width, ye.height)), ge < 1)
            if (typeof HTMLImageElement < "u" && J instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && J instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && J instanceof ImageBitmap || typeof VideoFrame < "u" && J instanceof VideoFrame) {
                const fe = Math.floor(ge * ye.width),
                    Ke = Math.floor(ge * ye.height);
                y === void 0 && (y = C(fe, Ke));
                const Le = $ ? C(fe, Ke) : y;
                return Le.width = fe, Le.height = Ke, Le.getContext("2d").drawImage(J, 0, 0, fe, Ke), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ye.width + "x" + ye.height + ") to (" + fe + "x" + Ke + ")."), Le
            } else return "data" in J && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ye.width + "x" + ye.height + ")."), J;
        return J
    }

    function P(J) {
        return J.generateMipmaps
    }

    function w(J) {
        l.generateMipmap(J)
    }

    function T(J) {
        return J.isWebGLCubeRenderTarget ? l.TEXTURE_CUBE_MAP : J.isWebGL3DRenderTarget ? l.TEXTURE_3D : J.isWebGLArrayRenderTarget || J.isCompressedArrayTexture ? l.TEXTURE_2D_ARRAY : l.TEXTURE_2D
    }

    function M(J, $, ae, ge, ye = !1) {
        if (J !== null) {
            if (l[J] !== void 0) return l[J];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + J + "'")
        }
        let fe = $;
        if ($ === l.RED && (ae === l.FLOAT && (fe = l.R32F), ae === l.HALF_FLOAT && (fe = l.R16F), ae === l.UNSIGNED_BYTE && (fe = l.R8)), $ === l.RED_INTEGER && (ae === l.UNSIGNED_BYTE && (fe = l.R8UI), ae === l.UNSIGNED_SHORT && (fe = l.R16UI), ae === l.UNSIGNED_INT && (fe = l.R32UI), ae === l.BYTE && (fe = l.R8I), ae === l.SHORT && (fe = l.R16I), ae === l.INT && (fe = l.R32I)), $ === l.RG && (ae === l.FLOAT && (fe = l.RG32F), ae === l.HALF_FLOAT && (fe = l.RG16F), ae === l.UNSIGNED_BYTE && (fe = l.RG8)), $ === l.RG_INTEGER && (ae === l.UNSIGNED_BYTE && (fe = l.RG8UI), ae === l.UNSIGNED_SHORT && (fe = l.RG16UI), ae === l.UNSIGNED_INT && (fe = l.RG32UI), ae === l.BYTE && (fe = l.RG8I), ae === l.SHORT && (fe = l.RG16I), ae === l.INT && (fe = l.RG32I)), $ === l.RGB_INTEGER && (ae === l.UNSIGNED_BYTE && (fe = l.RGB8UI), ae === l.UNSIGNED_SHORT && (fe = l.RGB16UI), ae === l.UNSIGNED_INT && (fe = l.RGB32UI), ae === l.BYTE && (fe = l.RGB8I), ae === l.SHORT && (fe = l.RGB16I), ae === l.INT && (fe = l.RGB32I)), $ === l.RGBA_INTEGER && (ae === l.UNSIGNED_BYTE && (fe = l.RGBA8UI), ae === l.UNSIGNED_SHORT && (fe = l.RGBA16UI), ae === l.UNSIGNED_INT && (fe = l.RGBA32UI), ae === l.BYTE && (fe = l.RGBA8I), ae === l.SHORT && (fe = l.RGBA16I), ae === l.INT && (fe = l.RGBA32I)), $ === l.RGB && ae === l.UNSIGNED_INT_5_9_9_9_REV && (fe = l.RGB9_E5), $ === l.RGBA) {
            const Ke = ye ? LinearTransfer : ColorManagement.getTransfer(ge);
            ae === l.FLOAT && (fe = l.RGBA32F), ae === l.HALF_FLOAT && (fe = l.RGBA16F), ae === l.UNSIGNED_BYTE && (fe = Ke === SRGBTransfer ? l.SRGB8_ALPHA8 : l.RGBA8), ae === l.UNSIGNED_SHORT_4_4_4_4 && (fe = l.RGBA4), ae === l.UNSIGNED_SHORT_5_5_5_1 && (fe = l.RGB5_A1)
        }
        return (fe === l.R16F || fe === l.R32F || fe === l.RG16F || fe === l.RG32F || fe === l.RGBA16F || fe === l.RGBA32F) && i.get("EXT_color_buffer_float"), fe
    }

    function A(J, $) {
        let ae;
        return J ? $ === null || $ === UnsignedIntType || $ === UnsignedInt248Type ? ae = l.DEPTH24_STENCIL8 : $ === FloatType ? ae = l.DEPTH32F_STENCIL8 : $ === UnsignedShortType && (ae = l.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : $ === null || $ === UnsignedIntType || $ === UnsignedInt248Type ? ae = l.DEPTH_COMPONENT24 : $ === FloatType ? ae = l.DEPTH_COMPONENT32F : $ === UnsignedShortType && (ae = l.DEPTH_COMPONENT16), ae
    }

    function D(J, $) {
        return P(J) === !0 || J.isFramebufferTexture && J.minFilter !== NearestFilter && J.minFilter !== LinearFilter ? Math.log2(Math.max($.width, $.height)) + 1 : J.mipmaps !== void 0 && J.mipmaps.length > 0 ? J.mipmaps.length : J.isCompressedTexture && Array.isArray(J.image) ? $.mipmaps.length : 1
    }

    function R(J) {
        const $ = J.target;
        $.removeEventListener("dispose", R), k($), $.isVideoTexture && x.delete($)
    }

    function I(J) {
        const $ = J.target;
        $.removeEventListener("dispose", I), V($)
    }

    function k(J) {
        const $ = c.get(J);
        if ($.__webglInit === void 0) return;
        const ae = J.source,
            ge = b.get(ae);
        if (ge) {
            const ye = ge[$.__cacheKey];
            ye.usedTimes--, ye.usedTimes === 0 && F(J), Object.keys(ge).length === 0 && b.delete(ae)
        }
        c.remove(J)
    }

    function F(J) {
        const $ = c.get(J);
        l.deleteTexture($.__webglTexture);
        const ae = J.source,
            ge = b.get(ae);
        delete ge[$.__cacheKey], m.memory.textures--
    }

    function V(J) {
        const $ = c.get(J);
        if (J.depthTexture && (J.depthTexture.dispose(), c.remove(J.depthTexture)), J.isWebGLCubeRenderTarget)
            for (let ge = 0; ge < 6; ge++) {
                if (Array.isArray($.__webglFramebuffer[ge]))
                    for (let ye = 0; ye < $.__webglFramebuffer[ge].length; ye++) l.deleteFramebuffer($.__webglFramebuffer[ge][ye]);
                else l.deleteFramebuffer($.__webglFramebuffer[ge]);
                $.__webglDepthbuffer && l.deleteRenderbuffer($.__webglDepthbuffer[ge])
            } else {
                if (Array.isArray($.__webglFramebuffer))
                    for (let ge = 0; ge < $.__webglFramebuffer.length; ge++) l.deleteFramebuffer($.__webglFramebuffer[ge]);
                else l.deleteFramebuffer($.__webglFramebuffer);
                if ($.__webglDepthbuffer && l.deleteRenderbuffer($.__webglDepthbuffer), $.__webglMultisampledFramebuffer && l.deleteFramebuffer($.__webglMultisampledFramebuffer), $.__webglColorRenderbuffer)
                    for (let ge = 0; ge < $.__webglColorRenderbuffer.length; ge++) $.__webglColorRenderbuffer[ge] && l.deleteRenderbuffer($.__webglColorRenderbuffer[ge]);
                $.__webglDepthRenderbuffer && l.deleteRenderbuffer($.__webglDepthRenderbuffer)
            }
        const ae = J.textures;
        for (let ge = 0, ye = ae.length; ge < ye; ge++) {
            const fe = c.get(ae[ge]);
            fe.__webglTexture && (l.deleteTexture(fe.__webglTexture), m.memory.textures--), c.remove(ae[ge])
        }
        c.remove(J)
    }
    let B = 0;

    function U() {
        B = 0
    }

    function H() {
        const J = B;
        return J >= u.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + J + " texture units while this GPU supports only " + u.maxTextures), B += 1, J
    }

    function Q(J) {
        const $ = [];
        return $.push(J.wrapS), $.push(J.wrapT), $.push(J.wrapR || 0), $.push(J.magFilter), $.push(J.minFilter), $.push(J.anisotropy), $.push(J.internalFormat), $.push(J.format), $.push(J.type), $.push(J.generateMipmaps), $.push(J.premultiplyAlpha), $.push(J.flipY), $.push(J.unpackAlignment), $.push(J.colorSpace), $.join()
    }

    function Y(J, $) {
        const ae = c.get(J);
        if (J.isVideoTexture && ze(J), J.isRenderTargetTexture === !1 && J.version > 0 && ae.__version !== J.version) {
            const ge = J.image;
            if (ge === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (ge.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Te(ae, J, $);
                return
            }
        }
        o.bindTexture(l.TEXTURE_2D, ae.__webglTexture, l.TEXTURE0 + $)
    }

    function O(J, $) {
        const ae = c.get(J);
        if (J.version > 0 && ae.__version !== J.version) {
            Te(ae, J, $);
            return
        }
        o.bindTexture(l.TEXTURE_2D_ARRAY, ae.__webglTexture, l.TEXTURE0 + $)
    }

    function G(J, $) {
        const ae = c.get(J);
        if (J.version > 0 && ae.__version !== J.version) {
            Te(ae, J, $);
            return
        }
        o.bindTexture(l.TEXTURE_3D, ae.__webglTexture, l.TEXTURE0 + $)
    }

    function L(J, $) {
        const ae = c.get(J);
        if (J.version > 0 && ae.__version !== J.version) {
            Me(ae, J, $);
            return
        }
        o.bindTexture(l.TEXTURE_CUBE_MAP, ae.__webglTexture, l.TEXTURE0 + $)
    }
    const N = {
            [RepeatWrapping]: l.REPEAT,
            [ClampToEdgeWrapping]: l.CLAMP_TO_EDGE,
            [MirroredRepeatWrapping]: l.MIRRORED_REPEAT
        },
        K = {
            [NearestFilter]: l.NEAREST,
            [NearestMipmapNearestFilter]: l.NEAREST_MIPMAP_NEAREST,
            [NearestMipmapLinearFilter]: l.NEAREST_MIPMAP_LINEAR,
            [LinearFilter]: l.LINEAR,
            [LinearMipmapNearestFilter]: l.LINEAR_MIPMAP_NEAREST,
            [LinearMipmapLinearFilter]: l.LINEAR_MIPMAP_LINEAR
        },
        Z = {
            [NeverCompare]: l.NEVER,
            [AlwaysCompare]: l.ALWAYS,
            [LessCompare]: l.LESS,
            [LessEqualCompare]: l.LEQUAL,
            [EqualCompare]: l.EQUAL,
            [GreaterEqualCompare]: l.GEQUAL,
            [GreaterCompare]: l.GREATER,
            [NotEqualCompare]: l.NOTEQUAL
        };

    function he(J, $) {
        if ($.type === FloatType && i.has("OES_texture_float_linear") === !1 && ($.magFilter === LinearFilter || $.magFilter === LinearMipmapNearestFilter || $.magFilter === NearestMipmapLinearFilter || $.magFilter === LinearMipmapLinearFilter || $.minFilter === LinearFilter || $.minFilter === LinearMipmapNearestFilter || $.minFilter === NearestMipmapLinearFilter || $.minFilter === LinearMipmapLinearFilter) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), l.texParameteri(J, l.TEXTURE_WRAP_S, N[$.wrapS]), l.texParameteri(J, l.TEXTURE_WRAP_T, N[$.wrapT]), (J === l.TEXTURE_3D || J === l.TEXTURE_2D_ARRAY) && l.texParameteri(J, l.TEXTURE_WRAP_R, N[$.wrapR]), l.texParameteri(J, l.TEXTURE_MAG_FILTER, K[$.magFilter]), l.texParameteri(J, l.TEXTURE_MIN_FILTER, K[$.minFilter]), $.compareFunction && (l.texParameteri(J, l.TEXTURE_COMPARE_MODE, l.COMPARE_REF_TO_TEXTURE), l.texParameteri(J, l.TEXTURE_COMPARE_FUNC, Z[$.compareFunction])), i.has("EXT_texture_filter_anisotropic") === !0) {
            if ($.magFilter === NearestFilter || $.minFilter !== NearestMipmapLinearFilter && $.minFilter !== LinearMipmapLinearFilter || $.type === FloatType && i.has("OES_texture_float_linear") === !1) return;
            if ($.anisotropy > 1 || c.get($).__currentAnisotropy) {
                const ae = i.get("EXT_texture_filter_anisotropic");
                l.texParameterf(J, ae.TEXTURE_MAX_ANISOTROPY_EXT, Math.min($.anisotropy, u.getMaxAnisotropy())), c.get($).__currentAnisotropy = $.anisotropy
            }
        }
    }

    function we(J, $) {
        let ae = !1;
        J.__webglInit === void 0 && (J.__webglInit = !0, $.addEventListener("dispose", R));
        const ge = $.source;
        let ye = b.get(ge);
        ye === void 0 && (ye = {}, b.set(ge, ye));
        const fe = Q($);
        if (fe !== J.__cacheKey) {
            ye[fe] === void 0 && (ye[fe] = {
                texture: l.createTexture(),
                usedTimes: 0
            }, m.memory.textures++, ae = !0), ye[fe].usedTimes++;
            const Ke = ye[J.__cacheKey];
            Ke !== void 0 && (ye[J.__cacheKey].usedTimes--, Ke.usedTimes === 0 && F($)), J.__cacheKey = fe, J.__webglTexture = ye[fe].texture
        }
        return ae
    }

    function ie(J, $, ae) {
        return Math.floor(Math.floor(J / ae) / $)
    }

    function _e(J, $, ae, ge) {
        const fe = J.updateRanges;
        if (fe.length === 0) o.texSubImage2D(l.TEXTURE_2D, 0, 0, 0, $.width, $.height, ae, ge, $.data);
        else {
            fe.sort((Se, qe) => Se.start - qe.start);
            let Ke = 0;
            for (let Se = 1; Se < fe.length; Se++) {
                const qe = fe[Ke],
                    Je = fe[Se],
                    it = qe.start + qe.count,
                    Fe = ie(Je.start, $.width, 4),
                    ct = ie(qe.start, $.width, 4);
                Je.start <= it + 1 && Fe === ct && ie(Je.start + Je.count - 1, $.width, 4) === Fe ? qe.count = Math.max(qe.count, Je.start + Je.count - qe.start) : (++Ke, fe[Ke] = Je)
            }
            fe.length = Ke + 1;
            const Le = l.getParameter(l.UNPACK_ROW_LENGTH),
                Oe = l.getParameter(l.UNPACK_SKIP_PIXELS),
                Ze = l.getParameter(l.UNPACK_SKIP_ROWS);
            l.pixelStorei(l.UNPACK_ROW_LENGTH, $.width);
            for (let Se = 0, qe = fe.length; Se < qe; Se++) {
                const Je = fe[Se],
                    it = Math.floor(Je.start / 4),
                    Fe = Math.ceil(Je.count / 4),
                    ct = it % $.width,
                    te = Math.floor(it / $.width),
                    Ve = Fe,
                    Ce = 1;
                l.pixelStorei(l.UNPACK_SKIP_PIXELS, ct), l.pixelStorei(l.UNPACK_SKIP_ROWS, te), o.texSubImage2D(l.TEXTURE_2D, 0, ct, te, Ve, Ce, ae, ge, $.data)
            }
            J.clearUpdateRanges(), l.pixelStorei(l.UNPACK_ROW_LENGTH, Le), l.pixelStorei(l.UNPACK_SKIP_PIXELS, Oe), l.pixelStorei(l.UNPACK_SKIP_ROWS, Ze)
        }
    }

    function Te(J, $, ae) {
        let ge = l.TEXTURE_2D;
        ($.isDataArrayTexture || $.isCompressedArrayTexture) && (ge = l.TEXTURE_2D_ARRAY), $.isData3DTexture && (ge = l.TEXTURE_3D);
        const ye = we(J, $),
            fe = $.source;
        o.bindTexture(ge, J.__webglTexture, l.TEXTURE0 + ae);
        const Ke = c.get(fe);
        if (fe.version !== Ke.__version || ye === !0) {
            o.activeTexture(l.TEXTURE0 + ae);
            const Le = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
                Oe = $.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries($.colorSpace),
                Ze = $.colorSpace === NoColorSpace || Le === Oe ? l.NONE : l.BROWSER_DEFAULT_WEBGL;
            l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL, $.flipY), l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $.premultiplyAlpha), l.pixelStorei(l.UNPACK_ALIGNMENT, $.unpackAlignment), l.pixelStorei(l.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ze);
            let Se = E($.image, !1, u.maxTextureSize);
            Se = Ie($, Se);
            const qe = p.convert($.format, $.colorSpace),
                Je = p.convert($.type);
            let it = M($.internalFormat, qe, Je, $.colorSpace, $.isVideoTexture);
            he(ge, $);
            let Fe;
            const ct = $.mipmaps,
                te = $.isVideoTexture !== !0,
                Ve = Ke.__version === void 0 || ye === !0,
                Ce = fe.dataReady,
                Xe = D($, Se);
            if ($.isDepthTexture) it = A($.format === DepthStencilFormat, $.type), Ve && (te ? o.texStorage2D(l.TEXTURE_2D, 1, it, Se.width, Se.height) : o.texImage2D(l.TEXTURE_2D, 0, it, Se.width, Se.height, 0, qe, Je, null));
            else if ($.isDataTexture)
                if (ct.length > 0) {
                    te && Ve && o.texStorage2D(l.TEXTURE_2D, Xe, it, ct[0].width, ct[0].height);
                    for (let Ee = 0, ve = ct.length; Ee < ve; Ee++) Fe = ct[Ee], te ? Ce && o.texSubImage2D(l.TEXTURE_2D, Ee, 0, 0, Fe.width, Fe.height, qe, Je, Fe.data) : o.texImage2D(l.TEXTURE_2D, Ee, it, Fe.width, Fe.height, 0, qe, Je, Fe.data);
                    $.generateMipmaps = !1
                } else te ? (Ve && o.texStorage2D(l.TEXTURE_2D, Xe, it, Se.width, Se.height), Ce && _e($, Se, qe, Je)) : o.texImage2D(l.TEXTURE_2D, 0, it, Se.width, Se.height, 0, qe, Je, Se.data);
            else if ($.isCompressedTexture)
                if ($.isCompressedArrayTexture) {
                    te && Ve && o.texStorage3D(l.TEXTURE_2D_ARRAY, Xe, it, ct[0].width, ct[0].height, Se.depth);
                    for (let Ee = 0, ve = ct.length; Ee < ve; Ee++)
                        if (Fe = ct[Ee], $.format !== RGBAFormat)
                            if (qe !== null)
                                if (te) {
                                    if (Ce)
                                        if ($.layerUpdates.size > 0) {
                                            const Ye = getByteLength(Fe.width, Fe.height, $.format, $.type);
                                            for (const et of $.layerUpdates) {
                                                const kt = Fe.data.subarray(et * Ye / Fe.data.BYTES_PER_ELEMENT, (et + 1) * Ye / Fe.data.BYTES_PER_ELEMENT);
                                                o.compressedTexSubImage3D(l.TEXTURE_2D_ARRAY, Ee, 0, 0, et, Fe.width, Fe.height, 1, qe, kt)
                                            }
                                            $.clearLayerUpdates()
                                        } else o.compressedTexSubImage3D(l.TEXTURE_2D_ARRAY, Ee, 0, 0, 0, Fe.width, Fe.height, Se.depth, qe, Fe.data)
                                } else o.compressedTexImage3D(l.TEXTURE_2D_ARRAY, Ee, it, Fe.width, Fe.height, Se.depth, 0, Fe.data, 0, 0);
                    else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    else te ? Ce && o.texSubImage3D(l.TEXTURE_2D_ARRAY, Ee, 0, 0, 0, Fe.width, Fe.height, Se.depth, qe, Je, Fe.data) : o.texImage3D(l.TEXTURE_2D_ARRAY, Ee, it, Fe.width, Fe.height, Se.depth, 0, qe, Je, Fe.data)
                } else {
                    te && Ve && o.texStorage2D(l.TEXTURE_2D, Xe, it, ct[0].width, ct[0].height);
                    for (let Ee = 0, ve = ct.length; Ee < ve; Ee++) Fe = ct[Ee], $.format !== RGBAFormat ? qe !== null ? te ? Ce && o.compressedTexSubImage2D(l.TEXTURE_2D, Ee, 0, 0, Fe.width, Fe.height, qe, Fe.data) : o.compressedTexImage2D(l.TEXTURE_2D, Ee, it, Fe.width, Fe.height, 0, Fe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : te ? Ce && o.texSubImage2D(l.TEXTURE_2D, Ee, 0, 0, Fe.width, Fe.height, qe, Je, Fe.data) : o.texImage2D(l.TEXTURE_2D, Ee, it, Fe.width, Fe.height, 0, qe, Je, Fe.data)
                }
            else if ($.isDataArrayTexture)
                if (te) {
                    if (Ve && o.texStorage3D(l.TEXTURE_2D_ARRAY, Xe, it, Se.width, Se.height, Se.depth), Ce)
                        if ($.layerUpdates.size > 0) {
                            const Ee = getByteLength(Se.width, Se.height, $.format, $.type);
                            for (const ve of $.layerUpdates) {
                                const Ye = Se.data.subarray(ve * Ee / Se.data.BYTES_PER_ELEMENT, (ve + 1) * Ee / Se.data.BYTES_PER_ELEMENT);
                                o.texSubImage3D(l.TEXTURE_2D_ARRAY, 0, 0, 0, ve, Se.width, Se.height, 1, qe, Je, Ye)
                            }
                            $.clearLayerUpdates()
                        } else o.texSubImage3D(l.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Se.width, Se.height, Se.depth, qe, Je, Se.data)
                } else o.texImage3D(l.TEXTURE_2D_ARRAY, 0, it, Se.width, Se.height, Se.depth, 0, qe, Je, Se.data);
            else if ($.isData3DTexture) te ? (Ve && o.texStorage3D(l.TEXTURE_3D, Xe, it, Se.width, Se.height, Se.depth), Ce && o.texSubImage3D(l.TEXTURE_3D, 0, 0, 0, 0, Se.width, Se.height, Se.depth, qe, Je, Se.data)) : o.texImage3D(l.TEXTURE_3D, 0, it, Se.width, Se.height, Se.depth, 0, qe, Je, Se.data);
            else if ($.isFramebufferTexture) {
                if (Ve)
                    if (te) o.texStorage2D(l.TEXTURE_2D, Xe, it, Se.width, Se.height);
                    else {
                        let Ee = Se.width,
                            ve = Se.height;
                        for (let Ye = 0; Ye < Xe; Ye++) o.texImage2D(l.TEXTURE_2D, Ye, it, Ee, ve, 0, qe, Je, null), Ee >>= 1, ve >>= 1
                    }
            } else if (ct.length > 0) {
                if (te && Ve) {
                    const Ee = Dt(ct[0]);
                    o.texStorage2D(l.TEXTURE_2D, Xe, it, Ee.width, Ee.height)
                }
                for (let Ee = 0, ve = ct.length; Ee < ve; Ee++) Fe = ct[Ee], te ? Ce && o.texSubImage2D(l.TEXTURE_2D, Ee, 0, 0, qe, Je, Fe) : o.texImage2D(l.TEXTURE_2D, Ee, it, qe, Je, Fe);
                $.generateMipmaps = !1
            } else if (te) {
                if (Ve) {
                    const Ee = Dt(Se);
                    o.texStorage2D(l.TEXTURE_2D, Xe, it, Ee.width, Ee.height)
                }
                Ce && o.texSubImage2D(l.TEXTURE_2D, 0, 0, 0, qe, Je, Se)
            } else o.texImage2D(l.TEXTURE_2D, 0, it, qe, Je, Se);
            P($) && w(ge), Ke.__version = fe.version, $.onUpdate && $.onUpdate($)
        }
        J.__version = $.version
    }

    function Me(J, $, ae) {
        if ($.image.length !== 6) return;
        const ge = we(J, $),
            ye = $.source;
        o.bindTexture(l.TEXTURE_CUBE_MAP, J.__webglTexture, l.TEXTURE0 + ae);
        const fe = c.get(ye);
        if (ye.version !== fe.__version || ge === !0) {
            o.activeTexture(l.TEXTURE0 + ae);
            const Ke = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
                Le = $.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries($.colorSpace),
                Oe = $.colorSpace === NoColorSpace || Ke === Le ? l.NONE : l.BROWSER_DEFAULT_WEBGL;
            l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL, $.flipY), l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $.premultiplyAlpha), l.pixelStorei(l.UNPACK_ALIGNMENT, $.unpackAlignment), l.pixelStorei(l.UNPACK_COLORSPACE_CONVERSION_WEBGL, Oe);
            const Ze = $.isCompressedTexture || $.image[0].isCompressedTexture,
                Se = $.image[0] && $.image[0].isDataTexture,
                qe = [];
            for (let ve = 0; ve < 6; ve++) !Ze && !Se ? qe[ve] = E($.image[ve], !0, u.maxCubemapSize) : qe[ve] = Se ? $.image[ve].image : $.image[ve], qe[ve] = Ie($, qe[ve]);
            const Je = qe[0],
                it = p.convert($.format, $.colorSpace),
                Fe = p.convert($.type),
                ct = M($.internalFormat, it, Fe, $.colorSpace),
                te = $.isVideoTexture !== !0,
                Ve = fe.__version === void 0 || ge === !0,
                Ce = ye.dataReady;
            let Xe = D($, Je);
            he(l.TEXTURE_CUBE_MAP, $);
            let Ee;
            if (Ze) {
                te && Ve && o.texStorage2D(l.TEXTURE_CUBE_MAP, Xe, ct, Je.width, Je.height);
                for (let ve = 0; ve < 6; ve++) {
                    Ee = qe[ve].mipmaps;
                    for (let Ye = 0; Ye < Ee.length; Ye++) {
                        const et = Ee[Ye];
                        $.format !== RGBAFormat ? it !== null ? te ? Ce && o.compressedTexSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ye, 0, 0, et.width, et.height, it, et.data) : o.compressedTexImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ye, ct, et.width, et.height, 0, et.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : te ? Ce && o.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ye, 0, 0, et.width, et.height, it, Fe, et.data) : o.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ye, ct, et.width, et.height, 0, it, Fe, et.data)
                    }
                }
            } else {
                if (Ee = $.mipmaps, te && Ve) {
                    Ee.length > 0 && Xe++;
                    const ve = Dt(qe[0]);
                    o.texStorage2D(l.TEXTURE_CUBE_MAP, Xe, ct, ve.width, ve.height)
                }
                for (let ve = 0; ve < 6; ve++)
                    if (Se) {
                        te ? Ce && o.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, 0, 0, 0, qe[ve].width, qe[ve].height, it, Fe, qe[ve].data) : o.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, 0, ct, qe[ve].width, qe[ve].height, 0, it, Fe, qe[ve].data);
                        for (let Ye = 0; Ye < Ee.length; Ye++) {
                            const kt = Ee[Ye].image[ve].image;
                            te ? Ce && o.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ye + 1, 0, 0, kt.width, kt.height, it, Fe, kt.data) : o.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ye + 1, ct, kt.width, kt.height, 0, it, Fe, kt.data)
                        }
                    } else {
                        te ? Ce && o.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, 0, 0, 0, it, Fe, qe[ve]) : o.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, 0, ct, it, Fe, qe[ve]);
                        for (let Ye = 0; Ye < Ee.length; Ye++) {
                            const et = Ee[Ye];
                            te ? Ce && o.texSubImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ye + 1, 0, 0, it, Fe, et.image[ve]) : o.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ye + 1, ct, it, Fe, et.image[ve])
                        }
                    }
            }
            P($) && w(l.TEXTURE_CUBE_MAP), fe.__version = ye.version, $.onUpdate && $.onUpdate($)
        }
        J.__version = $.version
    }

    function Pe(J, $, ae, ge, ye, fe) {
        const Ke = p.convert(ae.format, ae.colorSpace),
            Le = p.convert(ae.type),
            Oe = M(ae.internalFormat, Ke, Le, ae.colorSpace),
            Ze = c.get($),
            Se = c.get(ae);
        if (Se.__renderTarget = $, !Ze.__hasExternalTextures) {
            const qe = Math.max(1, $.width >> fe),
                Je = Math.max(1, $.height >> fe);
            ye === l.TEXTURE_3D || ye === l.TEXTURE_2D_ARRAY ? o.texImage3D(ye, fe, Oe, qe, Je, $.depth, 0, Ke, Le, null) : o.texImage2D(ye, fe, Oe, qe, Je, 0, Ke, Le, null)
        }
        o.bindFramebuffer(l.FRAMEBUFFER, J), ot($) ? g.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER, ge, ye, Se.__webglTexture, 0, ke($)) : (ye === l.TEXTURE_2D || ye >= l.TEXTURE_CUBE_MAP_POSITIVE_X && ye <= l.TEXTURE_CUBE_MAP_NEGATIVE_Z) && l.framebufferTexture2D(l.FRAMEBUFFER, ge, ye, Se.__webglTexture, fe), o.bindFramebuffer(l.FRAMEBUFFER, null)
    }

    function be(J, $, ae) {
        if (l.bindRenderbuffer(l.RENDERBUFFER, J), $.depthBuffer) {
            const ge = $.depthTexture,
                ye = ge && ge.isDepthTexture ? ge.type : null,
                fe = A($.stencilBuffer, ye),
                Ke = $.stencilBuffer ? l.DEPTH_STENCIL_ATTACHMENT : l.DEPTH_ATTACHMENT,
                Le = ke($);
            ot($) ? g.renderbufferStorageMultisampleEXT(l.RENDERBUFFER, Le, fe, $.width, $.height) : ae ? l.renderbufferStorageMultisample(l.RENDERBUFFER, Le, fe, $.width, $.height) : l.renderbufferStorage(l.RENDERBUFFER, fe, $.width, $.height), l.framebufferRenderbuffer(l.FRAMEBUFFER, Ke, l.RENDERBUFFER, J)
        } else {
            const ge = $.textures;
            for (let ye = 0; ye < ge.length; ye++) {
                const fe = ge[ye],
                    Ke = p.convert(fe.format, fe.colorSpace),
                    Le = p.convert(fe.type),
                    Oe = M(fe.internalFormat, Ke, Le, fe.colorSpace),
                    Ze = ke($);
                ae && ot($) === !1 ? l.renderbufferStorageMultisample(l.RENDERBUFFER, Ze, Oe, $.width, $.height) : ot($) ? g.renderbufferStorageMultisampleEXT(l.RENDERBUFFER, Ze, Oe, $.width, $.height) : l.renderbufferStorage(l.RENDERBUFFER, Oe, $.width, $.height)
            }
        }
        l.bindRenderbuffer(l.RENDERBUFFER, null)
    }

    function Be(J, $) {
        if ($ && $.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (o.bindFramebuffer(l.FRAMEBUFFER, J), !($.depthTexture && $.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const ge = c.get($.depthTexture);
        ge.__renderTarget = $, (!ge.__webglTexture || $.depthTexture.image.width !== $.width || $.depthTexture.image.height !== $.height) && ($.depthTexture.image.width = $.width, $.depthTexture.image.height = $.height, $.depthTexture.needsUpdate = !0), Y($.depthTexture, 0);
        const ye = ge.__webglTexture,
            fe = ke($);
        if ($.depthTexture.format === DepthFormat) ot($) ? g.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER, l.DEPTH_ATTACHMENT, l.TEXTURE_2D, ye, 0, fe) : l.framebufferTexture2D(l.FRAMEBUFFER, l.DEPTH_ATTACHMENT, l.TEXTURE_2D, ye, 0);
        else if ($.depthTexture.format === DepthStencilFormat) ot($) ? g.framebufferTexture2DMultisampleEXT(l.FRAMEBUFFER, l.DEPTH_STENCIL_ATTACHMENT, l.TEXTURE_2D, ye, 0, fe) : l.framebufferTexture2D(l.FRAMEBUFFER, l.DEPTH_STENCIL_ATTACHMENT, l.TEXTURE_2D, ye, 0);
        else throw new Error("Unknown depthTexture format")
    }

    function De(J) {
        const $ = c.get(J),
            ae = J.isWebGLCubeRenderTarget === !0;
        if ($.__boundDepthTexture !== J.depthTexture) {
            const ge = J.depthTexture;
            if ($.__depthDisposeCallback && $.__depthDisposeCallback(), ge) {
                const ye = () => {
                    delete $.__boundDepthTexture, delete $.__depthDisposeCallback, ge.removeEventListener("dispose", ye)
                };
                ge.addEventListener("dispose", ye), $.__depthDisposeCallback = ye
            }
            $.__boundDepthTexture = ge
        }
        if (J.depthTexture && !$.__autoAllocateDepthBuffer) {
            if (ae) throw new Error("target.depthTexture not supported in Cube render targets");
            const ge = J.texture.mipmaps;
            ge && ge.length > 0 ? Be($.__webglFramebuffer[0], J) : Be($.__webglFramebuffer, J)
        } else if (ae) {
            $.__webglDepthbuffer = [];
            for (let ge = 0; ge < 6; ge++)
                if (o.bindFramebuffer(l.FRAMEBUFFER, $.__webglFramebuffer[ge]), $.__webglDepthbuffer[ge] === void 0) $.__webglDepthbuffer[ge] = l.createRenderbuffer(), be($.__webglDepthbuffer[ge], J, !1);
                else {
                    const ye = J.stencilBuffer ? l.DEPTH_STENCIL_ATTACHMENT : l.DEPTH_ATTACHMENT,
                        fe = $.__webglDepthbuffer[ge];
                    l.bindRenderbuffer(l.RENDERBUFFER, fe), l.framebufferRenderbuffer(l.FRAMEBUFFER, ye, l.RENDERBUFFER, fe)
                }
        } else {
            const ge = J.texture.mipmaps;
            if (ge && ge.length > 0 ? o.bindFramebuffer(l.FRAMEBUFFER, $.__webglFramebuffer[0]) : o.bindFramebuffer(l.FRAMEBUFFER, $.__webglFramebuffer), $.__webglDepthbuffer === void 0) $.__webglDepthbuffer = l.createRenderbuffer(), be($.__webglDepthbuffer, J, !1);
            else {
                const ye = J.stencilBuffer ? l.DEPTH_STENCIL_ATTACHMENT : l.DEPTH_ATTACHMENT,
                    fe = $.__webglDepthbuffer;
                l.bindRenderbuffer(l.RENDERBUFFER, fe), l.framebufferRenderbuffer(l.FRAMEBUFFER, ye, l.RENDERBUFFER, fe)
            }
        }
        o.bindFramebuffer(l.FRAMEBUFFER, null)
    }

    function We(J, $, ae) {
        const ge = c.get(J);
        $ !== void 0 && Pe(ge.__webglFramebuffer, J, J.texture, l.COLOR_ATTACHMENT0, l.TEXTURE_2D, 0), ae !== void 0 && De(J)
    }

    function Re(J) {
        const $ = J.texture,
            ae = c.get(J),
            ge = c.get($);
        J.addEventListener("dispose", I);
        const ye = J.textures,
            fe = J.isWebGLCubeRenderTarget === !0,
            Ke = ye.length > 1;
        if (Ke || (ge.__webglTexture === void 0 && (ge.__webglTexture = l.createTexture()), ge.__version = $.version, m.memory.textures++), fe) {
            ae.__webglFramebuffer = [];
            for (let Le = 0; Le < 6; Le++)
                if ($.mipmaps && $.mipmaps.length > 0) {
                    ae.__webglFramebuffer[Le] = [];
                    for (let Oe = 0; Oe < $.mipmaps.length; Oe++) ae.__webglFramebuffer[Le][Oe] = l.createFramebuffer()
                } else ae.__webglFramebuffer[Le] = l.createFramebuffer()
        } else {
            if ($.mipmaps && $.mipmaps.length > 0) {
                ae.__webglFramebuffer = [];
                for (let Le = 0; Le < $.mipmaps.length; Le++) ae.__webglFramebuffer[Le] = l.createFramebuffer()
            } else ae.__webglFramebuffer = l.createFramebuffer();
            if (Ke)
                for (let Le = 0, Oe = ye.length; Le < Oe; Le++) {
                    const Ze = c.get(ye[Le]);
                    Ze.__webglTexture === void 0 && (Ze.__webglTexture = l.createTexture(), m.memory.textures++)
                }
            if (J.samples > 0 && ot(J) === !1) {
                ae.__webglMultisampledFramebuffer = l.createFramebuffer(), ae.__webglColorRenderbuffer = [], o.bindFramebuffer(l.FRAMEBUFFER, ae.__webglMultisampledFramebuffer);
                for (let Le = 0; Le < ye.length; Le++) {
                    const Oe = ye[Le];
                    ae.__webglColorRenderbuffer[Le] = l.createRenderbuffer(), l.bindRenderbuffer(l.RENDERBUFFER, ae.__webglColorRenderbuffer[Le]);
                    const Ze = p.convert(Oe.format, Oe.colorSpace),
                        Se = p.convert(Oe.type),
                        qe = M(Oe.internalFormat, Ze, Se, Oe.colorSpace, J.isXRRenderTarget === !0),
                        Je = ke(J);
                    l.renderbufferStorageMultisample(l.RENDERBUFFER, Je, qe, J.width, J.height), l.framebufferRenderbuffer(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0 + Le, l.RENDERBUFFER, ae.__webglColorRenderbuffer[Le])
                }
                l.bindRenderbuffer(l.RENDERBUFFER, null), J.depthBuffer && (ae.__webglDepthRenderbuffer = l.createRenderbuffer(), be(ae.__webglDepthRenderbuffer, J, !0)), o.bindFramebuffer(l.FRAMEBUFFER, null)
            }
        }
        if (fe) {
            o.bindTexture(l.TEXTURE_CUBE_MAP, ge.__webglTexture), he(l.TEXTURE_CUBE_MAP, $);
            for (let Le = 0; Le < 6; Le++)
                if ($.mipmaps && $.mipmaps.length > 0)
                    for (let Oe = 0; Oe < $.mipmaps.length; Oe++) Pe(ae.__webglFramebuffer[Le][Oe], J, $, l.COLOR_ATTACHMENT0, l.TEXTURE_CUBE_MAP_POSITIVE_X + Le, Oe);
                else Pe(ae.__webglFramebuffer[Le], J, $, l.COLOR_ATTACHMENT0, l.TEXTURE_CUBE_MAP_POSITIVE_X + Le, 0);
            P($) && w(l.TEXTURE_CUBE_MAP), o.unbindTexture()
        } else if (Ke) {
            for (let Le = 0, Oe = ye.length; Le < Oe; Le++) {
                const Ze = ye[Le],
                    Se = c.get(Ze);
                o.bindTexture(l.TEXTURE_2D, Se.__webglTexture), he(l.TEXTURE_2D, Ze), Pe(ae.__webglFramebuffer, J, Ze, l.COLOR_ATTACHMENT0 + Le, l.TEXTURE_2D, 0), P(Ze) && w(l.TEXTURE_2D)
            }
            o.unbindTexture()
        } else {
            let Le = l.TEXTURE_2D;
            if ((J.isWebGL3DRenderTarget || J.isWebGLArrayRenderTarget) && (Le = J.isWebGL3DRenderTarget ? l.TEXTURE_3D : l.TEXTURE_2D_ARRAY), o.bindTexture(Le, ge.__webglTexture), he(Le, $), $.mipmaps && $.mipmaps.length > 0)
                for (let Oe = 0; Oe < $.mipmaps.length; Oe++) Pe(ae.__webglFramebuffer[Oe], J, $, l.COLOR_ATTACHMENT0, Le, Oe);
            else Pe(ae.__webglFramebuffer, J, $, l.COLOR_ATTACHMENT0, Le, 0);
            P($) && w(Le), o.unbindTexture()
        }
        J.depthBuffer && De(J)
    }

    function q(J) {
        const $ = J.textures;
        for (let ae = 0, ge = $.length; ae < ge; ae++) {
            const ye = $[ae];
            if (P(ye)) {
                const fe = T(J),
                    Ke = c.get(ye).__webglTexture;
                o.bindTexture(fe, Ke), w(fe), o.unbindTexture()
            }
        }
    }
    const At = [],
        dt = [];

    function tt(J) {
        if (J.samples > 0) {
            if (ot(J) === !1) {
                const $ = J.textures,
                    ae = J.width,
                    ge = J.height;
                let ye = l.COLOR_BUFFER_BIT;
                const fe = J.stencilBuffer ? l.DEPTH_STENCIL_ATTACHMENT : l.DEPTH_ATTACHMENT,
                    Ke = c.get(J),
                    Le = $.length > 1;
                if (Le)
                    for (let Ze = 0; Ze < $.length; Ze++) o.bindFramebuffer(l.FRAMEBUFFER, Ke.__webglMultisampledFramebuffer), l.framebufferRenderbuffer(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0 + Ze, l.RENDERBUFFER, null), o.bindFramebuffer(l.FRAMEBUFFER, Ke.__webglFramebuffer), l.framebufferTexture2D(l.DRAW_FRAMEBUFFER, l.COLOR_ATTACHMENT0 + Ze, l.TEXTURE_2D, null, 0);
                o.bindFramebuffer(l.READ_FRAMEBUFFER, Ke.__webglMultisampledFramebuffer);
                const Oe = J.texture.mipmaps;
                Oe && Oe.length > 0 ? o.bindFramebuffer(l.DRAW_FRAMEBUFFER, Ke.__webglFramebuffer[0]) : o.bindFramebuffer(l.DRAW_FRAMEBUFFER, Ke.__webglFramebuffer);
                for (let Ze = 0; Ze < $.length; Ze++) {
                    if (J.resolveDepthBuffer && (J.depthBuffer && (ye |= l.DEPTH_BUFFER_BIT), J.stencilBuffer && J.resolveStencilBuffer && (ye |= l.STENCIL_BUFFER_BIT)), Le) {
                        l.framebufferRenderbuffer(l.READ_FRAMEBUFFER, l.COLOR_ATTACHMENT0, l.RENDERBUFFER, Ke.__webglColorRenderbuffer[Ze]);
                        const Se = c.get($[Ze]).__webglTexture;
                        l.framebufferTexture2D(l.DRAW_FRAMEBUFFER, l.COLOR_ATTACHMENT0, l.TEXTURE_2D, Se, 0)
                    }
                    l.blitFramebuffer(0, 0, ae, ge, 0, 0, ae, ge, ye, l.NEAREST), _ === !0 && (At.length = 0, dt.length = 0, At.push(l.COLOR_ATTACHMENT0 + Ze), J.depthBuffer && J.resolveDepthBuffer === !1 && (At.push(fe), dt.push(fe), l.invalidateFramebuffer(l.DRAW_FRAMEBUFFER, dt)), l.invalidateFramebuffer(l.READ_FRAMEBUFFER, At))
                }
                if (o.bindFramebuffer(l.READ_FRAMEBUFFER, null), o.bindFramebuffer(l.DRAW_FRAMEBUFFER, null), Le)
                    for (let Ze = 0; Ze < $.length; Ze++) {
                        o.bindFramebuffer(l.FRAMEBUFFER, Ke.__webglMultisampledFramebuffer), l.framebufferRenderbuffer(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0 + Ze, l.RENDERBUFFER, Ke.__webglColorRenderbuffer[Ze]);
                        const Se = c.get($[Ze]).__webglTexture;
                        o.bindFramebuffer(l.FRAMEBUFFER, Ke.__webglFramebuffer), l.framebufferTexture2D(l.DRAW_FRAMEBUFFER, l.COLOR_ATTACHMENT0 + Ze, l.TEXTURE_2D, Se, 0)
                    }
                o.bindFramebuffer(l.DRAW_FRAMEBUFFER, Ke.__webglMultisampledFramebuffer)
            } else if (J.depthBuffer && J.resolveDepthBuffer === !1 && _) {
                const $ = J.stencilBuffer ? l.DEPTH_STENCIL_ATTACHMENT : l.DEPTH_ATTACHMENT;
                l.invalidateFramebuffer(l.DRAW_FRAMEBUFFER, [$])
            }
        }
    }

    function ke(J) {
        return Math.min(u.maxSamples, J.samples)
    }

    function ot(J) {
        const $ = c.get(J);
        return J.samples > 0 && i.has("WEBGL_multisampled_render_to_texture") === !0 && $.__useRenderToTexture !== !1
    }

    function ze(J) {
        const $ = m.render.frame;
        x.get(J) !== $ && (x.set(J, $), J.update())
    }

    function Ie(J, $) {
        const ae = J.colorSpace,
            ge = J.format,
            ye = J.type;
        return J.isCompressedTexture === !0 || J.isVideoTexture === !0 || ae !== LinearSRGBColorSpace && ae !== NoColorSpace && (ColorManagement.getTransfer(ae) === SRGBTransfer ? (ge !== RGBAFormat || ye !== UnsignedByteType) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ae)), $
    }

    function Dt(J) {
        return typeof HTMLImageElement < "u" && J instanceof HTMLImageElement ? (v.width = J.naturalWidth || J.width, v.height = J.naturalHeight || J.height) : typeof VideoFrame < "u" && J instanceof VideoFrame ? (v.width = J.displayWidth, v.height = J.displayHeight) : (v.width = J.width, v.height = J.height), v
    }
    this.allocateTextureUnit = H, this.resetTextureUnits = U, this.setTexture2D = Y, this.setTexture2DArray = O, this.setTexture3D = G, this.setTextureCube = L, this.rebindTextures = We, this.setupRenderTarget = Re, this.updateRenderTargetMipmap = q, this.updateMultisampleRenderTarget = tt, this.setupDepthRenderbuffer = De, this.setupFrameBufferTexture = Pe, this.useMultisampledRTT = ot
}

function WebGLUtils(l, i) {
    function o(c, u = NoColorSpace) {
        let p;
        const m = ColorManagement.getTransfer(u);
        if (c === UnsignedByteType) return l.UNSIGNED_BYTE;
        if (c === UnsignedShort4444Type) return l.UNSIGNED_SHORT_4_4_4_4;
        if (c === UnsignedShort5551Type) return l.UNSIGNED_SHORT_5_5_5_1;
        if (c === UnsignedInt5999Type) return l.UNSIGNED_INT_5_9_9_9_REV;
        if (c === ByteType) return l.BYTE;
        if (c === ShortType) return l.SHORT;
        if (c === UnsignedShortType) return l.UNSIGNED_SHORT;
        if (c === IntType) return l.INT;
        if (c === UnsignedIntType) return l.UNSIGNED_INT;
        if (c === FloatType) return l.FLOAT;
        if (c === HalfFloatType) return l.HALF_FLOAT;
        if (c === AlphaFormat) return l.ALPHA;
        if (c === RGBFormat) return l.RGB;
        if (c === RGBAFormat) return l.RGBA;
        if (c === DepthFormat) return l.DEPTH_COMPONENT;
        if (c === DepthStencilFormat) return l.DEPTH_STENCIL;
        if (c === RedFormat) return l.RED;
        if (c === RedIntegerFormat) return l.RED_INTEGER;
        if (c === RGFormat) return l.RG;
        if (c === RGIntegerFormat) return l.RG_INTEGER;
        if (c === RGBAIntegerFormat) return l.RGBA_INTEGER;
        if (c === RGB_S3TC_DXT1_Format || c === RGBA_S3TC_DXT1_Format || c === RGBA_S3TC_DXT3_Format || c === RGBA_S3TC_DXT5_Format)
            if (m === SRGBTransfer)
                if (p = i.get("WEBGL_compressed_texture_s3tc_srgb"), p !== null) {
                    if (c === RGB_S3TC_DXT1_Format) return p.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (c === RGBA_S3TC_DXT1_Format) return p.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (c === RGBA_S3TC_DXT3_Format) return p.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (c === RGBA_S3TC_DXT5_Format) return p.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else return null;
        else if (p = i.get("WEBGL_compressed_texture_s3tc"), p !== null) {
            if (c === RGB_S3TC_DXT1_Format) return p.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (c === RGBA_S3TC_DXT1_Format) return p.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (c === RGBA_S3TC_DXT3_Format) return p.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (c === RGBA_S3TC_DXT5_Format) return p.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } else return null;
        if (c === RGB_PVRTC_4BPPV1_Format || c === RGB_PVRTC_2BPPV1_Format || c === RGBA_PVRTC_4BPPV1_Format || c === RGBA_PVRTC_2BPPV1_Format)
            if (p = i.get("WEBGL_compressed_texture_pvrtc"), p !== null) {
                if (c === RGB_PVRTC_4BPPV1_Format) return p.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (c === RGB_PVRTC_2BPPV1_Format) return p.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (c === RGBA_PVRTC_4BPPV1_Format) return p.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (c === RGBA_PVRTC_2BPPV1_Format) return p.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else return null;
        if (c === RGB_ETC1_Format || c === RGB_ETC2_Format || c === RGBA_ETC2_EAC_Format)
            if (p = i.get("WEBGL_compressed_texture_etc"), p !== null) {
                if (c === RGB_ETC1_Format || c === RGB_ETC2_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ETC2 : p.COMPRESSED_RGB8_ETC2;
                if (c === RGBA_ETC2_EAC_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : p.COMPRESSED_RGBA8_ETC2_EAC
            } else return null;
        if (c === RGBA_ASTC_4x4_Format || c === RGBA_ASTC_5x4_Format || c === RGBA_ASTC_5x5_Format || c === RGBA_ASTC_6x5_Format || c === RGBA_ASTC_6x6_Format || c === RGBA_ASTC_8x5_Format || c === RGBA_ASTC_8x6_Format || c === RGBA_ASTC_8x8_Format || c === RGBA_ASTC_10x5_Format || c === RGBA_ASTC_10x6_Format || c === RGBA_ASTC_10x8_Format || c === RGBA_ASTC_10x10_Format || c === RGBA_ASTC_12x10_Format || c === RGBA_ASTC_12x12_Format)
            if (p = i.get("WEBGL_compressed_texture_astc"), p !== null) {
                if (c === RGBA_ASTC_4x4_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : p.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (c === RGBA_ASTC_5x4_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : p.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (c === RGBA_ASTC_5x5_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : p.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (c === RGBA_ASTC_6x5_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : p.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (c === RGBA_ASTC_6x6_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : p.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (c === RGBA_ASTC_8x5_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : p.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (c === RGBA_ASTC_8x6_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : p.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (c === RGBA_ASTC_8x8_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : p.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (c === RGBA_ASTC_10x5_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : p.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (c === RGBA_ASTC_10x6_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : p.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (c === RGBA_ASTC_10x8_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : p.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (c === RGBA_ASTC_10x10_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : p.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (c === RGBA_ASTC_12x10_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : p.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (c === RGBA_ASTC_12x12_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : p.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else return null;
        if (c === RGBA_BPTC_Format || c === RGB_BPTC_SIGNED_Format || c === RGB_BPTC_UNSIGNED_Format)
            if (p = i.get("EXT_texture_compression_bptc"), p !== null) {
                if (c === RGBA_BPTC_Format) return m === SRGBTransfer ? p.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : p.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (c === RGB_BPTC_SIGNED_Format) return p.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (c === RGB_BPTC_UNSIGNED_Format) return p.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else return null;
        if (c === RED_RGTC1_Format || c === SIGNED_RED_RGTC1_Format || c === RED_GREEN_RGTC2_Format || c === SIGNED_RED_GREEN_RGTC2_Format)
            if (p = i.get("EXT_texture_compression_rgtc"), p !== null) {
                if (c === RGBA_BPTC_Format) return p.COMPRESSED_RED_RGTC1_EXT;
                if (c === SIGNED_RED_RGTC1_Format) return p.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (c === RED_GREEN_RGTC2_Format) return p.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (c === SIGNED_RED_GREEN_RGTC2_Format) return p.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else return null;
        return c === UnsignedInt248Type ? l.UNSIGNED_INT_24_8 : l[c] !== void 0 ? l[c] : null
    }
    return {
        convert: o
    }
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
    _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
    constructor() {
        this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
    }
    init(i, o, c) {
        if (this.texture === null) {
            const u = new Texture,
                p = i.properties.get(u);
            p.__webglTexture = o.texture, (o.depthNear !== c.depthNear || o.depthFar !== c.depthFar) && (this.depthNear = o.depthNear, this.depthFar = o.depthFar), this.texture = u
        }
    }
    getMesh(i) {
        if (this.texture !== null && this.mesh === null) {
            const o = i.cameras[0].viewport,
                c = new ShaderMaterial({
                    vertexShader: _occlusion_vertex,
                    fragmentShader: _occlusion_fragment,
                    uniforms: {
                        depthColor: {
                            value: this.texture
                        },
                        depthWidth: {
                            value: o.z
                        },
                        depthHeight: {
                            value: o.w
                        }
                    }
                });
            this.mesh = new Mesh(new PlaneGeometry(20, 20), c)
        }
        return this.mesh
    }
    reset() {
        this.texture = null, this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class WebXRManager extends EventDispatcher {
    constructor(i, o) {
        super();
        const c = this;
        let u = null,
            p = 1,
            m = null,
            g = "local-floor",
            _ = 1,
            v = null,
            x = null,
            y = null,
            b = null,
            S = null,
            C = null;
        const E = new WebXRDepthSensing,
            P = o.getContextAttributes();
        let w = null,
            T = null;
        const M = [],
            A = [],
            D = new Vector2;
        let R = null;
        const I = new PerspectiveCamera;
        I.viewport = new Vector4;
        const k = new PerspectiveCamera;
        k.viewport = new Vector4;
        const F = [I, k],
            V = new ArrayCamera;
        let B = null,
            U = null;
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(ie) {
            let _e = M[ie];
            return _e === void 0 && (_e = new WebXRController, M[ie] = _e), _e.getTargetRaySpace()
        }, this.getControllerGrip = function(ie) {
            let _e = M[ie];
            return _e === void 0 && (_e = new WebXRController, M[ie] = _e), _e.getGripSpace()
        }, this.getHand = function(ie) {
            let _e = M[ie];
            return _e === void 0 && (_e = new WebXRController, M[ie] = _e), _e.getHandSpace()
        };

        function H(ie) {
            const _e = A.indexOf(ie.inputSource);
            if (_e === -1) return;
            const Te = M[_e];
            Te !== void 0 && (Te.update(ie.inputSource, ie.frame, v || m), Te.dispatchEvent({
                type: ie.type,
                data: ie.inputSource
            }))
        }

        function Q() {
            u.removeEventListener("select", H), u.removeEventListener("selectstart", H), u.removeEventListener("selectend", H), u.removeEventListener("squeeze", H), u.removeEventListener("squeezestart", H), u.removeEventListener("squeezeend", H), u.removeEventListener("end", Q), u.removeEventListener("inputsourceschange", Y);
            for (let ie = 0; ie < M.length; ie++) {
                const _e = A[ie];
                _e !== null && (A[ie] = null, M[ie].disconnect(_e))
            }
            B = null, U = null, E.reset(), i.setRenderTarget(w), S = null, b = null, y = null, u = null, T = null, we.stop(), c.isPresenting = !1, i.setPixelRatio(R), i.setSize(D.width, D.height, !1), c.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(ie) {
            p = ie, c.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function(ie) {
            g = ie, c.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function() {
            return v || m
        }, this.setReferenceSpace = function(ie) {
            v = ie
        }, this.getBaseLayer = function() {
            return b !== null ? b : S
        }, this.getBinding = function() {
            return y
        }, this.getFrame = function() {
            return C
        }, this.getSession = function() {
            return u
        }, this.setSession = async function(ie) {
            if (u = ie, u !== null) {
                if (w = i.getRenderTarget(), u.addEventListener("select", H), u.addEventListener("selectstart", H), u.addEventListener("selectend", H), u.addEventListener("squeeze", H), u.addEventListener("squeezestart", H), u.addEventListener("squeezeend", H), u.addEventListener("end", Q), u.addEventListener("inputsourceschange", Y), P.xrCompatible !== !0 && await o.makeXRCompatible(), R = i.getPixelRatio(), i.getSize(D), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                    let Te = null,
                        Me = null,
                        Pe = null;
                    P.depth && (Pe = P.stencil ? o.DEPTH24_STENCIL8 : o.DEPTH_COMPONENT24, Te = P.stencil ? DepthStencilFormat : DepthFormat, Me = P.stencil ? UnsignedInt248Type : UnsignedIntType);
                    const be = {
                        colorFormat: o.RGBA8,
                        depthFormat: Pe,
                        scaleFactor: p
                    };
                    y = new XRWebGLBinding(u, o), b = y.createProjectionLayer(be), u.updateRenderState({
                        layers: [b]
                    }), i.setPixelRatio(1), i.setSize(b.textureWidth, b.textureHeight, !1), T = new WebGLRenderTarget(b.textureWidth, b.textureHeight, {
                        format: RGBAFormat,
                        type: UnsignedByteType,
                        depthTexture: new DepthTexture(b.textureWidth, b.textureHeight, Me, void 0, void 0, void 0, void 0, void 0, void 0, Te),
                        stencilBuffer: P.stencil,
                        colorSpace: i.outputColorSpace,
                        samples: P.antialias ? 4 : 0,
                        resolveDepthBuffer: b.ignoreDepthValues === !1,
                        resolveStencilBuffer: b.ignoreDepthValues === !1
                    })
                } else {
                    const Te = {
                        antialias: P.antialias,
                        alpha: !0,
                        depth: P.depth,
                        stencil: P.stencil,
                        framebufferScaleFactor: p
                    };
                    S = new XRWebGLLayer(u, o, Te), u.updateRenderState({
                        baseLayer: S
                    }), i.setPixelRatio(1), i.setSize(S.framebufferWidth, S.framebufferHeight, !1), T = new WebGLRenderTarget(S.framebufferWidth, S.framebufferHeight, {
                        format: RGBAFormat,
                        type: UnsignedByteType,
                        colorSpace: i.outputColorSpace,
                        stencilBuffer: P.stencil,
                        resolveDepthBuffer: S.ignoreDepthValues === !1,
                        resolveStencilBuffer: S.ignoreDepthValues === !1
                    })
                }
                T.isXRRenderTarget = !0, this.setFoveation(_), v = null, m = await u.requestReferenceSpace(g), we.setContext(u), we.start(), c.isPresenting = !0, c.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }, this.getEnvironmentBlendMode = function() {
            if (u !== null) return u.environmentBlendMode
        }, this.getDepthTexture = function() {
            return E.getDepthTexture()
        };

        function Y(ie) {
            for (let _e = 0; _e < ie.removed.length; _e++) {
                const Te = ie.removed[_e],
                    Me = A.indexOf(Te);
                Me >= 0 && (A[Me] = null, M[Me].disconnect(Te))
            }
            for (let _e = 0; _e < ie.added.length; _e++) {
                const Te = ie.added[_e];
                let Me = A.indexOf(Te);
                if (Me === -1) {
                    for (let be = 0; be < M.length; be++)
                        if (be >= A.length) {
                            A.push(Te), Me = be;
                            break
                        } else if (A[be] === null) {
                        A[be] = Te, Me = be;
                        break
                    }
                    if (Me === -1) break
                }
                const Pe = M[Me];
                Pe && Pe.connect(Te)
            }
        }
        const O = new Vector3$1,
            G = new Vector3$1;

        function L(ie, _e, Te) {
            O.setFromMatrixPosition(_e.matrixWorld), G.setFromMatrixPosition(Te.matrixWorld);
            const Me = O.distanceTo(G),
                Pe = _e.projectionMatrix.elements,
                be = Te.projectionMatrix.elements,
                Be = Pe[14] / (Pe[10] - 1),
                De = Pe[14] / (Pe[10] + 1),
                We = (Pe[9] + 1) / Pe[5],
                Re = (Pe[9] - 1) / Pe[5],
                q = (Pe[8] - 1) / Pe[0],
                At = (be[8] + 1) / be[0],
                dt = Be * q,
                tt = Be * At,
                ke = Me / (-q + At),
                ot = ke * -q;
            if (_e.matrixWorld.decompose(ie.position, ie.quaternion, ie.scale), ie.translateX(ot), ie.translateZ(ke), ie.matrixWorld.compose(ie.position, ie.quaternion, ie.scale), ie.matrixWorldInverse.copy(ie.matrixWorld).invert(), Pe[10] === -1) ie.projectionMatrix.copy(_e.projectionMatrix), ie.projectionMatrixInverse.copy(_e.projectionMatrixInverse);
            else {
                const ze = Be + ke,
                    Ie = De + ke,
                    Dt = dt - ot,
                    J = tt + (Me - ot),
                    $ = We * De / Ie * ze,
                    ae = Re * De / Ie * ze;
                ie.projectionMatrix.makePerspective(Dt, J, $, ae, ze, Ie), ie.projectionMatrixInverse.copy(ie.projectionMatrix).invert()
            }
        }

        function N(ie, _e) {
            _e === null ? ie.matrixWorld.copy(ie.matrix) : ie.matrixWorld.multiplyMatrices(_e.matrixWorld, ie.matrix), ie.matrixWorldInverse.copy(ie.matrixWorld).invert()
        }
        this.updateCamera = function(ie) {
            if (u === null) return;
            let _e = ie.near,
                Te = ie.far;
            E.texture !== null && (E.depthNear > 0 && (_e = E.depthNear), E.depthFar > 0 && (Te = E.depthFar)), V.near = k.near = I.near = _e, V.far = k.far = I.far = Te, (B !== V.near || U !== V.far) && (u.updateRenderState({
                depthNear: V.near,
                depthFar: V.far
            }), B = V.near, U = V.far), I.layers.mask = ie.layers.mask | 2, k.layers.mask = ie.layers.mask | 4, V.layers.mask = I.layers.mask | k.layers.mask;
            const Me = ie.parent,
                Pe = V.cameras;
            N(V, Me);
            for (let be = 0; be < Pe.length; be++) N(Pe[be], Me);
            Pe.length === 2 ? L(V, I, k) : V.projectionMatrix.copy(I.projectionMatrix), K(ie, V, Me)
        };

        function K(ie, _e, Te) {
            Te === null ? ie.matrix.copy(_e.matrixWorld) : (ie.matrix.copy(Te.matrixWorld), ie.matrix.invert(), ie.matrix.multiply(_e.matrixWorld)), ie.matrix.decompose(ie.position, ie.quaternion, ie.scale), ie.updateMatrixWorld(!0), ie.projectionMatrix.copy(_e.projectionMatrix), ie.projectionMatrixInverse.copy(_e.projectionMatrixInverse), ie.isPerspectiveCamera && (ie.fov = RAD2DEG * 2 * Math.atan(1 / ie.projectionMatrix.elements[5]), ie.zoom = 1)
        }
        this.getCamera = function() {
            return V
        }, this.getFoveation = function() {
            if (!(b === null && S === null)) return _
        }, this.setFoveation = function(ie) {
            _ = ie, b !== null && (b.fixedFoveation = ie), S !== null && S.fixedFoveation !== void 0 && (S.fixedFoveation = ie)
        }, this.hasDepthSensing = function() {
            return E.texture !== null
        }, this.getDepthSensingMesh = function() {
            return E.getMesh(V)
        };
        let Z = null;

        function he(ie, _e) {
            if (x = _e.getViewerPose(v || m), C = _e, x !== null) {
                const Te = x.views;
                S !== null && (i.setRenderTargetFramebuffer(T, S.framebuffer), i.setRenderTarget(T));
                let Me = !1;
                Te.length !== V.cameras.length && (V.cameras.length = 0, Me = !0);
                for (let Be = 0; Be < Te.length; Be++) {
                    const De = Te[Be];
                    let We = null;
                    if (S !== null) We = S.getViewport(De);
                    else {
                        const q = y.getViewSubImage(b, De);
                        We = q.viewport, Be === 0 && (i.setRenderTargetTextures(T, q.colorTexture, q.depthStencilTexture), i.setRenderTarget(T))
                    }
                    let Re = F[Be];
                    Re === void 0 && (Re = new PerspectiveCamera, Re.layers.enable(Be), Re.viewport = new Vector4, F[Be] = Re), Re.matrix.fromArray(De.transform.matrix), Re.matrix.decompose(Re.position, Re.quaternion, Re.scale), Re.projectionMatrix.fromArray(De.projectionMatrix), Re.projectionMatrixInverse.copy(Re.projectionMatrix).invert(), Re.viewport.set(We.x, We.y, We.width, We.height), Be === 0 && (V.matrix.copy(Re.matrix), V.matrix.decompose(V.position, V.quaternion, V.scale)), Me === !0 && V.cameras.push(Re)
                }
                const Pe = u.enabledFeatures;
                if (Pe && Pe.includes("depth-sensing") && u.depthUsage == "gpu-optimized" && y) {
                    const Be = y.getDepthInformation(Te[0]);
                    Be && Be.isValid && Be.texture && E.init(i, Be, u.renderState)
                }
            }
            for (let Te = 0; Te < M.length; Te++) {
                const Me = A[Te],
                    Pe = M[Te];
                Me !== null && Pe !== void 0 && Pe.update(Me, _e, v || m)
            }
            Z && Z(ie, _e), _e.detectedPlanes && c.dispatchEvent({
                type: "planesdetected",
                data: _e
            }), C = null
        }
        const we = new WebGLAnimation;
        we.setAnimationLoop(he), this.setAnimationLoop = function(ie) {
            Z = ie
        }, this.dispose = function() {}
    }
}
const _e1 = new Euler$1,
    _m1 = new Matrix4;

function WebGLMaterials(l, i) {
    function o(P, w) {
        P.matrixAutoUpdate === !0 && P.updateMatrix(), w.value.copy(P.matrix)
    }

    function c(P, w) {
        w.color.getRGB(P.fogColor.value, getUnlitUniformColorSpace(l)), w.isFog ? (P.fogNear.value = w.near, P.fogFar.value = w.far) : w.isFogExp2 && (P.fogDensity.value = w.density)
    }

    function u(P, w, T, M, A) {
        w.isMeshBasicMaterial || w.isMeshLambertMaterial ? p(P, w) : w.isMeshToonMaterial ? (p(P, w), y(P, w)) : w.isMeshPhongMaterial ? (p(P, w), x(P, w)) : w.isMeshStandardMaterial ? (p(P, w), b(P, w), w.isMeshPhysicalMaterial && S(P, w, A)) : w.isMeshMatcapMaterial ? (p(P, w), C(P, w)) : w.isMeshDepthMaterial ? p(P, w) : w.isMeshDistanceMaterial ? (p(P, w), E(P, w)) : w.isMeshNormalMaterial ? p(P, w) : w.isLineBasicMaterial ? (m(P, w), w.isLineDashedMaterial && g(P, w)) : w.isPointsMaterial ? _(P, w, T, M) : w.isSpriteMaterial ? v(P, w) : w.isShadowMaterial ? (P.color.value.copy(w.color), P.opacity.value = w.opacity) : w.isShaderMaterial && (w.uniformsNeedUpdate = !1)
    }

    function p(P, w) {
        P.opacity.value = w.opacity, w.color && P.diffuse.value.copy(w.color), w.emissive && P.emissive.value.copy(w.emissive).multiplyScalar(w.emissiveIntensity), w.map && (P.map.value = w.map, o(w.map, P.mapTransform)), w.alphaMap && (P.alphaMap.value = w.alphaMap, o(w.alphaMap, P.alphaMapTransform)), w.bumpMap && (P.bumpMap.value = w.bumpMap, o(w.bumpMap, P.bumpMapTransform), P.bumpScale.value = w.bumpScale, w.side === BackSide && (P.bumpScale.value *= -1)), w.normalMap && (P.normalMap.value = w.normalMap, o(w.normalMap, P.normalMapTransform), P.normalScale.value.copy(w.normalScale), w.side === BackSide && P.normalScale.value.negate()), w.displacementMap && (P.displacementMap.value = w.displacementMap, o(w.displacementMap, P.displacementMapTransform), P.displacementScale.value = w.displacementScale, P.displacementBias.value = w.displacementBias), w.emissiveMap && (P.emissiveMap.value = w.emissiveMap, o(w.emissiveMap, P.emissiveMapTransform)), w.specularMap && (P.specularMap.value = w.specularMap, o(w.specularMap, P.specularMapTransform)), w.alphaTest > 0 && (P.alphaTest.value = w.alphaTest);
        const T = i.get(w),
            M = T.envMap,
            A = T.envMapRotation;
        M && (P.envMap.value = M, _e1.copy(A), _e1.x *= -1, _e1.y *= -1, _e1.z *= -1, M.isCubeTexture && M.isRenderTargetTexture === !1 && (_e1.y *= -1, _e1.z *= -1), P.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)), P.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, P.reflectivity.value = w.reflectivity, P.ior.value = w.ior, P.refractionRatio.value = w.refractionRatio), w.lightMap && (P.lightMap.value = w.lightMap, P.lightMapIntensity.value = w.lightMapIntensity, o(w.lightMap, P.lightMapTransform)), w.aoMap && (P.aoMap.value = w.aoMap, P.aoMapIntensity.value = w.aoMapIntensity, o(w.aoMap, P.aoMapTransform))
    }

    function m(P, w) {
        P.diffuse.value.copy(w.color), P.opacity.value = w.opacity, w.map && (P.map.value = w.map, o(w.map, P.mapTransform))
    }

    function g(P, w) {
        P.dashSize.value = w.dashSize, P.totalSize.value = w.dashSize + w.gapSize, P.scale.value = w.scale
    }

    function _(P, w, T, M) {
        P.diffuse.value.copy(w.color), P.opacity.value = w.opacity, P.size.value = w.size * T, P.scale.value = M * .5, w.map && (P.map.value = w.map, o(w.map, P.uvTransform)), w.alphaMap && (P.alphaMap.value = w.alphaMap, o(w.alphaMap, P.alphaMapTransform)), w.alphaTest > 0 && (P.alphaTest.value = w.alphaTest)
    }

    function v(P, w) {
        P.diffuse.value.copy(w.color), P.opacity.value = w.opacity, P.rotation.value = w.rotation, w.map && (P.map.value = w.map, o(w.map, P.mapTransform)), w.alphaMap && (P.alphaMap.value = w.alphaMap, o(w.alphaMap, P.alphaMapTransform)), w.alphaTest > 0 && (P.alphaTest.value = w.alphaTest)
    }

    function x(P, w) {
        P.specular.value.copy(w.specular), P.shininess.value = Math.max(w.shininess, 1e-4)
    }

    function y(P, w) {
        w.gradientMap && (P.gradientMap.value = w.gradientMap)
    }

    function b(P, w) {
        P.metalness.value = w.metalness, w.metalnessMap && (P.metalnessMap.value = w.metalnessMap, o(w.metalnessMap, P.metalnessMapTransform)), P.roughness.value = w.roughness, w.roughnessMap && (P.roughnessMap.value = w.roughnessMap, o(w.roughnessMap, P.roughnessMapTransform)), w.envMap && (P.envMapIntensity.value = w.envMapIntensity)
    }

    function S(P, w, T) {
        P.ior.value = w.ior, w.sheen > 0 && (P.sheenColor.value.copy(w.sheenColor).multiplyScalar(w.sheen), P.sheenRoughness.value = w.sheenRoughness, w.sheenColorMap && (P.sheenColorMap.value = w.sheenColorMap, o(w.sheenColorMap, P.sheenColorMapTransform)), w.sheenRoughnessMap && (P.sheenRoughnessMap.value = w.sheenRoughnessMap, o(w.sheenRoughnessMap, P.sheenRoughnessMapTransform))), w.clearcoat > 0 && (P.clearcoat.value = w.clearcoat, P.clearcoatRoughness.value = w.clearcoatRoughness, w.clearcoatMap && (P.clearcoatMap.value = w.clearcoatMap, o(w.clearcoatMap, P.clearcoatMapTransform)), w.clearcoatRoughnessMap && (P.clearcoatRoughnessMap.value = w.clearcoatRoughnessMap, o(w.clearcoatRoughnessMap, P.clearcoatRoughnessMapTransform)), w.clearcoatNormalMap && (P.clearcoatNormalMap.value = w.clearcoatNormalMap, o(w.clearcoatNormalMap, P.clearcoatNormalMapTransform), P.clearcoatNormalScale.value.copy(w.clearcoatNormalScale), w.side === BackSide && P.clearcoatNormalScale.value.negate())), w.dispersion > 0 && (P.dispersion.value = w.dispersion), w.iridescence > 0 && (P.iridescence.value = w.iridescence, P.iridescenceIOR.value = w.iridescenceIOR, P.iridescenceThicknessMinimum.value = w.iridescenceThicknessRange[0], P.iridescenceThicknessMaximum.value = w.iridescenceThicknessRange[1], w.iridescenceMap && (P.iridescenceMap.value = w.iridescenceMap, o(w.iridescenceMap, P.iridescenceMapTransform)), w.iridescenceThicknessMap && (P.iridescenceThicknessMap.value = w.iridescenceThicknessMap, o(w.iridescenceThicknessMap, P.iridescenceThicknessMapTransform))), w.transmission > 0 && (P.transmission.value = w.transmission, P.transmissionSamplerMap.value = T.texture, P.transmissionSamplerSize.value.set(T.width, T.height), w.transmissionMap && (P.transmissionMap.value = w.transmissionMap, o(w.transmissionMap, P.transmissionMapTransform)), P.thickness.value = w.thickness, w.thicknessMap && (P.thicknessMap.value = w.thicknessMap, o(w.thicknessMap, P.thicknessMapTransform)), P.attenuationDistance.value = w.attenuationDistance, P.attenuationColor.value.copy(w.attenuationColor)), w.anisotropy > 0 && (P.anisotropyVector.value.set(w.anisotropy * Math.cos(w.anisotropyRotation), w.anisotropy * Math.sin(w.anisotropyRotation)), w.anisotropyMap && (P.anisotropyMap.value = w.anisotropyMap, o(w.anisotropyMap, P.anisotropyMapTransform))), P.specularIntensity.value = w.specularIntensity, P.specularColor.value.copy(w.specularColor), w.specularColorMap && (P.specularColorMap.value = w.specularColorMap, o(w.specularColorMap, P.specularColorMapTransform)), w.specularIntensityMap && (P.specularIntensityMap.value = w.specularIntensityMap, o(w.specularIntensityMap, P.specularIntensityMapTransform))
    }

    function C(P, w) {
        w.matcap && (P.matcap.value = w.matcap)
    }

    function E(P, w) {
        const T = i.get(w).light;
        P.referencePosition.value.setFromMatrixPosition(T.matrixWorld), P.nearDistance.value = T.shadow.camera.near, P.farDistance.value = T.shadow.camera.far
    }
    return {
        refreshFogUniforms: c,
        refreshMaterialUniforms: u
    }
}

function WebGLUniformsGroups(l, i, o, c) {
    let u = {},
        p = {},
        m = [];
    const g = l.getParameter(l.MAX_UNIFORM_BUFFER_BINDINGS);

    function _(T, M) {
        const A = M.program;
        c.uniformBlockBinding(T, A)
    }

    function v(T, M) {
        let A = u[T.id];
        A === void 0 && (C(T), A = x(T), u[T.id] = A, T.addEventListener("dispose", P));
        const D = M.program;
        c.updateUBOMapping(T, D);
        const R = i.render.frame;
        p[T.id] !== R && (b(T), p[T.id] = R)
    }

    function x(T) {
        const M = y();
        T.__bindingPointIndex = M;
        const A = l.createBuffer(),
            D = T.__size,
            R = T.usage;
        return l.bindBuffer(l.UNIFORM_BUFFER, A), l.bufferData(l.UNIFORM_BUFFER, D, R), l.bindBuffer(l.UNIFORM_BUFFER, null), l.bindBufferBase(l.UNIFORM_BUFFER, M, A), A
    }

    function y() {
        for (let T = 0; T < g; T++)
            if (m.indexOf(T) === -1) return m.push(T), T;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
    }

    function b(T) {
        const M = u[T.id],
            A = T.uniforms,
            D = T.__cache;
        l.bindBuffer(l.UNIFORM_BUFFER, M);
        for (let R = 0, I = A.length; R < I; R++) {
            const k = Array.isArray(A[R]) ? A[R] : [A[R]];
            for (let F = 0, V = k.length; F < V; F++) {
                const B = k[F];
                if (S(B, R, F, D) === !0) {
                    const U = B.__offset,
                        H = Array.isArray(B.value) ? B.value : [B.value];
                    let Q = 0;
                    for (let Y = 0; Y < H.length; Y++) {
                        const O = H[Y],
                            G = E(O);
                        typeof O == "number" || typeof O == "boolean" ? (B.__data[0] = O, l.bufferSubData(l.UNIFORM_BUFFER, U + Q, B.__data)) : O.isMatrix3 ? (B.__data[0] = O.elements[0], B.__data[1] = O.elements[1], B.__data[2] = O.elements[2], B.__data[3] = 0, B.__data[4] = O.elements[3], B.__data[5] = O.elements[4], B.__data[6] = O.elements[5], B.__data[7] = 0, B.__data[8] = O.elements[6], B.__data[9] = O.elements[7], B.__data[10] = O.elements[8], B.__data[11] = 0) : (O.toArray(B.__data, Q), Q += G.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    l.bufferSubData(l.UNIFORM_BUFFER, U, B.__data)
                }
            }
        }
        l.bindBuffer(l.UNIFORM_BUFFER, null)
    }

    function S(T, M, A, D) {
        const R = T.value,
            I = M + "_" + A;
        if (D[I] === void 0) return typeof R == "number" || typeof R == "boolean" ? D[I] = R : D[I] = R.clone(), !0; {
            const k = D[I];
            if (typeof R == "number" || typeof R == "boolean") {
                if (k !== R) return D[I] = R, !0
            } else if (k.equals(R) === !1) return k.copy(R), !0
        }
        return !1
    }

    function C(T) {
        const M = T.uniforms;
        let A = 0;
        const D = 16;
        for (let I = 0, k = M.length; I < k; I++) {
            const F = Array.isArray(M[I]) ? M[I] : [M[I]];
            for (let V = 0, B = F.length; V < B; V++) {
                const U = F[V],
                    H = Array.isArray(U.value) ? U.value : [U.value];
                for (let Q = 0, Y = H.length; Q < Y; Q++) {
                    const O = H[Q],
                        G = E(O),
                        L = A % D,
                        N = L % G.boundary,
                        K = L + N;
                    A += N, K !== 0 && D - K < G.storage && (A += D - K), U.__data = new Float32Array(G.storage / Float32Array.BYTES_PER_ELEMENT), U.__offset = A, A += G.storage
                }
            }
        }
        const R = A % D;
        return R > 0 && (A += D - R), T.__size = A, T.__cache = {}, this
    }

    function E(T) {
        const M = {
            boundary: 0,
            storage: 0
        };
        return typeof T == "number" || typeof T == "boolean" ? (M.boundary = 4, M.storage = 4) : T.isVector2 ? (M.boundary = 8, M.storage = 8) : T.isVector3 || T.isColor ? (M.boundary = 16, M.storage = 12) : T.isVector4 ? (M.boundary = 16, M.storage = 16) : T.isMatrix3 ? (M.boundary = 48, M.storage = 48) : T.isMatrix4 ? (M.boundary = 64, M.storage = 64) : T.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", T), M
    }

    function P(T) {
        const M = T.target;
        M.removeEventListener("dispose", P);
        const A = m.indexOf(M.__bindingPointIndex);
        m.splice(A, 1), l.deleteBuffer(u[M.id]), delete u[M.id], delete p[M.id]
    }

    function w() {
        for (const T in u) l.deleteBuffer(u[T]);
        m = [], u = {}, p = {}
    }
    return {
        bind: _,
        update: v,
        dispose: w
    }
}
class WebGLRenderer {
    constructor(i = {}) {
        const {
            canvas: o = createCanvasElement(),
            context: c = null,
            depth: u = !0,
            stencil: p = !1,
            alpha: m = !1,
            antialias: g = !1,
            premultipliedAlpha: _ = !0,
            preserveDrawingBuffer: v = !1,
            powerPreference: x = "default",
            failIfMajorPerformanceCaveat: y = !1,
            reverseDepthBuffer: b = !1
        } = i;
        this.isWebGLRenderer = !0;
        let S;
        if (c !== null) {
            if (typeof WebGLRenderingContext < "u" && c instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            S = c.getContextAttributes().alpha
        } else S = m;
        const C = new Uint32Array(4),
            E = new Int32Array(4);
        let P = null,
            w = null;
        const T = [],
            M = [];
        this.domElement = o, this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
        const A = this;
        let D = !1;
        this._outputColorSpace = SRGBColorSpace;
        let R = 0,
            I = 0,
            k = null,
            F = -1,
            V = null;
        const B = new Vector4,
            U = new Vector4;
        let H = null;
        const Q = new Color(0);
        let Y = 0,
            O = o.width,
            G = o.height,
            L = 1,
            N = null,
            K = null;
        const Z = new Vector4(0, 0, O, G),
            he = new Vector4(0, 0, O, G);
        let we = !1;
        const ie = new Frustum;
        let _e = !1,
            Te = !1;
        const Me = new Matrix4,
            Pe = new Matrix4,
            be = new Vector3$1,
            Be = new Vector4,
            De = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
        let We = !1;

        function Re() {
            return k === null ? L : 1
        }
        let q = c;

        function At(W, re) {
            return o.getContext(W, re)
        }
        try {
            const W = {
                alpha: !0,
                depth: u,
                stencil: p,
                antialias: g,
                premultipliedAlpha: _,
                preserveDrawingBuffer: v,
                powerPreference: x,
                failIfMajorPerformanceCaveat: y
            };
            if ("setAttribute" in o && o.setAttribute("data-engine", `three.js r${REVISION}`), o.addEventListener("webglcontextlost", Xe, !1), o.addEventListener("webglcontextrestored", Ee, !1), o.addEventListener("webglcontextcreationerror", ve, !1), q === null) {
                const re = "webgl2";
                if (q = At(re, W), q === null) throw At(re) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (W) {
            throw console.error("THREE.WebGLRenderer: " + W.message), W
        }
        let dt, tt, ke, ot, ze, Ie, Dt, J, $, ae, ge, ye, fe, Ke, Le, Oe, Ze, Se, qe, Je, it, Fe, ct, te;

        function Ve() {
            dt = new WebGLExtensions(q), dt.init(), Fe = new WebGLUtils(q, dt), tt = new WebGLCapabilities(q, dt, i, Fe), ke = new WebGLState(q, dt), tt.reverseDepthBuffer && b && ke.buffers.depth.setReversed(!0), ot = new WebGLInfo(q), ze = new WebGLProperties, Ie = new WebGLTextures(q, dt, ke, ze, tt, Fe, ot), Dt = new WebGLCubeMaps(A), J = new WebGLCubeUVMaps(A), $ = new WebGLAttributes(q), ct = new WebGLBindingStates(q, $), ae = new WebGLGeometries(q, $, ot, ct), ge = new WebGLObjects(q, ae, $, ot), qe = new WebGLMorphtargets(q, tt, Ie), Oe = new WebGLClipping(ze), ye = new WebGLPrograms(A, Dt, J, dt, tt, ct, Oe), fe = new WebGLMaterials(A, ze), Ke = new WebGLRenderLists, Le = new WebGLRenderStates(dt), Se = new WebGLBackground(A, Dt, J, ke, ge, S, _), Ze = new WebGLShadowMap(A, ge, tt), te = new WebGLUniformsGroups(q, ot, tt, ke), Je = new WebGLBufferRenderer(q, dt, ot), it = new WebGLIndexedBufferRenderer(q, dt, ot), ot.programs = ye.programs, A.capabilities = tt, A.extensions = dt, A.properties = ze, A.renderLists = Ke, A.shadowMap = Ze, A.state = ke, A.info = ot
        }
        Ve();
        const Ce = new WebXRManager(A, q);
        this.xr = Ce, this.getContext = function() {
            return q
        }, this.getContextAttributes = function() {
            return q.getContextAttributes()
        }, this.forceContextLoss = function() {
            const W = dt.get("WEBGL_lose_context");
            W && W.loseContext()
        }, this.forceContextRestore = function() {
            const W = dt.get("WEBGL_lose_context");
            W && W.restoreContext()
        }, this.getPixelRatio = function() {
            return L
        }, this.setPixelRatio = function(W) {
            W !== void 0 && (L = W, this.setSize(O, G, !1))
        }, this.getSize = function(W) {
            return W.set(O, G)
        }, this.setSize = function(W, re, ce = !0) {
            if (Ce.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            O = W, G = re, o.width = Math.floor(W * L), o.height = Math.floor(re * L), ce === !0 && (o.style.width = W + "px", o.style.height = re + "px"), this.setViewport(0, 0, W, re)
        }, this.getDrawingBufferSize = function(W) {
            return W.set(O * L, G * L).floor()
        }, this.setDrawingBufferSize = function(W, re, ce) {
            O = W, G = re, L = ce, o.width = Math.floor(W * ce), o.height = Math.floor(re * ce), this.setViewport(0, 0, W, re)
        }, this.getCurrentViewport = function(W) {
            return W.copy(B)
        }, this.getViewport = function(W) {
            return W.copy(Z)
        }, this.setViewport = function(W, re, ce, de) {
            W.isVector4 ? Z.set(W.x, W.y, W.z, W.w) : Z.set(W, re, ce, de), ke.viewport(B.copy(Z).multiplyScalar(L).round())
        }, this.getScissor = function(W) {
            return W.copy(he)
        }, this.setScissor = function(W, re, ce, de) {
            W.isVector4 ? he.set(W.x, W.y, W.z, W.w) : he.set(W, re, ce, de), ke.scissor(U.copy(he).multiplyScalar(L).round())
        }, this.getScissorTest = function() {
            return we
        }, this.setScissorTest = function(W) {
            ke.setScissorTest(we = W)
        }, this.setOpaqueSort = function(W) {
            N = W
        }, this.setTransparentSort = function(W) {
            K = W
        }, this.getClearColor = function(W) {
            return W.copy(Se.getClearColor())
        }, this.setClearColor = function() {
            Se.setClearColor(...arguments)
        }, this.getClearAlpha = function() {
            return Se.getClearAlpha()
        }, this.setClearAlpha = function() {
            Se.setClearAlpha(...arguments)
        }, this.clear = function(W = !0, re = !0, ce = !0) {
            let de = 0;
            if (W) {
                let se = !1;
                if (k !== null) {
                    const Ae = k.texture.format;
                    se = Ae === RGBAIntegerFormat || Ae === RGIntegerFormat || Ae === RedIntegerFormat
                }
                if (se) {
                    const Ae = k.texture.type,
                        Ne = Ae === UnsignedByteType || Ae === UnsignedIntType || Ae === UnsignedShortType || Ae === UnsignedInt248Type || Ae === UnsignedShort4444Type || Ae === UnsignedShort5551Type,
                        je = Se.getClearColor(),
                        $e = Se.getClearAlpha(),
                        rt = je.r,
                        at = je.g,
                        Qe = je.b;
                    Ne ? (C[0] = rt, C[1] = at, C[2] = Qe, C[3] = $e, q.clearBufferuiv(q.COLOR, 0, C)) : (E[0] = rt, E[1] = at, E[2] = Qe, E[3] = $e, q.clearBufferiv(q.COLOR, 0, E))
                } else de |= q.COLOR_BUFFER_BIT
            }
            re && (de |= q.DEPTH_BUFFER_BIT), ce && (de |= q.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), q.clear(de)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            o.removeEventListener("webglcontextlost", Xe, !1), o.removeEventListener("webglcontextrestored", Ee, !1), o.removeEventListener("webglcontextcreationerror", ve, !1), Se.dispose(), Ke.dispose(), Le.dispose(), ze.dispose(), Dt.dispose(), J.dispose(), ge.dispose(), ct.dispose(), te.dispose(), ye.dispose(), Ce.dispose(), Ce.removeEventListener("sessionstart", Gn), Ce.removeEventListener("sessionend", Hn), ui.stop()
        };

        function Xe(W) {
            W.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), D = !0
        }

        function Ee() {
            console.log("THREE.WebGLRenderer: Context Restored."), D = !1;
            const W = ot.autoReset,
                re = Ze.enabled,
                ce = Ze.autoUpdate,
                de = Ze.needsUpdate,
                se = Ze.type;
            Ve(), ot.autoReset = W, Ze.enabled = re, Ze.autoUpdate = ce, Ze.needsUpdate = de, Ze.type = se
        }

        function ve(W) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", W.statusMessage)
        }

        function Ye(W) {
            const re = W.target;
            re.removeEventListener("dispose", Ye), et(re)
        }

        function et(W) {
            kt(W), ze.remove(W)
        }

        function kt(W) {
            const re = ze.get(W).programs;
            re !== void 0 && (re.forEach(function(ce) {
                ye.releaseProgram(ce)
            }), W.isShaderMaterial && ye.releaseShaderCache(W))
        }
        this.renderBufferDirect = function(W, re, ce, de, se, Ae) {
            re === null && (re = De);
            const Ne = se.isMesh && se.matrixWorld.determinant() < 0,
                je = Hi(W, re, ce, de, se);
            ke.setMaterial(de, Ne);
            let $e = ce.index,
                rt = 1;
            if (de.wireframe === !0) {
                if ($e = ae.getWireframeAttribute(ce), $e === void 0) return;
                rt = 2
            }
            const at = ce.drawRange,
                Qe = ce.attributes.position;
            let bt = at.start * rt,
                ht = (at.start + at.count) * rt;
            Ae !== null && (bt = Math.max(bt, Ae.start * rt), ht = Math.min(ht, (Ae.start + Ae.count) * rt)), $e !== null ? (bt = Math.max(bt, 0), ht = Math.min(ht, $e.count)) : Qe != null && (bt = Math.max(bt, 0), ht = Math.min(ht, Qe.count));
            const Tt = ht - bt;
            if (Tt < 0 || Tt === 1 / 0) return;
            ct.setup(se, de, je, ce, $e);
            let Bt, Mt = Je;
            if ($e !== null && (Bt = $.get($e), Mt = it, Mt.setIndex(Bt)), se.isMesh) de.wireframe === !0 ? (ke.setLineWidth(de.wireframeLinewidth * Re()), Mt.setMode(q.LINES)) : Mt.setMode(q.TRIANGLES);
            else if (se.isLine) {
                let Ge = de.linewidth;
                Ge === void 0 && (Ge = 1), ke.setLineWidth(Ge * Re()), se.isLineSegments ? Mt.setMode(q.LINES) : se.isLineLoop ? Mt.setMode(q.LINE_LOOP) : Mt.setMode(q.LINE_STRIP)
            } else se.isPoints ? Mt.setMode(q.POINTS) : se.isSprite && Mt.setMode(q.TRIANGLES);
            if (se.isBatchedMesh)
                if (se._multiDrawInstances !== null) warnOnce("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), Mt.renderMultiDrawInstances(se._multiDrawStarts, se._multiDrawCounts, se._multiDrawCount, se._multiDrawInstances);
                else if (dt.get("WEBGL_multi_draw")) Mt.renderMultiDraw(se._multiDrawStarts, se._multiDrawCounts, se._multiDrawCount);
            else {
                const Ge = se._multiDrawStarts,
                    Ot = se._multiDrawCounts,
                    Ft = se._multiDrawCount,
                    Fi = $e ? $.get($e).bytesPerElement : 1,
                    yi = ze.get(de).currentProgram.getUniforms();
                for (let di = 0; di < Ft; di++) yi.setValue(q, "_gl_DrawID", di), Mt.render(Ge[di] / Fi, Ot[di])
            } else if (se.isInstancedMesh) Mt.renderInstances(bt, Tt, se.count);
            else if (ce.isInstancedBufferGeometry) {
                const Ge = ce._maxInstanceCount !== void 0 ? ce._maxInstanceCount : 1 / 0,
                    Ot = Math.min(ce.instanceCount, Ge);
                Mt.renderInstances(bt, Tt, Ot)
            } else Mt.render(bt, Tt)
        };

        function It(W, re, ce) {
            W.transparent === !0 && W.side === DoubleSide && W.forceSinglePass === !1 ? (W.side = BackSide, W.needsUpdate = !0, Cn(W, re, ce), W.side = FrontSide, W.needsUpdate = !0, Cn(W, re, ce), W.side = DoubleSide) : Cn(W, re, ce)
        }
        this.compile = function(W, re, ce = null) {
            ce === null && (ce = W), w = Le.get(ce), w.init(re), M.push(w), ce.traverseVisible(function(se) {
                se.isLight && se.layers.test(re.layers) && (w.pushLight(se), se.castShadow && w.pushShadow(se))
            }), W !== ce && W.traverseVisible(function(se) {
                se.isLight && se.layers.test(re.layers) && (w.pushLight(se), se.castShadow && w.pushShadow(se))
            }), w.setupLights();
            const de = new Set;
            return W.traverse(function(se) {
                if (!(se.isMesh || se.isPoints || se.isLine || se.isSprite)) return;
                const Ae = se.material;
                if (Ae)
                    if (Array.isArray(Ae))
                        for (let Ne = 0; Ne < Ae.length; Ne++) {
                            const je = Ae[Ne];
                            It(je, ce, se), de.add(je)
                        } else It(Ae, ce, se), de.add(Ae)
            }), w = M.pop(), de
        }, this.compileAsync = function(W, re, ce = null) {
            const de = this.compile(W, re, ce);
            return new Promise(se => {
                function Ae() {
                    if (de.forEach(function(Ne) {
                            ze.get(Ne).currentProgram.isReady() && de.delete(Ne)
                        }), de.size === 0) {
                        se(W);
                        return
                    }
                    setTimeout(Ae, 10)
                }
                dt.get("KHR_parallel_shader_compile") !== null ? Ae() : setTimeout(Ae, 10)
            })
        };
        let Ii = null;

        function Ki(W) {
            Ii && Ii(W)
        }

        function Gn() {
            ui.stop()
        }

        function Hn() {
            ui.start()
        }
        const ui = new WebGLAnimation;
        ui.setAnimationLoop(Ki), typeof self < "u" && ui.setContext(self), this.setAnimationLoop = function(W) {
            Ii = W, Ce.setAnimationLoop(W), W === null ? ui.stop() : ui.start()
        }, Ce.addEventListener("sessionstart", Gn), Ce.addEventListener("sessionend", Hn), this.render = function(W, re) {
            if (re !== void 0 && re.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (D === !0) return;
            if (W.matrixWorldAutoUpdate === !0 && W.updateMatrixWorld(), re.parent === null && re.matrixWorldAutoUpdate === !0 && re.updateMatrixWorld(), Ce.enabled === !0 && Ce.isPresenting === !0 && (Ce.cameraAutoUpdate === !0 && Ce.updateCamera(re), re = Ce.getCamera()), W.isScene === !0 && W.onBeforeRender(A, W, re, k), w = Le.get(W, M.length), w.init(re), M.push(w), Pe.multiplyMatrices(re.projectionMatrix, re.matrixWorldInverse), ie.setFromProjectionMatrix(Pe), Te = this.localClippingEnabled, _e = Oe.init(this.clippingPlanes, Te), P = Ke.get(W, T.length), P.init(), T.push(P), Ce.enabled === !0 && Ce.isPresenting === !0) {
                const Ae = A.xr.getDepthSensingMesh();
                Ae !== null && sn(Ae, re, -1 / 0, A.sortObjects)
            }
            sn(W, re, 0, A.sortObjects), P.finish(), A.sortObjects === !0 && P.sort(N, K), We = Ce.enabled === !1 || Ce.isPresenting === !1 || Ce.hasDepthSensing() === !1, We && Se.addToRenderList(P, W), this.info.render.frame++, _e === !0 && Oe.beginShadows();
            const ce = w.state.shadowsArray;
            Ze.render(ce, W, re), _e === !0 && Oe.endShadows(), this.info.autoReset === !0 && this.info.reset();
            const de = P.opaque,
                se = P.transmissive;
            if (w.setupLights(), re.isArrayCamera) {
                const Ae = re.cameras;
                if (se.length > 0)
                    for (let Ne = 0, je = Ae.length; Ne < je; Ne++) {
                        const $e = Ae[Ne];
                        jn(de, se, W, $e)
                    }
                We && Se.render(W);
                for (let Ne = 0, je = Ae.length; Ne < je; Ne++) {
                    const $e = Ae[Ne];
                    Wn(P, W, $e, $e.viewport)
                }
            } else se.length > 0 && jn(de, se, W, re), We && Se.render(W), Wn(P, W, re);
            k !== null && I === 0 && (Ie.updateMultisampleRenderTarget(k), Ie.updateRenderTargetMipmap(k)), W.isScene === !0 && W.onAfterRender(A, W, re), ct.resetDefaultState(), F = -1, V = null, M.pop(), M.length > 0 ? (w = M[M.length - 1], _e === !0 && Oe.setGlobalState(A.clippingPlanes, w.state.camera)) : w = null, T.pop(), T.length > 0 ? P = T[T.length - 1] : P = null
        };

        function sn(W, re, ce, de) {
            if (W.visible === !1) return;
            if (W.layers.test(re.layers)) {
                if (W.isGroup) ce = W.renderOrder;
                else if (W.isLOD) W.autoUpdate === !0 && W.update(re);
                else if (W.isLight) w.pushLight(W), W.castShadow && w.pushShadow(W);
                else if (W.isSprite) {
                    if (!W.frustumCulled || ie.intersectsSprite(W)) {
                        de && Be.setFromMatrixPosition(W.matrixWorld).applyMatrix4(Pe);
                        const Ne = ge.update(W),
                            je = W.material;
                        je.visible && P.push(W, Ne, je, ce, Be.z, null)
                    }
                } else if ((W.isMesh || W.isLine || W.isPoints) && (!W.frustumCulled || ie.intersectsObject(W))) {
                    const Ne = ge.update(W),
                        je = W.material;
                    if (de && (W.boundingSphere !== void 0 ? (W.boundingSphere === null && W.computeBoundingSphere(), Be.copy(W.boundingSphere.center)) : (Ne.boundingSphere === null && Ne.computeBoundingSphere(), Be.copy(Ne.boundingSphere.center)), Be.applyMatrix4(W.matrixWorld).applyMatrix4(Pe)), Array.isArray(je)) {
                        const $e = Ne.groups;
                        for (let rt = 0, at = $e.length; rt < at; rt++) {
                            const Qe = $e[rt],
                                bt = je[Qe.materialIndex];
                            bt && bt.visible && P.push(W, Ne, bt, ce, Be.z, Qe)
                        }
                    } else je.visible && P.push(W, Ne, je, ce, Be.z, null)
                }
            }
            const Ae = W.children;
            for (let Ne = 0, je = Ae.length; Ne < je; Ne++) sn(Ae[Ne], re, ce, de)
        }

        function Wn(W, re, ce, de) {
            const se = W.opaque,
                Ae = W.transmissive,
                Ne = W.transparent;
            w.setupLightsView(ce), _e === !0 && Oe.setGlobalState(A.clippingPlanes, ce), de && ke.viewport(B.copy(de)), se.length > 0 && Gi(se, re, ce), Ae.length > 0 && Gi(Ae, re, ce), Ne.length > 0 && Gi(Ne, re, ce), ke.buffers.depth.setTest(!0), ke.buffers.depth.setMask(!0), ke.buffers.color.setMask(!0), ke.setPolygonOffset(!1)
        }

        function jn(W, re, ce, de) {
            if ((ce.isScene === !0 ? ce.overrideMaterial : null) !== null) return;
            w.state.transmissionRenderTarget[de.id] === void 0 && (w.state.transmissionRenderTarget[de.id] = new WebGLRenderTarget(1, 1, {
                generateMipmaps: !0,
                type: dt.has("EXT_color_buffer_half_float") || dt.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
                minFilter: LinearMipmapLinearFilter,
                samples: 4,
                stencilBuffer: p,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: ColorManagement.workingColorSpace
            }));
            const Ae = w.state.transmissionRenderTarget[de.id],
                Ne = de.viewport || B;
            Ae.setSize(Ne.z * A.transmissionResolutionScale, Ne.w * A.transmissionResolutionScale);
            const je = A.getRenderTarget();
            A.setRenderTarget(Ae), A.getClearColor(Q), Y = A.getClearAlpha(), Y < 1 && A.setClearColor(16777215, .5), A.clear(), We && Se.render(ce);
            const $e = A.toneMapping;
            A.toneMapping = NoToneMapping;
            const rt = de.viewport;
            if (de.viewport !== void 0 && (de.viewport = void 0), w.setupLightsView(de), _e === !0 && Oe.setGlobalState(A.clippingPlanes, de), Gi(W, ce, de), Ie.updateMultisampleRenderTarget(Ae), Ie.updateRenderTargetMipmap(Ae), dt.has("WEBGL_multisampled_render_to_texture") === !1) {
                let at = !1;
                for (let Qe = 0, bt = re.length; Qe < bt; Qe++) {
                    const ht = re[Qe],
                        Tt = ht.object,
                        Bt = ht.geometry,
                        Mt = ht.material,
                        Ge = ht.group;
                    if (Mt.side === DoubleSide && Tt.layers.test(de.layers)) {
                        const Ot = Mt.side;
                        Mt.side = BackSide, Mt.needsUpdate = !0, qn(Tt, ce, de, Bt, Mt, Ge), Mt.side = Ot, Mt.needsUpdate = !0, at = !0
                    }
                }
                at === !0 && (Ie.updateMultisampleRenderTarget(Ae), Ie.updateRenderTargetMipmap(Ae))
            }
            A.setRenderTarget(je), A.setClearColor(Q, Y), rt !== void 0 && (de.viewport = rt), A.toneMapping = $e
        }

        function Gi(W, re, ce) {
            const de = re.isScene === !0 ? re.overrideMaterial : null;
            for (let se = 0, Ae = W.length; se < Ae; se++) {
                const Ne = W[se],
                    je = Ne.object,
                    $e = Ne.geometry,
                    rt = Ne.group;
                let at = Ne.material;
                at.allowOverride === !0 && de !== null && (at = de), je.layers.test(ce.layers) && qn(je, re, ce, $e, at, rt)
            }
        }

        function qn(W, re, ce, de, se, Ae) {
            W.onBeforeRender(A, re, ce, de, se, Ae), W.modelViewMatrix.multiplyMatrices(ce.matrixWorldInverse, W.matrixWorld), W.normalMatrix.getNormalMatrix(W.modelViewMatrix), se.onBeforeRender(A, re, ce, de, W, Ae), se.transparent === !0 && se.side === DoubleSide && se.forceSinglePass === !1 ? (se.side = BackSide, se.needsUpdate = !0, A.renderBufferDirect(ce, re, de, se, W, Ae), se.side = FrontSide, se.needsUpdate = !0, A.renderBufferDirect(ce, re, de, se, W, Ae), se.side = DoubleSide) : A.renderBufferDirect(ce, re, de, se, W, Ae), W.onAfterRender(A, re, ce, de, se, Ae)
        }

        function Cn(W, re, ce) {
            re.isScene !== !0 && (re = De);
            const de = ze.get(W),
                se = w.state.lights,
                Ae = w.state.shadowsArray,
                Ne = se.state.version,
                je = ye.getParameters(W, se.state, Ae, re, ce),
                $e = ye.getProgramCacheKey(je);
            let rt = de.programs;
            de.environment = W.isMeshStandardMaterial ? re.environment : null, de.fog = re.fog, de.envMap = (W.isMeshStandardMaterial ? J : Dt).get(W.envMap || de.environment), de.envMapRotation = de.environment !== null && W.envMap === null ? re.environmentRotation : W.envMapRotation, rt === void 0 && (W.addEventListener("dispose", Ye), rt = new Map, de.programs = rt);
            let at = rt.get($e);
            if (at !== void 0) {
                if (de.currentProgram === at && de.lightsStateVersion === Ne) return ir(W, je), at
            } else je.uniforms = ye.getUniforms(W), W.onBeforeCompile(je, A), at = ye.acquireProgram(je, $e), rt.set($e, at), de.uniforms = je.uniforms;
            const Qe = de.uniforms;
            return (!W.isShaderMaterial && !W.isRawShaderMaterial || W.clipping === !0) && (Qe.clippingPlanes = Oe.uniform), ir(W, je), de.needsLights = Ti(W), de.lightsStateVersion = Ne, de.needsLights && (Qe.ambientLightColor.value = se.state.ambient, Qe.lightProbe.value = se.state.probe, Qe.directionalLights.value = se.state.directional, Qe.directionalLightShadows.value = se.state.directionalShadow, Qe.spotLights.value = se.state.spot, Qe.spotLightShadows.value = se.state.spotShadow, Qe.rectAreaLights.value = se.state.rectArea, Qe.ltc_1.value = se.state.rectAreaLTC1, Qe.ltc_2.value = se.state.rectAreaLTC2, Qe.pointLights.value = se.state.point, Qe.pointLightShadows.value = se.state.pointShadow, Qe.hemisphereLights.value = se.state.hemi, Qe.directionalShadowMap.value = se.state.directionalShadowMap, Qe.directionalShadowMatrix.value = se.state.directionalShadowMatrix, Qe.spotShadowMap.value = se.state.spotShadowMap, Qe.spotLightMatrix.value = se.state.spotLightMatrix, Qe.spotLightMap.value = se.state.spotLightMap, Qe.pointShadowMap.value = se.state.pointShadowMap, Qe.pointShadowMatrix.value = se.state.pointShadowMatrix), de.currentProgram = at, de.uniformsList = null, at
        }

        function tr(W) {
            if (W.uniformsList === null) {
                const re = W.currentProgram.getUniforms();
                W.uniformsList = WebGLUniforms.seqWithValue(re.seq, W.uniforms)
            }
            return W.uniformsList
        }

        function ir(W, re) {
            const ce = ze.get(W);
            ce.outputColorSpace = re.outputColorSpace, ce.batching = re.batching, ce.batchingColor = re.batchingColor, ce.instancing = re.instancing, ce.instancingColor = re.instancingColor, ce.instancingMorph = re.instancingMorph, ce.skinning = re.skinning, ce.morphTargets = re.morphTargets, ce.morphNormals = re.morphNormals, ce.morphColors = re.morphColors, ce.morphTargetsCount = re.morphTargetsCount, ce.numClippingPlanes = re.numClippingPlanes, ce.numIntersection = re.numClipIntersection, ce.vertexAlphas = re.vertexAlphas, ce.vertexTangents = re.vertexTangents, ce.toneMapping = re.toneMapping
        }

        function Hi(W, re, ce, de, se) {
            re.isScene !== !0 && (re = De), Ie.resetTextureUnits();
            const Ae = re.fog,
                Ne = de.isMeshStandardMaterial ? re.environment : null,
                je = k === null ? A.outputColorSpace : k.isXRRenderTarget === !0 ? k.texture.colorSpace : LinearSRGBColorSpace,
                $e = (de.isMeshStandardMaterial ? J : Dt).get(de.envMap || Ne),
                rt = de.vertexColors === !0 && !!ce.attributes.color && ce.attributes.color.itemSize === 4,
                at = !!ce.attributes.tangent && (!!de.normalMap || de.anisotropy > 0),
                Qe = !!ce.morphAttributes.position,
                bt = !!ce.morphAttributes.normal,
                ht = !!ce.morphAttributes.color;
            let Tt = NoToneMapping;
            de.toneMapped && (k === null || k.isXRRenderTarget === !0) && (Tt = A.toneMapping);
            const Bt = ce.morphAttributes.position || ce.morphAttributes.normal || ce.morphAttributes.color,
                Mt = Bt !== void 0 ? Bt.length : 0,
                Ge = ze.get(de),
                Ot = w.state.lights;
            if (_e === !0 && (Te === !0 || W !== V)) {
                const ti = W === V && de.id === F;
                Oe.setState(de, W, ti)
            }
            let Ft = !1;
            de.version === Ge.__version ? (Ge.needsLights && Ge.lightsStateVersion !== Ot.state.version || Ge.outputColorSpace !== je || se.isBatchedMesh && Ge.batching === !1 || !se.isBatchedMesh && Ge.batching === !0 || se.isBatchedMesh && Ge.batchingColor === !0 && se.colorTexture === null || se.isBatchedMesh && Ge.batchingColor === !1 && se.colorTexture !== null || se.isInstancedMesh && Ge.instancing === !1 || !se.isInstancedMesh && Ge.instancing === !0 || se.isSkinnedMesh && Ge.skinning === !1 || !se.isSkinnedMesh && Ge.skinning === !0 || se.isInstancedMesh && Ge.instancingColor === !0 && se.instanceColor === null || se.isInstancedMesh && Ge.instancingColor === !1 && se.instanceColor !== null || se.isInstancedMesh && Ge.instancingMorph === !0 && se.morphTexture === null || se.isInstancedMesh && Ge.instancingMorph === !1 && se.morphTexture !== null || Ge.envMap !== $e || de.fog === !0 && Ge.fog !== Ae || Ge.numClippingPlanes !== void 0 && (Ge.numClippingPlanes !== Oe.numPlanes || Ge.numIntersection !== Oe.numIntersection) || Ge.vertexAlphas !== rt || Ge.vertexTangents !== at || Ge.morphTargets !== Qe || Ge.morphNormals !== bt || Ge.morphColors !== ht || Ge.toneMapping !== Tt || Ge.morphTargetsCount !== Mt) && (Ft = !0) : (Ft = !0, Ge.__version = de.version);
            let Fi = Ge.currentProgram;
            Ft === !0 && (Fi = Cn(de, re, se));
            let yi = !1,
                di = !1,
                gn = !1;
            const zt = Fi.getUniforms(),
                bi = Ge.uniforms;
            if (ke.useProgram(Fi.program) && (yi = !0, di = !0, gn = !0), de.id !== F && (F = de.id, di = !0), yi || V !== W) {
                ke.buffers.depth.getReversed() ? (Me.copy(W.projectionMatrix), toNormalizedProjectionMatrix(Me), toReversedProjectionMatrix(Me), zt.setValue(q, "projectionMatrix", Me)) : zt.setValue(q, "projectionMatrix", W.projectionMatrix), zt.setValue(q, "viewMatrix", W.matrixWorldInverse);
                const Rt = zt.map.cameraPosition;
                Rt !== void 0 && Rt.setValue(q, be.setFromMatrixPosition(W.matrixWorld)), tt.logarithmicDepthBuffer && zt.setValue(q, "logDepthBufFC", 2 / (Math.log(W.far + 1) / Math.LN2)), (de.isMeshPhongMaterial || de.isMeshToonMaterial || de.isMeshLambertMaterial || de.isMeshBasicMaterial || de.isMeshStandardMaterial || de.isShaderMaterial) && zt.setValue(q, "isOrthographic", W.isOrthographicCamera === !0), V !== W && (V = W, di = !0, gn = !0)
            }
            if (se.isSkinnedMesh) {
                zt.setOptional(q, se, "bindMatrix"), zt.setOptional(q, se, "bindMatrixInverse");
                const ti = se.skeleton;
                ti && (ti.boneTexture === null && ti.computeBoneTexture(), zt.setValue(q, "boneTexture", ti.boneTexture, Ie))
            }
            se.isBatchedMesh && (zt.setOptional(q, se, "batchingTexture"), zt.setValue(q, "batchingTexture", se._matricesTexture, Ie), zt.setOptional(q, se, "batchingIdTexture"), zt.setValue(q, "batchingIdTexture", se._indirectTexture, Ie), zt.setOptional(q, se, "batchingColorTexture"), se._colorsTexture !== null && zt.setValue(q, "batchingColorTexture", se._colorsTexture, Ie));
            const ki = ce.morphAttributes;
            if ((ki.position !== void 0 || ki.normal !== void 0 || ki.color !== void 0) && qe.update(se, ce, Fi), (di || Ge.receiveShadow !== se.receiveShadow) && (Ge.receiveShadow = se.receiveShadow, zt.setValue(q, "receiveShadow", se.receiveShadow)), de.isMeshGouraudMaterial && de.envMap !== null && (bi.envMap.value = $e, bi.flipEnvMap.value = $e.isCubeTexture && $e.isRenderTargetTexture === !1 ? -1 : 1), de.isMeshStandardMaterial && de.envMap === null && re.environment !== null && (bi.envMapIntensity.value = re.environmentIntensity), di && (zt.setValue(q, "toneMappingExposure", A.toneMappingExposure), Ge.needsLights && Vn(bi, gn), Ae && de.fog === !0 && fe.refreshFogUniforms(bi, Ae), fe.refreshMaterialUniforms(bi, de, L, G, w.state.transmissionRenderTarget[W.id]), WebGLUniforms.upload(q, tr(Ge), bi, Ie)), de.isShaderMaterial && de.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(q, tr(Ge), bi, Ie), de.uniformsNeedUpdate = !1), de.isSpriteMaterial && zt.setValue(q, "center", se.center), zt.setValue(q, "modelViewMatrix", se.modelViewMatrix), zt.setValue(q, "normalMatrix", se.normalMatrix), zt.setValue(q, "modelMatrix", se.matrixWorld), de.isShaderMaterial || de.isRawShaderMaterial) {
                const ti = de.uniformsGroups;
                for (let Rt = 0, Xt = ti.length; Rt < Xt; Rt++) {
                    const Wi = ti[Rt];
                    te.update(Wi, Fi), te.bind(Wi, Fi)
                }
            }
            return Fi
        }

        function Vn(W, re) {
            W.ambientLightColor.needsUpdate = re, W.lightProbe.needsUpdate = re, W.directionalLights.needsUpdate = re, W.directionalLightShadows.needsUpdate = re, W.pointLights.needsUpdate = re, W.pointLightShadows.needsUpdate = re, W.spotLights.needsUpdate = re, W.spotLightShadows.needsUpdate = re, W.rectAreaLights.needsUpdate = re, W.hemisphereLights.needsUpdate = re
        }

        function Ti(W) {
            return W.isMeshLambertMaterial || W.isMeshToonMaterial || W.isMeshPhongMaterial || W.isMeshStandardMaterial || W.isShadowMaterial || W.isShaderMaterial && W.lights === !0
        }
        this.getActiveCubeFace = function() {
            return R
        }, this.getActiveMipmapLevel = function() {
            return I
        }, this.getRenderTarget = function() {
            return k
        }, this.setRenderTargetTextures = function(W, re, ce) {
            const de = ze.get(W);
            de.__autoAllocateDepthBuffer = W.resolveDepthBuffer === !1, de.__autoAllocateDepthBuffer === !1 && (de.__useRenderToTexture = !1), ze.get(W.texture).__webglTexture = re, ze.get(W.depthTexture).__webglTexture = de.__autoAllocateDepthBuffer ? void 0 : ce, de.__hasExternalTextures = !0
        }, this.setRenderTargetFramebuffer = function(W, re) {
            const ce = ze.get(W);
            ce.__webglFramebuffer = re, ce.__useDefaultFramebuffer = re === void 0
        };
        const hi = q.createFramebuffer();
        this.setRenderTarget = function(W, re = 0, ce = 0) {
            k = W, R = re, I = ce;
            let de = !0,
                se = null,
                Ae = !1,
                Ne = !1;
            if (W) {
                const $e = ze.get(W);
                if ($e.__useDefaultFramebuffer !== void 0) ke.bindFramebuffer(q.FRAMEBUFFER, null), de = !1;
                else if ($e.__webglFramebuffer === void 0) Ie.setupRenderTarget(W);
                else if ($e.__hasExternalTextures) Ie.rebindTextures(W, ze.get(W.texture).__webglTexture, ze.get(W.depthTexture).__webglTexture);
                else if (W.depthBuffer) {
                    const Qe = W.depthTexture;
                    if ($e.__boundDepthTexture !== Qe) {
                        if (Qe !== null && ze.has(Qe) && (W.width !== Qe.image.width || W.height !== Qe.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        Ie.setupDepthRenderbuffer(W)
                    }
                }
                const rt = W.texture;
                (rt.isData3DTexture || rt.isDataArrayTexture || rt.isCompressedArrayTexture) && (Ne = !0);
                const at = ze.get(W).__webglFramebuffer;
                W.isWebGLCubeRenderTarget ? (Array.isArray(at[re]) ? se = at[re][ce] : se = at[re], Ae = !0) : W.samples > 0 && Ie.useMultisampledRTT(W) === !1 ? se = ze.get(W).__webglMultisampledFramebuffer : Array.isArray(at) ? se = at[ce] : se = at, B.copy(W.viewport), U.copy(W.scissor), H = W.scissorTest
            } else B.copy(Z).multiplyScalar(L).floor(), U.copy(he).multiplyScalar(L).floor(), H = we;
            if (ce !== 0 && (se = hi), ke.bindFramebuffer(q.FRAMEBUFFER, se) && de && ke.drawBuffers(W, se), ke.viewport(B), ke.scissor(U), ke.setScissorTest(H), Ae) {
                const $e = ze.get(W.texture);
                q.framebufferTexture2D(q.FRAMEBUFFER, q.COLOR_ATTACHMENT0, q.TEXTURE_CUBE_MAP_POSITIVE_X + re, $e.__webglTexture, ce)
            } else if (Ne) {
                const $e = ze.get(W.texture),
                    rt = re;
                q.framebufferTextureLayer(q.FRAMEBUFFER, q.COLOR_ATTACHMENT0, $e.__webglTexture, ce, rt)
            } else if (W !== null && ce !== 0) {
                const $e = ze.get(W.texture);
                q.framebufferTexture2D(q.FRAMEBUFFER, q.COLOR_ATTACHMENT0, q.TEXTURE_2D, $e.__webglTexture, ce)
            }
            F = -1
        }, this.readRenderTargetPixels = function(W, re, ce, de, se, Ae, Ne, je = 0) {
            if (!(W && W.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let $e = ze.get(W).__webglFramebuffer;
            if (W.isWebGLCubeRenderTarget && Ne !== void 0 && ($e = $e[Ne]), $e) {
                ke.bindFramebuffer(q.FRAMEBUFFER, $e);
                try {
                    const rt = W.textures[je],
                        at = rt.format,
                        Qe = rt.type;
                    if (!tt.textureFormatReadable(at)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!tt.textureTypeReadable(Qe)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    re >= 0 && re <= W.width - de && ce >= 0 && ce <= W.height - se && (W.textures.length > 1 && q.readBuffer(q.COLOR_ATTACHMENT0 + je), q.readPixels(re, ce, de, se, Fe.convert(at), Fe.convert(Qe), Ae))
                } finally {
                    const rt = k !== null ? ze.get(k).__webglFramebuffer : null;
                    ke.bindFramebuffer(q.FRAMEBUFFER, rt)
                }
            }
        }, this.readRenderTargetPixelsAsync = async function(W, re, ce, de, se, Ae, Ne, je = 0) {
            if (!(W && W.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let $e = ze.get(W).__webglFramebuffer;
            if (W.isWebGLCubeRenderTarget && Ne !== void 0 && ($e = $e[Ne]), $e)
                if (re >= 0 && re <= W.width - de && ce >= 0 && ce <= W.height - se) {
                    ke.bindFramebuffer(q.FRAMEBUFFER, $e);
                    const rt = W.textures[je],
                        at = rt.format,
                        Qe = rt.type;
                    if (!tt.textureFormatReadable(at)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!tt.textureTypeReadable(Qe)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const bt = q.createBuffer();
                    q.bindBuffer(q.PIXEL_PACK_BUFFER, bt), q.bufferData(q.PIXEL_PACK_BUFFER, Ae.byteLength, q.STREAM_READ), W.textures.length > 1 && q.readBuffer(q.COLOR_ATTACHMENT0 + je), q.readPixels(re, ce, de, se, Fe.convert(at), Fe.convert(Qe), 0);
                    const ht = k !== null ? ze.get(k).__webglFramebuffer : null;
                    ke.bindFramebuffer(q.FRAMEBUFFER, ht);
                    const Tt = q.fenceSync(q.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return q.flush(), await probeAsync(q, Tt, 4), q.bindBuffer(q.PIXEL_PACK_BUFFER, bt), q.getBufferSubData(q.PIXEL_PACK_BUFFER, 0, Ae), q.deleteBuffer(bt), q.deleteSync(Tt), Ae
                } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
        }, this.copyFramebufferToTexture = function(W, re = null, ce = 0) {
            const de = Math.pow(2, -ce),
                se = Math.floor(W.image.width * de),
                Ae = Math.floor(W.image.height * de),
                Ne = re !== null ? re.x : 0,
                je = re !== null ? re.y : 0;
            Ie.setTexture2D(W, 0), q.copyTexSubImage2D(q.TEXTURE_2D, ce, 0, 0, Ne, je, se, Ae), ke.unbindTexture()
        };
        const En = q.createFramebuffer(),
            on = q.createFramebuffer();
        this.copyTextureToTexture = function(W, re, ce = null, de = null, se = 0, Ae = null) {
            Ae === null && (se !== 0 ? (warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), Ae = se, se = 0) : Ae = 0);
            let Ne, je, $e, rt, at, Qe, bt, ht, Tt;
            const Bt = W.isCompressedTexture ? W.mipmaps[Ae] : W.image;
            if (ce !== null) Ne = ce.max.x - ce.min.x, je = ce.max.y - ce.min.y, $e = ce.isBox3 ? ce.max.z - ce.min.z : 1, rt = ce.min.x, at = ce.min.y, Qe = ce.isBox3 ? ce.min.z : 0;
            else {
                const ki = Math.pow(2, -se);
                Ne = Math.floor(Bt.width * ki), je = Math.floor(Bt.height * ki), W.isDataArrayTexture ? $e = Bt.depth : W.isData3DTexture ? $e = Math.floor(Bt.depth * ki) : $e = 1, rt = 0, at = 0, Qe = 0
            }
            de !== null ? (bt = de.x, ht = de.y, Tt = de.z) : (bt = 0, ht = 0, Tt = 0);
            const Mt = Fe.convert(re.format),
                Ge = Fe.convert(re.type);
            let Ot;
            re.isData3DTexture ? (Ie.setTexture3D(re, 0), Ot = q.TEXTURE_3D) : re.isDataArrayTexture || re.isCompressedArrayTexture ? (Ie.setTexture2DArray(re, 0), Ot = q.TEXTURE_2D_ARRAY) : (Ie.setTexture2D(re, 0), Ot = q.TEXTURE_2D), q.pixelStorei(q.UNPACK_FLIP_Y_WEBGL, re.flipY), q.pixelStorei(q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, re.premultiplyAlpha), q.pixelStorei(q.UNPACK_ALIGNMENT, re.unpackAlignment);
            const Ft = q.getParameter(q.UNPACK_ROW_LENGTH),
                Fi = q.getParameter(q.UNPACK_IMAGE_HEIGHT),
                yi = q.getParameter(q.UNPACK_SKIP_PIXELS),
                di = q.getParameter(q.UNPACK_SKIP_ROWS),
                gn = q.getParameter(q.UNPACK_SKIP_IMAGES);
            q.pixelStorei(q.UNPACK_ROW_LENGTH, Bt.width), q.pixelStorei(q.UNPACK_IMAGE_HEIGHT, Bt.height), q.pixelStorei(q.UNPACK_SKIP_PIXELS, rt), q.pixelStorei(q.UNPACK_SKIP_ROWS, at), q.pixelStorei(q.UNPACK_SKIP_IMAGES, Qe);
            const zt = W.isDataArrayTexture || W.isData3DTexture,
                bi = re.isDataArrayTexture || re.isData3DTexture;
            if (W.isDepthTexture) {
                const ki = ze.get(W),
                    ti = ze.get(re),
                    Rt = ze.get(ki.__renderTarget),
                    Xt = ze.get(ti.__renderTarget);
                ke.bindFramebuffer(q.READ_FRAMEBUFFER, Rt.__webglFramebuffer), ke.bindFramebuffer(q.DRAW_FRAMEBUFFER, Xt.__webglFramebuffer);
                for (let Wi = 0; Wi < $e; Wi++) zt && (q.framebufferTextureLayer(q.READ_FRAMEBUFFER, q.COLOR_ATTACHMENT0, ze.get(W).__webglTexture, se, Qe + Wi), q.framebufferTextureLayer(q.DRAW_FRAMEBUFFER, q.COLOR_ATTACHMENT0, ze.get(re).__webglTexture, Ae, Tt + Wi)), q.blitFramebuffer(rt, at, Ne, je, bt, ht, Ne, je, q.DEPTH_BUFFER_BIT, q.NEAREST);
                ke.bindFramebuffer(q.READ_FRAMEBUFFER, null), ke.bindFramebuffer(q.DRAW_FRAMEBUFFER, null)
            } else if (se !== 0 || W.isRenderTargetTexture || ze.has(W)) {
                const ki = ze.get(W),
                    ti = ze.get(re);
                ke.bindFramebuffer(q.READ_FRAMEBUFFER, En), ke.bindFramebuffer(q.DRAW_FRAMEBUFFER, on);
                for (let Rt = 0; Rt < $e; Rt++) zt ? q.framebufferTextureLayer(q.READ_FRAMEBUFFER, q.COLOR_ATTACHMENT0, ki.__webglTexture, se, Qe + Rt) : q.framebufferTexture2D(q.READ_FRAMEBUFFER, q.COLOR_ATTACHMENT0, q.TEXTURE_2D, ki.__webglTexture, se), bi ? q.framebufferTextureLayer(q.DRAW_FRAMEBUFFER, q.COLOR_ATTACHMENT0, ti.__webglTexture, Ae, Tt + Rt) : q.framebufferTexture2D(q.DRAW_FRAMEBUFFER, q.COLOR_ATTACHMENT0, q.TEXTURE_2D, ti.__webglTexture, Ae), se !== 0 ? q.blitFramebuffer(rt, at, Ne, je, bt, ht, Ne, je, q.COLOR_BUFFER_BIT, q.NEAREST) : bi ? q.copyTexSubImage3D(Ot, Ae, bt, ht, Tt + Rt, rt, at, Ne, je) : q.copyTexSubImage2D(Ot, Ae, bt, ht, rt, at, Ne, je);
                ke.bindFramebuffer(q.READ_FRAMEBUFFER, null), ke.bindFramebuffer(q.DRAW_FRAMEBUFFER, null)
            } else bi ? W.isDataTexture || W.isData3DTexture ? q.texSubImage3D(Ot, Ae, bt, ht, Tt, Ne, je, $e, Mt, Ge, Bt.data) : re.isCompressedArrayTexture ? q.compressedTexSubImage3D(Ot, Ae, bt, ht, Tt, Ne, je, $e, Mt, Bt.data) : q.texSubImage3D(Ot, Ae, bt, ht, Tt, Ne, je, $e, Mt, Ge, Bt) : W.isDataTexture ? q.texSubImage2D(q.TEXTURE_2D, Ae, bt, ht, Ne, je, Mt, Ge, Bt.data) : W.isCompressedTexture ? q.compressedTexSubImage2D(q.TEXTURE_2D, Ae, bt, ht, Bt.width, Bt.height, Mt, Bt.data) : q.texSubImage2D(q.TEXTURE_2D, Ae, bt, ht, Ne, je, Mt, Ge, Bt);
            q.pixelStorei(q.UNPACK_ROW_LENGTH, Ft), q.pixelStorei(q.UNPACK_IMAGE_HEIGHT, Fi), q.pixelStorei(q.UNPACK_SKIP_PIXELS, yi), q.pixelStorei(q.UNPACK_SKIP_ROWS, di), q.pixelStorei(q.UNPACK_SKIP_IMAGES, gn), Ae === 0 && re.generateMipmaps && q.generateMipmap(Ot), ke.unbindTexture()
        }, this.copyTextureToTexture3D = function(W, re, ce = null, de = null, se = 0) {
            return warnOnce('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(W, re, ce, de, se)
        }, this.initRenderTarget = function(W) {
            ze.get(W).__webglFramebuffer === void 0 && Ie.setupRenderTarget(W)
        }, this.initTexture = function(W) {
            W.isCubeTexture ? Ie.setTextureCube(W, 0) : W.isData3DTexture ? Ie.setTexture3D(W, 0) : W.isDataArrayTexture || W.isCompressedArrayTexture ? Ie.setTexture2DArray(W, 0) : Ie.setTexture2D(W, 0), ke.unbindTexture()
        }, this.resetState = function() {
            R = 0, I = 0, k = null, ke.reset(), ct.reset()
        }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    get coordinateSystem() {
        return WebGLCoordinateSystem
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(i) {
        this._outputColorSpace = i;
        const o = this.getContext();
        o.drawingBufferColorSpace = ColorManagement._getDrawingBufferColorSpace(i), o.unpackColorSpace = ColorManagement._getUnpackColorSpace()
    }
}
var lethargy = {},
    hasRequiredLethargy;

function requireLethargy() {
    return hasRequiredLethargy || (hasRequiredLethargy = 1, function(l) {
        (function() {
            var i;
            i = l !== null ? l : this, i.Lethargy = function() {
                function o(c, u, p, m) {
                    this.stability = c != null ? Math.abs(c) : 8, this.sensitivity = u != null ? 1 + Math.abs(u) : 100, this.tolerance = p != null ? 1 + Math.abs(p) : 1.1, this.delay = m ? ? 150, this.lastUpDeltas = function() {
                        var g, _, v;
                        for (v = [], g = 1, _ = this.stability * 2; 1 <= _ ? g <= _ : g >= _; 1 <= _ ? g++ : g--) v.push(null);
                        return v
                    }.call(this), this.lastDownDeltas = function() {
                        var g, _, v;
                        for (v = [], g = 1, _ = this.stability * 2; 1 <= _ ? g <= _ : g >= _; 1 <= _ ? g++ : g--) v.push(null);
                        return v
                    }.call(this), this.deltasTimestamp = function() {
                        var g, _, v;
                        for (v = [], g = 1, _ = this.stability * 2; 1 <= _ ? g <= _ : g >= _; 1 <= _ ? g++ : g--) v.push(null);
                        return v
                    }.call(this)
                }
                return o.prototype.check = function(c) {
                    var u;
                    return c = c.originalEvent || c, c.wheelDelta != null ? u = c.wheelDelta : c.deltaY != null ? u = c.deltaY * -40 : (c.detail != null || c.detail === 0) && (u = c.detail * -40), this.deltasTimestamp.push(Date.now()), this.deltasTimestamp.shift(), u > 0 ? (this.lastUpDeltas.push(u), this.lastUpDeltas.shift(), this.isInertia(1)) : (this.lastDownDeltas.push(u), this.lastDownDeltas.shift(), this.isInertia(-1))
                }, o.prototype.isInertia = function(c) {
                    var u, p, m, g, _, v, x;
                    return u = c === -1 ? this.lastDownDeltas : this.lastUpDeltas, u[0] === null ? c : this.deltasTimestamp[this.stability * 2 - 2] + this.delay > Date.now() && u[0] === u[this.stability * 2 - 1] ? !1 : (m = u.slice(0, this.stability), p = u.slice(this.stability, this.stability * 2), x = m.reduce(function(y, b) {
                        return y + b
                    }), _ = p.reduce(function(y, b) {
                        return y + b
                    }), v = x / m.length, g = _ / p.length, Math.abs(v) < Math.abs(g * this.tolerance) && this.sensitivity < Math.abs(g) ? c : !1)
                }, o.prototype.showLastUpDeltas = function() {
                    return this.lastUpDeltas
                }, o.prototype.showLastDownDeltas = function() {
                    return this.lastDownDeltas
                }, o
            }()
        }).call(lethargy)
    }(lethargy)), lethargy
}
requireLethargy();
var Bezier;
(l => {
    l.NEWTON_ITERATIONS = 4, l.NEWTON_MIN_SLOPE = .001, l.SUBDIVISION_PRECISION = 1e-7, l.SUBDIVISION_MAX_ITERATIONS = 10, l.BEZIER_EASING_CACHE_SIZE = 11, l.BEZIER_EASING_SAMPLE_STEP_SIZE = 1 / l.BEZIER_EASING_CACHE_SIZE;

    function i(v) {
        return -v.p0 + 3 * v.p1 - 3 * v.p2 + v.p3
    }

    function o(v) {
        return 3 * v.p0 - 6 * v.p1 + 3 * v.p2
    }

    function c(v) {
        return -3 * v.p0 + 3 * v.p1
    }

    function u(v, x) {
        return 3 * i(v) * x * x + 2 * o(v) * x + c(v)
    }
    l.calcBezierSlope = u;

    function p(v, x) {
        return ((i(v) * x + o(v)) * x + c(v)) * x + v.p0
    }
    l.calcBezier = p;

    function m(v, x, y, b) {
        let S = 0,
            C = 0;
        for (let E = 0; E < l.SUBDIVISION_MAX_ITERATIONS; E++) C = x + (y - x) / 2, S = p(b, C), S > v ? y = C : x = C;
        return C
    }

    function g(v, x, y) {
        for (let b = 0; b < l.NEWTON_ITERATIONS; b++) {
            const S = u(x, y);
            if (S == 0) return y;
            const C = p(x, y) - v;
            y -= C / S
        }
        return y
    }

    function _(v, x, y) {
        v.p1 = Math.max(v.p0, Math.min(v.p3, v.p1)), v.p2 = Math.max(v.p0, Math.min(v.p3, v.p2));
        let b = 0;
        for (let E = 1; E < y.length && (b = E - 1, !(x < y[E])); E++);
        const S = b / (l.BEZIER_EASING_CACHE_SIZE - 1),
            C = u(v, S) / (v.p3 - v.p0);
        return C == 0 ? S : C > .01 ? g(x, v, S) : m(x, S, S + l.BEZIER_EASING_SAMPLE_STEP_SIZE, v)
    }
    l.getBezierTfromX = _
})(Bezier || (Bezier = {}));
var Easings;
(l => {
    function i(T = 6) {
        return M => {
            const A = Math.exp(-T * (2 * M - 1)),
                D = Math.exp(-T);
            return (1 + (1 - A) / (1 + A) * (1 + D) / (1 - D)) / 2
        }
    }
    l.sigmoid = i;

    function o(T, M, A) {
        const D = Math.max(0, Math.min(1, (A - T) / (M - T)));
        return D * D * (3 - 2 * D)
    }
    l.smoothstep = o;

    function c(T) {
        return T
    }
    l.linear = c;

    function u(T) {
        return T * T
    }
    l.easeInQuad = u;

    function p(T) {
        return T * (2 - T)
    }
    l.easeOutQuad = p;

    function m(T) {
        return T < .5 ? 2 * T * T : -1 + (4 - 2 * T) * T
    }
    l.easeInOutQuad = m;

    function g(T) {
        return T * T * T
    }
    l.easeInCubic = g;

    function _(T) {
        return --T * T * T + 1
    }
    l.easeOutCubic = _;

    function v(T) {
        return T < .5 ? 4 * T * T * T : (T - 1) * (2 * T - 2) * (2 * T - 2) + 1
    }
    l.easeInOutCubic = v;

    function x(T) {
        return T * T * T * T
    }
    l.easeInQuart = x;

    function y(T) {
        return 1 - --T * T * T * T
    }
    l.easeOutQuart = y;

    function b(T) {
        return T < .5 ? 8 * T * T * T * T : 1 - 8 * --T * T * T * T
    }
    l.easeInOutQuart = b;

    function S(T) {
        return T * T * T * T * T
    }
    l.easeInQuint = S;

    function C(T) {
        return 1 + --T * T * T * T * T
    }
    l.easeOutQuint = C;

    function E(T) {
        return T < .5 ? 16 * T * T * T * T * T : 1 + 16 * --T * T * T * T * T
    }
    l.easeInOutQuint = E;

    function P(T, M, A, D) {
        const R = new Array(Bezier.BEZIER_EASING_CACHE_SIZE);
        for (let I = 0; I < Bezier.BEZIER_EASING_CACHE_SIZE; ++I) R[I] = Bezier.calcBezier({
            p0: T.x,
            p1: M.x,
            p2: A.x,
            p3: D.x
        }, I / (Bezier.BEZIER_EASING_CACHE_SIZE - 1));
        return I => I <= T.x ? T.y : D.x <= I ? D.y : Bezier.calcBezier({
            p0: T.y,
            p1: M.y,
            p2: A.y,
            p3: D.y
        }, Bezier.getBezierTfromX({
            p0: T.x,
            p1: M.x,
            p2: A.x,
            p3: D.x
        }, I, R))
    }
    l.bezier = P;

    function w(T, M, A, D) {
        return P({
            x: 0,
            y: 0
        }, {
            x: T,
            y: M
        }, {
            x: A,
            y: D
        }, {
            x: 1,
            y: 1
        })
    }
    l.cubicBezier = w
})(Easings || (Easings = {}));
var Lerps;
(l => {
    function i(g, _, v) {
        return g + (_ - g) * v
    }
    l.number = i;

    function o(g, _, v) {
        if (g.length == _.length) {
            const x = [];
            for (let y = 0; y < g.length; y++) x.push(g[y] + (_[y] - g[y]) * v);
            return x
        } else return console.log("Different length Arrays!!!"), !1
    }
    l.numberArray = o;

    function c(g, _, v) {
        return g.clone().lerp(_, v)
    }
    l.THREEVectors = c;

    function u(g, _, v) {
        return g.clone().slerp(_, v)
    }
    l.THREEQuaternion = u;

    function p(g, _, v) {
        const x = g.clone(),
            y = _.clone();
        return x.x = x.x + (y.x - x.x) * v, x.y = x.y + (y.y - x.y) * v, x.z = x.z + (y.z - x.z) * v, x
    }
    l.THREEEuler = p;

    function m(g) {
        if (typeof g == "number") return l.number;
        if (g instanceof Array) return l.numberArray;
        if ("isVector2" in g || "isVector3" in g || "isVector4" in g || "isColor" in g) return l.THREEVectors;
        if ("isQuaternion" in g) return l.THREEQuaternion;
        if ("isEuler" in g) return l.THREEEuler
    }
    l.getLerpFunc = m
})(Lerps || (Lerps = {}));
const cloneValue = l => typeof l == "number" ? l : l instanceof Array ? l.concat() : "clone" in l ? l.clone() : l;
class Animator extends EventDispatcher {
    dataBase;
    variables;
    dispatchEvents = [];
    _isAnimating = !1;
    constructor() {
        super(), this.variables = {}, this.dataBase = {}
    }
    add(i) {
        const o = {
            time: 0,
            duration: 0,
            value: cloneValue(i.initValue),
            startValue: cloneValue(i.initValue),
            goalValue: cloneValue(i.initValue),
            easing: i.easing || Easings.sigmoid(),
            lerpFunc: i.customLerpFunc || Lerps.getLerpFunc(i.initValue),
            userData: i.userData,
            isAnimating: !1,
            isAnimatingReseve: !1
        };
        return this.dataBase[i.name] = o.value, this.variables[i.name] = o, o
    }
    setEasing(i, o) {
        const c = this.variables[i];
        c ? c.easing = o : console.warn('"' + i + '" is not exist')
    }
    setValue(i, o, c) {
        let u = this.dataBase[i];
        if (u !== void 0) typeof u == "number" ? this.dataBase[i] = o : "copy" in u ? u.copy(o) : u instanceof Array && (u = o.concat()), c && this.setEasing(i, c), this.updateDataBase(i), this.cancelAnimate(i);
        else return console.warn('"' + i + '" is not exist'), null
    }
    animate(i, o, c = 1) {
        return new Promise((u, p) => {
            const m = this.variables[i];
            m ? (this.cancelAnimate(i), m.time = 0, m.isAnimating = !0, m.isAnimatingReseve = !0, m.duration = c, m.startValue = cloneValue(m.value), m.goalValue = cloneValue(o), m.onAnimationCanceled = () => {
                m.onAnimationFinished = null, p("animation canceled")
            }, m.onAnimationFinished = () => {
                m.onAnimationFinished = null, u(null)
            }, this._isAnimating = !0) : p('"' + i + '" is not exist')
        }).catch(u => {})
    }
    cancelAnimate(i) {
        const o = this.variables[i];
        o ? (o.isAnimating = !1, o.onAnimationFinished = null, o.onAnimationCanceled && o.onAnimationCanceled(), o.onAnimationCanceled = null) : console.warn('"' + i + '" is not exist')
    }
    get(i) {
        return this.variables[i] ? this.variables[i].value : (console.warn('"' + i + '" is not exist'), null)
    }
    getVariableObject(i, o = !1) {
        return this.variables[i] ? this.variables[i] : (o || console.warn('"' + i + '" is not exist'), null)
    }
    isAnimating(i) {
        return i !== void 0 ? this.variables[i] ? this.variables[i].isAnimating : !1 : this._isAnimating
    }
    wait(i) {
        return new Promise(c => {
            setTimeout(() => {
                c()
            }, i * 1e3)
        })
    }
    update(i) {
        this._isAnimating = !1;
        const o = Object.keys(this.variables);
        for (let c = 0; c < o.length; c++) {
            const u = o[c],
                p = this.variables[u];
            if (p.isAnimating && p.isAnimatingReseve) {
                this._isAnimating = !0;
                let m = !1;
                const g = p.duration,
                    _ = p.easing,
                    v = p.lerpFunc;
                g == 0 ? p.time = 1 : p.time += (i || .016) / g, p.time >= 1 && (m = !0, p.time = 1);
                let x = p.goalValue;
                v && (x = v(p.startValue, p.goalValue, _(p.time)));
                const y = this.dataBase[u];
                typeof y == "number" || !("copy" in y) ? this.dataBase[u] = x : "copy" in y && y.copy(x), this.dispatchEvent({
                    type: "update/" + o[c],
                    deltaTime: i,
                    value: p.value
                }), m && (p.onAnimationFinished && this.dispatchEvents.push(p.onAnimationFinished), p.isAnimatingReseve = !1)
            } else p.isAnimating = !1, p.time = 0
        }
        for (; this.dispatchEvents.length != 0;) {
            const c = this.dispatchEvents.pop();
            c && c()
        }
        this.updateDataBase(), this.dispatchEvent({
            type: "update",
            deltaTime: i
        }), this._isAnimating && this.dispatchEvent({
            type: "animate",
            deltaTime: i
        })
    }
    updateDataBase(i) {
        const o = u => {
            const p = this.variables[u],
                m = this.dataBase[u];
            p && m !== void 0 && (typeof p.value == "number" || !("copy" in p.value)) && (p.value = m)
        };
        if (i) {
            o(i);
            return
        }
        const c = Object.keys(this.dataBase);
        for (let u = 0; u < c.length; u++) o(c[u])
    }
}
var EventEmitter$3 = {
    exports: {}
};
/*!
 * EventEmitter v5.2.9 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - https://oli.me.uk/
 * @preserve
 */
var EventEmitter$2 = EventEmitter$3.exports,
    hasRequiredEventEmitter;

function requireEventEmitter() {
    return hasRequiredEventEmitter || (hasRequiredEventEmitter = 1, function(l) {
        (function(i) {
            function o() {}
            var c = o.prototype,
                u = i.EventEmitter;

            function p(_, v) {
                for (var x = _.length; x--;)
                    if (_[x].listener === v) return x;
                return -1
            }

            function m(_) {
                return function() {
                    return this[_].apply(this, arguments)
                }
            }
            c.getListeners = function(v) {
                var x = this._getEvents(),
                    y, b;
                if (v instanceof RegExp) {
                    y = {};
                    for (b in x) x.hasOwnProperty(b) && v.test(b) && (y[b] = x[b])
                } else y = x[v] || (x[v] = []);
                return y
            }, c.flattenListeners = function(v) {
                var x = [],
                    y;
                for (y = 0; y < v.length; y += 1) x.push(v[y].listener);
                return x
            }, c.getListenersAsObject = function(v) {
                var x = this.getListeners(v),
                    y;
                return x instanceof Array && (y = {}, y[v] = x), y || x
            };

            function g(_) {
                return typeof _ == "function" || _ instanceof RegExp ? !0 : _ && typeof _ == "object" ? g(_.listener) : !1
            }
            c.addListener = function(v, x) {
                if (!g(x)) throw new TypeError("listener must be a function");
                var y = this.getListenersAsObject(v),
                    b = typeof x == "object",
                    S;
                for (S in y) y.hasOwnProperty(S) && p(y[S], x) === -1 && y[S].push(b ? x : {
                    listener: x,
                    once: !1
                });
                return this
            }, c.on = m("addListener"), c.addOnceListener = function(v, x) {
                return this.addListener(v, {
                    listener: x,
                    once: !0
                })
            }, c.once = m("addOnceListener"), c.defineEvent = function(v) {
                return this.getListeners(v), this
            }, c.defineEvents = function(v) {
                for (var x = 0; x < v.length; x += 1) this.defineEvent(v[x]);
                return this
            }, c.removeListener = function(v, x) {
                var y = this.getListenersAsObject(v),
                    b, S;
                for (S in y) y.hasOwnProperty(S) && (b = p(y[S], x), b !== -1 && y[S].splice(b, 1));
                return this
            }, c.off = m("removeListener"), c.addListeners = function(v, x) {
                return this.manipulateListeners(!1, v, x)
            }, c.removeListeners = function(v, x) {
                return this.manipulateListeners(!0, v, x)
            }, c.manipulateListeners = function(v, x, y) {
                var b, S, C = v ? this.removeListener : this.addListener,
                    E = v ? this.removeListeners : this.addListeners;
                if (typeof x == "object" && !(x instanceof RegExp))
                    for (b in x) x.hasOwnProperty(b) && (S = x[b]) && (typeof S == "function" ? C.call(this, b, S) : E.call(this, b, S));
                else
                    for (b = y.length; b--;) C.call(this, x, y[b]);
                return this
            }, c.removeEvent = function(v) {
                var x = typeof v,
                    y = this._getEvents(),
                    b;
                if (x === "string") delete y[v];
                else if (v instanceof RegExp)
                    for (b in y) y.hasOwnProperty(b) && v.test(b) && delete y[b];
                else delete this._events;
                return this
            }, c.removeAllListeners = m("removeEvent"), c.emitEvent = function(v, x) {
                var y = this.getListenersAsObject(v),
                    b, S, C, E, P;
                for (E in y)
                    if (y.hasOwnProperty(E))
                        for (b = y[E].slice(0), C = 0; C < b.length; C++) S = b[C], S.once === !0 && this.removeListener(v, S.listener), P = S.listener.apply(this, x || []), P === this._getOnceReturnValue() && this.removeListener(v, S.listener);
                return this
            }, c.trigger = m("emitEvent"), c.emit = function(v) {
                var x = Array.prototype.slice.call(arguments, 1);
                return this.emitEvent(v, x)
            }, c.setOnceReturnValue = function(v) {
                return this._onceReturnValue = v, this
            }, c._getOnceReturnValue = function() {
                return this.hasOwnProperty("_onceReturnValue") ? this._onceReturnValue : !0
            }, c._getEvents = function() {
                return this._events || (this._events = {})
            }, o.noConflict = function() {
                return i.EventEmitter = u, o
            }, l.exports ? l.exports = o : i.EventEmitter = o
        })(typeof window < "u" ? window : EventEmitter$2 || {})
    }(EventEmitter$3)), EventEmitter$3.exports
}
var EventEmitterExports = requireEventEmitter();
const EventEmitter$1 = getDefaultExportFromCjs(EventEmitterExports),
    vert = `#define GLSLIFY 1
varying vec2 vUv;void main(){gl_Position=vec4(position,1.0);vUv=uv;}`,
    passThroughFrag = `#define GLSLIFY 1
uniform sampler2D tex;varying vec2 vUv;void main(){gl_FragColor=texture2D(tex,vUv);}`;
var UniformsLib;
(l => {
    function i(...o) {
        const c = {};
        for (let u = 0; u < o.length; u++) o[u] != null && Object.assign(c, o[u]);
        return c
    }
    l.mergeUniforms = i
})(UniformsLib || (UniformsLib = {}));
class GPUComputationController {
    renderer;
    dataSize;
    uniforms;
    scene;
    camera;
    mesh;
    materials;
    tempDataLinear;
    tempDataNear;
    renderTargets = [];
    get isSupported() {
        return this.renderer.extensions.get("OES_texture_float")
    }
    constructor(i, o) {
        this.renderer = i, this.dataSize = o.clone(), this.uniforms = {
            dataSize: {
                value: this.dataSize
            }
        }, this.tempDataLinear = this.createData({
            minFilter: LinearFilter,
            magFilter: LinearFilter
        }), this.tempDataNear = this.createData({
            minFilter: NearestFilter,
            magFilter: NearestFilter
        }), this.scene = new Scene, this.camera = new Camera, this.materials = [], this.mesh = new Mesh(new PlaneGeometry(2, 2)), this.scene.add(this.mesh)
    }
    createInitializeTexture() {
        const i = new Float32Array(this.uniforms.dataSize.value.x * this.uniforms.dataSize.value.y * 4),
            o = new DataTexture(i, this.uniforms.dataSize.value.x, this.uniforms.dataSize.value.y, RGBAFormat, FloatType);
        return o.needsUpdate = !0, o
    }
    createData(i, o) {
        const c = navigator.userAgent,
            u = c.indexOf("iPhone") >= 0 || c.indexOf("iPad") >= 0 || navigator.platform == "iPad" || navigator.platform == "MacIntel" && navigator.userAgent.indexOf("Safari") != -1 && navigator.userAgent.indexOf("Chrome") == -1 && navigator.standalone !== void 0,
            p = {
                wrapS: ClampToEdgeWrapping,
                wrapT: ClampToEdgeWrapping,
                minFilter: NearestFilter,
                magFilter: NearestFilter,
                format: RGBAFormat,
                type: u ? HalfFloatType : FloatType,
                stencilBuffer: !1,
                depthBuffer: !1
            };
        let m = null,
            g = null;
        i && (i.isDataTexture ? (m = i, o && (g = o)) : g = i), g && (p.wrapS = g.wrapS || p.wrapS, p.wrapT = g.wrapT || p.wrapT, p.minFilter = g.minFilter || p.minFilter, p.magFilter = g.magFilter || p.magFilter, p.format = g.format || p.format, p.type = g.type || p.type, p.stencilBuffer = g.stencilBuffer || p.stencilBuffer, p.depthBuffer = g.depthBuffer || p.depthBuffer);
        const _ = new WebGLRenderTarget(this.uniforms.dataSize.value.x, this.uniforms.dataSize.value.y, p),
            v = {
                buffer: _
            };
        if (this.renderTargets.push(_), m) {
            const x = this.createKernel({
                fragmentShader: passThroughFrag,
                uniforms: {
                    tex: {
                        value: m
                    }
                }
            });
            this.compute(x, v)
        }
        return v
    }
    createKernel(i) {
        const o = UniformsLib.mergeUniforms(i.uniforms, this.uniforms);
        i.uniforms = o, i.vertexShader = i.vertexShader || vert;
        const c = new ShaderMaterial(i);
        return this.materials.push(c), {
            material: c,
            uniforms: i.uniforms
        }
    }
    compute(i, o, c) {
        let u;
        o.buffer.texture.magFilter == LinearFilter ? u = this.tempDataLinear : u = this.tempDataNear, this.mesh.material = i.material;
        const p = this.renderer.getRenderTarget();
        this.renderer.setRenderTarget(u.buffer), this.renderer.render(this.scene, c || this.camera), this.swapBuffers(o, u), this.renderer.setRenderTarget(p)
    }
    swapBuffers(i, o) {
        const c = i.buffer;
        i.buffer = o.buffer, o.buffer = c
    }
    dispose() {
        this.mesh.geometry.dispose();
        for (let o = 0; o < this.materials.length; o++) this.materials[o].dispose();
        this.scene.remove(this.mesh), this.tempDataLinear.buffer.dispose(), this.tempDataNear.buffer.dispose()
    }
    resizeData(i) {
        this.dataSize.copy(i);
        for (let o = 0; o < this.renderTargets.length; o++) this.renderTargets[o].setSize(i.x, i.y)
    }
}
class PostProcess {
    renderer;
    passes;
    scene;
    quad;
    camera;
    projectionMatrix;
    projectionMatrixInverse;
    cameraMatrix;
    viewMatrix;
    constructor(i) {
        this.renderer = i.renderer, this.passes = i.passes, this.scene = new Scene, this.quad = new Mesh(new PlaneGeometry(2, 2)), this.scene.add(this.quad), this.camera = new Camera, this.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4, this.cameraMatrix = new Matrix4, this.viewMatrix = new Matrix4
    }
    render(i, o) {
        const c = this.renderer.getRenderTarget(),
            u = this.renderer.autoClear;
        this.renderer.autoClear = !1, o && o.camera && (this.projectionMatrix.copy(o.camera.projectionMatrix), this.projectionMatrixInverse.copy(this.projectionMatrix).invert(), this.cameraMatrix.copy(o.camera.matrixWorld), this.viewMatrix.copy(o.camera.matrixWorld).invert());
        let p = i || null;
        for (let m = 0; m < this.passes.length; m++) {
            const g = this.passes[m];
            this.quad.material = g, g.uniforms.uBackBuffer = {
                value: p
            }, o && o.camera && (g.uniforms.pProjectionMatrix = {
                value: this.projectionMatrix
            }, g.uniforms.pProjectionMatrixInverse = {
                value: this.projectionMatrixInverse
            }, g.uniforms.pCameraMatrix = {
                value: this.cameraMatrix
            }, g.uniforms.pViewMatrix = {
                value: this.viewMatrix
            }), this.renderer.setRenderTarget(g.renderTarget), this.renderer.render(this.scene, this.camera), !g.passThrough && g.renderTarget && (p = g.renderTarget.texture)
        }
        this.renderer.setRenderTarget(c), this.renderer.autoClear = u
    }
    resize(i) {
        for (let o = 0; o < this.passes.length; o++) this.passes[o].resize(i)
    }
}
const quadVert = `#define GLSLIFY 1
out vec2 vUv;void main(void){vec3 pos=position;gl_Position=vec4(pos.xy,0.0,1.0);vUv=uv;}`,
    outFrag = `#define GLSLIFY 1
uniform sampler2D uBackBuffer;varying vec2 vUv;void main(void){vec4 col=texture2D(uBackBuffer,vUv);gl_FragColor=col;}`;
class PostProcessPass extends ShaderMaterial {
    renderTarget;
    clearColor;
    clearDepth;
    passThrough;
    resolution;
    resolutionInv;
    resolutionRatio;
    constructor(i) {
        i = i || {};
        const {
            renderTarget: o,
            resolutionRatio: c,
            passThrough: u,
            ...p
        } = i, m = UniformsLib.mergeUniforms(p.uniforms, {
            uResolution: {
                value: new Vector2
            },
            uResolutionInv: {
                value: new Vector2
            }
        });
        super({ ...p,
            vertexShader: i.vertexShader ? ? quadVert,
            fragmentShader: i.fragmentShader ? ? outFrag,
            uniforms: m
        }), o === void 0 ? this.renderTarget = new WebGLRenderTarget(1, 1) : this.renderTarget = o, this.clearColor = i.clearColor ? ? null, this.clearDepth = i.clearDepth ? ? null, this.passThrough = u || !1, this.resolution = m.uResolution.value, this.resolutionInv = m.uResolutionInv.value, this.resolutionRatio = c || 1
    }
    resize(i) {
        this.resolution.copy(i).multiplyScalar(this.resolutionRatio).floor(), this.resolutionInv.set(1, 1).divide(this.resolution), this.renderTarget && this.renderTarget.setSize(this.resolution.x, this.resolution.y)
    }
    setRendertarget(i) {
        this.renderTarget = i, this.renderTarget && (this.renderTarget.width != this.resolution.x || this.renderTarget.height != this.resolution.y) && this.resize(this.resolution)
    }
}
class LayoutController {
    obj;
    baseTransform;
    transform;
    constructor(i, o, c) {
        this.obj = i, this.baseTransform = {
            position: this.obj.position.clone(),
            rotation: this.obj.quaternion.clone(),
            scale: this.obj.scale.clone()
        }, this.transform = o, c || (this.transform.position && this.transform.position.add(this.obj.position), this.transform.rotation && this.transform.rotation.multiply(this.obj.quaternion))
    }
    updateTransform(i) {
        this.transform.position && this.obj.position.copy(this.baseTransform.position.clone().lerp(this.transform.position, i)), this.transform.rotation && this.obj.quaternion.copy(this.baseTransform.rotation.clone().slerp(this.transform.rotation, i)), this.transform.scale && this.obj.scale.copy(this.baseTransform.scale.clone().multiplyScalar(this.transform.scale * i + 1 - i))
    }
}
var version = "1.3.4";

function clamp$2(l, i, o) {
    return Math.max(l, Math.min(i, o))
}

function lerp(l, i, o) {
    return (1 - o) * l + o * i
}

function damp(l, i, o, c) {
    return lerp(l, i, 1 - Math.exp(-o * c))
}

function modulo(l, i) {
    return (l % i + i) % i
}
var Animate = class {
    isRunning = !1;
    value = 0;
    from = 0;
    to = 0;
    currentTime = 0;
    lerp;
    duration;
    easing;
    onUpdate;
    advance(l) {
        if (!this.isRunning) return;
        let i = !1;
        if (this.duration && this.easing) {
            this.currentTime += l;
            const o = clamp$2(0, this.currentTime / this.duration, 1);
            i = o >= 1;
            const c = i ? 1 : this.easing(o);
            this.value = this.from + (this.to - this.from) * c
        } else this.lerp ? (this.value = damp(this.value, this.to, this.lerp * 60, l), Math.round(this.value) === this.to && (this.value = this.to, i = !0)) : (this.value = this.to, i = !0);
        i && this.stop(), this.onUpdate ? .(this.value, i)
    }
    stop() {
        this.isRunning = !1
    }
    fromTo(l, i, {
        lerp: o,
        duration: c,
        easing: u,
        onStart: p,
        onUpdate: m
    }) {
        this.from = this.value = l, this.to = i, this.lerp = o, this.duration = c, this.easing = u, this.currentTime = 0, this.isRunning = !0, p ? .(), this.onUpdate = m
    }
};

function debounce(l, i) {
    let o;
    return function(...c) {
        let u = this;
        clearTimeout(o), o = setTimeout(() => {
            o = void 0, l.apply(u, c)
        }, i)
    }
}
var Dimensions = class {
        constructor(l, i, {
            autoResize: o = !0,
            debounce: c = 250
        } = {}) {
            this.wrapper = l, this.content = i, o && (this.debouncedResize = debounce(this.resize, c), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
        }
        width = 0;
        height = 0;
        scrollHeight = 0;
        scrollWidth = 0;
        debouncedResize;
        wrapperResizeObserver;
        contentResizeObserver;
        destroy() {
            this.wrapperResizeObserver ? .disconnect(), this.contentResizeObserver ? .disconnect(), this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1)
        }
        resize = () => {
            this.onWrapperResize(), this.onContentResize()
        };
        onWrapperResize = () => {
            this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
        };
        onContentResize = () => {
            this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
        };
        get limit() {
            return {
                x: this.scrollWidth - this.width,
                y: this.scrollHeight - this.height
            }
        }
    },
    Emitter$2 = class {
        events = {};
        emit(i, ...o) {
            let c = this.events[i] || [];
            for (let u = 0, p = c.length; u < p; u++) c[u] ? .(...o)
        }
        on(i, o) {
            return this.events[i] ? .push(o) || (this.events[i] = [o]), () => {
                this.events[i] = this.events[i] ? .filter(c => o !== c)
            }
        }
        off(i, o) {
            this.events[i] = this.events[i] ? .filter(c => o !== c)
        }
        destroy() {
            this.events = {}
        }
    },
    LINE_HEIGHT = 100 / 6,
    listenerOptions = {
        passive: !1
    },
    VirtualScroll = class {
        constructor(l, i = {
            wheelMultiplier: 1,
            touchMultiplier: 1
        }) {
            this.element = l, this.options = i, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, listenerOptions), this.element.addEventListener("touchstart", this.onTouchStart, listenerOptions), this.element.addEventListener("touchmove", this.onTouchMove, listenerOptions), this.element.addEventListener("touchend", this.onTouchEnd, listenerOptions)
        }
        touchStart = {
            x: 0,
            y: 0
        };
        lastDelta = {
            x: 0,
            y: 0
        };
        window = {
            width: 0,
            height: 0
        };
        emitter = new Emitter$2;
        on(l, i) {
            return this.emitter.on(l, i)
        }
        destroy() {
            this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, listenerOptions), this.element.removeEventListener("touchstart", this.onTouchStart, listenerOptions), this.element.removeEventListener("touchmove", this.onTouchMove, listenerOptions), this.element.removeEventListener("touchend", this.onTouchEnd, listenerOptions)
        }
        onTouchStart = l => {
            const {
                clientX: i,
                clientY: o
            } = l.targetTouches ? l.targetTouches[0] : l;
            this.touchStart.x = i, this.touchStart.y = o, this.lastDelta = {
                x: 0,
                y: 0
            }, this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: l
            })
        };
        onTouchMove = l => {
            const {
                clientX: i,
                clientY: o
            } = l.targetTouches ? l.targetTouches[0] : l, c = -(i - this.touchStart.x) * this.options.touchMultiplier, u = -(o - this.touchStart.y) * this.options.touchMultiplier;
            this.touchStart.x = i, this.touchStart.y = o, this.lastDelta = {
                x: c,
                y: u
            }, this.emitter.emit("scroll", {
                deltaX: c,
                deltaY: u,
                event: l
            })
        };
        onTouchEnd = l => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: l
            })
        };
        onWheel = l => {
            let {
                deltaX: i,
                deltaY: o,
                deltaMode: c
            } = l;
            const u = c === 1 ? LINE_HEIGHT : c === 2 ? this.window.width : 1,
                p = c === 1 ? LINE_HEIGHT : c === 2 ? this.window.height : 1;
            i *= u, o *= p, i *= this.options.wheelMultiplier, o *= this.options.wheelMultiplier, this.emitter.emit("scroll", {
                deltaX: i,
                deltaY: o,
                event: l
            })
        };
        onWindowResize = () => {
            this.window = {
                width: window.innerWidth,
                height: window.innerHeight
            }
        }
    },
    defaultEasing = l => Math.min(1, 1.001 - Math.pow(2, -10 * l)),
    Lenis = class {
        _isScrolling = !1;
        _isStopped = !1;
        _isLocked = !1;
        _preventNextNativeScrollEvent = !1;
        _resetVelocityTimeout = null;
        __rafID = null;
        isTouching;
        time = 0;
        userData = {};
        lastVelocity = 0;
        velocity = 0;
        direction = 0;
        options;
        targetScroll;
        animatedScroll;
        animate = new Animate;
        emitter = new Emitter$2;
        dimensions;
        virtualScroll;
        constructor({
            wrapper: l = window,
            content: i = document.documentElement,
            eventsTarget: o = l,
            smoothWheel: c = !0,
            syncTouch: u = !1,
            syncTouchLerp: p = .075,
            touchInertiaMultiplier: m = 35,
            duration: g,
            easing: _,
            lerp: v = .1,
            infinite: x = !1,
            orientation: y = "vertical",
            gestureOrientation: b = "vertical",
            touchMultiplier: S = 1,
            wheelMultiplier: C = 1,
            autoResize: E = !0,
            prevent: P,
            virtualScroll: w,
            overscroll: T = !0,
            autoRaf: M = !1,
            anchors: A = !1,
            autoToggle: D = !1,
            allowNestedScroll: R = !1,
            __experimental__naiveDimensions: I = !1
        } = {}) {
            window.lenisVersion = version, (!l || l === document.documentElement) && (l = window), typeof g == "number" && typeof _ != "function" ? _ = defaultEasing : typeof _ == "function" && typeof g != "number" && (g = 1), this.options = {
                wrapper: l,
                content: i,
                eventsTarget: o,
                smoothWheel: c,
                syncTouch: u,
                syncTouchLerp: p,
                touchInertiaMultiplier: m,
                duration: g,
                easing: _,
                lerp: v,
                infinite: x,
                gestureOrientation: b,
                orientation: y,
                touchMultiplier: S,
                wheelMultiplier: C,
                autoResize: E,
                prevent: P,
                virtualScroll: w,
                overscroll: T,
                autoRaf: M,
                anchors: A,
                autoToggle: D,
                allowNestedScroll: R,
                __experimental__naiveDimensions: I
            }, this.dimensions = new Dimensions(l, i, {
                autoResize: E
            }), this.updateClassName(), this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, {
                capture: !0
            }), this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener("click", this.onClick, !1), this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1), this.virtualScroll = new VirtualScroll(o, {
                touchMultiplier: S,
                wheelMultiplier: C
            }), this.virtualScroll.on("scroll", this.onVirtualScroll), this.options.autoToggle && this.rootElement.addEventListener("transitionend", this.onTransitionEnd, {
                passive: !0
            }), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
        }
        destroy() {
            this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, {
                capture: !0
            }), this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1), this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener("click", this.onClick, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName(), this.__rafID && cancelAnimationFrame(this.__rafID)
        }
        on(l, i) {
            return this.emitter.on(l, i)
        }
        off(l, i) {
            return this.emitter.off(l, i)
        }
        onScrollEnd = l => {
            l instanceof CustomEvent || (this.isScrolling === "smooth" || this.isScrolling === !1) && l.stopPropagation()
        };
        dispatchScrollendEvent = () => {
            this.options.wrapper.dispatchEvent(new CustomEvent("scrollend", {
                bubbles: this.options.wrapper === window,
                detail: {
                    lenisScrollEnd: !0
                }
            }))
        };
        onTransitionEnd = l => {
            if (l.propertyName.includes("overflow")) {
                const i = this.isHorizontal ? "overflow-x" : "overflow-y",
                    o = getComputedStyle(this.rootElement)[i];
                ["hidden", "clip"].includes(o) ? this.stop() : this.start()
            }
        };
        setScroll(l) {
            this.isHorizontal ? this.options.wrapper.scrollTo({
                left: l,
                behavior: "instant"
            }) : this.options.wrapper.scrollTo({
                top: l,
                behavior: "instant"
            })
        }
        onClick = l => {
            const o = l.composedPath().find(c => c instanceof HTMLAnchorElement && (c.getAttribute("href") ? .startsWith("#") || c.getAttribute("href") ? .startsWith("/#") || c.getAttribute("href") ? .startsWith("./#")));
            if (o) {
                const c = o.getAttribute("href");
                if (c) {
                    const u = typeof this.options.anchors == "object" && this.options.anchors ? this.options.anchors : void 0;
                    let p = `#${c.split("#")[1]}`;
                    ["#", "/#", "./#", "#top", "/#top", "./#top"].includes(c) && (p = 0), this.scrollTo(p, u)
                }
            }
        };
        onPointerDown = l => {
            l.button === 1 && this.reset()
        };
        onVirtualScroll = l => {
            if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(l) === !1) return;
            const {
                deltaX: i,
                deltaY: o,
                event: c
            } = l;
            if (this.emitter.emit("virtual-scroll", {
                    deltaX: i,
                    deltaY: o,
                    event: c
                }), c.ctrlKey || c.lenisStopPropagation) return;
            const u = c.type.includes("touch"),
                p = c.type.includes("wheel");
            this.isTouching = c.type === "touchstart" || c.type === "touchmove";
            const m = i === 0 && o === 0;
            if (this.options.syncTouch && u && c.type === "touchstart" && m && !this.isStopped && !this.isLocked) {
                this.reset();
                return
            }
            const _ = this.options.gestureOrientation === "vertical" && o === 0 || this.options.gestureOrientation === "horizontal" && i === 0;
            if (m || _) return;
            let v = c.composedPath();
            v = v.slice(0, v.indexOf(this.rootElement));
            const x = this.options.prevent;
            if (v.find(P => P instanceof HTMLElement && (typeof x == "function" && x ? .(P) || P.hasAttribute ? .("data-lenis-prevent") || u && P.hasAttribute ? .("data-lenis-prevent-touch") || p && P.hasAttribute ? .("data-lenis-prevent-wheel") || this.options.allowNestedScroll && this.checkNestedScroll(P, {
                    deltaX: i,
                    deltaY: o
                })))) return;
            if (this.isStopped || this.isLocked) {
                c.preventDefault();
                return
            }
            if (!(this.options.syncTouch && u || this.options.smoothWheel && p)) {
                this.isScrolling = "native", this.animate.stop(), c.lenisStopPropagation = !0;
                return
            }
            let b = o;
            this.options.gestureOrientation === "both" ? b = Math.abs(o) > Math.abs(i) ? o : i : this.options.gestureOrientation === "horizontal" && (b = i), (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && o > 0 || this.animatedScroll === this.limit && o < 0)) && (c.lenisStopPropagation = !0), c.preventDefault();
            const S = u && this.options.syncTouch,
                E = u && c.type === "touchend" && Math.abs(b) > 5;
            E && (b = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + b, {
                programmatic: !1,
                ...S ? {
                    lerp: E ? this.options.syncTouchLerp : 1
                } : {
                    lerp: this.options.lerp,
                    duration: this.options.duration,
                    easing: this.options.easing
                }
            })
        };
        resize() {
            this.dimensions.resize(), this.animatedScroll = this.targetScroll = this.actualScroll, this.emit()
        }
        emit() {
            this.emitter.emit("scroll", this)
        }
        onNativeScroll = () => {
            if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent) {
                this._preventNextNativeScrollEvent = !1;
                return
            }
            if (this.isScrolling === !1 || this.isScrolling === "native") {
                const l = this.animatedScroll;
                this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - l, this.direction = Math.sign(this.animatedScroll - l), this.isStopped || (this.isScrolling = "native"), this.emit(), this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout(() => {
                    this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit()
                }, 400))
            }
        };
        reset() {
            this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop()
        }
        start() {
            this.isStopped && (this.reset(), this.isStopped = !1, this.emit())
        }
        stop() {
            this.isStopped || (this.reset(), this.isStopped = !0, this.emit())
        }
        raf = l => {
            const i = l - (this.time || l);
            this.time = l, this.animate.advance(i * .001), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
        };
        scrollTo(l, {
            offset: i = 0,
            immediate: o = !1,
            lock: c = !1,
            duration: u = this.options.duration,
            easing: p = this.options.easing,
            lerp: m = this.options.lerp,
            onStart: g,
            onComplete: _,
            force: v = !1,
            programmatic: x = !0,
            userData: y
        } = {}) {
            if (!((this.isStopped || this.isLocked) && !v)) {
                if (typeof l == "string" && ["top", "left", "start"].includes(l)) l = 0;
                else if (typeof l == "string" && ["bottom", "right", "end"].includes(l)) l = this.limit;
                else {
                    let b;
                    if (typeof l == "string" ? b = document.querySelector(l) : l instanceof HTMLElement && l ? .nodeType && (b = l), b) {
                        if (this.options.wrapper !== window) {
                            const C = this.rootElement.getBoundingClientRect();
                            i -= this.isHorizontal ? C.left : C.top
                        }
                        const S = b.getBoundingClientRect();
                        l = (this.isHorizontal ? S.left : S.top) + this.animatedScroll
                    }
                }
                if (typeof l == "number") {
                    if (l += i, l = Math.round(l), this.options.infinite) {
                        if (x) {
                            this.targetScroll = this.animatedScroll = this.scroll;
                            const b = l - this.animatedScroll;
                            b > this.limit / 2 ? l = l - this.limit : b < -this.limit / 2 && (l = l + this.limit)
                        }
                    } else l = clamp$2(0, l, this.limit);
                    if (l === this.targetScroll) {
                        g ? .(this), _ ? .(this);
                        return
                    }
                    if (this.userData = y ? ? {}, o) {
                        this.animatedScroll = this.targetScroll = l, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), _ ? .(this), this.userData = {}, requestAnimationFrame(() => {
                            this.dispatchScrollendEvent()
                        });
                        return
                    }
                    x || (this.targetScroll = l), typeof u == "number" && typeof p != "function" ? p = defaultEasing : typeof p == "function" && typeof u != "number" && (u = 1), this.animate.fromTo(this.animatedScroll, l, {
                        duration: u,
                        easing: p,
                        lerp: m,
                        onStart: () => {
                            c && (this.isLocked = !0), this.isScrolling = "smooth", g ? .(this)
                        },
                        onUpdate: (b, S) => {
                            this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = b - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = b, this.setScroll(this.scroll), x && (this.targetScroll = b), S || this.emit(), S && (this.reset(), this.emit(), _ ? .(this), this.userData = {}, requestAnimationFrame(() => {
                                this.dispatchScrollendEvent()
                            }), this.preventNextNativeScrollEvent())
                        }
                    })
                }
            }
        }
        preventNextNativeScrollEvent() {
            this._preventNextNativeScrollEvent = !0, requestAnimationFrame(() => {
                this._preventNextNativeScrollEvent = !1
            })
        }
        checkNestedScroll(l, {
            deltaX: i,
            deltaY: o
        }) {
            const c = Date.now(),
                u = l._lenis ? ? = {};
            let p, m, g, _, v, x, y, b;
            const S = this.options.gestureOrientation;
            if (c - (u.time ? ? 0) > 2e3) {
                u.time = Date.now();
                const D = window.getComputedStyle(l);
                u.computedStyle = D;
                const R = D.overflowX,
                    I = D.overflowY;
                if (p = ["auto", "overlay", "scroll"].includes(R), m = ["auto", "overlay", "scroll"].includes(I), u.hasOverflowX = p, u.hasOverflowY = m, !p && !m || S === "vertical" && !m || S === "horizontal" && !p) return !1;
                v = l.scrollWidth, x = l.scrollHeight, y = l.clientWidth, b = l.clientHeight, g = v > y, _ = x > b, u.isScrollableX = g, u.isScrollableY = _, u.scrollWidth = v, u.scrollHeight = x, u.clientWidth = y, u.clientHeight = b
            } else g = u.isScrollableX, _ = u.isScrollableY, p = u.hasOverflowX, m = u.hasOverflowY, v = u.scrollWidth, x = u.scrollHeight, y = u.clientWidth, b = u.clientHeight;
            if (!p && !m || !g && !_ || S === "vertical" && (!m || !_) || S === "horizontal" && (!p || !g)) return !1;
            let C;
            if (S === "horizontal") C = "x";
            else if (S === "vertical") C = "y";
            else {
                const D = i !== 0,
                    R = o !== 0;
                D && p && g && (C = "x"), R && m && _ && (C = "y")
            }
            if (!C) return !1;
            let E, P, w, T, M;
            if (C === "x") E = l.scrollLeft, P = v - y, w = i, T = p, M = g;
            else if (C === "y") E = l.scrollTop, P = x - b, w = o, T = m, M = _;
            else return !1;
            return (w > 0 ? E < P : E > 0) && T && M
        }
        get rootElement() {
            return this.options.wrapper === window ? document.documentElement : this.options.wrapper
        }
        get limit() {
            return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
        }
        get isHorizontal() {
            return this.options.orientation === "horizontal"
        }
        get actualScroll() {
            const l = this.options.wrapper;
            return this.isHorizontal ? l.scrollX ? ? l.scrollLeft : l.scrollY ? ? l.scrollTop
        }
        get scroll() {
            return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll
        }
        get progress() {
            return this.limit === 0 ? 1 : this.scroll / this.limit
        }
        get isScrolling() {
            return this._isScrolling
        }
        set isScrolling(l) {
            this._isScrolling !== l && (this._isScrolling = l, this.updateClassName())
        }
        get isStopped() {
            return this._isStopped
        }
        set isStopped(l) {
            this._isStopped !== l && (this._isStopped = l, this.updateClassName())
        }
        get isLocked() {
            return this._isLocked
        }
        set isLocked(l) {
            this._isLocked !== l && (this._isLocked = l, this.updateClassName())
        }
        get isSmooth() {
            return this.isScrolling === "smooth"
        }
        get className() {
            let l = "lenis";
            return this.options.autoToggle && (l += " lenis-autoToggle"), this.isStopped && (l += " lenis-stopped"), this.isLocked && (l += " lenis-locked"), this.isScrolling && (l += " lenis-scrolling"), this.isScrolling === "smooth" && (l += " lenis-smooth"), l
        }
        updateClassName() {
            this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim()
        }
        cleanUpClassName() {
            this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
        }
    };
const bloomBlurFrag = `#define GLSLIFY 1
in vec2 vUv;uniform sampler2D uBloomBackBuffer;uniform vec2 uResolution;uniform bool uIsVertical;uniform float blurRange;layout(location=0)out vec4 outColor;uniform float[GAUSS_WEIGHTS]uWeights;void main(void){vec2 coord=vec2(gl_FragCoord.xy);vec3 sum=uWeights[0]*texture(uBloomBackBuffer,vUv).rgb;for(int i=1;i<GAUSS_WEIGHTS;i++){vec2 offset=(uIsVertical ? vec2(0,i): vec2(i,0))*2.0;sum+=uWeights[i]*texture(uBloomBackBuffer,vUv+offset/uResolution).rgb;sum+=uWeights[i]*texture(uBloomBackBuffer,vUv-offset/uResolution).rgb;}outColor=vec4(sum,1.0);}`,
    bloomBrightFrag = `#define GLSLIFY 1
uniform sampler2D uBackBuffer;uniform float threshold;in vec2 vUv;layout(location=0)out vec4 outColor;void main(void){vec4 c=texture(uBackBuffer,vUv);vec3 f;f.x=max(0.0,c.x-threshold);f.y=max(0.0,c.y-threshold);f.z=max(0.0,c.z-threshold);outColor=vec4(vec3(c)*f,1.0);}`,
    topSceneCompositeFrag = `#define GLSLIFY 1
uniform sampler2D uBackBuffer;uniform sampler2D uBloomTexture[4];uniform float cameraNear;uniform float cameraFar;uniform sampler2D uFluidsTex;uniform sampler2D uNotFoundSceneTex;uniform float uNotFoundVisibility;uniform sampler2D uAsciiTexture;uniform float uScreenAspectRatio;uniform float uSPWeight;in vec2 vUv;layout(location=0)out vec4 outColor;vec2 lens_distortion(vec2 r,float alpha){return r*(1.0-alpha*dot(r,r));}vec3 filmic(vec3 x){vec3 X=max(vec3(0.0),x-0.004);vec3 result=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);return pow(result,vec3(2.2));}void main(void){vec3 col=vec3(0.0,0.0,0.0);vec2 uv=vUv;vec2 cuv=uv-0.5;float len=length(cuv);vec4 fluids=texture2D(uFluidsTex,uv);uv-=(fluids.xy)*0.001;col=texture(uBackBuffer,uv).xyz;vec2 res=vec2(70.0)*(1.0-uSPWeight*0.3);if(uScreenAspectRatio>1.0){res.x*=uScreenAspectRatio;}else{res.y*=1.0/uScreenAspectRatio;}vec2 notFoundUv=floor(uv*res)/res;vec2 asciiUv=fract(uv*res);vec4 notFoundColor=texture(uNotFoundSceneTex,notFoundUv);vec4 asciiFluid=texture2D(uFluidsTex,notFoundUv);float asciiLevel=notFoundColor.x+length(asciiFluid.xy)*0.2;asciiLevel=min(1.0,asciiLevel*1.9);asciiUv.y=1.0-asciiUv.y;asciiUv.x+=15.0-(floor(asciiLevel*15.0));asciiUv.x/=16.0;vec4 asciiColor=texture(uAsciiTexture,asciiUv);col*=1.0-uNotFoundVisibility*0.6;col=mix(col,vec3(1.0),asciiColor.x*uNotFoundVisibility*0.5);
#pragma unroll_loop_start
for(int i=0;i<3;i++){col+=texture(uBloomTexture[UNROLLED_LOOP_INDEX],uv).xyz*(0.5+float(UNROLLED_LOOP_INDEX)*0.5)*0.15;}
#pragma unroll_loop_end
col.xyz*=1.3;outColor=vec4(col,1.0);}`,
    fxaaFrag = `#define GLSLIFY 1
uniform sampler2D uBackBuffer;uniform vec2 uResolution;uniform vec2 uResolutionInv;in vec2 vUv;layout(location=0)out vec4 outColor;vec4 texOffset(sampler2D tex,vec2 uv,vec2 offsetPixel,vec2 resolutionInv){return texture(tex,uv+offsetPixel*resolutionInv);}
#define FXAA_REDUCE_MIN ( 1.0 / 128.0 )
#define FXAA_REDUCE_MUL ( 1.0 / 8.0 )
#define FXAA_SPAN_MAX 8.0
void main(void){vec3 rgbNW=texOffset(uBackBuffer,vUv,vec2(-1.0,1.0),uResolutionInv).xyz;vec3 rgbNE=texOffset(uBackBuffer,vUv,vec2(1.0,1.0),uResolutionInv).xyz;vec3 rgbSW=texOffset(uBackBuffer,vUv,vec2(-1.0,-1.0),uResolutionInv).xyz;vec3 rgbSE=texOffset(uBackBuffer,vUv,vec2(1.0,-1.0),uResolutionInv).xyz;vec3 rgbM=texture(uBackBuffer,vUv).xyz;vec3 luma=vec3(0.299,0.587,0.114);float lumaNW=dot(rgbNW,luma);float lumaNE=dot(rgbNE,luma);float lumaSW=dot(rgbSW,luma);float lumaSE=dot(rgbSE,luma);float lumaM=dot(rgbM,luma);float lumaMin=min(lumaM,min(min(lumaNW,lumaNE),min(lumaSW,lumaSE)));float lumaMax=max(lumaM,max(max(lumaNW,lumaNE),max(lumaSW,lumaSE)));vec2 dir;dir.x=-((lumaNW+lumaNE)-(lumaSW+lumaSE));dir.y=((lumaNW+lumaSW)-(lumaNE+lumaSE));float dirReduce=max((lumaNW+lumaNE+lumaSW+lumaSE)*(0.25*FXAA_REDUCE_MUL),FXAA_REDUCE_MIN);float rcpDirMin=1.0/(min(abs(dir.x),abs(dir.y))+dirReduce);dir=min(vec2(FXAA_SPAN_MAX,FXAA_SPAN_MAX),max(vec2(-FXAA_SPAN_MAX,-FXAA_SPAN_MAX),dir*rcpDirMin))*uResolutionInv.xy;vec3 rgbA=(1.0/2.0)*(texture(uBackBuffer,vUv+dir*(1.0/3.0-0.5)).xyz+texture(uBackBuffer,vUv+dir*(2.0/3.0-0.5)).xyz);vec3 rgbB=rgbA*0.5+0.25*(texture(uBackBuffer,vUv+dir*-0.5).xyz+texture(uBackBuffer,vUv+dir*0.5).xyz);float lumaB=dot(rgbB,luma);if((lumaB<lumaMin)||(lumaB>lumaMax)){outColor=vec4(rgbA,1.0);}else{outColor=vec4(rgbB,1.0);};}`,
    topSceneMixerFrag = `#define GLSLIFY 1
uniform float uScreenAspectRatio;uniform float uSPWeight;uniform vec2 uResolution;uniform sampler2D uMainSceneTex;uniform sampler2D uMissionVisionSceneTex;uniform sampler2D uServiceSceneTex;uniform sampler2D uNoiseTex;uniform sampler2D uFluidsTex;uniform float uVisibleMissionVision;uniform float uVisibleMissionVisionMotionBlur;uniform float uVisibleService;in vec2 vUv;layout(location=0)out vec4 outColor;
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
void main(void){vec2 uv=vUv;vec2 cuv=uv-0.5;float len=length(cuv);vec3 o=vec3(0.0);vec4 fluids=texture2D(uFluidsTex,uv);float fluidsLength=length(fluids.xy);vec3 mainSceneCol=texture(uMainSceneTex,uv+fluids.xy*0.01).xyz;mainSceneCol.xyz*=smoothstep(1.2,0.0,len);mainSceneCol*=1.0+fluidsLength*0.8;o+=mainSceneCol;vec3 missionVisionSceneCol=texture(uMissionVisionSceneTex,uv-fluids.xy*0.01).xyz;float range=1.0/uResolution.y+abs(uVisibleMissionVisionMotionBlur)*0.2;float missionVisionSelector=0.0;float round=-cos((uv.x-0.5)*2.0*PI/2.0)*uVisibleMissionVisionMotionBlur*(1.0-uSPWeight*0.8);if(uVisibleMissionVisionMotionBlur>0.0){missionVisionSelector=smoothstep(0.0,range,-vUv.y+uVisibleMissionVision*(1.0+range)+round);}else{missionVisionSelector=smoothstep(0.0,range,-vUv.y+uVisibleMissionVision*1.0+round);}float missionFluidsThreshold=0.4+(uVisibleService*10.0);float missionVisionFluids=smoothstep(missionFluidsThreshold,missionFluidsThreshold+0.01,fluidsLength);missionVisionSceneCol.xyz*=1.0+length(fluids.xyz)*0.1*missionFluidsThreshold;missionVisionSceneCol.xyz*=smoothstep(1.5,0.3,len);o=mix(o,missionVisionSceneCol,missionVisionSelector);vec3 serviceSceneCol=texture(uServiceSceneTex,uv+fluids.xy*0.01).xyz;serviceSceneCol*=1.0+fluidsLength*0.8;serviceSceneCol.xyz*=smoothstep(1.5,0.3,len);o=mix(o.xyz,serviceSceneCol,step(0.9999,uVisibleService));outColor=vec4(o.xyz,1.0);}`,
    supageSceneMixerFrag = `#define GLSLIFY 1
uniform sampler2D uBackBuffer;uniform sampler2D uSubpageSceneTex;uniform float uSubPageSelector;uniform sampler2D uFluidsTex;in vec2 vUv;layout(location=0)out vec4 outColor;void main(void){vec2 uv=vUv;vec2 cuv=uv-0.5;float len=length(cuv);vec3 o=vec3(0.0);vec4 mainScene=texture(uBackBuffer,uv);vec4 subPage=texture(uSubpageSceneTex,uv);vec4 fluids=texture2D(uFluidsTex,uv);float fluidsLength=length(fluids.xy);subPage.xyz*=1.0+fluidsLength*0.8;subPage.xyz*=smoothstep(1.5,0.3,len);o.xyz=mix(mainScene.xyz,subPage.xyz,uSubPageSelector);outColor=vec4(o.xyz,1.0);}`,
    finalCompositeFrag = `#define GLSLIFY 1
uniform sampler2D uBackBuffer;uniform sampler2D uThumbnailSceneTex;uniform sampler2D uLoadingSVGTex;uniform float uTransition;uniform float uLoaded;uniform float uScreenAspectRatio;uniform float uTime;in vec2 vUv;layout(location=0)out vec4 outColor;
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
void main(void){vec2 uv=vUv;vec2 cuv=vUv-0.5;vec4 col=vec4(0.0,0.0,0.0,1.0);if(uLoaded<0.999){if(uScreenAspectRatio>1.0){cuv.y/=uScreenAspectRatio;}else{cuv.x*=uScreenAspectRatio;}float r=smoothstep(0.0,0.2+uLoaded*0.7,-length(cuv)+uLoaded*1.4);vec2 sceneUv=uv;sceneUv-=0.5;sceneUv*=(0.5+uLoaded*0.5);sceneUv+=0.5;sceneUv-=(sin(r*PI))*normalize(cuv)*0.1;vec2 luv=uv-sin(r*PI)*normalize(cuv)*0.1;vec4 backbufferCol=texture(uBackBuffer,sceneUv);vec4 thumbnailCol=texture(uThumbnailSceneTex,sceneUv);col=backbufferCol;col.rgb=mix(col.rgb,thumbnailCol.rgb,thumbnailCol.w*(1.0-uTransition));vec2 loadingUv=luv;loadingUv.y=1.0-loadingUv.y;loadingUv-=0.5;float gradMask=1.0;if(uScreenAspectRatio>1.0){loadingUv.y/=uScreenAspectRatio;loadingUv*=1.0/0.8;gradMask=smoothstep(0.5,0.4,abs(loadingUv.x));}else{loadingUv.x*=uScreenAspectRatio;}loadingUv+=0.5;vec3 loadingSVG=texture(uLoadingSVGTex,loadingUv).xyz*gradMask;col.rgb=mix(loadingSVG,col.rgb,smoothstep(0.0,0.5,r));}else{vec4 backbufferCol=texture(uBackBuffer,uv);vec4 thumbnailCol=texture(uThumbnailSceneTex,uv);col=backbufferCol;col.rgb=mix(col.rgb,thumbnailCol.rgb,thumbnailCol.w*(1.0-uTransition));}outColor=vec4(col.xyz,1.0);}`;
class RenderPipeline {
    _renderer;
    _commonUniforms;
    _scenePostProcess;
    _finalPostProcess;
    _topSceneMixer;
    _subPageSceneMixer;
    _fxaa;
    _bloomRenderCount;
    _bloomBright;
    _bloomBlur;
    _sceneComposite;
    _finalComposite;
    constructor(i, o) {
        this._renderer = i, this._commonUniforms = UniformsLib.mergeUniforms(o, {}), this._topSceneMixer = new PostProcessPass({
            glslVersion: GLSL3,
            fragmentShader: topSceneMixerFrag,
            renderTarget: new WebGLRenderTarget(1, 1, {
                type: HalfFloatType
            }),
            uniforms: UniformsLib.mergeUniforms(this._commonUniforms, {
                uMainSceneTex: {
                    value: rtMainScene.texture
                },
                uMissionVisionSceneTex: {
                    value: rtMissionVisionScene.texture
                },
                uServiceSceneTex: {
                    value: rtServiceScene.texture
                },
                uVisibleMissionVision: {
                    value: 0
                },
                uVisibleMissionVisionMotionBlur: {
                    value: 0
                },
                uVisibleService: {
                    value: 0
                }
            })
        }), this._subPageSceneMixer = new PostProcessPass({
            glslVersion: GLSL3,
            fragmentShader: supageSceneMixerFrag,
            renderTarget: new WebGLRenderTarget(1, 1, {
                type: HalfFloatType
            }),
            uniforms: UniformsLib.mergeUniforms(this._commonUniforms, {
                uSubpageSceneTex: {
                    value: rtSubpageScene.texture
                },
                uSubPageSelector: {
                    value: 0
                }
            })
        }), this._fxaa = new PostProcessPass({
            glslVersion: GLSL3,
            fragmentShader: fxaaFrag,
            uniforms: this._commonUniforms
        }), this._bloomRenderCount = 3, this._bloomBright = new PostProcessPass({
            glslVersion: GLSL3,
            fragmentShader: bloomBrightFrag,
            uniforms: UniformsLib.mergeUniforms(this._commonUniforms, {
                threshold: {
                    value: .9
                }
            }),
            passThrough: !0
        }), this._bloomBlur = [];
        let c = this._bloomBright.renderTarget.texture;
        const u = [],
            p = UniformsLib.mergeUniforms(this._commonUniforms, {
                uWeights: {
                    value: this._guassWeight(this._bloomRenderCount)
                }
            });
        let m = 4;
        for (let g = 0; g < this._bloomRenderCount; g++) {
            const _ = new PostProcessPass({
                    glslVersion: GLSL3,
                    fragmentShader: bloomBlurFrag,
                    uniforms: UniformsLib.mergeUniforms(p, {
                        uIsVertical: {
                            value: !0
                        },
                        uBloomBackBuffer: {
                            value: c
                        }
                    }),
                    defines: {
                        GAUSS_WEIGHTS: this._bloomRenderCount.toString()
                    },
                    resolutionRatio: 1 / m,
                    passThrough: !0
                }),
                v = new PostProcessPass({
                    glslVersion: GLSL3,
                    fragmentShader: bloomBlurFrag,
                    uniforms: UniformsLib.mergeUniforms(p, {
                        uIsVertical: {
                            value: !1
                        },
                        uBloomBackBuffer: {
                            value: _.renderTarget.texture
                        }
                    }),
                    defines: {
                        GAUSS_WEIGHTS: this._bloomRenderCount.toString()
                    },
                    resolutionRatio: 1 / m,
                    passThrough: !0
                });
            this._bloomBlur.push(_, v), u.push(v.renderTarget.texture), c = v.renderTarget.texture, m *= 2
        }
        this._sceneComposite = new PostProcessPass({
            glslVersion: GLSL3,
            fragmentShader: topSceneCompositeFrag,
            uniforms: UniformsLib.mergeUniforms(this._commonUniforms, {
                uBloomTexture: {
                    value: u
                },
                uBrightness: animator.add({
                    name: "compositeBrightness",
                    initValue: 1,
                    easing: Easings.easeInOutCubic
                }),
                uNotFoundSceneTex: {
                    value: rtNotFoundScene.texture
                },
                uNotFoundVisibility: {
                    value: 0
                },
                uAsciiTexture: resources.getTextureUniform("asciiTexture")
            }),
            defines: {
                BLOOM_COUNT: this._bloomRenderCount.toString()
            }
        }), this._finalComposite = new PostProcessPass({
            glslVersion: GLSL3,
            fragmentShader: finalCompositeFrag,
            uniforms: UniformsLib.mergeUniforms(this._commonUniforms, {
                uThumbnailSceneTex: {
                    value: rtThumbnailScene.texture
                },
                uSubPageSelector: {
                    value: 0
                },
                uLoadingSVGTex: resources.getTextureUniform("loadingSVG")
            }),
            renderTarget: null
        }), this._scenePostProcess = new PostProcess({
            renderer: this._renderer,
            passes: [this._topSceneMixer, this._subPageSceneMixer, this._bloomBright, ...this._bloomBlur, this._sceneComposite]
        }), this._finalPostProcess = new PostProcess({
            renderer: this._renderer,
            passes: [this._finalComposite]
        })
    }
    _guassWeight(i) {
        const o = new Array(i);
        let c = 0;
        const u = 100;
        for (let p = 0; p < o.length; p++) {
            const m = 1 + 2 * p;
            let g = Math.exp(-.5 * (m * m) / u);
            o[p] = g, p > 0 && (g *= 2), c += g
        }
        for (let p = 0; p < o.length; p++) o[p] /= c;
        return o
    }
    render({
        top: i,
        subpage: o,
        thumbnail: c,
        notfound: u,
        camera: p
    }) {
        const {
            mainScene: m,
            missionVisionScene: g,
            serviceScene: _,
            visibleMission: v,
            visibleService: x,
            visibleVision: y
        } = i, {
            subpageScene: b,
            subpageSceneCamera: S,
            subpageSceneSelector: C
        } = o, {
            thumbnailScene: E
        } = c, {
            notfoundScene: P,
            notfoundSceneCamera: w,
            notfoundVisibility: T
        } = u;
        v < .99 && (this._renderer.setRenderTarget(rtMainScene), this._renderer.setClearAlpha(1), this._renderer.clearColor(), this._renderer.render(m, m.camera)), y > .01 && (this._renderer.setRenderTarget(rtServiceScene), this._renderer.setClearAlpha(1), this._renderer.clearColor(), this._renderer.render(_, _.camera)), v > .01 && x < .9999999 && (this._renderer.setRenderTarget(rtMissionVisionScene), this._renderer.setClearAlpha(1), this._renderer.clearColor(), this._renderer.render(g, m.camera));
        const M = v - this._topSceneMixer.uniforms.uVisibleMissionVision.value,
            A = M - this._topSceneMixer.uniforms.uVisibleMissionVisionMotionBlur.value;
        this._topSceneMixer.uniforms.uVisibleMissionVisionMotionBlur.value += A * .5, this._topSceneMixer.uniforms.uVisibleMissionVision.value += M * .5, this._topSceneMixer.uniforms.uVisibleService.value = x, this._finalComposite.uniforms.uSubPageSelector.value = C, this._sceneComposite.uniforms.uNotFoundVisibility.value = T, C > 0 && (this._renderer.setRenderTarget(rtSubpageScene), this._renderer.setClearAlpha(1), this._renderer.clearColor(), this._renderer.render(b, S), this._subPageSceneMixer.uniforms.uSubPageSelector.value = C), T > 0 && (this._renderer.setRenderTarget(rtNotFoundScene), this._renderer.setClearAlpha(1), this._renderer.clearColor(), this._renderer.render(P, w)), this._renderer.setRenderTarget(rtThumbnailScene), this._renderer.setClearAlpha(0), this._renderer.clearColor(), this._renderer.render(E, m.camera), this._scenePostProcess.render(rtMainScene.texture, {
            camera: p
        });
        const D = this._scenePostProcess.passes[this._scenePostProcess.passes.length - 1].renderTarget.texture;
        this._finalPostProcess.render(D, {
            camera: p
        })
    }
    resize(i) {
        this._scenePostProcess.resize(i.sceneResolution), this._finalPostProcess.resize(i.thumbnailResolution), rtMainScene.setSize(i.sceneResolution.x, i.sceneResolution.y), rtMissionVisionScene.setSize(i.sceneResolution.x, i.sceneResolution.y), rtServiceScene.setSize(i.sceneResolution.x, i.sceneResolution.y), rtSubpageScene.setSize(i.sceneResolution.x / 1.5, i.sceneResolution.y / 1.5), rtThumbnailScene.setSize(i.thumbnailResolution.x, i.thumbnailResolution.y), rtNotFoundScene.setSize(i.sceneResolution.x / 10, i.sceneResolution.y / 10)
    }
}
class ProceduralTexture extends PostProcess {
    userData = {};
    constructor(i) {
        const {
            renderer: o,
            resolution: c,
            ...u
        } = i;
        super({
            renderer: o,
            passes: [new PostProcessPass(u)]
        });
        const p = this.passes[0].renderTarget;
        p && (p.texture.wrapS = RepeatWrapping, p.texture.wrapT = RepeatWrapping), this.resize(c), this.userData = {}
    }
    set resolutionRatio(i) {
        this.passes[0].resolutionRatio = i
    }
    get texture() {
        return this.passes[0] && this.passes[0].renderTarget ? this.passes[0].renderTarget.texture : null
    }
    dispose() {
        this.passes.forEach(i => {
            i.dispose()
        }), this.passes = []
    }
}
const copyFrag = `#define GLSLIFY 1
uniform sampler2D uBackBuffer;varying vec2 vUv;void main(void){vec4 col=texture2D(uBackBuffer,vUv);gl_FragColor=col;}`;
class TransparentBufferRenderer extends Mesh {
    _buffer = null;
    _bufferUni = {
        value: null
    };
    _bufferPrm;
    _uniformset;
    constructor() {
        const i = new PlaneGeometry(0, 0),
            o = new ShaderMaterial({
                transparent: !0
            });
        super(i, o), this._uniformset = {
            uTrnsTex: this._bufferUni,
            uTrnsWinRes: {
                value: new Vector2
            }
        }, this.renderOrder = 100, this.frustumCulled = !1, this.onBeforeRender = c => {
            this._buffer || (this._buffer = new ProceduralTexture({
                renderer: c,
                resolution: new Vector2(512, 512),
                fragmentShader: copyFrag
            }), this.dispatchEvent({
                type: "created",
                buffer: this._buffer
            }), this._bufferUni.value = this._buffer.texture);
            const u = c.getRenderTarget();
            u && this._buffer.render(u.texture)
        }, this._bufferPrm = new Promise(c => {
            this.addEventListener("created", u => {
                c(u.buffer)
            })
        })
    }
    get buffer() {
        return this._buffer
    }
    get bufferUni() {
        return this._bufferUni
    }
    get uniformset() {
        return this._uniformset
    }
    get bufferAsync() {
        return this._buffer ? Promise.resolve(this._buffer) : this._bufferPrm
    }
    init() {
        this._buffer && this._buffer.dispose(), this._buffer = null, this._bufferPrm = new Promise(i => {
            this.addEventListener("created", o => {
                i(o.buffer)
            })
        })
    }
    resize(i) {
        this._uniformset.uTrnsWinRes.value.copy(i)
    }
}
class Resources extends EventEmitter$1 {
    _textures;
    _textureUniforms;
    constructor() {
        super(), this._textures = new Map, this._textureUniforms = new Map
    }
    get textures() {
        return this._textures
    }
    clear() {
        this._textures.forEach(i => {
            i.dispose()
        }), this._textures.clear(), this._textureUniforms.clear()
    }
    addTexture(i, o) {
        this._textures.set(i, o);
        const c = this._textureUniforms.get(i);
        c ? c.value = o : this._textureUniforms.set(i, {
            value: o
        })
    }
    getTexture(i) {
        return this._textures.get(i)
    }
    getTextureUniform(i) {
        let o = this._textureUniforms.get(i);
        return o || (o = {
            value: null
        }, this._textureUniforms.set(i, o), o)
    }
}
const comShaderAdvect = `#define GLSLIFY 1
uniform vec2 dataSize;uniform sampler2D dataTex;uniform float velocityAttenuation;uniform float pressureAttenuation;vec2 sampleVelocity(sampler2D tex,vec2 uv,vec2 resolution){vec2 offset=vec2(0.0,0.0);float w=1.0;return w*texture2D(tex,uv+offset/resolution).xy;}float samplePressure(sampler2D tex,vec2 uv,vec2 resolution){vec2 offset=vec2(0.0,0.0);if(uv.x<0.0){offset.x=1.0;}else if(uv.x>1.0){offset.x=-1.0;}if(uv.y<0.0){offset.y=1.0;}else if(uv.y>1.0){offset.y=-1.0;}return texture2D(tex,uv+offset/resolution).z;}void main(){vec2 uv=gl_FragCoord.xy/dataSize;vec2 p=gl_FragCoord.xy-sampleVelocity(dataTex,uv,dataSize);gl_FragColor=vec4(sampleVelocity(dataTex,p/dataSize,dataSize)*velocityAttenuation,samplePressure(dataTex,uv,dataSize)*pressureAttenuation,0.0);}`,
    comShaderCurl = `#define GLSLIFY 1
uniform sampler2D dataTex;uniform vec2 dataSize;uniform float curl;vec2 sampleData(sampler2D tex,vec2 uv,vec2 res){vec2 offset=vec2(0.0,0.0);float w=1.0;return w*texture2D(tex,uv+offset/res).xy;}void main(){vec2 uv=gl_FragCoord.xy/dataSize;vec2 offsetX=vec2(1.0,0.0);vec2 offsetY=vec2(0.0,1.0);float l=sampleData(dataTex,(gl_FragCoord.xy-offsetX)/dataSize,dataSize).y;float r=sampleData(dataTex,(gl_FragCoord.xy+offsetX)/dataSize,dataSize).y;float t=sampleData(dataTex,(gl_FragCoord.xy-offsetY)/dataSize,dataSize).x;float b=sampleData(dataTex,(gl_FragCoord.xy+offsetY)/dataSize,dataSize).x;float c=(r-l-b+t);gl_FragColor=vec4(curl*c,0.0,0.0,1.0);}`,
    comShaderDivergence = `#define GLSLIFY 1
uniform vec2 dataSize;uniform sampler2D dataTex;vec2 sampleData(sampler2D tex,vec2 uv,vec2 resolution){vec2 offset=vec2(0.0,0.0);float w=1.0;return w*texture2D(tex,uv+offset/resolution).xy;}void main(){vec4 data=texture2D(dataTex,gl_FragCoord.xy/dataSize);vec2 offsetX=vec2(1.0,0.0);vec2 offsetY=vec2(0.0,1.0);vec2 l=sampleData(dataTex,(gl_FragCoord.xy-offsetX)/dataSize,dataSize);vec2 r=sampleData(dataTex,(gl_FragCoord.xy+offsetX)/dataSize,dataSize);vec2 t=sampleData(dataTex,(gl_FragCoord.xy-offsetY)/dataSize,dataSize);vec2 b=sampleData(dataTex,(gl_FragCoord.xy+offsetY)/dataSize,dataSize);float divergence=((r.x-l.x)+(b.y-t.y))*0.5;gl_FragColor=vec4(data.xyz,divergence);}`,
    comShaderGradientSubtract = `precision mediump float;precision mediump sampler2D;
#define GLSLIFY 1
uniform vec2 dataSize;uniform sampler2D dataTex;float sampleData(sampler2D tex,vec2 uv,vec2 resolution){vec2 offset=vec2(0.0,0.0);return texture2D(tex,uv+offset/resolution).z;}void main(){vec2 uv=gl_FragCoord.xy/dataSize;float l=sampleData(dataTex,(gl_FragCoord.xy-vec2(1.0,0.0))/dataSize,dataSize);float r=sampleData(dataTex,(gl_FragCoord.xy+vec2(1.0,0.0))/dataSize,dataSize);float t=sampleData(dataTex,(gl_FragCoord.xy-vec2(0.0,1.0))/dataSize,dataSize);float b=sampleData(dataTex,(gl_FragCoord.xy+vec2(0.0,1.0))/dataSize,dataSize);vec4 data=texture2D(dataTex,uv);data.xy-=vec2(r-l,b-t);gl_FragColor=data;}`,
    comShadePressure = `#define GLSLIFY 1
uniform float alpha;uniform float beta;uniform vec2 dataSize;uniform sampler2D dataTex;float sampleData(sampler2D tex,vec2 uv,vec2 resolution){vec2 offset=vec2(0.0,0.0);return texture2D(tex,uv+offset/resolution).z;}void main(){vec4 data=texture2D(dataTex,gl_FragCoord.xy/dataSize);float l=sampleData(dataTex,(gl_FragCoord.xy-vec2(1.0,0.0))/dataSize,dataSize);float r=sampleData(dataTex,(gl_FragCoord.xy+vec2(1.0,0.0))/dataSize,dataSize);float t=sampleData(dataTex,(gl_FragCoord.xy-vec2(0.0,1.0))/dataSize,dataSize);float b=sampleData(dataTex,(gl_FragCoord.xy+vec2(0.0,1.0))/dataSize,dataSize);float divergence=data.w;float pressure=((l+r+t+b)-divergence)*0.25;gl_FragColor=vec4(data.xy,pressure,divergence);}`,
    comShaderVelocity = `#define GLSLIFY 1
uniform float uTime;uniform vec2 dataSize;uniform sampler2D dataTex;uniform sampler2D curlTex;uniform vec2 pointerPos;uniform vec2 pointerVec;uniform float pointerSize;uniform float screenAspect;uniform vec2 uElmListPos[5];uniform vec2 uElmListVel[5];uniform vec2 uElmListSize[5];float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}vec2 smapleVelocity(sampler2D tex,vec2 uv,vec2 resolution){vec2 offset=vec2(0.0,0.0);float w=1.0;return w*texture2D(tex,uv+offset/resolution).xy;}float samplePressure(sampler2D tex,vec2 uv,vec2 resolution){vec2 offset=vec2(0.0,0.0);float w=1.0;if(uv.x<0.0){offset.x=1.0;w=-1.0;}else if(uv.x>1.0){offset.x=-1.0;w=-1.0;}if(uv.y<0.0){offset.y=1.0;w=-1.0;}else if(uv.y>1.0){offset.y=-1.0;w=-1.0;}return w*texture2D(tex,uv+offset/resolution).z;}void main(){vec2 uv=gl_FragCoord.xy/dataSize;vec2 offsetX=vec2(1.0,0.0);vec2 offsetY=vec2(0.0,1.0);float l=smapleVelocity(curlTex,(gl_FragCoord.xy-offsetX)/dataSize,dataSize).x;float r=smapleVelocity(curlTex,(gl_FragCoord.xy+offsetX)/dataSize,dataSize).x;float t=smapleVelocity(curlTex,(gl_FragCoord.xy-offsetY)/dataSize,dataSize).x;float b=smapleVelocity(curlTex,(gl_FragCoord.xy+offsetY)/dataSize,dataSize).x;float c=texture2D(curlTex,uv).x;vec2 force=0.5*vec2(abs(b)-abs(t),abs(r)-abs(l));force/=length(force)+0.0001;force*=1.0*c;force.y*=-1.0;vec4 data=texture2D(dataTex,uv);vec2 pointerUv=uv;pointerUv-=pointerPos;if(screenAspect<1.0){pointerUv.x*=screenAspect;}else{pointerUv.y/=screenAspect;}float pv=length(pointerVec);pv=smoothstep(0.01,1.0,pv);float pointerW=smoothstep(0.01+0.1*min(0.5,pv),0.0,length(pointerUv));vec2 vel=vec2(0.0,0.0);vec2 velPower=pointerVec*30.0;if(screenAspect<1.0){velPower.x/=screenAspect;}else{velPower.y*=screenAspect;}velPower=min(abs(velPower),vec2(2.0))*sign(velPower);vel+=pointerW*velPower;gl_FragColor=vec4(data.xy+vel+force,data.zw);}`;
class StableFluids {
    _parameter = {
        solverIteration: 4,
        screenAspect: 1,
        pointerSize: .1,
        curl: .02,
        velocityAttenuation: .99,
        pressureAttenuation: 0
    };
    _gcConroller;
    _resolution;
    _kernels;
    _fluidData;
    _curlData;
    _time = 0;
    _renderer;
    _tmpVec2 = new Vector2;
    constructor(i, o) {
        this._renderer = i, this._resolution = new Vector2(1, 1), this._gcConroller = new GPUComputationController(this._renderer, this._resolution), this._kernels = {
            curl: this._gcConroller.createKernel({
                fragmentShader: comShaderCurl,
                uniforms: {
                    dataTex: {
                        value: null
                    },
                    curl: {
                        value: null
                    }
                }
            }),
            divergence: this._gcConroller.createKernel({
                fragmentShader: comShaderDivergence,
                uniforms: {
                    dataTex: {
                        value: null
                    }
                }
            }),
            velocity: this._gcConroller.createKernel({
                fragmentShader: comShaderVelocity,
                uniforms: UniformsLib.mergeUniforms({
                    dataTex: {
                        value: null
                    },
                    curlTex: {
                        value: null
                    },
                    pointerPos: {
                        value: new Vector2
                    },
                    pointerVec: {
                        value: new Vector2
                    },
                    screenAspect: {
                        value: this._parameter.screenAspect
                    },
                    pointerSize: {
                        value: this._parameter.pointerSize
                    }
                }, o)
            }),
            gradientSubtract: this._gcConroller.createKernel({
                fragmentShader: comShaderGradientSubtract,
                uniforms: {
                    dataTex: {
                        value: null
                    }
                }
            }),
            pressure: this._gcConroller.createKernel({
                fragmentShader: comShadePressure,
                uniforms: {
                    dataTex: {
                        value: null
                    }
                }
            }),
            advect: this._gcConroller.createKernel({
                fragmentShader: comShaderAdvect,
                uniforms: {
                    dataTex: {
                        value: null
                    },
                    velocityAttenuation: {
                        value: this._parameter.velocityAttenuation
                    },
                    pressureAttenuation: {
                        value: this._parameter.pressureAttenuation
                    }
                }
            })
        }, this._fluidData = this._gcConroller.createData({
            magFilter: LinearFilter,
            minFilter: LinearFilter
        }), this._curlData = this._gcConroller.createData({
            magFilter: LinearFilter,
            minFilter: LinearFilter
        })
    }
    get parameter() {
        return this._parameter
    }
    update(i) {
        this._time += i, this._kernels.curl.uniforms.curl.value = this._parameter.curl, this._kernels.velocity.uniforms.screenAspect.value = this._parameter.screenAspect, this._kernels.velocity.uniforms.pointerSize.value = this._parameter.pointerSize, this._kernels.advect.uniforms.velocityAttenuation.value = this._parameter.velocityAttenuation, this._kernels.advect.uniforms.pressureAttenuation.value = this._parameter.pressureAttenuation, this._kernels.curl.uniforms.dataTex.value = this._fluidData.buffer.texture, this._gcConroller.compute(this._kernels.curl, this._curlData), this._kernels.velocity.uniforms.dataTex.value = this._fluidData.buffer.texture, this._kernels.velocity.uniforms.curlTex.value = this._curlData.buffer.texture, this._gcConroller.compute(this._kernels.velocity, this._fluidData), this._kernels.divergence.uniforms.dataTex.value = this._fluidData.buffer.texture, this._gcConroller.compute(this._kernels.divergence, this._fluidData);
        for (let o = 0; o < this._parameter.solverIteration; o++) this._kernels.pressure.uniforms.dataTex.value = this._fluidData.buffer.texture, this._gcConroller.compute(this._kernels.pressure, this._fluidData);
        this._kernels.gradientSubtract.uniforms.dataTex.value = this._fluidData.buffer.texture, this._gcConroller.compute(this._kernels.gradientSubtract, this._fluidData), this._kernels.advect.uniforms.dataTex.value = this._fluidData.buffer.texture, this._gcConroller.compute(this._kernels.advect, this._fluidData), this._kernels.velocity.uniforms.pointerVec.value.multiplyScalar(.5)
    }
    setPointer(i, o) {
        this._kernels.velocity.uniforms.pointerPos.value.set(i.x * .5 + .5, i.y * .5 + .5), this._tmpVec2.copy(o), this._parameter.screenAspect > 1, this._tmpVec2.x = Math.sign(this._tmpVec2.x) * Math.pow(Math.abs(this._tmpVec2.x), 1.6), this._tmpVec2.y = Math.sign(this._tmpVec2.y) * Math.pow(Math.abs(this._tmpVec2.y), 1.6), this._kernels.velocity.uniforms.pointerVec.value.x += this._tmpVec2.x, this._kernels.velocity.uniforms.pointerVec.value.y -= this._tmpVec2.y, this._kernels.velocity.uniforms.pointerVec.value.min({
            x: 1,
            y: 1
        }), this._kernels.velocity.uniforms.pointerVec.value.max({
            x: -1,
            y: -1
        })
    }
    getTexture() {
        return this._fluidData.buffer.texture
    }
    resize(i) {
        this._parameter.screenAspect = i.x / i.y, this._resolution.copy(i), this._gcConroller.resizeData(i)
    }
}
const domMeshFrag = `#define GLSLIFY 1
uniform sampler2D uTex;uniform float uVisibility;uniform float uTransition;uniform vec2 screenSpacePos;uniform vec2 screenSpaceSize;uniform float uWindowAspect;uniform vec2 uMovement;varying float vMovementPower;varying vec2 vUv;varying vec2 vUvMesh;varying vec2 vFunya;uniform float uIsLoading;uniform int uLoadingType;
#define LOADING_TYPE_DEFAULT 0
#define LOADING_TYPE_CENTER 1
float sdBox(in vec2 p,in vec2 b){vec2 d=abs(p)-b;return length(max(d,0.0))+min(max(d.x,d.y),0.0);}float opRound(in vec2 p,in float r){return sdBox(p,vec2(0.5))-r;}void main(void){float visibilityInv=1.0-uVisibility;vec2 uv=vUv;vec2 cuv=uv-0.5;vec2 meshCuv=vUvMesh-0.5;uv-=0.5;uv*=0.95-visibilityInv*0.05;uv+=screenSpacePos*0.05;uv+=0.5;vec2 uvOffset=vec2(0.0);uvOffset.x-=vFunya.x*(1.0/screenSpaceSize.x)*length(meshCuv)*0.5;uvOffset.y-=vFunya.y*(1.0/screenSpaceSize.y)*smoothstep(0.0,1.0,length(meshCuv))*0.5;vec4 col=vec4(0.0);col.x=texture2D(uTex,uv+uvOffset*0.5).x;col.y=texture2D(uTex,uv+uvOffset*1.0).y;col.z=texture2D(uTex,uv+uvOffset*1.5).z;col.w=1.0;col.w*=1.0-uTransition;if(uIsLoading>0.0){if(uLoadingType==LOADING_TYPE_CENTER){col.w*=mix(1.0,0.7,uIsLoading);}else{col.w*=mix(1.0,0.7,uIsLoading);}}float radiusEffect=0.2;if(uLoadingType==LOADING_TYPE_CENTER){radiusEffect=0.1;}float meshAspect=screenSpaceSize.x/screenSpaceSize.y;float radius=visibilityInv*0.3;radius+=uIsLoading*radiusEffect;radius+=vMovementPower*0.3;vec2 radiusCuv=meshCuv*2.0;radiusCuv.x*=meshAspect*uWindowAspect;vec2 rectSize=vec2(1.0-radius);rectSize.x*=meshAspect;rectSize.x*=uWindowAspect;if(uIsLoading>0.0&&uLoadingType!=LOADING_TYPE_CENTER){}col.w*=uVisibility;gl_FragColor=col;}`,
    domMeshVert = `#define GLSLIFY 1
varying vec2 vUvMesh;varying vec2 vUv;uniform vec2 screenSpacePos;uniform vec2 screenSpaceSize;uniform float uTexAspect;uniform float uMeshAspect;uniform float uWindowAspect;uniform vec2 uMovement;varying float vMovementPower;varying vec2 vFunya;uniform float uIsLoading;uniform int uLoadingType;
#define LOADING_TYPE_DEFAULT 0
#define LOADING_TYPE_CENTER 1
void main(void){vec3 pos=position;vec2 finalScreenSpaceSize=screenSpaceSize;vUv=uv;vUvMesh=uv;if(uTexAspect>uMeshAspect){vUv-=0.5;vUv.x*=uMeshAspect;vUv.x/=uTexAspect;vUv+=0.5;}else{vUv-=0.5;vUv.y/=uMeshAspect;vUv.y*=uTexAspect;vUv+=0.5;}float loading=uIsLoading;if(loading>0.0){if(uLoadingType==LOADING_TYPE_CENTER){vec2 wideScreenSize=vec2(0.5);if(uWindowAspect<uTexAspect){wideScreenSize.y*=uWindowAspect/uTexAspect;}else{wideScreenSize.x/=uWindowAspect/(uTexAspect);}float wideScreenSizeAspect=wideScreenSize.x/wideScreenSize.y;finalScreenSpaceSize=mix(screenSpaceSize,wideScreenSize,loading);vec2 collectedUv=vUv;collectedUv.x-=0.5;collectedUv.x*=(uMeshAspect/uTexAspect);collectedUv.x*=wideScreenSizeAspect/(uTexAspect/uWindowAspect);collectedUv.x+=0.5;vUv=mix(vUv,collectedUv,loading);}}pos.xy*=finalScreenSpaceSize.xy;float lengthMovement=length(uMovement);vec2 normalizedMovement=lengthMovement>0.0 ? normalize(uMovement): vec2(0.0);vMovementPower=lengthMovement*10.0;vec2 funya=(0.2+length(position.xy)*0.8)*normalizedMovement*vMovementPower*0.1;vFunya=funya;pos.xy-=funya;pos.xy+=screenSpacePos.xy;gl_Position=vec4(pos.xy,0.9,1.0);}`,
    LOADING_TYPE = {
        DEFAULT: 0,
        CENTER: 1
    };
class DomMesh extends Mesh {
    _animator;
    enableUpdate;
    elm;
    texture;
    currentImgSrc;
    windowSize;
    positionState;
    sizeState;
    firstUpdate;
    positionAnimDuration;
    loading;
    static instanceCount = 0;
    constructor(i) {
        const o = new Animator,
            c = new PlaneGeometry(2, 2, 8, 8),
            u = new ShaderMaterial({
                vertexShader: domMeshVert,
                fragmentShader: domMeshFrag,
                uniforms: {
                    screenSpacePos: {
                        value: new Vector2(0, 0)
                    },
                    screenSpaceSize: {
                        value: new Vector2(0, 0)
                    },
                    uTex: {
                        value: null
                    },
                    uVisibility: o.add({
                        name: "visibility",
                        initValue: 0,
                        easing: Easings.easeOutCubic
                    }),
                    uTransition: o.add({
                        name: "transition",
                        initValue: 0
                    }),
                    uTexAspect: {
                        value: 1
                    },
                    uMeshAspect: {
                        value: 1
                    },
                    uWindowAspect: {
                        value: 1
                    },
                    uIsLoading: o.add({
                        name: "isLoading",
                        initValue: 0,
                        easing: Easings.easeOutCubic
                    }),
                    uLoadingType: {
                        value: LOADING_TYPE.DEFAULT
                    },
                    uMovement: {
                        value: new Vector2(0, 0)
                    }
                },
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            });
        super(c, u), this._animator = o, this.renderOrder = 10, this._animator.add({
            name: "positionAnimation",
            initValue: 0,
            easing: Easings.cubicBezier(.22, -.01, 0, 1)
        }), this.windowSize = new Vector2(window.innerWidth, window.innerHeight), this.positionState = {
            current: new Vector2,
            target: new Vector2,
            start: new Vector2
        }, this.sizeState = {
            current: new Vector2,
            target: new Vector2,
            start: new Vector2
        }, this.loading = {
            isActive: !1,
            time: 0,
            center: new Vector2(0, 0),
            radius: .3,
            speed: 2,
            index: DomMesh.instanceCount++,
            type: "default"
        }, this.firstUpdate = !0, this.positionAnimDuration = .5, this.enableUpdate = !0, this.texture = null, this.currentImgSrc = null, this.setElm(i)
    }
    setElm(i) {
        this.elm = i;
        const o = "src" in i ? i.src : null;
        if (o !== this.currentImgSrc) {
            if (o) {
                const u = new TextureLoader;
                setTimeout(() => {
                    const p = o;
                    u.load(p, m => {
                        this.texture && (this.texture.dispose(), this.texture = null), m.wrapS = MirroredRepeatWrapping, m.wrapT = MirroredRepeatWrapping, this.texture = m, this.updateTextureAspect(this.texture), this.material.uniforms.uTex.value = this.texture
                    })
                }, Math.random() * 200)
            } else this.material.uniforms.uTex.value = null, this.material.uniforms.uTexAspect.value = 1;
            this.currentImgSrc = o
        }
        const c = () => {
            const u = this.elm.getBoundingClientRect();
            this.updateTargetValues(u), this.firstUpdate ? (this.positionState.current.copy(this.positionState.target), this.sizeState.current.copy(this.sizeState.target), this._animator.setValue("positionAnimation", 1)) : this._startPositionAnimation()
        };
        queueMicrotask(() => {
            c()
        }), setTimeout(() => {
            c(), this.firstUpdate = !1, window.innerWidth <= 768 ? this._animator.animate("visibility", 0) : this._animator.animate("visibility", 1, .8)
        }, 10)
    }
    resize(i) {
        this.windowSize.copy(i), this.material.uniforms.uWindowAspect.value = i.x / i.y, i.x <= 768 ? this._animator.animate("visibility", 0) : this._animator.animate("visibility", 1, .8)
    }
    updateTargetValues(i) {
        const o = gl.canvas.getBoundingClientRect(),
            c = i.left - o.left,
            u = i.top - o.top;
        this.positionState.target.x = (c + i.width / 2) / o.width * 2 - 1, this.positionState.target.y = -((u + i.height / 2) / o.height * 2 - 1), this.sizeState.target.x = i.width / o.width, this.sizeState.target.y = i.height / o.height
    }
    update(i) {
        if (!this.enableUpdate) return;
        this._animator.update(i.deltaTime);
        const o = this.elm.getBoundingClientRect();
        if (o.width === 0 || o.height === 0 || o.x === 0 || o.y === 0) return;
        if (this.updateTargetValues(o), this.loading.isActive) this.loading.time += i.deltaTime * this.loading.speed, this._updateLoadingPosition();
        else {
            const v = this._animator.get("positionAnimation");
            this._animator.isAnimating("positionAnimation") ? (this.positionState.current.x = this.positionState.start.x + (this.positionState.target.x - this.positionState.start.x) * v, this.positionState.current.y = this.positionState.start.y + (this.positionState.target.y - this.positionState.start.y) * v, this.sizeState.current.x = this.sizeState.start.x + (this.sizeState.target.x - this.sizeState.start.x) * v, this.sizeState.current.y = this.sizeState.start.y + (this.sizeState.target.y - this.sizeState.start.y) * v) : (this.positionState.current.copy(this.positionState.target), this.sizeState.current.copy(this.sizeState.target))
        }
        const c = this.positionState.current.x - this.material.uniforms.screenSpacePos.value.x,
            u = this.positionState.current.y - this.material.uniforms.screenSpacePos.value.y,
            p = i.deltaTime * 8;
        this.material.uniforms.uMovement.value.x += (c - this.material.uniforms.uMovement.value.x) * p, this.material.uniforms.uMovement.value.y += (u - this.material.uniforms.uMovement.value.y) * p, this.material.uniforms.screenSpacePos.value.copy(this.positionState.current), this.material.uniforms.screenSpaceSize.value.copy(this.sizeState.current);
        const m = gl.canvas.getBoundingClientRect(),
            g = m.width / m.height,
            _ = this.sizeState.current.x / this.sizeState.current.y * g;
        this.material.uniforms.uMeshAspect.value = _
    }
    _startPositionAnimation(i) {
        this.positionState.start.copy(this.positionState.current), this.sizeState.start.copy(this.sizeState.current), this._animator.setValue("positionAnimation", 0), i !== void 0 && (this.positionAnimDuration = i);
        const o = this.positionAnimDuration + Math.min(1, this.positionState.start.distanceTo(this.positionState.target) * .3);
        this._animator.animate("positionAnimation", 1, o)
    }
    transitionStart() {
        this._animator.animate("transition", 1, .5)
    }
    transitionEnd() {
        this._animator.animate("transition", 0, .5)
    }
    setPositionAnimDuration(i) {
        this.positionAnimDuration = i
    }
    updateTextureAspect(i) {
        const o = i.image.width / i.image.height;
        this.material.uniforms.uTexAspect.value = o
    }
    hideAndDispose(i) {
        this._animator.animate("visibility", 0, .3), setTimeout(() => {
            this.dispose(), i ? .()
        }, 300)
    }
    _updateLoadingPosition() {
        const i = this._animator.get("isLoading");
        i > 0 && this.loading.type === "center" && (this.positionState.current.x = this.positionState.target.x * (1 - i), this.positionState.current.y = this.positionState.target.y * (1 - i));
        const o = 1 - i * .2;
        this.sizeState.current.x = this.sizeState.target.x * o, this.sizeState.current.y = this.sizeState.target.y * o
    }
    startLoading(i = {}) {
        this.loading.isActive = !0, this.loading.time = 0, this.loading.type = i.type || "default", this.renderOrder = 20, this.material.uniforms.uLoadingType.value = this._getLoadingTypeValue(this.loading.type), this._animator.animate("isLoading", 1, .5)
    }
    setLoadingIndex(i) {
        this.loading.index = i
    }
    endLoading() {
        if (this.loading.isActive = !1, this._animator.animate("isLoading", 0, .5), this.elm) {
            const i = this.elm.getBoundingClientRect();
            this.updateTargetValues(i), this._startPositionAnimation(1)
        }
    }
    _getLoadingTypeValue(i) {
        switch (i) {
            case "center":
                return LOADING_TYPE.CENTER;
            case "default":
            default:
                return LOADING_TYPE.DEFAULT
        }
    }
    dispose() {
        this.texture ? .dispose(), this.material.dispose(), this.geometry.dispose()
    }
}
class BaseScene extends Scene {
    _camera;
    _layoutControllers = [];
    constructor() {
        super(), this._camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1e3), this._camera.position.set(0, 0, 5)
    }
    get camera() {
        return this._camera
    }
    addLayoutController(i, o) {
        const c = new LayoutController(i, {
            position: o ? .position || new Vector3$1(0, 0, 0),
            scale: o ? .scale || 1
        });
        return this._layoutControllers.push(c), c
    }
    resize(i) {
        this._camera.aspect = i.aspectRatio, this._camera.updateProjectionMatrix(), this._layoutControllers.forEach(o => {
            o.updateTransform(i.spWeight)
        })
    }
    update(i) {}
    hover(i) {}
}
const worksThumbnailVert = `#define GLSLIFY 1
uniform float uTexAspect;uniform float uPosX;uniform float uScrollVelocity;
#define MESH_ASPECT ( 16.0 / 9.0 )
varying vec2 vUv;varying vec2 vMeshUv;varying float vFunya;varying vec3 vNormal;varying vec3 vNormalGeo;varying float vFront;varying vec3 vMVPosition;varying vec3 vRefDir;mat2 rotate(float rad){return mat2(cos(rad),sin(rad),-sin(rad),cos(rad));}
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
void main(void){vFunya=abs(uScrollVelocity);vec3 pos=position;pos+=length(position.xy)*vec3(1.0,-0.1,0.0)*vec3(vec2(min(0.1,uScrollVelocity*0.0)),0.0);pos.z*=0.2;pos.z+=cos(pos.x/4.0*PI/2.0*0.5)*1.5-1.0;vUv=uv;vMeshUv=uv;if(uTexAspect<=MESH_ASPECT){vUv.y-=0.5;vUv.y*=uTexAspect/MESH_ASPECT;vUv.y+=0.5;}else{vUv.x-=0.5;vUv.x/=uTexAspect/MESH_ASPECT;vUv.x+=0.5;}vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);gl_Position=projectionMatrix*mvPosition;vNormalGeo=normal;vNormal=normal*normalMatrix;vFront=step(0.5,normal.z);vMVPosition=mvPosition.xyz;vRefDir=reflect(-vMVPosition,normalize(vNormal));vRefDir.yz*=rotate(0.2);vRefDir.xy*=rotate(-0.9);vRefDir.xz*=rotate(0.3);}`,
    worksThumbnailFrag = `#define GLSLIFY 1
uniform sampler2D uTex;uniform samplerCube uEnvMap;uniform float uLoaded;uniform float uPosX;uniform float uWorksProgress;uniform float uAlpha;uniform float uScrollVelocity;varying vec2 vUv;varying vec2 vMeshUv;varying float vFunya;varying vec3 vNormal;varying vec3 vNormalGeo;varying float vFront;varying vec3 vMVPosition;varying vec3 vRefDir;mat2 rotate(float rad){return mat2(cos(rad),sin(rad),-sin(rad),cos(rad));}uniform float uTime;float sdBox(in vec2 p,in vec2 b){vec2 d=abs(p)-b;return length(max(d,0.0))+min(max(d.x,d.y),0.0);}float opRound(in vec2 p,in float r){return sdBox(p,vec2(0.5))-r;}vec2 lens_distortion(vec2 r,float alpha){return r*(1.0-alpha*dot(r,r));}void main(void){vec2 uv=vUv;vec2 meshCuv=(vMeshUv-0.5);vec2 moveUVOffset=vec2(0.0);moveUVOffset.x-=uScrollVelocity*1.0;vec2 normalOffset=vec2(0.0);float frontDir=dot(normalize(vNormal),vec3(0.0,0.0,1.0));normalOffset-=vNormal.xy*0.5*smoothstep(0.8,1.0,frontDir);vec4 col=vec4(0.0);if(vFront<0.5){uv.x*=0.01;uv.x+=1.0-vNormalGeo.x*0.19;uv.x+=-vNormal.x*0.5;}for(int i=0;i<4;i++){float fi=float(i)/4.0;vec2 cuv=uv-0.5;cuv*=1.3;cuv.x*=0.9;float distBase=0.1+fi*0.03;col.x+=texture2D(uTex,lens_distortion(cuv,distBase+0.1)+0.5+normalOffset*1.0).x;col.y+=texture2D(uTex,lens_distortion(cuv,distBase+0.12)+0.5+normalOffset*1.01).y;col.z+=texture2D(uTex,lens_distortion(cuv,distBase+0.14)+0.5+normalOffset*1.02).z;}col.xyz/=4.0;col.w=1.0;col.xyz*=smoothstep(0.9,0.49,length(meshCuv));col.w*=uLoaded;col.w*=uAlpha;col.xyz=mix(col.xyz,vec3(smoothstep(0.0,0.2,vRefDir.x)),0.05);gl_FragColor=col;}`;
class WorksThumbnail extends Object3D {
    _animator;
    _commonUniforms;
    _link;
    _mesh;
    _meshReady;
    constructor(i, o) {
        super(), this._animator = new Animator, this._mesh = null;
        const c = i.getAttribute("data-top_works_item"),
            u = i.getAttribute("data-works_id");
        u ? this._link = `/works/detail/${u}` : this._link = null, this._commonUniforms = UniformsLib.mergeUniforms(o, {
            uTex: {
                value: null
            },
            uLoaded: this._animator.add({
                name: "loaded",
                initValue: 0
            }),
            uTexAspect: {
                value: 1
            },
            uPosX: {
                value: 0
            },
            uAlpha: {
                value: 0
            },
            uEnvMap: resources.getTextureUniform("envMap")
        });
        const p = new ShaderMaterial({
            vertexShader: worksThumbnailVert,
            fragmentShader: worksThumbnailFrag,
            uniforms: this._commonUniforms,
            transparent: !0,
            side: FrontSide
        });
        this._meshReady = gltfPrm.then(m => {
            const g = m.scene.getObjectByName("ThumbnailScreen");
            if (g) this._mesh = new Mesh(g.geometry, p), this._mesh.name = "worksThumbnail_" + this.uuid, this.add(this._mesh);
            else {
                console.warn("ThumbnailScreen not found in gltf, using fallback BoxGeometry");
                const _ = 8,
                    v = _ / (16 / 9),
                    x = new BoxGeometry(_, v, .1, 16, 16);
                this._mesh = new Mesh(x, p), this._mesh.name = "worksThumbnail_" + this.uuid, this.add(this._mesh)
            }
            return this._mesh
        }), textureLoader.load(c + "?w=1024", m => {
            m.wrapS = MirroredRepeatWrapping, m.wrapT = MirroredRepeatWrapping, this._commonUniforms.uTex.value = m, this._commonUniforms.uTexAspect.value = m.image.width / m.image.height, this._animator.animate("loaded", 1, 1)
        })
    }
    setAlpha(i) {
        this._commonUniforms.uAlpha.value = i, this._mesh && (this._mesh.visible = this.visible = i > .01)
    }
    setPosX(i) {
        this._commonUniforms.uPosX.value = i
    }
    update(i) {
        this._animator.update(i.deltaTime)
    }
    get mesh() {
        return this._mesh
    }
    get meshReady() {
        return this._meshReady
    }
    get link() {
        return this._link
    }
}
class WorksThumbnails extends Object3D {
    _commonUniforms;
    _worksThumbnails;
    _trigger;
    constructor(i) {
        super(), this.name = "WorksThumbnails", this._commonUniforms = UniformsLib.mergeUniforms(i, {
            uNumWorks: {
                value: 0
            },
            uCurrentIndex: {
                value: 0
            },
            uScrollVelocity: {
                value: 0
            }
        }), this._worksThumbnails = [], this._trigger = null
    } in () {
        const i = document.querySelectorAll("[data-top_works_item]");
        this._worksThumbnails.forEach(o => {
            this.remove(o)
        }), this._worksThumbnails = [], i.forEach(o => {
            const c = new WorksThumbnail(o, this._commonUniforms);
            this._worksThumbnails.push(c), this.add(c)
        }), this._trigger = topScrollManager.getTrigger("works_progress"), this._worksThumbnails.forEach(o => {
            o.meshReady.then(c => {
                easyRaycaster.touchableObjects.push(c);
                const u = c.name;
                easyRaycaster.addEventListener("click/" + u, () => {
                    o.link && swupPromise.then(p => {
                        p.navigate(o.link)
                    })
                }), easyRaycaster.addEventListener("enter/" + u, () => {
                    document.body.style.cursor = "pointer"
                }), easyRaycaster.addEventListener("out/" + u, () => {
                    document.body.style.cursor = ""
                })
            })
        })
    }
    out() {
        this._worksThumbnails.forEach(i => {
            if (i.mesh) {
                const o = easyRaycaster.touchableObjects.indexOf(i.mesh);
                o > -1 && easyRaycaster.touchableObjects.splice(o, 1);
                const c = i.mesh.name;
                easyRaycaster.removeEventListener("click/" + c, () => {}), easyRaycaster.removeEventListener("enter/" + c, () => {}), easyRaycaster.removeEventListener("out/" + c, () => {})
            }
        }), this._worksThumbnails.forEach(i => {
            this.remove(i)
        }), this._worksThumbnails = []
    }
    setCamera(i) {}
    update(i) {
        if (!this._trigger) return;
        const o = lerper.set("works_progress", this._trigger.progress, 1) * (this._worksThumbnails.length + 1),
            c = Math.round(o);
        let u = lerper.set("works_current_index", c - (c - o) * .4, .5);
        debugController.enabled && (u = o), this._commonUniforms.uScrollVelocity.value = lerper.set("works_progress_velocity", lerper.get("works_progress").velocity || 0, .5);
        const p = Math.min(1, u * 2),
            m = Math.min(1, (this._worksThumbnails.length + 1 - u) * 2);
        this._worksThumbnails.forEach((g, _) => {
            const x = _ + 1 - u;
            g.position.x = Math.sin(x) * (11 - 0 * i.spWeight), g.position.z = Math.cos(x) * 5 - 6, g.position.y = -x, g.rotation.y = x * .6, g.scale.setScalar(.9 + .1 * i.spWeight + .2 * (1 - Math.min(1, Math.abs(x)))), g.setPosX(x), g.setAlpha((1 - MathUtils.smoothstep(Math.abs(x), .8, 2.5)) * p * m), g.update(i)
        })
    }
}
class ThumbnailScene extends BaseScene {
    _commonUniforms;
    _topWorksThumbnail;
    _domMeshMap;
    windowSize;
    constructor(i) {
        super(), this._commonUniforms = UniformsLib.mergeUniforms(i), this._topWorksThumbnail = new WorksThumbnails(this._commonUniforms), this.add(this._topWorksThumbnail), this.addLayoutController(this._topWorksThumbnail, {
            position: new Vector3$1(0, .8, 0),
            scale: .6
        }), this._domMeshMap = new Map, this.windowSize = new Vector2(window.innerWidth, window.innerHeight)
    }
    get domMeshMap() {
        return this._domMeshMap
    }
    get topWorksThumbnail() {
        return this._topWorksThumbnail
    }
    update(i) {
        this._domMeshMap.forEach(o => {
            o.update(i)
        }), this._topWorksThumbnail.update(i)
    }
    resize(i) {
        super.resize(i), this.windowSize.set(i.canvasSize.x, i.canvasSize.y), this._domMeshMap.forEach(o => {
            o.resize(this.windowSize)
        })
    }
    attachElm(i, o) {
        const c = this._domMeshMap.get(i);
        if (c) {
            c.setElm(o), c.resize(this.windowSize), this.add(c);
            return
        }
        let u = this._domMeshMap.get(i);
        u ? u.setElm(o) : (u = new DomMesh(o), this._domMeshMap.set(i, u)), u.resize(this.windowSize), this.add(u)
    }
    detachElm(i) {
        const o = this._domMeshMap.get(i);
        o && o.hideAndDispose(() => {
            this._domMeshMap.delete(i), this.remove(o)
        })
    }
    transitionStart() {
        this._domMeshMap.forEach(i => {
            i.transitionStart()
        })
    }
    transitionEnd() {
        this._domMeshMap.forEach(i => {
            i.transitionEnd()
        })
    } in () {
        this._topWorksThumbnail.in()
    }
    out() {
        this._topWorksThumbnail.out()
    }
    setRenderCamera(i) {
        this._topWorksThumbnail.setCamera(i)
    }
}
const bgFrag = `#define GLSLIFY 1
varying vec2 vUv;uniform sampler2D uNoiseTex;uniform float uNoise;uniform vec2 uScreenResolution;uniform vec2 uMousePos;float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}void main(void){vec3 o=vec3(0.0);vec4 noise=texture2D(uNoiseTex,vUv*1.0)+random(vUv)*0.2;float rnd=(0.6+random(vUv)*0.4);o.x+=smoothstep(0.5,1.0,noise.x);o.y+=smoothstep(0.2,1.0,noise.y);o.z+=smoothstep(0.0,1.0,noise.z);o.xyz*=vec3(0.3,0.4,0.6)*0.3;o+=vec3(0.01,0.025,0.06);vec2 cuv=vUv-0.5;float len=length(cuv);o.xyz*=smoothstep(0.9,0.3,len);o*=smoothstep(1.0,0.0,length(vUv-0.5+vec2(-0.3,0.0)))*0.8;vec2 fragUv=gl_FragCoord.xy/uScreenResolution.xy;gl_FragColor=vec4(o,1.0);}`,
    bgVert = `#define GLSLIFY 1
varying vec2 vUv;void main(void){gl_Position=vec4(position.xy,1.0,1.0);vUv=uv;}`;
class SubPageBG extends Mesh {
    constructor(i) {
        const o = new PlaneGeometry(2, 2),
            c = new ShaderMaterial({
                vertexShader: bgVert,
                fragmentShader: bgFrag,
                uniforms: UniformsLib.mergeUniforms(i, {
                    uNoiseTex: {
                        value: resources.getTexture("noise").texture
                    }
                })
            });
        super(o, c)
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
const gridVert = `#define GLSLIFY 1
varying vec2 vUv;uniform vec3 uScale;uniform float uTime;uniform float uScroll;
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
mat2 rotate(float rad){return mat2(cos(rad),sin(rad),-sin(rad),cos(rad));}
#ifdef IS_GRID
#endif
#ifdef IS_CROSS
attribute vec2 instanceId;
#endif
void main(void){vec2 localPos=position.xy;
#ifdef IS_CROSS
vec2 loopPos=instanceId.xy;loopPos.y=mod(loopPos.y+uScroll*0.1,1.0);localPos=(loopPos-0.5)*1.0;
#endif
float theta=localPos.x*PI;vec3 roundedPos=vec3(0.0);
#ifdef IS_ROUND
roundedPos=vec3(sin(theta)*0.5*uScale.x,localPos.y*uScale.y*1.5,-cos(theta)*uScale.x*0.5);
#endif
#ifdef IS_FLAT
roundedPos=vec3(localPos.x*uScale.x,localPos.y*uScale.y,0.0);
#endif
vec3 pos=vec3(0.0);
#ifdef IS_GRID
pos=roundedPos;
#endif
#ifdef IS_CROSS
pos=position*0.15;
#ifdef IS_ROUND
pos.xz*=rotate(-theta);
#endif
pos+=roundedPos;
#endif
gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);vUv=uv;}`,
    gridFrag$1 = `#define GLSLIFY 1
varying vec2 vUv;uniform vec2 uGrid;uniform float uTime;uniform float uScroll;uniform sampler2D uFluidsTex;void main(void){float line=0.0;vec2 gridUv=vUv*uGrid;gridUv.y-=uScroll*1.5;float lineThreshold=0.45;
#ifndef IS_DARK
#ifdef IS_THIN_LIGHT
lineThreshold=0.44;
#else
lineThreshold=0.46;
#endif
#endif
line+=smoothstep(lineThreshold,0.5,abs(fract(gridUv.x)-0.5));line=max(line,smoothstep(lineThreshold,0.5,abs(fract(gridUv.y)-0.5)));
#ifdef IS_DARK
gl_FragColor=vec4(vec3(0.0),0.1);
#else
vec4 fluids=texture2D(uFluidsTex,vUv);vec3 col=vec3(1.0);col.xy-=fluids.xy*0.005;gl_FragColor=vec4(col,0.5);
#endif
#ifdef IS_THIN_LIGHT
gl_FragColor.a*=line*0.05;
#else
gl_FragColor.a*=line*0.2;
#endif
}`,
    crossFrag$1 = `#define GLSLIFY 1
varying vec2 vUv;void main(void){float line=0.0;vec2 gridUv=vUv-0.5;float w=0.08;line+=smoothstep(w,0.01,abs(gridUv.x));line=max(line,smoothstep(w,w*0.1,abs(gridUv.y)));
#ifdef IS_DARK
gl_FragColor=vec4(vec3(0.0),0.2);
#else
gl_FragColor=vec4(vec3(1.0),0.3);
#ifdef IS_THIN_LIGHT
gl_FragColor.a*=0.5;
#endif
#endif
gl_FragColor.a*=line;}`;
class Grid extends Mesh {
    _commonUniforms;
    _cross;
    constructor(i, o, c) {
        const p = new Vector2().setScalar(64),
            m = UniformsLib.mergeUniforms(c, {
                uGrid: {
                    value: p
                },
                uScale: {
                    value: new Vector3$1(1, 1, 1)
                },
                uScroll: {
                    value: 0
                }
            }),
            g = new PlaneGeometry(1, 1, 64, 64),
            _ = new ShaderMaterial({
                name: "GridMaterial",
                uniforms: m,
                vertexShader: gridVert,
                fragmentShader: gridFrag$1,
                transparent: !0,
                defines: {
                    IS_GRID: "",
                    [`IS_${o.toUpperCase()}`]: "",
                    [`IS_${i.toUpperCase()}`]: ""
                },
                depthWrite: !1,
                depthTest: !1
            });
        super(g, _), this.renderOrder = -999, this._commonUniforms = m;
        const v = [],
            x = new Vector2(p.x / 8, p.y / 8);
        for (let C = 0; C <= x.y; C++)
            for (let E = 0; E <= x.x; E++) v.push(E / x.x, C / x.y);
        const y = new PlaneGeometry(1, 1, 8, 8),
            b = new InstancedBufferGeometry;
        b.setAttribute("position", y.getAttribute("position")), b.setAttribute("uv", y.getAttribute("uv")), b.setAttribute("instanceId", new InstancedBufferAttribute(new Float32Array(v), 2)), b.setIndex(y.getIndex());
        const S = new ShaderMaterial({
            name: "GridCrossMaterial",
            uniforms: UniformsLib.mergeUniforms(this._commonUniforms, {
                uGridCross: {
                    value: x
                }
            }),
            transparent: !0,
            fragmentShader: crossFrag$1,
            vertexShader: gridVert,
            defines: {
                IS_CROSS: "",
                [`IS_${o.toUpperCase()}`]: "",
                [`IS_${i.toUpperCase()}`]: ""
            },
            depthWrite: !1,
            depthTest: !1
        });
        this._cross = new Mesh(b, S), this._cross.renderOrder = -999, this.add(this._cross)
    }
    resize(i) {
        if (i instanceof PerspectiveCamera) {
            const o = i.userData.basePos || i.position,
                c = i.userData.baseFov || i.fov,
                u = Math.abs(o.z),
                p = MathUtils.degToRad(c),
                m = 2 * u * Math.tan(p / 2),
                g = m * i.aspect;
            g < m ? this._commonUniforms.uScale.value.set(m, m, 1) : this._commonUniforms.uScale.value.set(g, g, 1)
        } else if (i instanceof OrthographicCamera) {
            const o = i.right - i.left,
                c = i.top - i.bottom;
            o < c ? this._commonUniforms.uScale.value.set(c, c, 1) : this._commonUniforms.uScale.value.set(o, o, 1)
        }
    }
    setScrollAmount(i) {
        this._commonUniforms.uScroll.value = i
    }
}
class SubPageScene extends BaseScene {
    _bg;
    _grid;
    _uniforms;
    constructor(i) {
        super(), this._uniforms = UniformsLib.mergeUniforms(i, {}), this._bg = new SubPageBG(this._uniforms), this.add(this._bg), this._grid = new Grid("thin_light", "flat", this._uniforms), this.add(this._grid)
    }
    resize(i) {
        super.resize(i), this._grid.resize(this.camera)
    }
}
const notFoundVert = `#define GLSLIFY 1
uniform float uTime;uniform float uVisibility;varying vec2 vUv;varying float vVisibility;varying vec3 vNormal;mat2 rotate(float rad){return mat2(cos(rad),sin(rad),-sin(rad),cos(rad));}void main(){vUv=uv;vVisibility=uVisibility;float rotationAngle=uTime*1.0;mat2 rot=rotate(rotationAngle);vec3 pos=position;pos.xz*=rot;vec3 nml=normal;nml.xz*=rot;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);vNormal=normalize(normalMatrix*nml);}`,
    notFoundFrag = `#define GLSLIFY 1
uniform float uTime;varying vec2 vUv;varying float vVisibility;varying vec3 vNormal;void main(){vec3 col=vec3(0.0,0.0,0.0);col.xyz+=vNormal*0.5+0.5;col=vec3(dot(col.xyz,normalize(vec3(1.0,1.0,1.0))))*0.4;gl_FragColor=vec4(col,1.0);}`;
class NotFoundScene extends BaseScene {
    _uniforms;
    _notFoundMesh;
    constructor(i) {
        super(), this._uniforms = UniformsLib.mergeUniforms(i, {
            uVisibility: {
                value: 0
            },
            uTime: {
                value: 0
            }
        });
        const o = new ShaderMaterial({
            vertexShader: notFoundVert,
            fragmentShader: notFoundFrag,
            uniforms: this._uniforms,
            transparent: !0,
            side: DoubleSide
        });
        this._notFoundMesh = null, gltfPrm.then(c => {
            const p = c.scene.getObjectByName("Alche_A").geometry;
            this._notFoundMesh = new Mesh(p, o), this._notFoundMesh.scale.setScalar(6), this.add(this._notFoundMesh)
        })
    }
    resize(i) {
        super.resize(i), this.camera.fov = 40 + i.spWeight * 20, this.camera.updateProjectionMatrix(), this.camera.position.set(0, .2, 5)
    }
    update(i) {
        super.update(i), this._uniforms.uTime.value = i.time, this._notFoundMesh && (this._notFoundMesh.position.y = lenis.scroll / window.innerHeight * 2.5 + i.spWeight * .5)
    }
    get uniforms() {
        return this._uniforms
    }
}
const noiseFrag$1 = `#define GLSLIFY 1
uniform sampler2D uTex;uniform float uScreenAspectRatio;varying vec2 vUv;uniform float uTime;vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float noise3D(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}void main(void){float tn=uTime*0.1;float t=uTime*0.1;vec2 aspUv=vUv*vec2(uScreenAspectRatio,1.0)-0.5;vec2 nuv=aspUv*0.5;float n1=noise3D(vec3(nuv+1234.0,tn+0.0));float n2=noise3D(vec3(nuv+5678.0,tn+10.0));vec2 uv=aspUv*0.6+vec2(n1,n2)*0.7;vec4 col=vec4(0.0);col.x+=noise3D(vec3(uv+1.0,t+0.0));col.y+=noise3D(vec3(uv+2.0,t+1.0));col.z+=noise3D(vec3(uv+3.0,t+2.0));col.w+=noise3D(vec3(aspUv+noise3D(vec3(nuv+1234.0,t*0.)),t*0.05+3.0));col=col*0.5+0.5;gl_FragColor=col;}`,
    createSVGTexture = (l, i = 256) => new Promise((o, c) => {
        fetch(l).then(u => u.text()).then(u => {
            const p = new Image,
                m = new Blob([u], {
                    type: "image/svg+xml"
                }),
                g = URL.createObjectURL(m);
            p.onload = () => {
                const _ = document.createElement("canvas");
                _.width = i, _.height = i;
                const v = _.getContext("2d");
                v.clearRect(0, 0, i, i), v.drawImage(p, 0, 0, i, i);
                const x = new CanvasTexture(_);
                x.needsUpdate = !0, x.flipY = !1, URL.revokeObjectURL(g), o(x)
            }, p.onerror = () => {
                URL.revokeObjectURL(g), c(new Error(`Failed to load SVG: ${l}`))
            }, p.src = g
        }).catch(c)
    }),
    initResources = (l, i) => {
        const o = new CubeTextureLoader(loadingManager),
            c = new TextureLoader(loadingManager);
        o.load(["/envmap/px.png", "/envmap/nx.png", "/envmap/py.png", "/envmap/ny.png", "/envmap/pz.png", "/envmap/nz.png"], u => {
            resources.addTexture("envMap", u)
        }), resources.addTexture("noise", new ProceduralTexture({
            uniforms: i,
            renderer: l,
            fragmentShader: noiseFrag$1,
            resolution: new Vector2(64, 64),
            renderTarget: new WebGLRenderTarget(1, 1, {
                type: FloatType
            })
        })), createSVGTexture("/common/loading.svg", 2048).then(u => {
            resources.addTexture("loadingSVG", u)
        }).catch(u => {
            console.warn("Loading SVG texture creation failed:", u)
        }), c.load("/404/ascii_texture.png", u => {
            u.flipY = !1, u.wrapS = RepeatWrapping, u.wrapT = RepeatWrapping, u.minFilter = NearestFilter, u.magFilter = NearestFilter, resources.addTexture("asciiTexture", u)
        }, void 0, u => {
            console.warn("ASCII texture loading failed:", u)
        })
    },
    mainLogoFrag = `#define GLSLIFY 1
uniform sampler2D uTrnsTex;uniform sampler2D uNoiseTex;uniform samplerCube uEnvMap;uniform vec2 uTrnsWinRes;uniform float uHideQuad;uniform float uKvOutVisibility;uniform float uScrollOutro;uniform float uRoughness;uniform float uNoiseScale;uniform vec3 uMaterialColor;varying vec2 vUv;varying vec3 vNormal;varying vec3 vViewPos;varying vec3 vColor;
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}
#define SMPLAES 8
float ggx(float dNH,float roughness){float a2=roughness*roughness;a2=a2*a2;float dNH2=dNH*dNH;if(dNH2<=0.0)return 0.0;return a2/(PI*pow(dNH2*(a2-1.0)+1.0,2.0));}float fresnel(float d){float f0=0.1;return f0+(1.0-f0)*pow(1.0-d,5.0);}void main(void){vec3 c=vec3(0.0);vec2 trnsUv=gl_FragCoord.xy/uTrnsWinRes.xy;vec4 noise=texture2D(uNoiseTex,vUv*uNoiseScale);vec4 noise2=texture2D(uNoiseTex,vUv*1.0+(noise.xy-0.5)*2.0);float roughness=smoothstep(0.3,0.8,noise2.y)*uRoughness;vec3 normal=normalize(vNormal);float refractPower=0.1;vec2 refractNormal=normal.xy*(1.0-normal.z*0.7);vec2 refractUv=trnsUv;vec3 refractCol=vec3(0.0);for(int i=0;i<SMPLAES;i++){float slide=0.005+random(trnsUv+float(i)*0.2)*0.007;vec2 roughnessDir=vec2(random(trnsUv+float(i)*0.1)-0.5,random(trnsUv+float(i)*0.2)-0.5)*roughness*0.3;vec2 refractUvR=roughnessDir+refractUv-refractNormal*(refractPower+slide*1.0);vec2 refractUvG=roughnessDir+refractUv-refractNormal*(refractPower+slide*2.0);vec2 refractUvB=roughnessDir+refractUv-refractNormal*(refractPower+slide*4.0);vec3 bg=vec3(texture2D(uTrnsTex,refractUvR).x,texture2D(uTrnsTex,refractUvG).y,texture2D(uTrnsTex,refractUvB).z);refractCol+=bg*0.9;}refractCol/=float(SMPLAES);c+=(refractCol);vec3 viewDir=normalize(vViewPos);vec3 L=normalize(vec3(-1.0,0.8,-1.0));vec3 H=normalize(viewDir+L);float dNH=dot(normal,H);float spec=ggx(dNH,0.003+roughness*0.4);c+=spec;float F=fresnel(dot(viewDir,normal));c+=mix(c,textureCube(uEnvMap,reflect(viewDir,normal)).rgb,F*0.9)*(1.0-F);c*=1.2;c*=uMaterialColor/255.0;gl_FragColor=vec4(c,1.0);}`,
    mainLogoVert = `#define GLSLIFY 1
attribute vec3 color;varying vec2 vUv;varying vec3 vNormal;varying vec3 vViewPos;varying vec3 vColor;uniform float uTime;uniform float uHideQuad;uniform float uVisionRotate;uniform float uServiceIn;uniform float uServiceRotate;uniform float uScreenAspectRatio;mat2 rotate(float rad){return mat2(cos(rad),sin(rad),-sin(rad),cos(rad));}
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
void main(void){vec3 pos=position;vec3 nml=normal;mat2 rot;float vis=step(0.95,uHideQuad);pos.xz*=rotate((uVisionRotate*0.15+uServiceRotate*0.5)*HPI);pos.yz*=rotate(uVisionRotate*-0.1-uServiceRotate*0.2);vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);vec4 orthoPos=projectionMatrix*mvPosition;orthoPos.xyz/=orthoPos.w;orthoPos.w=1.0;vec3 scPos=position;
#ifdef IS_OUTLINE
scPos.xyz-=nml*0.001*smoothstep(0.0,0.2,uServiceIn);
#endif
scPos.xz*=rotate(HPI);vec4 screenPos=vec4(scPos.x*(20.5+(1.0/uScreenAspectRatio*3.0)),scPos.y*(7.0+uScreenAspectRatio*8.0)-0.22,orthoPos.z,1.0);vec4 finalPosition=mix(orthoPos,screenPos,uServiceRotate);gl_Position=finalPosition;vUv=uv;vNormal=normalMatrix*nml;vViewPos=-mvPosition.xyz;vColor=color;}`,
    mainLogoOutlineFrag = `#define GLSLIFY 1
varying vec2 vUv;void main(void){
#ifdef IS_BASE
gl_FragColor=vec4(vec3(vec3(0.8431372549019608,0.8588235294117647,0.8627450980392157)),0.0);
#endif
#ifdef IS_OUTLINE
gl_FragColor=vec4(vec3(1.0),1.0);
#endif
}`,
    mainLogoScreenFrag = `#define GLSLIFY 1
varying vec2 vUv;uniform sampler2D uSceneTex;uniform sampler2D uNoiseTex;uniform vec2 uScreenResolution;uniform float uServiceIn;uniform float uScreenNoiseScale;float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}vec2 lens_distortion(vec2 r,float alpha){return r*(1.0-alpha*dot(r,r));}uniform float uVisionRotate;void main(void){vec2 geoUV=vUv;geoUV.x-=0.5;geoUV.x*=0.15;geoUV.x+=0.5;vec2 screenUv=gl_FragCoord.xy/uScreenResolution.xy;vec2 uv=mix(geoUV,screenUv,pow(uServiceIn,0.2));vec2 effectUv=geoUV;vec4 n1=texture2D(uNoiseTex,effectUv*uScreenNoiseScale);vec4 n2=texture2D(uNoiseTex,effectUv*0.3*uScreenNoiseScale+n1.xy*(2.3+random(screenUv)*0.2));vec3 effectCol=n2.xyz;vec3 sceneCol=vec3(0.0);float serviceInInv=(1.0-uServiceIn);for(int i=0;i<5;i++){float fi=(float(i)/5.0);vec2 distortedUv=uv;distortedUv.xy+=(n2.xy-0.5)*serviceInInv;float distortPower=serviceInInv*5.0+fi*0.2*serviceInInv;sceneCol.x+=texture2D(uSceneTex,lens_distortion(distortedUv-0.5,1.0*distortPower)+0.5).x;sceneCol.y+=texture2D(uSceneTex,lens_distortion(distortedUv-0.5,1.05*distortPower)+0.5).y;sceneCol.z+=texture2D(uSceneTex,lens_distortion(distortedUv-0.5,1.1*distortPower)+0.5).z;}sceneCol/=5.0;sceneCol*=1.0+serviceInInv*3.0;sceneCol*=mix(0.5+effectCol*1.0,vec3(1.0),uServiceIn);vec2 warpUv=vUv;warpUv.x-=0.5;warpUv.x*=0.5;warpUv.x+=0.5;warpUv.y+=0.05;float w=smoothstep(0.0,0.0+1.0*smoothstep(0.0,1.0,n2.z),-n2.y+uServiceIn*2.0);vec3 outCol=vec3(effectCol.xyz);outCol=mix(outCol,sceneCol,w);gl_FragColor=vec4(outCol,smoothstep(0.0,0.1,uVisionRotate));}`; /*! Tweakpane 4.0.5 (c) 2016 cocopon, licensed under the MIT license. */
function forceCast$1(l) {
    return l
}

function isEmpty$1(l) {
    return l == null
}

function isObject$1$2(l) {
    return l !== null && typeof l == "object"
}

function isRecord$1(l) {
    return l !== null && typeof l == "object"
}

function deepEqualsArray$1(l, i) {
    if (l.length !== i.length) return !1;
    for (let o = 0; o < l.length; o++)
        if (l[o] !== i[o]) return !1;
    return !0
}

function deepMerge$1(l, i) {
    return Array.from(new Set([...Object.keys(l), ...Object.keys(i)])).reduce((c, u) => {
        const p = l[u],
            m = i[u];
        return isRecord$1(p) && isRecord$1(m) ? Object.assign(Object.assign({}, c), {
            [u]: deepMerge$1(p, m)
        }) : Object.assign(Object.assign({}, c), {
            [u]: u in i ? m : p
        })
    }, {})
}

function isBinding$1(l) {
    return isObject$1$2(l) ? "target" in l : !1
}
const CREATE_MESSAGE_MAP$1 = {
    alreadydisposed: () => "View has been already disposed",
    invalidparams: l => `Invalid parameters for '${l.name}'`,
    nomatchingcontroller: l => `No matching controller for '${l.key}'`,
    nomatchingview: l => `No matching view for '${JSON.stringify(l.params)}'`,
    notbindable: () => "Value is not bindable",
    notcompatible: l => `Not compatible with  plugin '${l.id}'`,
    propertynotfound: l => `Property '${l.name}' not found`,
    shouldneverhappen: () => "This error should never happen"
};
let TpError$1 = class zn {
        static alreadyDisposed() {
            return new zn({
                type: "alreadydisposed"
            })
        }
        static notBindable() {
            return new zn({
                type: "notbindable"
            })
        }
        static notCompatible(i, o) {
            return new zn({
                type: "notcompatible",
                context: {
                    id: `${i}.${o}`
                }
            })
        }
        static propertyNotFound(i) {
            return new zn({
                type: "propertynotfound",
                context: {
                    name: i
                }
            })
        }
        static shouldNeverHappen() {
            return new zn({
                type: "shouldneverhappen"
            })
        }
        constructor(i) {
            var o;
            this.message = (o = CREATE_MESSAGE_MAP$1[i.type](i.context)) !== null && o !== void 0 ? o : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = i.type
        }
        toString() {
            return this.message
        }
    },
    BindingTarget$1 = class Hr {
        constructor(i, o) {
            this.obj_ = i, this.key = o
        }
        static isBindable(i) {
            return !(i === null || typeof i != "object" && typeof i != "function")
        }
        read() {
            return this.obj_[this.key]
        }
        write(i) {
            this.obj_[this.key] = i
        }
        writeProperty(i, o) {
            const c = this.read();
            if (!Hr.isBindable(c)) throw TpError$1.notBindable();
            if (!(i in c)) throw TpError$1.propertyNotFound(i);
            c[i] = o
        }
    },
    Emitter$1 = class {
        constructor() {
            this.observers_ = {}
        }
        on(i, o, c) {
            var u;
            let p = this.observers_[i];
            return p || (p = this.observers_[i] = []), p.push({
                handler: o,
                key: (u = c ? .key) !== null && u !== void 0 ? u : o
            }), this
        }
        off(i, o) {
            const c = this.observers_[i];
            return c && (this.observers_[i] = c.filter(u => u.key !== o)), this
        }
        emit(i, o) {
            const c = this.observers_[i];
            c && c.forEach(u => {
                u.handler(o)
            })
        }
    },
    ComplexValue$1 = class {
        constructor(i, o) {
            var c;
            this.constraint_ = o ? .constraint, this.equals_ = (c = o ? .equals) !== null && c !== void 0 ? c : (u, p) => u === p, this.emitter = new Emitter$1, this.rawValue_ = i
        }
        get constraint() {
            return this.constraint_
        }
        get rawValue() {
            return this.rawValue_
        }
        set rawValue(i) {
            this.setRawValue(i, {
                forceEmit: !1,
                last: !0
            })
        }
        setRawValue(i, o) {
            const c = o ? ? {
                    forceEmit: !1,
                    last: !0
                },
                u = this.constraint_ ? this.constraint_.constrain(i) : i,
                p = this.rawValue_;
            this.equals_(p, u) && !c.forceEmit || (this.emitter.emit("beforechange", {
                sender: this
            }), this.rawValue_ = u, this.emitter.emit("change", {
                options: c,
                previousRawValue: p,
                rawValue: u,
                sender: this
            }))
        }
    },
    PrimitiveValue$1 = class {
        constructor(i) {
            this.emitter = new Emitter$1, this.value_ = i
        }
        get rawValue() {
            return this.value_
        }
        set rawValue(i) {
            this.setRawValue(i, {
                forceEmit: !1,
                last: !0
            })
        }
        setRawValue(i, o) {
            const c = o ? ? {
                    forceEmit: !1,
                    last: !0
                },
                u = this.value_;
            u === i && !c.forceEmit || (this.emitter.emit("beforechange", {
                sender: this
            }), this.value_ = i, this.emitter.emit("change", {
                options: c,
                previousRawValue: u,
                rawValue: this.value_,
                sender: this
            }))
        }
    },
    ReadonlyPrimitiveValue$1 = class {
        constructor(i) {
            this.emitter = new Emitter$1, this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.value_ = i, this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_)
        }
        get rawValue() {
            return this.value_.rawValue
        }
        onValueBeforeChange_(i) {
            this.emitter.emit("beforechange", Object.assign(Object.assign({}, i), {
                sender: this
            }))
        }
        onValueChange_(i) {
            this.emitter.emit("change", Object.assign(Object.assign({}, i), {
                sender: this
            }))
        }
    };

function createValue$1(l, i) {
    const o = i ? .constraint,
        c = i ? .equals;
    return !o && !c ? new PrimitiveValue$1(l) : new ComplexValue$1(l, i)
}

function createReadonlyValue$1(l) {
    return [new ReadonlyPrimitiveValue$1(l), (i, o) => {
        l.setRawValue(i, o)
    }]
}
let ValueMap$1 = class Wr {
        constructor(i) {
            this.emitter = new Emitter$1, this.valMap_ = i;
            for (const o in this.valMap_) this.valMap_[o].emitter.on("change", () => {
                this.emitter.emit("change", {
                    key: o,
                    sender: this
                })
            })
        }
        static createCore(i) {
            return Object.keys(i).reduce((c, u) => Object.assign(c, {
                [u]: createValue$1(i[u])
            }), {})
        }
        static fromObject(i) {
            const o = this.createCore(i);
            return new Wr(o)
        }
        get(i) {
            return this.valMap_[i].rawValue
        }
        set(i, o) {
            this.valMap_[i].rawValue = o
        }
        value(i) {
            return this.valMap_[i]
        }
    },
    DefiniteRangeConstraint$1 = class {
        constructor(i) {
            this.values = ValueMap$1.fromObject({
                max: i.max,
                min: i.min
            })
        }
        constrain(i) {
            const o = this.values.get("max"),
                c = this.values.get("min");
            return Math.min(Math.max(i, c), o)
        }
    },
    RangeConstraint$1 = class {
        constructor(i) {
            this.values = ValueMap$1.fromObject({
                max: i.max,
                min: i.min
            })
        }
        constrain(i) {
            const o = this.values.get("max"),
                c = this.values.get("min");
            let u = i;
            return isEmpty$1(c) || (u = Math.max(u, c)), isEmpty$1(o) || (u = Math.min(u, o)), u
        }
    },
    StepConstraint$1 = class {
        constructor(i, o = 0) {
            this.step = i, this.origin = o
        }
        constrain(i) {
            const o = this.origin % this.step,
                c = Math.round((i - o) / this.step);
            return o + c * this.step
        }
    },
    NumberLiteralNode$1 = class {
        constructor(i) {
            this.text = i
        }
        evaluate() {
            return Number(this.text)
        }
        toString() {
            return this.text
        }
    };
const BINARY_OPERATION_MAP$1 = {
    "**": (l, i) => Math.pow(l, i),
    "*": (l, i) => l * i,
    "/": (l, i) => l / i,
    "%": (l, i) => l % i,
    "+": (l, i) => l + i,
    "-": (l, i) => l - i,
    "<<": (l, i) => l << i,
    ">>": (l, i) => l >> i,
    ">>>": (l, i) => l >>> i,
    "&": (l, i) => l & i,
    "^": (l, i) => l ^ i,
    "|": (l, i) => l | i
};
let BinaryOperationNode$1 = class {
    constructor(i, o, c) {
        this.left = o, this.operator = i, this.right = c
    }
    evaluate() {
        const i = BINARY_OPERATION_MAP$1[this.operator];
        if (!i) throw new Error(`unexpected binary operator: '${this.operator}`);
        return i(this.left.evaluate(), this.right.evaluate())
    }
    toString() {
        return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
    }
};
const UNARY_OPERATION_MAP$1 = {
    "+": l => l,
    "-": l => -l,
    "~": l => ~l
};
let UnaryOperationNode$1 = class {
    constructor(i, o) {
        this.operator = i, this.expression = o
    }
    evaluate() {
        const i = UNARY_OPERATION_MAP$1[this.operator];
        if (!i) throw new Error(`unexpected unary operator: '${this.operator}`);
        return i(this.expression.evaluate())
    }
    toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
    }
};

function combineReader$1(l) {
    return (i, o) => {
        for (let c = 0; c < l.length; c++) {
            const u = l[c](i, o);
            if (u !== "") return u
        }
        return ""
    }
}

function readWhitespace$1(l, i) {
    var o;
    const c = l.substr(i).match(/^\s+/);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readNonZeroDigit$1(l, i) {
    const o = l.substr(i, 1);
    return o.match(/^[1-9]$/) ? o : ""
}

function readDecimalDigits$1(l, i) {
    var o;
    const c = l.substr(i).match(/^[0-9]+/);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readSignedInteger$1(l, i) {
    const o = readDecimalDigits$1(l, i);
    if (o !== "") return o;
    const c = l.substr(i, 1);
    if (i += 1, c !== "-" && c !== "+") return "";
    const u = readDecimalDigits$1(l, i);
    return u === "" ? "" : c + u
}

function readExponentPart$1(l, i) {
    const o = l.substr(i, 1);
    if (i += 1, o.toLowerCase() !== "e") return "";
    const c = readSignedInteger$1(l, i);
    return c === "" ? "" : o + c
}

function readDecimalIntegerLiteral$1(l, i) {
    const o = l.substr(i, 1);
    if (o === "0") return o;
    const c = readNonZeroDigit$1(l, i);
    return i += c.length, c === "" ? "" : c + readDecimalDigits$1(l, i)
}

function readDecimalLiteral1$1(l, i) {
    const o = readDecimalIntegerLiteral$1(l, i);
    if (i += o.length, o === "") return "";
    const c = l.substr(i, 1);
    if (i += c.length, c !== ".") return "";
    const u = readDecimalDigits$1(l, i);
    return i += u.length, o + c + u + readExponentPart$1(l, i)
}

function readDecimalLiteral2$1(l, i) {
    const o = l.substr(i, 1);
    if (i += o.length, o !== ".") return "";
    const c = readDecimalDigits$1(l, i);
    return i += c.length, c === "" ? "" : o + c + readExponentPart$1(l, i)
}

function readDecimalLiteral3$1(l, i) {
    const o = readDecimalIntegerLiteral$1(l, i);
    return i += o.length, o === "" ? "" : o + readExponentPart$1(l, i)
}
const readDecimalLiteral$1 = combineReader$1([readDecimalLiteral1$1, readDecimalLiteral2$1, readDecimalLiteral3$1]);

function parseBinaryDigits$1(l, i) {
    var o;
    const c = l.substr(i).match(/^[01]+/);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readBinaryIntegerLiteral$1(l, i) {
    const o = l.substr(i, 2);
    if (i += o.length, o.toLowerCase() !== "0b") return "";
    const c = parseBinaryDigits$1(l, i);
    return c === "" ? "" : o + c
}

function readOctalDigits$1(l, i) {
    var o;
    const c = l.substr(i).match(/^[0-7]+/);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readOctalIntegerLiteral$1(l, i) {
    const o = l.substr(i, 2);
    if (i += o.length, o.toLowerCase() !== "0o") return "";
    const c = readOctalDigits$1(l, i);
    return c === "" ? "" : o + c
}

function readHexDigits$1(l, i) {
    var o;
    const c = l.substr(i).match(/^[0-9a-f]+/i);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readHexIntegerLiteral$1(l, i) {
    const o = l.substr(i, 2);
    if (i += o.length, o.toLowerCase() !== "0x") return "";
    const c = readHexDigits$1(l, i);
    return c === "" ? "" : o + c
}
const readNonDecimalIntegerLiteral$1 = combineReader$1([readBinaryIntegerLiteral$1, readOctalIntegerLiteral$1, readHexIntegerLiteral$1]),
    readNumericLiteral$1 = combineReader$1([readNonDecimalIntegerLiteral$1, readDecimalLiteral$1]);

function parseLiteral$1(l, i) {
    const o = readNumericLiteral$1(l, i);
    return i += o.length, o === "" ? null : {
        evaluable: new NumberLiteralNode$1(o),
        cursor: i
    }
}

function parseParenthesizedExpression$1(l, i) {
    const o = l.substr(i, 1);
    if (i += o.length, o !== "(") return null;
    const c = parseExpression$1(l, i);
    if (!c) return null;
    i = c.cursor, i += readWhitespace$1(l, i).length;
    const u = l.substr(i, 1);
    return i += u.length, u !== ")" ? null : {
        evaluable: c.evaluable,
        cursor: i
    }
}

function parsePrimaryExpression$1(l, i) {
    var o;
    return (o = parseLiteral$1(l, i)) !== null && o !== void 0 ? o : parseParenthesizedExpression$1(l, i)
}

function parseUnaryExpression$1(l, i) {
    const o = parsePrimaryExpression$1(l, i);
    if (o) return o;
    const c = l.substr(i, 1);
    if (i += c.length, c !== "+" && c !== "-" && c !== "~") return null;
    const u = parseUnaryExpression$1(l, i);
    return u ? (i = u.cursor, {
        cursor: i,
        evaluable: new UnaryOperationNode$1(c, u.evaluable)
    }) : null
}

function readBinaryOperator$1(l, i, o) {
    o += readWhitespace$1(i, o).length;
    const c = l.filter(u => i.startsWith(u, o))[0];
    return c ? (o += c.length, o += readWhitespace$1(i, o).length, {
        cursor: o,
        operator: c
    }) : null
}

function createBinaryOperationExpressionParser$1(l, i) {
    return (o, c) => {
        const u = l(o, c);
        if (!u) return null;
        c = u.cursor;
        let p = u.evaluable;
        for (;;) {
            const m = readBinaryOperator$1(i, o, c);
            if (!m) break;
            c = m.cursor;
            const g = l(o, c);
            if (!g) return null;
            c = g.cursor, p = new BinaryOperationNode$1(m.operator, p, g.evaluable)
        }
        return p ? {
            cursor: c,
            evaluable: p
        } : null
    }
}
const parseBinaryOperationExpression$1 = [
    ["**"],
    ["*", "/", "%"],
    ["+", "-"],
    ["<<", ">>>", ">>"],
    ["&"],
    ["^"],
    ["|"]
].reduce((l, i) => createBinaryOperationExpressionParser$1(l, i), parseUnaryExpression$1);

function parseExpression$1(l, i) {
    return i += readWhitespace$1(l, i).length, parseBinaryOperationExpression$1(l, i)
}

function parseEcmaNumberExpression$1(l) {
    const i = parseExpression$1(l, 0);
    return !i || i.cursor + readWhitespace$1(l, i.cursor).length !== l.length ? null : i.evaluable
}

function parseNumber$1(l) {
    var i;
    const o = parseEcmaNumberExpression$1(l);
    return (i = o ? .evaluate()) !== null && i !== void 0 ? i : null
}

function numberFromUnknown$1(l) {
    if (typeof l == "number") return l;
    if (typeof l == "string") {
        const i = parseNumber$1(l);
        if (!isEmpty$1(i)) return i
    }
    return 0
}

function numberToString(l) {
    return String(l)
}

function createNumberFormatter$1(l) {
    return i => i.toFixed(Math.max(Math.min(l, 20), 0))
}

function mapRange$2(l, i, o, c, u) {
    const p = (l - i) / (o - i);
    return c + p * (u - c)
}

function getDecimalDigits$1(l) {
    return String(l.toFixed(10)).split(".")[1].replace(/0+$/, "").length
}

function constrainRange$1(l, i, o) {
    return Math.min(Math.max(l, i), o)
}

function loopRange$1(l, i) {
    return (l % i + i) % i
}

function getSuitableDecimalDigits$1(l, i) {
    return isEmpty$1(l.step) ? Math.max(getDecimalDigits$1(i), 2) : getDecimalDigits$1(l.step)
}

function getSuitableKeyScale$1(l) {
    var i;
    return (i = l.step) !== null && i !== void 0 ? i : 1
}

function getSuitablePointerScale$1(l, i) {
    var o;
    const c = Math.abs((o = l.step) !== null && o !== void 0 ? o : i);
    return c === 0 ? .1 : Math.pow(10, Math.floor(Math.log10(c)) - 1)
}

function createStepConstraint$1(l, i) {
    return isEmpty$1(l.step) ? null : new StepConstraint$1(l.step, i)
}

function createRangeConstraint$1(l) {
    return !isEmpty$1(l.max) && !isEmpty$1(l.min) ? new DefiniteRangeConstraint$1({
        max: l.max,
        min: l.min
    }) : !isEmpty$1(l.max) || !isEmpty$1(l.min) ? new RangeConstraint$1({
        max: l.max,
        min: l.min
    }) : null
}

function createNumberTextPropsObject$1(l, i) {
    var o, c, u;
    return {
        formatter: (o = l.format) !== null && o !== void 0 ? o : createNumberFormatter$1(getSuitableDecimalDigits$1(l, i)),
        keyScale: (c = l.keyScale) !== null && c !== void 0 ? c : getSuitableKeyScale$1(l),
        pointerScale: (u = l.pointerScale) !== null && u !== void 0 ? u : getSuitablePointerScale$1(l, i)
    }
}

function createNumberTextInputParamsParser$1(l) {
    return {
        format: l.optional.function,
        keyScale: l.optional.number,
        max: l.optional.number,
        min: l.optional.number,
        pointerScale: l.optional.number,
        step: l.optional.number
    }
}

function createPointAxis$1(l) {
    return {
        constraint: l.constraint,
        textProps: ValueMap$1.fromObject(createNumberTextPropsObject$1(l.params, l.initialValue))
    }
}
let BladeApi$1 = class {
        constructor(i) {
            this.controller = i
        }
        get element() {
            return this.controller.view.element
        }
        get disabled() {
            return this.controller.viewProps.get("disabled")
        }
        set disabled(i) {
            this.controller.viewProps.set("disabled", i)
        }
        get hidden() {
            return this.controller.viewProps.get("hidden")
        }
        set hidden(i) {
            this.controller.viewProps.set("hidden", i)
        }
        dispose() {
            this.controller.viewProps.set("disposed", !0)
        }
        importState(i) {
            return this.controller.importState(i)
        }
        exportState() {
            return this.controller.exportState()
        }
    },
    TpEvent$1 = class {
        constructor(i) {
            this.target = i
        }
    },
    TpChangeEvent$1 = class extends TpEvent$1 {
        constructor(i, o, c) {
            super(i), this.value = o, this.last = c ? ? !0
        }
    },
    TpFoldEvent$1 = class extends TpEvent$1 {
        constructor(i, o) {
            super(i), this.expanded = o
        }
    },
    TpTabSelectEvent$1 = class extends TpEvent$1 {
        constructor(i, o) {
            super(i), this.index = o
        }
    };
class TpMouseEvent extends TpEvent$1 {
    constructor(i, o) {
        super(i), this.native = o
    }
}
let BindingApi$1 = class extends BladeApi$1 {
    constructor(i) {
        super(i), this.onValueChange_ = this.onValueChange_.bind(this), this.emitter_ = new Emitter$1, this.controller.value.emitter.on("change", this.onValueChange_)
    }
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(i) {
        this.controller.labelController.props.set("label", i)
    }
    get key() {
        return this.controller.value.binding.target.key
    }
    get tag() {
        return this.controller.tag
    }
    set tag(i) {
        this.controller.tag = i
    }
    on(i, o) {
        const c = o.bind(this);
        return this.emitter_.on(i, u => {
            c(u)
        }, {
            key: o
        }), this
    }
    off(i, o) {
        return this.emitter_.off(i, o), this
    }
    refresh() {
        this.controller.value.fetch()
    }
    onValueChange_(i) {
        const o = this.controller.value;
        this.emitter_.emit("change", new TpChangeEvent$1(this, o.binding.target.read(), i.options.last))
    }
};
class InputBindingValue {
    constructor(i, o) {
        this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.binding = o, this.value_ = i, this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_), this.emitter = new Emitter$1
    }
    get rawValue() {
        return this.value_.rawValue
    }
    set rawValue(i) {
        this.value_.rawValue = i
    }
    setRawValue(i, o) {
        this.value_.setRawValue(i, o)
    }
    fetch() {
        this.value_.rawValue = this.binding.read()
    }
    push() {
        this.binding.write(this.value_.rawValue)
    }
    onValueBeforeChange_(i) {
        this.emitter.emit("beforechange", Object.assign(Object.assign({}, i), {
            sender: this
        }))
    }
    onValueChange_(i) {
        this.push(), this.emitter.emit("change", Object.assign(Object.assign({}, i), {
            sender: this
        }))
    }
}

function isInputBindingValue(l) {
    if (!("binding" in l)) return !1;
    const i = l.binding;
    return isBinding$1(i) && "read" in i && "write" in i
}

function parseObject$1(l, i) {
    const c = Object.keys(i).reduce((u, p) => {
        if (u === void 0) return;
        const m = i[p],
            g = m(l[p]);
        return g.succeeded ? Object.assign(Object.assign({}, u), {
            [p]: g.value
        }) : void 0
    }, {});
    return c
}

function parseArray$1(l, i) {
    return l.reduce((o, c) => {
        if (o === void 0) return;
        const u = i(c);
        if (!(!u.succeeded || u.value === void 0)) return [...o, u.value]
    }, [])
}

function isObject$3(l) {
    return l === null ? !1 : typeof l == "object"
}

function createMicroParserBuilder$1(l) {
    return i => o => {
        if (!i && o === void 0) return {
            succeeded: !1,
            value: void 0
        };
        if (i && o === void 0) return {
            succeeded: !0,
            value: void 0
        };
        const c = l(o);
        return c !== void 0 ? {
            succeeded: !0,
            value: c
        } : {
            succeeded: !1,
            value: void 0
        }
    }
}

function createMicroParserBuilders$1(l) {
    return {
        custom: i => createMicroParserBuilder$1(i)(l),
        boolean: createMicroParserBuilder$1(i => typeof i == "boolean" ? i : void 0)(l),
        number: createMicroParserBuilder$1(i => typeof i == "number" ? i : void 0)(l),
        string: createMicroParserBuilder$1(i => typeof i == "string" ? i : void 0)(l),
        function: createMicroParserBuilder$1(i => typeof i == "function" ? i : void 0)(l),
        constant: i => createMicroParserBuilder$1(o => o === i ? i : void 0)(l),
        raw: createMicroParserBuilder$1(i => i)(l),
        object: i => createMicroParserBuilder$1(o => {
            if (isObject$3(o)) return parseObject$1(o, i)
        })(l),
        array: i => createMicroParserBuilder$1(o => {
            if (Array.isArray(o)) return parseArray$1(o, i)
        })(l)
    }
}
const MicroParsers$1 = {
    optional: createMicroParserBuilders$1(!0),
    required: createMicroParserBuilders$1(!1)
};

function parseRecord$1(l, i) {
    const o = i(MicroParsers$1),
        c = MicroParsers$1.required.object(o)(l);
    return c.succeeded ? c.value : void 0
}

function importBladeState$1(l, i, o, c) {
    if (i && !i(l)) return !1;
    const u = parseRecord$1(l, o);
    return u ? c(u) : !1
}

function exportBladeState$1(l, i) {
    var o;
    return deepMerge$1((o = l ? .()) !== null && o !== void 0 ? o : {}, i)
}

function isValueBladeController$1(l) {
    return "value" in l
}

function isBindingValue$1(l) {
    if (!isObject$1$2(l) || !("binding" in l)) return !1;
    const i = l.binding;
    return isBinding$1(i)
}
const SVG_NS$1 = "http://www.w3.org/2000/svg";

function forceReflow$1(l) {
    l.offsetHeight
}

function disableTransitionTemporarily$1(l, i) {
    const o = l.style.transition;
    l.style.transition = "none", i(), l.style.transition = o
}

function supportsTouch$1(l) {
    return l.ontouchstart !== void 0
}

function getGlobalObject() {
    return globalThis
}

function getWindowDocument() {
    return getGlobalObject().document
}

function getCanvasContext$1(l) {
    const i = l.ownerDocument.defaultView;
    return i && "document" in i ? l.getContext("2d", {
        willReadFrequently: !0
    }) : null
}
const ICON_ID_TO_INNER_HTML_MAP$1 = {
    check: '<path d="M2 8l4 4l8 -8"/>',
    dropdown: '<path d="M5 7h6l-3 3 z"/>',
    p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
};

function createSvgIconElement$1(l, i) {
    const o = l.createElementNS(SVG_NS$1, "svg");
    return o.innerHTML = ICON_ID_TO_INNER_HTML_MAP$1[i], o
}

function insertElementAt$1(l, i, o) {
    l.insertBefore(i, l.children[o])
}

function removeElement$1(l) {
    l.parentElement && l.parentElement.removeChild(l)
}

function removeChildElements$1(l) {
    for (; l.children.length > 0;) l.removeChild(l.children[0])
}

function removeChildNodes$1(l) {
    for (; l.childNodes.length > 0;) l.removeChild(l.childNodes[0])
}

function findNextTarget$1(l) {
    return l.relatedTarget ? l.relatedTarget : "explicitOriginalTarget" in l ? l.explicitOriginalTarget : null
}

function bindValue$1(l, i) {
    l.emitter.on("change", o => {
        i(o.rawValue)
    }), i(l.rawValue)
}

function bindValueMap$1(l, i, o) {
    bindValue$1(l.value(i), o)
}
const PREFIX$1 = "tp";

function ClassName$1(l) {
    return (o, c) => [PREFIX$1, "-", l, "v", o ? `_${o}` : "", c ? `-${c}` : ""].join("")
}
const cn$r = ClassName$1("lbl");

function createLabelNode$1(l, i) {
    const o = l.createDocumentFragment();
    return i.split(`
`).map(u => l.createTextNode(u)).forEach((u, p) => {
        p > 0 && o.appendChild(l.createElement("br")), o.appendChild(u)
    }), o
}
let LabelView$1 = class {
        constructor(i, o) {
            this.element = i.createElement("div"), this.element.classList.add(cn$r()), o.viewProps.bindClassModifiers(this.element);
            const c = i.createElement("div");
            c.classList.add(cn$r("l")), bindValueMap$1(o.props, "label", p => {
                isEmpty$1(p) ? this.element.classList.add(cn$r(void 0, "nol")) : (this.element.classList.remove(cn$r(void 0, "nol")), removeChildNodes$1(c), c.appendChild(createLabelNode$1(i, p)))
            }), this.element.appendChild(c), this.labelElement = c;
            const u = i.createElement("div");
            u.classList.add(cn$r("v")), this.element.appendChild(u), this.valueElement = u
        }
    },
    LabelController$1 = class {
        constructor(i, o) {
            this.props = o.props, this.valueController = o.valueController, this.viewProps = o.valueController.viewProps, this.view = new LabelView$1(i, {
                props: o.props,
                viewProps: this.viewProps
            }), this.view.valueElement.appendChild(this.valueController.view.element)
        }
        importProps(i) {
            return importBladeState$1(i, null, o => ({
                label: o.optional.string
            }), o => (this.props.set("label", o.label), !0))
        }
        exportProps() {
            return exportBladeState$1(null, {
                label: this.props.get("label")
            })
        }
    };

function getAllBladePositions$1() {
    return ["veryfirst", "first", "last", "verylast"]
}
const cn$q$1 = ClassName$1(""),
    POS_TO_CLASS_NAME_MAP$1 = {
        veryfirst: "vfst",
        first: "fst",
        last: "lst",
        verylast: "vlst"
    };
let BladeController$1 = class {
    constructor(i) {
        this.parent_ = null, this.blade = i.blade, this.view = i.view, this.viewProps = i.viewProps;
        const o = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
            getAllBladePositions$1().forEach(c => {
                o.classList.remove(cn$q$1(void 0, POS_TO_CLASS_NAME_MAP$1[c]))
            }), this.blade.get("positions").forEach(c => {
                o.classList.add(cn$q$1(void 0, POS_TO_CLASS_NAME_MAP$1[c]))
            })
        }), this.viewProps.handleDispose(() => {
            removeElement$1(o)
        })
    }
    get parent() {
        return this.parent_
    }
    set parent(i) {
        this.parent_ = i, this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null)
    }
    importState(i) {
        return importBladeState$1(i, null, o => ({
            disabled: o.required.boolean,
            hidden: o.required.boolean
        }), o => (this.viewProps.importState(o), !0))
    }
    exportState() {
        return exportBladeState$1(null, Object.assign({}, this.viewProps.exportState()))
    }
};
class LabeledValueBladeController extends BladeController$1 {
    constructor(i, o) {
        if (o.value !== o.valueController.value) throw TpError$1.shouldNeverHappen();
        const c = o.valueController.viewProps,
            u = new LabelController$1(i, {
                blade: o.blade,
                props: o.props,
                valueController: o.valueController
            });
        super(Object.assign(Object.assign({}, o), {
            view: new LabelView$1(i, {
                props: o.props,
                viewProps: c
            }),
            viewProps: c
        })), this.labelController = u, this.value = o.value, this.valueController = o.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
    }
    importState(i) {
        return importBladeState$1(i, o => {
            var c, u, p;
            return super.importState(o) && this.labelController.importProps(o) && ((p = (u = (c = this.valueController).importProps) === null || u === void 0 ? void 0 : u.call(c, i)) !== null && p !== void 0 ? p : !0)
        }, o => ({
            value: o.optional.raw
        }), o => (o.value && (this.value.rawValue = o.value), !0))
    }
    exportState() {
        var i, o, c;
        return exportBladeState$1(() => super.exportState(), Object.assign(Object.assign({
            value: this.value.rawValue
        }, this.labelController.exportProps()), (c = (o = (i = this.valueController).exportProps) === null || o === void 0 ? void 0 : o.call(i)) !== null && c !== void 0 ? c : {}))
    }
}

function excludeValue(l) {
    const i = Object.assign({}, l);
    return delete i.value, i
}
class BindingController extends LabeledValueBladeController {
    constructor(i, o) {
        super(i, o), this.tag = o.tag
    }
    importState(i) {
        return importBladeState$1(i, o => super.importState(excludeValue(i)), o => ({
            tag: o.optional.string
        }), o => (this.tag = o.tag, !0))
    }
    exportState() {
        return exportBladeState$1(() => excludeValue(super.exportState()), {
            binding: {
                key: this.value.binding.target.key,
                value: this.value.binding.target.read()
            },
            tag: this.tag
        })
    }
}

function isBindingController(l) {
    return isValueBladeController$1(l) && isBindingValue$1(l.value)
}
class InputBindingController extends BindingController {
    importState(i) {
        return importBladeState$1(i, o => super.importState(o), o => ({
            binding: o.required.object({
                value: o.required.raw
            })
        }), o => (this.value.binding.inject(o.binding.value), this.value.fetch(), !0))
    }
}

function isInputBindingController(l) {
    return isValueBladeController$1(l) && isInputBindingValue(l.value)
}

function fillBuffer(l, i) {
    for (; l.length < i;) l.push(void 0)
}

function initializeBuffer(l) {
    const i = [];
    return fillBuffer(i, l), i
}

function createTrimmedBuffer(l) {
    const i = l.indexOf(void 0);
    return i < 0 ? l : l.slice(0, i)
}

function createPushedBuffer(l, i) {
    const o = [...createTrimmedBuffer(l), i];
    return o.length > l.length ? o.splice(0, o.length - l.length) : fillBuffer(o, l.length), o
}
class MonitorBindingValue {
    constructor(i) {
        this.emitter = new Emitter$1, this.onTick_ = this.onTick_.bind(this), this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.binding = i.binding, this.value_ = createValue$1(initializeBuffer(i.bufferSize)), this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_), this.ticker = i.ticker, this.ticker.emitter.on("tick", this.onTick_), this.fetch()
    }
    get rawValue() {
        return this.value_.rawValue
    }
    set rawValue(i) {
        this.value_.rawValue = i
    }
    setRawValue(i, o) {
        this.value_.setRawValue(i, o)
    }
    fetch() {
        this.value_.rawValue = createPushedBuffer(this.value_.rawValue, this.binding.read())
    }
    onTick_() {
        this.fetch()
    }
    onValueBeforeChange_(i) {
        this.emitter.emit("beforechange", Object.assign(Object.assign({}, i), {
            sender: this
        }))
    }
    onValueChange_(i) {
        this.emitter.emit("change", Object.assign(Object.assign({}, i), {
            sender: this
        }))
    }
}

function isMonitorBindingValue(l) {
    if (!("binding" in l)) return !1;
    const i = l.binding;
    return isBinding$1(i) && "read" in i && !("write" in i)
}
class MonitorBindingController extends BindingController {
    exportState() {
        return exportBladeState$1(() => super.exportState(), {
            binding: {
                readonly: !0
            }
        })
    }
}

function isMonitorBindingController(l) {
    return isValueBladeController$1(l) && isMonitorBindingValue(l.value)
}
let ButtonApi$1 = class extends BladeApi$1 {
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(i) {
        this.controller.labelController.props.set("label", i)
    }
    get title() {
        var i;
        return (i = this.controller.buttonController.props.get("title")) !== null && i !== void 0 ? i : ""
    }
    set title(i) {
        this.controller.buttonController.props.set("title", i)
    }
    on(i, o) {
        const c = o.bind(this);
        return this.controller.buttonController.emitter.on(i, p => {
            c(new TpMouseEvent(this, p.nativeEvent))
        }), this
    }
    off(i, o) {
        return this.controller.buttonController.emitter.off(i, o), this
    }
};

function applyClass$1(l, i, o) {
    o ? l.classList.add(i) : l.classList.remove(i)
}

function valueToClassName$1(l, i) {
    return o => {
        applyClass$1(l, i, o)
    }
}

function bindValueToTextContent$1(l, i) {
    bindValue$1(l, o => {
        i.textContent = o ? ? ""
    })
}
const cn$p$1 = ClassName$1("btn");
let ButtonView$1 = class {
        constructor(i, o) {
            this.element = i.createElement("div"), this.element.classList.add(cn$p$1()), o.viewProps.bindClassModifiers(this.element);
            const c = i.createElement("button");
            c.classList.add(cn$p$1("b")), o.viewProps.bindDisabled(c), this.element.appendChild(c), this.buttonElement = c;
            const u = i.createElement("div");
            u.classList.add(cn$p$1("t")), bindValueToTextContent$1(o.props.value("title"), u), this.buttonElement.appendChild(u)
        }
    },
    ButtonController$1 = class {
        constructor(i, o) {
            this.emitter = new Emitter$1, this.onClick_ = this.onClick_.bind(this), this.props = o.props, this.viewProps = o.viewProps, this.view = new ButtonView$1(i, {
                props: this.props,
                viewProps: this.viewProps
            }), this.view.buttonElement.addEventListener("click", this.onClick_)
        }
        importProps(i) {
            return importBladeState$1(i, null, o => ({
                title: o.optional.string
            }), o => (this.props.set("title", o.title), !0))
        }
        exportProps() {
            return exportBladeState$1(null, {
                title: this.props.get("title")
            })
        }
        onClick_(i) {
            this.emitter.emit("click", {
                nativeEvent: i,
                sender: this
            })
        }
    },
    ButtonBladeController$1 = class extends BladeController$1 {
        constructor(i, o) {
            const c = new ButtonController$1(i, {
                    props: o.buttonProps,
                    viewProps: o.viewProps
                }),
                u = new LabelController$1(i, {
                    blade: o.blade,
                    props: o.labelProps,
                    valueController: c
                });
            super({
                blade: o.blade,
                view: u.view,
                viewProps: o.viewProps
            }), this.buttonController = c, this.labelController = u
        }
        importState(i) {
            return importBladeState$1(i, o => super.importState(o) && this.buttonController.importProps(o) && this.labelController.importProps(o), () => ({}), () => !0)
        }
        exportState() {
            return exportBladeState$1(() => super.exportState(), Object.assign(Object.assign({}, this.buttonController.exportProps()), this.labelController.exportProps()))
        }
    },
    Semver$1 = class {
        constructor(i) {
            const [o, c] = i.split("-"), u = o.split(".");
            this.major = parseInt(u[0], 10), this.minor = parseInt(u[1], 10), this.patch = parseInt(u[2], 10), this.prerelease = c ? ? null
        }
        toString() {
            const i = [this.major, this.minor, this.patch].join(".");
            return this.prerelease !== null ? [i, this.prerelease].join("-") : i
        }
    };
const VERSION$1 = new Semver$1("2.0.5");

function createPlugin$1(l) {
    return Object.assign({
        core: VERSION$1
    }, l)
}
const ButtonBladePlugin = createPlugin$1({
    id: "button",
    type: "blade",
    accept(l) {
        const i = parseRecord$1(l, o => ({
            title: o.required.string,
            view: o.required.constant("button"),
            label: o.optional.string
        }));
        return i ? {
            params: i
        } : null
    },
    controller(l) {
        return new ButtonBladeController$1(l.document, {
            blade: l.blade,
            buttonProps: ValueMap$1.fromObject({
                title: l.params.title
            }),
            labelProps: ValueMap$1.fromObject({
                label: l.params.label
            }),
            viewProps: l.viewProps
        })
    },
    api(l) {
        return l.controller instanceof ButtonBladeController$1 ? new ButtonApi$1(l.controller) : null
    }
});

function addButtonAsBlade$1(l, i) {
    return l.addBlade(Object.assign(Object.assign({}, i), {
        view: "button"
    }))
}

function addFolderAsBlade$1(l, i) {
    return l.addBlade(Object.assign(Object.assign({}, i), {
        view: "folder"
    }))
}

function addTabAsBlade$1(l, i) {
    return l.addBlade(Object.assign(Object.assign({}, i), {
        view: "tab"
    }))
}

function isRefreshable$1(l) {
    return isObject$1$2(l) ? "refresh" in l && typeof l.refresh == "function" : !1
}

function createBindingTarget$1(l, i) {
    if (!BindingTarget$1.isBindable(l)) throw TpError$1.notBindable();
    return new BindingTarget$1(l, i)
}
let RackApi$1 = class {
        constructor(i, o) {
            this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.controller_ = i, this.emitter_ = new Emitter$1, this.pool_ = o, this.controller_.rack.emitter.on("valuechange", this.onRackValueChange_)
        }
        get children() {
            return this.controller_.rack.children.map(i => this.pool_.createApi(i))
        }
        addBinding(i, o, c) {
            const u = c ? ? {},
                p = this.controller_.element.ownerDocument,
                m = this.pool_.createBinding(p, createBindingTarget$1(i, o), u),
                g = this.pool_.createBindingApi(m);
            return this.add(g, u.index)
        }
        addFolder(i) {
            return addFolderAsBlade$1(this, i)
        }
        addButton(i) {
            return addButtonAsBlade$1(this, i)
        }
        addTab(i) {
            return addTabAsBlade$1(this, i)
        }
        add(i, o) {
            const c = i.controller;
            return this.controller_.rack.add(c, o), i
        }
        remove(i) {
            this.controller_.rack.remove(i.controller)
        }
        addBlade(i) {
            const o = this.controller_.element.ownerDocument,
                c = this.pool_.createBlade(o, i),
                u = this.pool_.createApi(c);
            return this.add(u, i.index)
        }
        on(i, o) {
            const c = o.bind(this);
            return this.emitter_.on(i, u => {
                c(u)
            }, {
                key: o
            }), this
        }
        off(i, o) {
            return this.emitter_.off(i, o), this
        }
        refresh() {
            this.children.forEach(i => {
                isRefreshable$1(i) && i.refresh()
            })
        }
        onRackValueChange_(i) {
            const o = i.bladeController,
                c = this.pool_.createApi(o),
                u = isBindingValue$1(o.value) ? o.value.binding : null;
            this.emitter_.emit("change", new TpChangeEvent$1(c, u ? u.target.read() : o.value.rawValue, i.options.last))
        }
    },
    ContainerBladeApi$1 = class extends BladeApi$1 {
        constructor(i, o) {
            super(i), this.rackApi_ = new RackApi$1(i.rackController, o)
        }
        refresh() {
            this.rackApi_.refresh()
        }
    },
    ContainerBladeController$1 = class extends BladeController$1 {
        constructor(i) {
            super({
                blade: i.blade,
                view: i.view,
                viewProps: i.rackController.viewProps
            }), this.rackController = i.rackController
        }
        importState(i) {
            return importBladeState$1(i, o => super.importState(o), o => ({
                children: o.required.array(o.required.raw)
            }), o => this.rackController.rack.children.every((c, u) => c.importState(o.children[u])))
        }
        exportState() {
            return exportBladeState$1(() => super.exportState(), {
                children: this.rackController.rack.children.map(i => i.exportState())
            })
        }
    };

function isContainerBladeController$1(l) {
    return "rackController" in l
}
let NestedOrderedSet$1 = class {
    constructor(i) {
        this.emitter = new Emitter$1, this.items_ = [], this.cache_ = new Set, this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = i
    }
    get items() {
        return this.items_
    }
    allItems() {
        return Array.from(this.cache_)
    }
    find(i) {
        for (const o of this.allItems())
            if (i(o)) return o;
        return null
    }
    includes(i) {
        return this.cache_.has(i)
    }
    add(i, o) {
        if (this.includes(i)) throw TpError$1.shouldNeverHappen();
        const c = o !== void 0 ? o : this.items_.length;
        this.items_.splice(c, 0, i), this.cache_.add(i);
        const u = this.extract_(i);
        u && (u.emitter.on("add", this.onSubListAdd_), u.emitter.on("remove", this.onSubListRemove_), u.allItems().forEach(p => {
            this.cache_.add(p)
        })), this.emitter.emit("add", {
            index: c,
            item: i,
            root: this,
            target: this
        })
    }
    remove(i) {
        const o = this.items_.indexOf(i);
        if (o < 0) return;
        this.items_.splice(o, 1), this.cache_.delete(i);
        const c = this.extract_(i);
        c && (c.allItems().forEach(u => {
            this.cache_.delete(u)
        }), c.emitter.off("add", this.onSubListAdd_), c.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
            index: o,
            item: i,
            root: this,
            target: this
        })
    }
    onSubListAdd_(i) {
        this.cache_.add(i.item), this.emitter.emit("add", {
            index: i.index,
            item: i.item,
            root: this,
            target: i.target
        })
    }
    onSubListRemove_(i) {
        this.cache_.delete(i.item), this.emitter.emit("remove", {
            index: i.index,
            item: i.item,
            root: this,
            target: i.target
        })
    }
};

function findValueBladeController$1(l, i) {
    for (let o = 0; o < l.length; o++) {
        const c = l[o];
        if (isValueBladeController$1(c) && c.value === i) return c
    }
    return null
}

function findSubBladeControllerSet$1(l) {
    return isContainerBladeController$1(l) ? l.rackController.rack.bcSet_ : null
}
let Rack$1 = class {
        constructor(i) {
            var o, c;
            this.emitter = new Emitter$1, this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onRackLayout_ = this.onRackLayout_.bind(this), this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.blade_ = (o = i.blade) !== null && o !== void 0 ? o : null, (c = this.blade_) === null || c === void 0 || c.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = i.viewProps, this.bcSet_ = new NestedOrderedSet$1(findSubBladeControllerSet$1), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_)
        }
        get children() {
            return this.bcSet_.items
        }
        add(i, o) {
            var c;
            (c = i.parent) === null || c === void 0 || c.remove(i), i.parent = this, this.bcSet_.add(i, o)
        }
        remove(i) {
            i.parent = null, this.bcSet_.remove(i)
        }
        find(i) {
            return this.bcSet_.allItems().filter(i)
        }
        onSetAdd_(i) {
            this.updatePositions_();
            const o = i.target === i.root;
            if (this.emitter.emit("add", {
                    bladeController: i.item,
                    index: i.index,
                    root: o,
                    sender: this
                }), !o) return;
            const c = i.item;
            if (c.viewProps.emitter.on("change", this.onChildViewPropsChange_), c.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), c.viewProps.handleDispose(this.onChildDispose_), isValueBladeController$1(c)) c.value.emitter.on("change", this.onChildValueChange_);
            else if (isContainerBladeController$1(c)) {
                const u = c.rackController.rack;
                if (u) {
                    const p = u.emitter;
                    p.on("layout", this.onRackLayout_), p.on("valuechange", this.onRackValueChange_)
                }
            }
        }
        onSetRemove_(i) {
            this.updatePositions_();
            const o = i.target === i.root;
            if (this.emitter.emit("remove", {
                    bladeController: i.item,
                    root: o,
                    sender: this
                }), !o) return;
            const c = i.item;
            if (isValueBladeController$1(c)) c.value.emitter.off("change", this.onChildValueChange_);
            else if (isContainerBladeController$1(c)) {
                const u = c.rackController.rack;
                if (u) {
                    const p = u.emitter;
                    p.off("layout", this.onRackLayout_), p.off("valuechange", this.onRackValueChange_)
                }
            }
        }
        updatePositions_() {
            const i = this.bcSet_.items.filter(u => !u.viewProps.get("hidden")),
                o = i[0],
                c = i[i.length - 1];
            this.bcSet_.items.forEach(u => {
                const p = [];
                u === o && (p.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && p.push("veryfirst")), u === c && (p.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && p.push("verylast")), u.blade.set("positions", p)
            })
        }
        onChildPositionsChange_() {
            this.updatePositions_(), this.emitter.emit("layout", {
                sender: this
            })
        }
        onChildViewPropsChange_(i) {
            this.updatePositions_(), this.emitter.emit("layout", {
                sender: this
            })
        }
        onChildDispose_() {
            this.bcSet_.items.filter(o => o.viewProps.get("disposed")).forEach(o => {
                this.bcSet_.remove(o)
            })
        }
        onChildValueChange_(i) {
            const o = findValueBladeController$1(this.find(isValueBladeController$1), i.sender);
            if (!o) throw TpError$1.alreadyDisposed();
            this.emitter.emit("valuechange", {
                bladeController: o,
                options: i.options,
                sender: this
            })
        }
        onRackLayout_(i) {
            this.updatePositions_(), this.emitter.emit("layout", {
                sender: this
            })
        }
        onRackValueChange_(i) {
            this.emitter.emit("valuechange", {
                bladeController: i.bladeController,
                options: i.options,
                sender: this
            })
        }
        onBladePositionsChange_() {
            this.updatePositions_()
        }
    },
    RackController$1 = class {
        constructor(i) {
            this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.element = i.element, this.viewProps = i.viewProps;
            const o = new Rack$1({
                blade: i.root ? void 0 : i.blade,
                viewProps: i.viewProps
            });
            o.emitter.on("add", this.onRackAdd_), o.emitter.on("remove", this.onRackRemove_), this.rack = o, this.viewProps.handleDispose(() => {
                for (let c = this.rack.children.length - 1; c >= 0; c--) this.rack.children[c].viewProps.set("disposed", !0)
            })
        }
        onRackAdd_(i) {
            i.root && insertElementAt$1(this.element, i.bladeController.view.element, i.index)
        }
        onRackRemove_(i) {
            i.root && removeElement$1(i.bladeController.view.element)
        }
    };

function createBlade$1() {
    return new ValueMap$1({
        positions: createValue$1([], {
            equals: deepEqualsArray$1
        })
    })
}
let Foldable$1 = class jr extends ValueMap$1 {
    constructor(i) {
        super(i)
    }
    static create(i) {
        const o = {
                completed: !0,
                expanded: i,
                expandedHeight: null,
                shouldFixHeight: !1,
                temporaryExpanded: null
            },
            c = ValueMap$1.createCore(o);
        return new jr(c)
    }
    get styleExpanded() {
        var i;
        return (i = this.get("temporaryExpanded")) !== null && i !== void 0 ? i : this.get("expanded")
    }
    get styleHeight() {
        if (!this.styleExpanded) return "0";
        const i = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !isEmpty$1(i) ? `${i}px` : "auto"
    }
    bindExpandedClass(i, o) {
        const c = () => {
            this.styleExpanded ? i.classList.add(o) : i.classList.remove(o)
        };
        bindValueMap$1(this, "expanded", c), bindValueMap$1(this, "temporaryExpanded", c)
    }
    cleanUpTransition() {
        this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0)
    }
};

function computeExpandedFolderHeight$1(l, i) {
    let o = 0;
    return disableTransitionTemporarily$1(i, () => {
        l.set("expandedHeight", null), l.set("temporaryExpanded", !0), forceReflow$1(i), o = i.clientHeight, l.set("temporaryExpanded", null), forceReflow$1(i)
    }), o
}

function applyHeight$1(l, i) {
    i.style.height = l.styleHeight
}

function bindFoldable$1(l, i) {
    l.value("expanded").emitter.on("beforechange", () => {
        if (l.set("completed", !1), isEmpty$1(l.get("expandedHeight"))) {
            const o = computeExpandedFolderHeight$1(l, i);
            o > 0 && l.set("expandedHeight", o)
        }
        l.set("shouldFixHeight", !0), forceReflow$1(i)
    }), l.emitter.on("change", () => {
        applyHeight$1(l, i)
    }), applyHeight$1(l, i), i.addEventListener("transitionend", o => {
        o.propertyName === "height" && l.cleanUpTransition()
    })
}
let FolderApi$1 = class extends ContainerBladeApi$1 {
    constructor(i, o) {
        super(i, o), this.emitter_ = new Emitter$1, this.controller.foldable.value("expanded").emitter.on("change", c => {
            this.emitter_.emit("fold", new TpFoldEvent$1(this, c.sender.rawValue))
        }), this.rackApi_.on("change", c => {
            this.emitter_.emit("change", c)
        })
    }
    get expanded() {
        return this.controller.foldable.get("expanded")
    }
    set expanded(i) {
        this.controller.foldable.set("expanded", i)
    }
    get title() {
        return this.controller.props.get("title")
    }
    set title(i) {
        this.controller.props.set("title", i)
    }
    get children() {
        return this.rackApi_.children
    }
    addBinding(i, o, c) {
        return this.rackApi_.addBinding(i, o, c)
    }
    addFolder(i) {
        return this.rackApi_.addFolder(i)
    }
    addButton(i) {
        return this.rackApi_.addButton(i)
    }
    addTab(i) {
        return this.rackApi_.addTab(i)
    }
    add(i, o) {
        return this.rackApi_.add(i, o)
    }
    remove(i) {
        this.rackApi_.remove(i)
    }
    addBlade(i) {
        return this.rackApi_.addBlade(i)
    }
    on(i, o) {
        const c = o.bind(this);
        return this.emitter_.on(i, u => {
            c(u)
        }, {
            key: o
        }), this
    }
    off(i, o) {
        return this.emitter_.off(i, o), this
    }
};
const bladeContainerClassName$1 = ClassName$1("cnt");
let FolderView$1 = class {
        constructor(i, o) {
            var c;
            this.className_ = ClassName$1((c = o.viewName) !== null && c !== void 0 ? c : "fld"), this.element = i.createElement("div"), this.element.classList.add(this.className_(), bladeContainerClassName$1()), o.viewProps.bindClassModifiers(this.element), this.foldable_ = o.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), bindValueMap$1(this.foldable_, "completed", valueToClassName$1(this.element, this.className_(void 0, "cpl")));
            const u = i.createElement("button");
            u.classList.add(this.className_("b")), bindValueMap$1(o.props, "title", v => {
                isEmpty$1(v) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"))
            }), o.viewProps.bindDisabled(u), this.element.appendChild(u), this.buttonElement = u;
            const p = i.createElement("div");
            p.classList.add(this.className_("i")), this.element.appendChild(p);
            const m = i.createElement("div");
            m.classList.add(this.className_("t")), bindValueToTextContent$1(o.props.value("title"), m), this.buttonElement.appendChild(m), this.titleElement = m;
            const g = i.createElement("div");
            g.classList.add(this.className_("m")), this.buttonElement.appendChild(g);
            const _ = i.createElement("div");
            _.classList.add(this.className_("c")), this.element.appendChild(_), this.containerElement = _
        }
    },
    FolderController$1 = class extends ContainerBladeController$1 {
        constructor(i, o) {
            var c;
            const u = Foldable$1.create((c = o.expanded) !== null && c !== void 0 ? c : !0),
                p = new FolderView$1(i, {
                    foldable: u,
                    props: o.props,
                    viewName: o.root ? "rot" : void 0,
                    viewProps: o.viewProps
                });
            super(Object.assign(Object.assign({}, o), {
                rackController: new RackController$1({
                    blade: o.blade,
                    element: p.containerElement,
                    root: o.root,
                    viewProps: o.viewProps
                }),
                view: p
            })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = o.props, this.foldable = u, bindFoldable$1(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
                this.foldable.cleanUpTransition()
            }), this.rackController.rack.emitter.on("remove", () => {
                this.foldable.cleanUpTransition()
            }), this.view.buttonElement.addEventListener("click", this.onTitleClick_)
        }
        get document() {
            return this.view.element.ownerDocument
        }
        importState(i) {
            return importBladeState$1(i, o => super.importState(o), o => ({
                expanded: o.required.boolean,
                title: o.optional.string
            }), o => (this.foldable.set("expanded", o.expanded), this.props.set("title", o.title), !0))
        }
        exportState() {
            return exportBladeState$1(() => super.exportState(), {
                expanded: this.foldable.get("expanded"),
                title: this.props.get("title")
            })
        }
        onTitleClick_() {
            this.foldable.set("expanded", !this.foldable.get("expanded"))
        }
    };
const FolderBladePlugin = createPlugin$1({
        id: "folder",
        type: "blade",
        accept(l) {
            const i = parseRecord$1(l, o => ({
                title: o.required.string,
                view: o.required.constant("folder"),
                expanded: o.optional.boolean
            }));
            return i ? {
                params: i
            } : null
        },
        controller(l) {
            return new FolderController$1(l.document, {
                blade: l.blade,
                expanded: l.params.expanded,
                props: ValueMap$1.fromObject({
                    title: l.params.title
                }),
                viewProps: l.viewProps
            })
        },
        api(l) {
            return l.controller instanceof FolderController$1 ? new FolderApi$1(l.controller, l.pool) : null
        }
    }),
    cn$o$1 = ClassName$1("");

function valueToModifier$1(l, i) {
    return valueToClassName$1(l, cn$o$1(void 0, i))
}
let ViewProps$1 = class qr extends ValueMap$1 {
    constructor(i) {
        var o;
        super(i), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue$1(createValue$1(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (o = this.get("parent")) === null || o === void 0 || o.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_)
    }
    static create(i) {
        var o, c, u;
        const p = i ? ? {};
        return new qr(ValueMap$1.createCore({
            disabled: (o = p.disabled) !== null && o !== void 0 ? o : !1,
            disposed: !1,
            hidden: (c = p.hidden) !== null && c !== void 0 ? c : !1,
            parent: (u = p.parent) !== null && u !== void 0 ? u : null
        }))
    }
    get globalDisabled() {
        return this.globalDisabled_
    }
    bindClassModifiers(i) {
        bindValue$1(this.globalDisabled_, valueToModifier$1(i, "disabled")), bindValueMap$1(this, "hidden", valueToModifier$1(i, "hidden"))
    }
    bindDisabled(i) {
        bindValue$1(this.globalDisabled_, o => {
            i.disabled = o
        })
    }
    bindTabIndex(i) {
        bindValue$1(this.globalDisabled_, o => {
            i.tabIndex = o ? -1 : 0
        })
    }
    handleDispose(i) {
        this.value("disposed").emitter.on("change", o => {
            o && i()
        })
    }
    importState(i) {
        this.set("disabled", i.disabled), this.set("hidden", i.hidden)
    }
    exportState() {
        return {
            disabled: this.get("disabled"),
            hidden: this.get("hidden")
        }
    }
    getGlobalDisabled_() {
        const i = this.get("parent");
        return (i ? i.globalDisabled.rawValue : !1) || this.get("disabled")
    }
    updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_())
    }
    onDisabledChange_() {
        this.updateGlobalDisabled_()
    }
    onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_()
    }
    onParentChange_(i) {
        var o;
        const c = i.previousRawValue;
        c ? .globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (o = this.get("parent")) === null || o === void 0 || o.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_()
    }
};
const cn$n$1 = ClassName$1("tbp");
let TabPageView$1 = class {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$n$1()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$n$1("c")), this.element.appendChild(c), this.containerElement = c
    }
};
const cn$m$1 = ClassName$1("tbi");
let TabItemView$1 = class {
        constructor(i, o) {
            this.element = i.createElement("div"), this.element.classList.add(cn$m$1()), o.viewProps.bindClassModifiers(this.element), bindValueMap$1(o.props, "selected", p => {
                p ? this.element.classList.add(cn$m$1(void 0, "sel")) : this.element.classList.remove(cn$m$1(void 0, "sel"))
            });
            const c = i.createElement("button");
            c.classList.add(cn$m$1("b")), o.viewProps.bindDisabled(c), this.element.appendChild(c), this.buttonElement = c;
            const u = i.createElement("div");
            u.classList.add(cn$m$1("t")), bindValueToTextContent$1(o.props.value("title"), u), this.buttonElement.appendChild(u), this.titleElement = u
        }
    },
    TabItemController$1 = class {
        constructor(i, o) {
            this.emitter = new Emitter$1, this.onClick_ = this.onClick_.bind(this), this.props = o.props, this.viewProps = o.viewProps, this.view = new TabItemView$1(i, {
                props: o.props,
                viewProps: o.viewProps
            }), this.view.buttonElement.addEventListener("click", this.onClick_)
        }
        onClick_() {
            this.emitter.emit("click", {
                sender: this
            })
        }
    },
    TabPageController$1 = class extends ContainerBladeController$1 {
        constructor(i, o) {
            const c = new TabPageView$1(i, {
                viewProps: o.viewProps
            });
            super(Object.assign(Object.assign({}, o), {
                rackController: new RackController$1({
                    blade: o.blade,
                    element: c.containerElement,
                    viewProps: o.viewProps
                }),
                view: c
            })), this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new TabItemController$1(i, {
                props: o.itemProps,
                viewProps: ViewProps$1.create()
            }), this.ic_.emitter.on("click", this.onItemClick_), this.props = o.props, bindValueMap$1(this.props, "selected", u => {
                this.itemController.props.set("selected", u), this.viewProps.set("hidden", !u)
            })
        }
        get itemController() {
            return this.ic_
        }
        importState(i) {
            return importBladeState$1(i, o => super.importState(o), o => ({
                selected: o.required.boolean,
                title: o.required.string
            }), o => (this.ic_.props.set("selected", o.selected), this.ic_.props.set("title", o.title), !0))
        }
        exportState() {
            return exportBladeState$1(() => super.exportState(), {
                selected: this.ic_.props.get("selected"),
                title: this.ic_.props.get("title")
            })
        }
        onItemClick_() {
            this.props.set("selected", !0)
        }
    },
    TabApi$1 = class extends ContainerBladeApi$1 {
        constructor(i, o) {
            super(i, o), this.emitter_ = new Emitter$1, this.onSelect_ = this.onSelect_.bind(this), this.pool_ = o, this.rackApi_.on("change", c => {
                this.emitter_.emit("change", c)
            }), this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_)
        }
        get pages() {
            return this.rackApi_.children
        }
        addPage(i) {
            const o = this.controller.view.element.ownerDocument,
                c = new TabPageController$1(o, {
                    blade: createBlade$1(),
                    itemProps: ValueMap$1.fromObject({
                        selected: !1,
                        title: i.title
                    }),
                    props: ValueMap$1.fromObject({
                        selected: !1
                    }),
                    viewProps: ViewProps$1.create()
                }),
                u = this.pool_.createApi(c);
            return this.rackApi_.add(u, i.index)
        }
        removePage(i) {
            this.rackApi_.remove(this.rackApi_.children[i])
        }
        on(i, o) {
            const c = o.bind(this);
            return this.emitter_.on(i, u => {
                c(u)
            }, {
                key: o
            }), this
        }
        off(i, o) {
            return this.emitter_.off(i, o), this
        }
        onSelect_(i) {
            this.emitter_.emit("select", new TpTabSelectEvent$1(this, i.rawValue))
        }
    },
    TabPageApi$1 = class extends ContainerBladeApi$1 {
        get title() {
            var i;
            return (i = this.controller.itemController.props.get("title")) !== null && i !== void 0 ? i : ""
        }
        set title(i) {
            this.controller.itemController.props.set("title", i)
        }
        get selected() {
            return this.controller.props.get("selected")
        }
        set selected(i) {
            this.controller.props.set("selected", i)
        }
        get children() {
            return this.rackApi_.children
        }
        addButton(i) {
            return this.rackApi_.addButton(i)
        }
        addFolder(i) {
            return this.rackApi_.addFolder(i)
        }
        addTab(i) {
            return this.rackApi_.addTab(i)
        }
        add(i, o) {
            this.rackApi_.add(i, o)
        }
        remove(i) {
            this.rackApi_.remove(i)
        }
        addBinding(i, o, c) {
            return this.rackApi_.addBinding(i, o, c)
        }
        addBlade(i) {
            return this.rackApi_.addBlade(i)
        }
    };
const INDEX_NOT_SELECTED$1 = -1;
let Tab$1 = class {
    constructor() {
        this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = createValue$1(!0), this.selectedIndex = createValue$1(INDEX_NOT_SELECTED$1), this.items_ = []
    }
    add(i, o) {
        const c = o ? ? this.items_.length;
        this.items_.splice(c, 0, i), i.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_()
    }
    remove(i) {
        const o = this.items_.indexOf(i);
        o < 0 || (this.items_.splice(o, 1), i.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_())
    }
    keepSelection_() {
        if (this.items_.length === 0) {
            this.selectedIndex.rawValue = INDEX_NOT_SELECTED$1, this.empty.rawValue = !0;
            return
        }
        const i = this.items_.findIndex(o => o.rawValue);
        i < 0 ? (this.items_.forEach((o, c) => {
            o.rawValue = c === 0
        }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((o, c) => {
            o.rawValue = c === i
        }), this.selectedIndex.rawValue = i), this.empty.rawValue = !1
    }
    onItemSelectedChange_(i) {
        if (i.rawValue) {
            const o = this.items_.findIndex(c => c === i.sender);
            this.items_.forEach((c, u) => {
                c.rawValue = u === o
            }), this.selectedIndex.rawValue = o
        } else this.keepSelection_()
    }
};
const cn$l$1 = ClassName$1("tab");
let TabView$1 = class {
        constructor(i, o) {
            this.element = i.createElement("div"), this.element.classList.add(cn$l$1(), bladeContainerClassName$1()), o.viewProps.bindClassModifiers(this.element), bindValue$1(o.empty, valueToClassName$1(this.element, cn$l$1(void 0, "nop")));
            const c = i.createElement("div");
            c.classList.add(cn$l$1("t")), this.element.appendChild(c), this.itemsElement = c;
            const u = i.createElement("div");
            u.classList.add(cn$l$1("i")), this.element.appendChild(u);
            const p = i.createElement("div");
            p.classList.add(cn$l$1("c")), this.element.appendChild(p), this.contentsElement = p
        }
    },
    TabController$1 = class extends ContainerBladeController$1 {
        constructor(i, o) {
            const c = new Tab$1,
                u = new TabView$1(i, {
                    empty: c.empty,
                    viewProps: o.viewProps
                });
            super({
                blade: o.blade,
                rackController: new RackController$1({
                    blade: o.blade,
                    element: u.contentsElement,
                    viewProps: o.viewProps
                }),
                view: u
            }), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
            const p = this.rackController.rack;
            p.emitter.on("add", this.onRackAdd_), p.emitter.on("remove", this.onRackRemove_), this.tab = c
        }
        add(i, o) {
            this.rackController.rack.add(i, o)
        }
        remove(i) {
            this.rackController.rack.remove(this.rackController.rack.children[i])
        }
        onRackAdd_(i) {
            if (!i.root) return;
            const o = i.bladeController;
            insertElementAt$1(this.view.itemsElement, o.itemController.view.element, i.index), o.itemController.viewProps.set("parent", this.viewProps), this.tab.add(o.props.value("selected"))
        }
        onRackRemove_(i) {
            if (!i.root) return;
            const o = i.bladeController;
            removeElement$1(o.itemController.view.element), o.itemController.viewProps.set("parent", null), this.tab.remove(o.props.value("selected"))
        }
    };
const TabBladePlugin = createPlugin$1({
    id: "tab",
    type: "blade",
    accept(l) {
        const i = parseRecord$1(l, o => ({
            pages: o.required.array(o.required.object({
                title: o.required.string
            })),
            view: o.required.constant("tab")
        }));
        return !i || i.pages.length === 0 ? null : {
            params: i
        }
    },
    controller(l) {
        const i = new TabController$1(l.document, {
            blade: l.blade,
            viewProps: l.viewProps
        });
        return l.params.pages.forEach(o => {
            const c = new TabPageController$1(l.document, {
                blade: createBlade$1(),
                itemProps: ValueMap$1.fromObject({
                    selected: !1,
                    title: o.title
                }),
                props: ValueMap$1.fromObject({
                    selected: !1
                }),
                viewProps: ViewProps$1.create()
            });
            i.add(c)
        }), i
    },
    api(l) {
        return l.controller instanceof TabController$1 ? new TabApi$1(l.controller, l.pool) : l.controller instanceof TabPageController$1 ? new TabPageApi$1(l.controller, l.pool) : null
    }
});

function createBladeController(l, i) {
    const o = l.accept(i.params);
    if (!o) return null;
    const c = parseRecord$1(i.params, u => ({
        disabled: u.optional.boolean,
        hidden: u.optional.boolean
    }));
    return l.controller({
        blade: createBlade$1(),
        document: i.document,
        params: Object.assign(Object.assign({}, o.params), {
            disabled: c ? .disabled,
            hidden: c ? .hidden
        }),
        viewProps: ViewProps$1.create({
            disabled: c ? .disabled,
            hidden: c ? .hidden
        })
    })
}
let ListInputBindingApi$1 = class extends BindingApi$1 {
    get options() {
        return this.controller.valueController.props.get("options")
    }
    set options(i) {
        this.controller.valueController.props.set("options", i)
    }
};
class ManualTicker {
    constructor() {
        this.disabled = !1, this.emitter = new Emitter$1
    }
    dispose() {}
    tick() {
        this.disabled || this.emitter.emit("tick", {
            sender: this
        })
    }
}
class IntervalTicker {
    constructor(i, o) {
        this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = i, this.emitter = new Emitter$1, this.interval_ = o, this.setTimer_()
    }
    get disabled() {
        return this.disabled_
    }
    set disabled(i) {
        this.disabled_ = i, this.disabled_ ? this.clearTimer_() : this.setTimer_()
    }
    dispose() {
        this.clearTimer_()
    }
    clearTimer_() {
        if (this.timerId_ === null) return;
        const i = this.doc_.defaultView;
        i && i.clearInterval(this.timerId_), this.timerId_ = null
    }
    setTimer_() {
        if (this.clearTimer_(), this.interval_ <= 0) return;
        const i = this.doc_.defaultView;
        i && (this.timerId_ = i.setInterval(this.onTick_, this.interval_))
    }
    onTick_() {
        this.disabled_ || this.emitter.emit("tick", {
            sender: this
        })
    }
}
let CompositeConstraint$1 = class {
    constructor(i) {
        this.constraints = i
    }
    constrain(i) {
        return this.constraints.reduce((o, c) => c.constrain(o), i)
    }
};

function findConstraint$1(l, i) {
    if (l instanceof i) return l;
    if (l instanceof CompositeConstraint$1) {
        const o = l.constraints.reduce((c, u) => c || (u instanceof i ? u : null), null);
        if (o) return o
    }
    return null
}
let ListConstraint$1 = class {
    constructor(i) {
        this.values = ValueMap$1.fromObject({
            options: i
        })
    }
    constrain(i) {
        const o = this.values.get("options");
        return o.length === 0 || o.filter(u => u.value === i).length > 0 ? i : o[0].value
    }
};

function parseListOptions$1(l) {
    var i;
    const o = MicroParsers$1;
    if (Array.isArray(l)) return (i = parseRecord$1({
        items: l
    }, c => ({
        items: c.required.array(c.required.object({
            text: c.required.string,
            value: c.required.raw
        }))
    }))) === null || i === void 0 ? void 0 : i.items;
    if (typeof l == "object") return o.required.raw(l).value
}

function normalizeListOptions$1(l) {
    if (Array.isArray(l)) return l;
    const i = [];
    return Object.keys(l).forEach(o => {
        i.push({
            text: o,
            value: l[o]
        })
    }), i
}

function createListConstraint$1(l) {
    return isEmpty$1(l) ? null : new ListConstraint$1(normalizeListOptions$1(l))
}
const cn$k$1 = ClassName$1("lst");
let ListView$1 = class {
        constructor(i, o) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = o.props, this.element = i.createElement("div"), this.element.classList.add(cn$k$1()), o.viewProps.bindClassModifiers(this.element);
            const c = i.createElement("select");
            c.classList.add(cn$k$1("s")), o.viewProps.bindDisabled(c), this.element.appendChild(c), this.selectElement = c;
            const u = i.createElement("div");
            u.classList.add(cn$k$1("m")), u.appendChild(createSvgIconElement$1(i, "dropdown")), this.element.appendChild(u), o.value.emitter.on("change", this.onValueChange_), this.value_ = o.value, bindValueMap$1(this.props_, "options", p => {
                removeChildElements$1(this.selectElement), p.forEach(m => {
                    const g = i.createElement("option");
                    g.textContent = m.text, this.selectElement.appendChild(g)
                }), this.update_()
            })
        }
        update_() {
            const i = this.props_.get("options").map(o => o.value);
            this.selectElement.selectedIndex = i.indexOf(this.value_.rawValue)
        }
        onValueChange_() {
            this.update_()
        }
    },
    ListController$1 = class {
        constructor(i, o) {
            this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = o.props, this.value = o.value, this.viewProps = o.viewProps, this.view = new ListView$1(i, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps
            }), this.view.selectElement.addEventListener("change", this.onSelectChange_)
        }
        onSelectChange_(i) {
            const o = i.currentTarget;
            this.value.rawValue = this.props.get("options")[o.selectedIndex].value
        }
        importProps(i) {
            return importBladeState$1(i, null, o => ({
                options: o.required.custom(parseListOptions$1)
            }), o => (this.props.set("options", normalizeListOptions$1(o.options)), !0))
        }
        exportProps() {
            return exportBladeState$1(null, {
                options: this.props.get("options")
            })
        }
    };
const cn$j$1 = ClassName$1("pop");
let PopupView$1 = class {
        constructor(i, o) {
            this.element = i.createElement("div"), this.element.classList.add(cn$j$1()), o.viewProps.bindClassModifiers(this.element), bindValue$1(o.shows, valueToClassName$1(this.element, cn$j$1(void 0, "v")))
        }
    },
    PopupController$1 = class {
        constructor(i, o) {
            this.shows = createValue$1(!1), this.viewProps = o.viewProps, this.view = new PopupView$1(i, {
                shows: this.shows,
                viewProps: this.viewProps
            })
        }
    };
const cn$i$1 = ClassName$1("txt");
let TextView$1 = class {
        constructor(i, o) {
            this.onChange_ = this.onChange_.bind(this), this.element = i.createElement("div"), this.element.classList.add(cn$i$1()), o.viewProps.bindClassModifiers(this.element), this.props_ = o.props, this.props_.emitter.on("change", this.onChange_);
            const c = i.createElement("input");
            c.classList.add(cn$i$1("i")), c.type = "text", o.viewProps.bindDisabled(c), this.element.appendChild(c), this.inputElement = c, o.value.emitter.on("change", this.onChange_), this.value_ = o.value, this.refresh()
        }
        refresh() {
            const i = this.props_.get("formatter");
            this.inputElement.value = i(this.value_.rawValue)
        }
        onChange_() {
            this.refresh()
        }
    },
    TextController$1 = class {
        constructor(i, o) {
            this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = o.parser, this.props = o.props, this.value = o.value, this.viewProps = o.viewProps, this.view = new TextView$1(i, {
                props: o.props,
                value: this.value,
                viewProps: this.viewProps
            }), this.view.inputElement.addEventListener("change", this.onInputChange_)
        }
        onInputChange_(i) {
            const c = i.currentTarget.value,
                u = this.parser_(c);
            isEmpty$1(u) || (this.value.rawValue = u), this.view.refresh()
        }
    };

function boolToString$1(l) {
    return String(l)
}

function boolFromUnknown$1(l) {
    return l === "false" ? !1 : !!l
}

function BooleanFormatter$1(l) {
    return boolToString$1(l)
}

function composeParsers$1(l) {
    return i => l.reduce((o, c) => o !== null ? o : c(i), null)
}
const innerFormatter$1 = createNumberFormatter$1(0);

function formatPercentage$1(l) {
    return innerFormatter$1(l) + "%"
}

function stringFromUnknown$1(l) {
    return String(l)
}

function formatString$1(l) {
    return l
}

function connectValues$1({
    primary: l,
    secondary: i,
    forward: o,
    backward: c
}) {
    let u = !1;

    function p(m) {
        u || (u = !0, m(), u = !1)
    }
    l.emitter.on("change", m => {
        p(() => {
            i.setRawValue(o(l.rawValue, i.rawValue), m.options)
        })
    }), i.emitter.on("change", m => {
        p(() => {
            l.setRawValue(c(l.rawValue, i.rawValue), m.options)
        }), p(() => {
            i.setRawValue(o(l.rawValue, i.rawValue), m.options)
        })
    }), p(() => {
        i.setRawValue(o(l.rawValue, i.rawValue), {
            forceEmit: !1,
            last: !0
        })
    })
}

function getStepForKey$1(l, i) {
    const o = l * (i.altKey ? .1 : 1) * (i.shiftKey ? 10 : 1);
    return i.upKey ? +o : i.downKey ? -o : 0
}

function getVerticalStepKeys$1(l) {
    return {
        altKey: l.altKey,
        downKey: l.key === "ArrowDown",
        shiftKey: l.shiftKey,
        upKey: l.key === "ArrowUp"
    }
}

function getHorizontalStepKeys$1(l) {
    return {
        altKey: l.altKey,
        downKey: l.key === "ArrowLeft",
        shiftKey: l.shiftKey,
        upKey: l.key === "ArrowRight"
    }
}

function isVerticalArrowKey$1(l) {
    return l === "ArrowUp" || l === "ArrowDown"
}

function isArrowKey$1(l) {
    return isVerticalArrowKey$1(l) || l === "ArrowLeft" || l === "ArrowRight"
}

function computeOffset$1$1(l, i) {
    var o, c;
    const u = i.ownerDocument.defaultView,
        p = i.getBoundingClientRect();
    return {
        x: l.pageX - (((o = u && u.scrollX) !== null && o !== void 0 ? o : 0) + p.left),
        y: l.pageY - (((c = u && u.scrollY) !== null && c !== void 0 ? c : 0) + p.top)
    }
}
let PointerHandler$1 = class {
    constructor(i) {
        this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = i, this.emitter = new Emitter$1, i.addEventListener("touchstart", this.onTouchStart_, {
            passive: !1
        }), i.addEventListener("touchmove", this.onTouchMove_, {
            passive: !0
        }), i.addEventListener("touchend", this.onTouchEnd_), i.addEventListener("mousedown", this.onMouseDown_)
    }
    computePosition_(i) {
        const o = this.elem_.getBoundingClientRect();
        return {
            bounds: {
                width: o.width,
                height: o.height
            },
            point: i ? {
                x: i.x,
                y: i.y
            } : null
        }
    }
    onMouseDown_(i) {
        var o;
        i.preventDefault(), (o = i.currentTarget) === null || o === void 0 || o.focus();
        const c = this.elem_.ownerDocument;
        c.addEventListener("mousemove", this.onDocumentMouseMove_), c.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
            altKey: i.altKey,
            data: this.computePosition_(computeOffset$1$1(i, this.elem_)),
            sender: this,
            shiftKey: i.shiftKey
        })
    }
    onDocumentMouseMove_(i) {
        this.emitter.emit("move", {
            altKey: i.altKey,
            data: this.computePosition_(computeOffset$1$1(i, this.elem_)),
            sender: this,
            shiftKey: i.shiftKey
        })
    }
    onDocumentMouseUp_(i) {
        const o = this.elem_.ownerDocument;
        o.removeEventListener("mousemove", this.onDocumentMouseMove_), o.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
            altKey: i.altKey,
            data: this.computePosition_(computeOffset$1$1(i, this.elem_)),
            sender: this,
            shiftKey: i.shiftKey
        })
    }
    onTouchStart_(i) {
        i.preventDefault();
        const o = i.targetTouches.item(0),
            c = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
            altKey: i.altKey,
            data: this.computePosition_(o ? {
                x: o.clientX - c.left,
                y: o.clientY - c.top
            } : void 0),
            sender: this,
            shiftKey: i.shiftKey
        }), this.lastTouch_ = o
    }
    onTouchMove_(i) {
        const o = i.targetTouches.item(0),
            c = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
            altKey: i.altKey,
            data: this.computePosition_(o ? {
                x: o.clientX - c.left,
                y: o.clientY - c.top
            } : void 0),
            sender: this,
            shiftKey: i.shiftKey
        }), this.lastTouch_ = o
    }
    onTouchEnd_(i) {
        var o;
        const c = (o = i.targetTouches.item(0)) !== null && o !== void 0 ? o : this.lastTouch_,
            u = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
            altKey: i.altKey,
            data: this.computePosition_(c ? {
                x: c.clientX - u.left,
                y: c.clientY - u.top
            } : void 0),
            sender: this,
            shiftKey: i.shiftKey
        })
    }
};
const cn$h$1 = ClassName$1("txt");
let NumberTextView$1 = class {
        constructor(i, o) {
            this.onChange_ = this.onChange_.bind(this), this.props_ = o.props, this.props_.emitter.on("change", this.onChange_), this.element = i.createElement("div"), this.element.classList.add(cn$h$1(), cn$h$1(void 0, "num")), o.arrayPosition && this.element.classList.add(cn$h$1(void 0, o.arrayPosition)), o.viewProps.bindClassModifiers(this.element);
            const c = i.createElement("input");
            c.classList.add(cn$h$1("i")), c.type = "text", o.viewProps.bindDisabled(c), this.element.appendChild(c), this.inputElement = c, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = o.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(cn$h$1()), this.inputElement.classList.add(cn$h$1("i"));
            const u = i.createElement("div");
            u.classList.add(cn$h$1("k")), this.element.appendChild(u), this.knobElement = u;
            const p = i.createElementNS(SVG_NS$1, "svg");
            p.classList.add(cn$h$1("g")), this.knobElement.appendChild(p);
            const m = i.createElementNS(SVG_NS$1, "path");
            m.classList.add(cn$h$1("gb")), p.appendChild(m), this.guideBodyElem_ = m;
            const g = i.createElementNS(SVG_NS$1, "path");
            g.classList.add(cn$h$1("gh")), p.appendChild(g), this.guideHeadElem_ = g;
            const _ = i.createElement("div");
            _.classList.add(ClassName$1("tt")()), this.knobElement.appendChild(_), this.tooltipElem_ = _, o.value.emitter.on("change", this.onChange_), this.value = o.value, this.refresh()
        }
        onDraggingChange_(i) {
            if (i.rawValue === null) {
                this.element.classList.remove(cn$h$1(void 0, "drg"));
                return
            }
            this.element.classList.add(cn$h$1(void 0, "drg"));
            const o = i.rawValue / this.props_.get("pointerScale"),
                c = o + (o > 0 ? -1 : o < 0 ? 1 : 0),
                u = constrainRange$1(-c, -4, 4);
            this.guideHeadElem_.setAttributeNS(null, "d", [`M ${c+u},0 L${c},4 L${c+u},8`, `M ${o},-1 L${o},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${o},4`);
            const p = this.props_.get("formatter");
            this.tooltipElem_.textContent = p(this.value.rawValue), this.tooltipElem_.style.left = `${o}px`
        }
        refresh() {
            const i = this.props_.get("formatter");
            this.inputElement.value = i(this.value.rawValue)
        }
        onChange_() {
            this.refresh()
        }
    },
    NumberTextController$1 = class {
        constructor(i, o) {
            var c;
            this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.parser_ = o.parser, this.props = o.props, this.sliderProps_ = (c = o.sliderProps) !== null && c !== void 0 ? c : null, this.value = o.value, this.viewProps = o.viewProps, this.dragging_ = createValue$1(null), this.view = new NumberTextView$1(i, {
                arrayPosition: o.arrayPosition,
                dragging: this.dragging_,
                props: this.props,
                value: this.value,
                viewProps: this.viewProps
            }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
            const u = new PointerHandler$1(this.view.knobElement);
            u.emitter.on("down", this.onPointerDown_), u.emitter.on("move", this.onPointerMove_), u.emitter.on("up", this.onPointerUp_)
        }
        constrainValue_(i) {
            var o, c;
            const u = (o = this.sliderProps_) === null || o === void 0 ? void 0 : o.get("min"),
                p = (c = this.sliderProps_) === null || c === void 0 ? void 0 : c.get("max");
            let m = i;
            return u !== void 0 && (m = Math.max(m, u)), p !== void 0 && (m = Math.min(m, p)), m
        }
        onInputChange_(i) {
            const c = i.currentTarget.value,
                u = this.parser_(c);
            isEmpty$1(u) || (this.value.rawValue = this.constrainValue_(u)), this.view.refresh()
        }
        onInputKeyDown_(i) {
            const o = getStepForKey$1(this.props.get("keyScale"), getVerticalStepKeys$1(i));
            o !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + o), {
                forceEmit: !1,
                last: !1
            })
        }
        onInputKeyUp_(i) {
            getStepForKey$1(this.props.get("keyScale"), getVerticalStepKeys$1(i)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0
            })
        }
        onPointerDown_() {
            this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0
        }
        computeDraggingValue_(i) {
            if (!i.point) return null;
            const o = i.point.x - i.bounds.width / 2;
            return this.constrainValue_(this.originRawValue_ + o * this.props.get("pointerScale"))
        }
        onPointerMove_(i) {
            const o = this.computeDraggingValue_(i.data);
            o !== null && (this.value.setRawValue(o, {
                forceEmit: !1,
                last: !1
            }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
        }
        onPointerUp_(i) {
            const o = this.computeDraggingValue_(i.data);
            o !== null && (this.value.setRawValue(o, {
                forceEmit: !0,
                last: !0
            }), this.dragging_.rawValue = null)
        }
    };
const cn$g$1 = ClassName$1("sld");
let SliderView$1 = class {
        constructor(i, o) {
            this.onChange_ = this.onChange_.bind(this), this.props_ = o.props, this.props_.emitter.on("change", this.onChange_), this.element = i.createElement("div"), this.element.classList.add(cn$g$1()), o.viewProps.bindClassModifiers(this.element);
            const c = i.createElement("div");
            c.classList.add(cn$g$1("t")), o.viewProps.bindTabIndex(c), this.element.appendChild(c), this.trackElement = c;
            const u = i.createElement("div");
            u.classList.add(cn$g$1("k")), this.trackElement.appendChild(u), this.knobElement = u, o.value.emitter.on("change", this.onChange_), this.value = o.value, this.update_()
        }
        update_() {
            const i = constrainRange$1(mapRange$2(this.value.rawValue, this.props_.get("min"), this.props_.get("max"), 0, 100), 0, 100);
            this.knobElement.style.width = `${i}%`
        }
        onChange_() {
            this.update_()
        }
    },
    SliderController$1 = class {
        constructor(i, o) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.props = o.props, this.view = new SliderView$1(i, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps
            }), this.ptHandler_ = new PointerHandler$1(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_)
        }
        handlePointerEvent_(i, o) {
            i.point && this.value.setRawValue(mapRange$2(constrainRange$1(i.point.x, 0, i.bounds.width), 0, i.bounds.width, this.props.get("min"), this.props.get("max")), o)
        }
        onPointerDownOrMove_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !1,
                last: !1
            })
        }
        onPointerUp_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !0,
                last: !0
            })
        }
        onKeyDown_(i) {
            const o = getStepForKey$1(this.props.get("keyScale"), getHorizontalStepKeys$1(i));
            o !== 0 && this.value.setRawValue(this.value.rawValue + o, {
                forceEmit: !1,
                last: !1
            })
        }
        onKeyUp_(i) {
            getStepForKey$1(this.props.get("keyScale"), getHorizontalStepKeys$1(i)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0
            })
        }
    };
const cn$f$1 = ClassName$1("sldtxt");
let SliderTextView$1 = class {
        constructor(i, o) {
            this.element = i.createElement("div"), this.element.classList.add(cn$f$1());
            const c = i.createElement("div");
            c.classList.add(cn$f$1("s")), this.sliderView_ = o.sliderView, c.appendChild(this.sliderView_.element), this.element.appendChild(c);
            const u = i.createElement("div");
            u.classList.add(cn$f$1("t")), this.textView_ = o.textView, u.appendChild(this.textView_.element), this.element.appendChild(u)
        }
    },
    SliderTextController$1 = class {
        constructor(i, o) {
            this.value = o.value, this.viewProps = o.viewProps, this.sliderC_ = new SliderController$1(i, {
                props: o.sliderProps,
                value: o.value,
                viewProps: this.viewProps
            }), this.textC_ = new NumberTextController$1(i, {
                parser: o.parser,
                props: o.textProps,
                sliderProps: o.sliderProps,
                value: o.value,
                viewProps: o.viewProps
            }), this.view = new SliderTextView$1(i, {
                sliderView: this.sliderC_.view,
                textView: this.textC_.view
            })
        }
        get sliderController() {
            return this.sliderC_
        }
        get textController() {
            return this.textC_
        }
        importProps(i) {
            return importBladeState$1(i, null, o => ({
                max: o.required.number,
                min: o.required.number
            }), o => {
                const c = this.sliderC_.props;
                return c.set("max", o.max), c.set("min", o.min), !0
            })
        }
        exportProps() {
            const i = this.sliderC_.props;
            return exportBladeState$1(null, {
                max: i.get("max"),
                min: i.get("min")
            })
        }
    };

function createSliderTextProps$1(l) {
    return {
        sliderProps: new ValueMap$1({
            keyScale: l.keyScale,
            max: l.max,
            min: l.min
        }),
        textProps: new ValueMap$1({
            formatter: createValue$1(l.formatter),
            keyScale: l.keyScale,
            pointerScale: createValue$1(l.pointerScale)
        })
    }
}
const CSS_VAR_MAP$1 = {
    containerUnitSize: "cnt-usz"
};

function getCssVar$1(l) {
    return `--${CSS_VAR_MAP$1[l]}`
}

function createPointDimensionParser$1(l) {
    return createNumberTextInputParamsParser$1(l)
}

function parsePointDimensionParams$1(l) {
    if (isRecord$1(l)) return parseRecord$1(l, createPointDimensionParser$1)
}

function createDimensionConstraint$2(l, i) {
    if (!l) return;
    const o = [],
        c = createStepConstraint$1(l, i);
    c && o.push(c);
    const u = createRangeConstraint$1(l);
    return u && o.push(u), new CompositeConstraint$1(o)
}

function isCompatible(l) {
    return l ? l.major === VERSION$1.major : !1
}

function parsePickerLayout$1(l) {
    if (l === "inline" || l === "popup") return l
}

function writePrimitive$1(l, i) {
    l.write(i)
}
const cn$e$1 = ClassName$1("ckb");
let CheckboxView$1 = class {
        constructor(i, o) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.element = i.createElement("div"), this.element.classList.add(cn$e$1()), o.viewProps.bindClassModifiers(this.element);
            const c = i.createElement("label");
            c.classList.add(cn$e$1("l")), this.element.appendChild(c), this.labelElement = c;
            const u = i.createElement("input");
            u.classList.add(cn$e$1("i")), u.type = "checkbox", this.labelElement.appendChild(u), this.inputElement = u, o.viewProps.bindDisabled(this.inputElement);
            const p = i.createElement("div");
            p.classList.add(cn$e$1("w")), this.labelElement.appendChild(p);
            const m = createSvgIconElement$1(i, "check");
            p.appendChild(m), o.value.emitter.on("change", this.onValueChange_), this.value = o.value, this.update_()
        }
        update_() {
            this.inputElement.checked = this.value.rawValue
        }
        onValueChange_() {
            this.update_()
        }
    },
    CheckboxController$1 = class {
        constructor(i, o) {
            this.onInputChange_ = this.onInputChange_.bind(this), this.onLabelMouseDown_ = this.onLabelMouseDown_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.view = new CheckboxView$1(i, {
                value: this.value,
                viewProps: this.viewProps
            }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.labelElement.addEventListener("mousedown", this.onLabelMouseDown_)
        }
        onInputChange_(i) {
            const o = i.currentTarget;
            this.value.rawValue = o.checked, i.preventDefault(), i.stopPropagation()
        }
        onLabelMouseDown_(i) {
            i.preventDefault()
        }
    };

function createConstraint$6$1(l) {
    const i = [],
        o = createListConstraint$1(l.options);
    return o && i.push(o), new CompositeConstraint$1(i)
}
const BooleanInputPlugin = createPlugin$1({
        id: "input-bool",
        type: "input",
        accept: (l, i) => {
            if (typeof l != "boolean") return null;
            const o = parseRecord$1(i, c => ({
                options: c.optional.custom(parseListOptions$1),
                readonly: c.optional.constant(!1)
            }));
            return o ? {
                initialValue: l,
                params: o
            } : null
        },
        binding: {
            reader: l => boolFromUnknown$1,
            constraint: l => createConstraint$6$1(l.params),
            writer: l => writePrimitive$1
        },
        controller: l => {
            const i = l.document,
                o = l.value,
                c = l.constraint,
                u = c && findConstraint$1(c, ListConstraint$1);
            return u ? new ListController$1(i, {
                props: new ValueMap$1({
                    options: u.values.value("options")
                }),
                value: o,
                viewProps: l.viewProps
            }) : new CheckboxController$1(i, {
                value: o,
                viewProps: l.viewProps
            })
        },
        api(l) {
            return typeof l.controller.value.rawValue != "boolean" ? null : l.controller.valueController instanceof ListController$1 ? new ListInputBindingApi$1(l.controller) : null
        }
    }),
    cn$d$1 = ClassName$1("col");
let ColorView$1 = class {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$d$1()), o.foldable.bindExpandedClass(this.element, cn$d$1(void 0, "expanded")), bindValueMap$1(o.foldable, "completed", valueToClassName$1(this.element, cn$d$1(void 0, "cpl")));
        const c = i.createElement("div");
        c.classList.add(cn$d$1("h")), this.element.appendChild(c);
        const u = i.createElement("div");
        u.classList.add(cn$d$1("s")), c.appendChild(u), this.swatchElement = u;
        const p = i.createElement("div");
        if (p.classList.add(cn$d$1("t")), c.appendChild(p), this.textElement = p, o.pickerLayout === "inline") {
            const m = i.createElement("div");
            m.classList.add(cn$d$1("p")), this.element.appendChild(m), this.pickerElement = m
        } else this.pickerElement = null
    }
};

function rgbToHslInt$1(l, i, o) {
    const c = constrainRange$1(l / 255, 0, 1),
        u = constrainRange$1(i / 255, 0, 1),
        p = constrainRange$1(o / 255, 0, 1),
        m = Math.max(c, u, p),
        g = Math.min(c, u, p),
        _ = m - g;
    let v = 0,
        x = 0;
    const y = (g + m) / 2;
    return _ !== 0 && (x = _ / (1 - Math.abs(m + g - 1)), c === m ? v = (u - p) / _ : u === m ? v = 2 + (p - c) / _ : v = 4 + (c - u) / _, v = v / 6 + (v < 0 ? 1 : 0)), [v * 360, x * 100, y * 100]
}

function hslToRgbInt$1(l, i, o) {
    const c = (l % 360 + 360) % 360,
        u = constrainRange$1(i / 100, 0, 1),
        p = constrainRange$1(o / 100, 0, 1),
        m = (1 - Math.abs(2 * p - 1)) * u,
        g = m * (1 - Math.abs(c / 60 % 2 - 1)),
        _ = p - m / 2;
    let v, x, y;
    return c >= 0 && c < 60 ? [v, x, y] = [m, g, 0] : c >= 60 && c < 120 ? [v, x, y] = [g, m, 0] : c >= 120 && c < 180 ? [v, x, y] = [0, m, g] : c >= 180 && c < 240 ? [v, x, y] = [0, g, m] : c >= 240 && c < 300 ? [v, x, y] = [g, 0, m] : [v, x, y] = [m, 0, g], [(v + _) * 255, (x + _) * 255, (y + _) * 255]
}

function rgbToHsvInt$1(l, i, o) {
    const c = constrainRange$1(l / 255, 0, 1),
        u = constrainRange$1(i / 255, 0, 1),
        p = constrainRange$1(o / 255, 0, 1),
        m = Math.max(c, u, p),
        g = Math.min(c, u, p),
        _ = m - g;
    let v;
    _ === 0 ? v = 0 : m === c ? v = 60 * (((u - p) / _ % 6 + 6) % 6) : m === u ? v = 60 * ((p - c) / _ + 2) : v = 60 * ((c - u) / _ + 4);
    const x = m === 0 ? 0 : _ / m,
        y = m;
    return [v, x * 100, y * 100]
}

function hsvToRgbInt$1(l, i, o) {
    const c = loopRange$1(l, 360),
        u = constrainRange$1(i / 100, 0, 1),
        p = constrainRange$1(o / 100, 0, 1),
        m = p * u,
        g = m * (1 - Math.abs(c / 60 % 2 - 1)),
        _ = p - m;
    let v, x, y;
    return c >= 0 && c < 60 ? [v, x, y] = [m, g, 0] : c >= 60 && c < 120 ? [v, x, y] = [g, m, 0] : c >= 120 && c < 180 ? [v, x, y] = [0, m, g] : c >= 180 && c < 240 ? [v, x, y] = [0, g, m] : c >= 240 && c < 300 ? [v, x, y] = [g, 0, m] : [v, x, y] = [m, 0, g], [(v + _) * 255, (x + _) * 255, (y + _) * 255]
}

function hslToHsvInt$1(l, i, o) {
    const c = o + i * (100 - Math.abs(2 * o - 100)) / 200;
    return [l, c !== 0 ? i * (100 - Math.abs(2 * o - 100)) / c : 0, o + i * (100 - Math.abs(2 * o - 100)) / (2 * 100)]
}

function hsvToHslInt$1(l, i, o) {
    const c = 100 - Math.abs(o * (200 - i) / 100 - 100);
    return [l, c !== 0 ? i * o / c : 0, o * (200 - i) / (2 * 100)]
}

function removeAlphaComponent$1(l) {
    return [l[0], l[1], l[2]]
}

function appendAlphaComponent$1(l, i) {
    return [l[0], l[1], l[2], i]
}
const MODE_CONVERTER_MAP$1 = {
    hsl: {
        hsl: (l, i, o) => [l, i, o],
        hsv: hslToHsvInt$1,
        rgb: hslToRgbInt$1
    },
    hsv: {
        hsl: hsvToHslInt$1,
        hsv: (l, i, o) => [l, i, o],
        rgb: hsvToRgbInt$1
    },
    rgb: {
        hsl: rgbToHslInt$1,
        hsv: rgbToHsvInt$1,
        rgb: (l, i, o) => [l, i, o]
    }
};

function getColorMaxComponents$1(l, i) {
    return [i === "float" ? 1 : l === "rgb" ? 255 : 360, i === "float" ? 1 : l === "rgb" ? 255 : 100, i === "float" ? 1 : l === "rgb" ? 255 : 100]
}

function loopHueRange$1(l, i) {
    return l === i ? i : loopRange$1(l, i)
}

function constrainColorComponents$1(l, i, o) {
    var c;
    const u = getColorMaxComponents$1(i, o);
    return [i === "rgb" ? constrainRange$1(l[0], 0, u[0]) : loopHueRange$1(l[0], u[0]), constrainRange$1(l[1], 0, u[1]), constrainRange$1(l[2], 0, u[2]), constrainRange$1((c = l[3]) !== null && c !== void 0 ? c : 1, 0, 1)]
}

function convertColorType$1(l, i, o, c) {
    const u = getColorMaxComponents$1(i, o),
        p = getColorMaxComponents$1(i, c);
    return l.map((m, g) => m / u[g] * p[g])
}

function convertColor$1(l, i, o) {
    const c = convertColorType$1(l, i.mode, i.type, "int"),
        u = MODE_CONVERTER_MAP$1[i.mode][o.mode](...c);
    return convertColorType$1(u, o.mode, "int", o.type)
}
let IntColor$1 = class Xr {
    static black() {
        return new Xr([0, 0, 0], "rgb")
    }
    constructor(i, o) {
        this.type = "int", this.mode = o, this.comps_ = constrainColorComponents$1(i, o, this.type)
    }
    getComponents(i) {
        return appendAlphaComponent$1(convertColor$1(removeAlphaComponent$1(this.comps_), {
            mode: this.mode,
            type: this.type
        }, {
            mode: i ? ? this.mode,
            type: this.type
        }), this.comps_[3])
    }
    toRgbaObject() {
        const i = this.getComponents("rgb");
        return {
            r: i[0],
            g: i[1],
            b: i[2],
            a: i[3]
        }
    }
};
const cn$c$1 = ClassName$1("colp");
let ColorPickerView$1 = class {
    constructor(i, o) {
        this.alphaViews_ = null, this.element = i.createElement("div"), this.element.classList.add(cn$c$1()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$c$1("hsv"));
        const u = i.createElement("div");
        u.classList.add(cn$c$1("sv")), this.svPaletteView_ = o.svPaletteView, u.appendChild(this.svPaletteView_.element), c.appendChild(u);
        const p = i.createElement("div");
        p.classList.add(cn$c$1("h")), this.hPaletteView_ = o.hPaletteView, p.appendChild(this.hPaletteView_.element), c.appendChild(p), this.element.appendChild(c);
        const m = i.createElement("div");
        if (m.classList.add(cn$c$1("rgb")), this.textsView_ = o.textsView, m.appendChild(this.textsView_.element), this.element.appendChild(m), o.alphaViews) {
            this.alphaViews_ = {
                palette: o.alphaViews.palette,
                text: o.alphaViews.text
            };
            const g = i.createElement("div");
            g.classList.add(cn$c$1("a"));
            const _ = i.createElement("div");
            _.classList.add(cn$c$1("ap")), _.appendChild(this.alphaViews_.palette.element), g.appendChild(_);
            const v = i.createElement("div");
            v.classList.add(cn$c$1("at")), v.appendChild(this.alphaViews_.text.element), g.appendChild(v), this.element.appendChild(g)
        }
    }
    get allFocusableElements() {
        const i = [this.svPaletteView_.element, this.hPaletteView_.element, this.textsView_.modeSelectElement, ...this.textsView_.inputViews.map(o => o.inputElement)];
        return this.alphaViews_ && i.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), i
    }
};

function parseColorType$1(l) {
    return l === "int" ? "int" : l === "float" ? "float" : void 0
}

function parseColorInputParams$1(l) {
    return parseRecord$1(l, i => ({
        color: i.optional.object({
            alpha: i.optional.boolean,
            type: i.optional.custom(parseColorType$1)
        }),
        expanded: i.optional.boolean,
        picker: i.optional.custom(parsePickerLayout$1),
        readonly: i.optional.constant(!1)
    }))
}

function getKeyScaleForColor$1(l) {
    return l ? .1 : 1
}

function extractColorType$1(l) {
    var i;
    return (i = l.color) === null || i === void 0 ? void 0 : i.type
}
let FloatColor$1 = class {
    constructor(i, o) {
        this.type = "float", this.mode = o, this.comps_ = constrainColorComponents$1(i, o, this.type)
    }
    getComponents(i) {
        return appendAlphaComponent$1(convertColor$1(removeAlphaComponent$1(this.comps_), {
            mode: this.mode,
            type: this.type
        }, {
            mode: i ? ? this.mode,
            type: this.type
        }), this.comps_[3])
    }
    toRgbaObject() {
        const i = this.getComponents("rgb");
        return {
            r: i[0],
            g: i[1],
            b: i[2],
            a: i[3]
        }
    }
};
const TYPE_TO_CONSTRUCTOR_MAP$1 = {
    int: (l, i) => new IntColor$1(l, i),
    float: (l, i) => new FloatColor$1(l, i)
};

function createColor$1(l, i, o) {
    return TYPE_TO_CONSTRUCTOR_MAP$1[o](l, i)
}

function isFloatColor$1(l) {
    return l.type === "float"
}

function isIntColor$1(l) {
    return l.type === "int"
}

function convertFloatToInt$1(l) {
    const i = l.getComponents(),
        o = getColorMaxComponents$1(l.mode, "int");
    return new IntColor$1([Math.round(mapRange$2(i[0], 0, 1, 0, o[0])), Math.round(mapRange$2(i[1], 0, 1, 0, o[1])), Math.round(mapRange$2(i[2], 0, 1, 0, o[2])), i[3]], l.mode)
}

function convertIntToFloat$1(l) {
    const i = l.getComponents(),
        o = getColorMaxComponents$1(l.mode, "int");
    return new FloatColor$1([mapRange$2(i[0], 0, o[0], 0, 1), mapRange$2(i[1], 0, o[1], 0, 1), mapRange$2(i[2], 0, o[2], 0, 1), i[3]], l.mode)
}

function mapColorType$1(l, i) {
    if (l.type === i) return l;
    if (isIntColor$1(l) && i === "float") return convertIntToFloat$1(l);
    if (isFloatColor$1(l) && i === "int") return convertFloatToInt$1(l);
    throw TpError$1.shouldNeverHappen()
}

function equalsStringColorFormat$1(l, i) {
    return l.alpha === i.alpha && l.mode === i.mode && l.notation === i.notation && l.type === i.type
}

function parseCssNumberOrPercentage$1(l, i) {
    const o = l.match(/^(.+)%$/);
    return Math.min(o ? parseFloat(o[1]) * .01 * i : parseFloat(l), i)
}
const ANGLE_TO_DEG_MAP$1 = {
    deg: l => l,
    grad: l => l * 360 / 400,
    rad: l => l * 360 / (2 * Math.PI),
    turn: l => l * 360
};

function parseCssNumberOrAngle$1(l) {
    const i = l.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
    if (!i) return parseFloat(l);
    const o = parseFloat(i[1]),
        c = i[2];
    return ANGLE_TO_DEG_MAP$1[c](o)
}

function parseFunctionalRgbColorComponents$1(l) {
    const i = l.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!i) return null;
    const o = [parseCssNumberOrPercentage$1(i[1], 255), parseCssNumberOrPercentage$1(i[2], 255), parseCssNumberOrPercentage$1(i[3], 255)];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) ? null : o
}

function parseFunctionalRgbColor$1(l) {
    const i = parseFunctionalRgbColorComponents$1(l);
    return i ? new IntColor$1(i, "rgb") : null
}

function parseFunctionalRgbaColorComponents$1(l) {
    const i = l.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!i) return null;
    const o = [parseCssNumberOrPercentage$1(i[1], 255), parseCssNumberOrPercentage$1(i[2], 255), parseCssNumberOrPercentage$1(i[3], 255), parseCssNumberOrPercentage$1(i[4], 1)];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) || isNaN(o[3]) ? null : o
}

function parseFunctionalRgbaColor$1(l) {
    const i = parseFunctionalRgbaColorComponents$1(l);
    return i ? new IntColor$1(i, "rgb") : null
}

function parseFunctionalHslColorComponents$1(l) {
    const i = l.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!i) return null;
    const o = [parseCssNumberOrAngle$1(i[1]), parseCssNumberOrPercentage$1(i[2], 100), parseCssNumberOrPercentage$1(i[3], 100)];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) ? null : o
}

function parseFunctionalHslColor$1(l) {
    const i = parseFunctionalHslColorComponents$1(l);
    return i ? new IntColor$1(i, "hsl") : null
}

function parseHslaColorComponents$1(l) {
    const i = l.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!i) return null;
    const o = [parseCssNumberOrAngle$1(i[1]), parseCssNumberOrPercentage$1(i[2], 100), parseCssNumberOrPercentage$1(i[3], 100), parseCssNumberOrPercentage$1(i[4], 1)];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) || isNaN(o[3]) ? null : o
}

function parseFunctionalHslaColor$1(l) {
    const i = parseHslaColorComponents$1(l);
    return i ? new IntColor$1(i, "hsl") : null
}

function parseHexRgbColorComponents$1(l) {
    const i = l.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
    if (i) return [parseInt(i[1] + i[1], 16), parseInt(i[2] + i[2], 16), parseInt(i[3] + i[3], 16)];
    const o = l.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
    return o ? [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)] : null
}

function parseHexRgbColor$1(l) {
    const i = parseHexRgbColorComponents$1(l);
    return i ? new IntColor$1(i, "rgb") : null
}

function parseHexRgbaColorComponents$1(l) {
    const i = l.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
    if (i) return [parseInt(i[1] + i[1], 16), parseInt(i[2] + i[2], 16), parseInt(i[3] + i[3], 16), mapRange$2(parseInt(i[4] + i[4], 16), 0, 255, 0, 1)];
    const o = l.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
    return o ? [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16), mapRange$2(parseInt(o[4], 16), 0, 255, 0, 1)] : null
}

function parseHexRgbaColor$1(l) {
    const i = parseHexRgbaColorComponents$1(l);
    return i ? new IntColor$1(i, "rgb") : null
}

function parseObjectRgbColorComponents$1(l) {
    const i = l.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
    if (!i) return null;
    const o = [parseFloat(i[1]), parseFloat(i[2]), parseFloat(i[3])];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) ? null : o
}

function createObjectRgbColorParser$1(l) {
    return i => {
        const o = parseObjectRgbColorComponents$1(i);
        return o ? createColor$1(o, "rgb", l) : null
    }
}

function parseObjectRgbaColorComponents$1(l) {
    const i = l.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
    if (!i) return null;
    const o = [parseFloat(i[1]), parseFloat(i[2]), parseFloat(i[3]), parseFloat(i[4])];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) || isNaN(o[3]) ? null : o
}

function createObjectRgbaColorParser$1(l) {
    return i => {
        const o = parseObjectRgbaColorComponents$1(i);
        return o ? createColor$1(o, "rgb", l) : null
    }
}
const PARSER_AND_RESULT$1 = [{
    parser: parseHexRgbColorComponents$1,
    result: {
        alpha: !1,
        mode: "rgb",
        notation: "hex"
    }
}, {
    parser: parseHexRgbaColorComponents$1,
    result: {
        alpha: !0,
        mode: "rgb",
        notation: "hex"
    }
}, {
    parser: parseFunctionalRgbColorComponents$1,
    result: {
        alpha: !1,
        mode: "rgb",
        notation: "func"
    }
}, {
    parser: parseFunctionalRgbaColorComponents$1,
    result: {
        alpha: !0,
        mode: "rgb",
        notation: "func"
    }
}, {
    parser: parseFunctionalHslColorComponents$1,
    result: {
        alpha: !1,
        mode: "hsl",
        notation: "func"
    }
}, {
    parser: parseHslaColorComponents$1,
    result: {
        alpha: !0,
        mode: "hsl",
        notation: "func"
    }
}, {
    parser: parseObjectRgbColorComponents$1,
    result: {
        alpha: !1,
        mode: "rgb",
        notation: "object"
    }
}, {
    parser: parseObjectRgbaColorComponents$1,
    result: {
        alpha: !0,
        mode: "rgb",
        notation: "object"
    }
}];

function detectStringColor$1(l) {
    return PARSER_AND_RESULT$1.reduce((i, {
        parser: o,
        result: c
    }) => i || (o(l) ? c : null), null)
}

function detectStringColorFormat$1(l, i = "int") {
    const o = detectStringColor$1(l);
    return o ? o.notation === "hex" && i !== "float" ? Object.assign(Object.assign({}, o), {
        type: "int"
    }) : o.notation === "func" ? Object.assign(Object.assign({}, o), {
        type: i
    }) : null : null
}

function createColorStringParser$1(l) {
    const i = [parseHexRgbColor$1, parseHexRgbaColor$1, parseFunctionalRgbColor$1, parseFunctionalRgbaColor$1, parseFunctionalHslColor$1, parseFunctionalHslaColor$1];
    i.push(createObjectRgbColorParser$1("int"), createObjectRgbaColorParser$1("int"));
    const o = composeParsers$1(i);
    return c => {
        const u = o(c);
        return u ? mapColorType$1(u, l) : null
    }
}

function readIntColorString$1(l) {
    const i = createColorStringParser$1("int");
    if (typeof l != "string") return IntColor$1.black();
    const o = i(l);
    return o ? ? IntColor$1.black()
}

function zerofill$1(l) {
    const i = constrainRange$1(Math.floor(l), 0, 255).toString(16);
    return i.length === 1 ? `0${i}` : i
}

function colorToHexRgbString$1(l, i = "#") {
    const o = removeAlphaComponent$1(l.getComponents("rgb")).map(zerofill$1).join("");
    return `${i}${o}`
}

function colorToHexRgbaString$1(l, i = "#") {
    const o = l.getComponents("rgb"),
        c = [o[0], o[1], o[2], o[3] * 255].map(zerofill$1).join("");
    return `${i}${c}`
}

function colorToFunctionalRgbString$1(l) {
    const i = createNumberFormatter$1(0),
        o = mapColorType$1(l, "int");
    return `rgb(${removeAlphaComponent$1(o.getComponents("rgb")).map(u=>i(u)).join(", ")})`
}

function colorToFunctionalRgbaString$1(l) {
    const i = createNumberFormatter$1(2),
        o = createNumberFormatter$1(0);
    return `rgba(${mapColorType$1(l,"int").getComponents("rgb").map((p,m)=>(m===3?i:o)(p)).join(", ")})`
}

function colorToFunctionalHslString$1(l) {
    const i = [createNumberFormatter$1(0), formatPercentage$1, formatPercentage$1],
        o = mapColorType$1(l, "int");
    return `hsl(${removeAlphaComponent$1(o.getComponents("hsl")).map((u,p)=>i[p](u)).join(", ")})`
}

function colorToFunctionalHslaString$1(l) {
    const i = [createNumberFormatter$1(0), formatPercentage$1, formatPercentage$1, createNumberFormatter$1(2)];
    return `hsla(${mapColorType$1(l,"int").getComponents("hsl").map((u,p)=>i[p](u)).join(", ")})`
}

function colorToObjectRgbString$1(l, i) {
    const o = createNumberFormatter$1(i === "float" ? 2 : 0),
        c = ["r", "g", "b"],
        u = mapColorType$1(l, i);
    return `{${removeAlphaComponent$1(u.getComponents("rgb")).map((m,g)=>`${c[g]}: ${o(m)}`).join(", ")}}`
}

function createObjectRgbColorFormatter$1(l) {
    return i => colorToObjectRgbString$1(i, l)
}

function colorToObjectRgbaString$1(l, i) {
    const o = createNumberFormatter$1(2),
        c = createNumberFormatter$1(i === "float" ? 2 : 0),
        u = ["r", "g", "b", "a"];
    return `{${mapColorType$1(l,i).getComponents("rgb").map((g,_)=>{const v=_===3?o:c;return`${u[_]}: ${v(g)}`}).join(", ")}}`
}

function createObjectRgbaColorFormatter$1(l) {
    return i => colorToObjectRgbaString$1(i, l)
}
const FORMAT_AND_STRINGIFIERS$1 = [{
    format: {
        alpha: !1,
        mode: "rgb",
        notation: "hex",
        type: "int"
    },
    stringifier: colorToHexRgbString$1
}, {
    format: {
        alpha: !0,
        mode: "rgb",
        notation: "hex",
        type: "int"
    },
    stringifier: colorToHexRgbaString$1
}, {
    format: {
        alpha: !1,
        mode: "rgb",
        notation: "func",
        type: "int"
    },
    stringifier: colorToFunctionalRgbString$1
}, {
    format: {
        alpha: !0,
        mode: "rgb",
        notation: "func",
        type: "int"
    },
    stringifier: colorToFunctionalRgbaString$1
}, {
    format: {
        alpha: !1,
        mode: "hsl",
        notation: "func",
        type: "int"
    },
    stringifier: colorToFunctionalHslString$1
}, {
    format: {
        alpha: !0,
        mode: "hsl",
        notation: "func",
        type: "int"
    },
    stringifier: colorToFunctionalHslaString$1
}, ...["int", "float"].reduce((l, i) => [...l, {
    format: {
        alpha: !1,
        mode: "rgb",
        notation: "object",
        type: i
    },
    stringifier: createObjectRgbColorFormatter$1(i)
}, {
    format: {
        alpha: !0,
        mode: "rgb",
        notation: "object",
        type: i
    },
    stringifier: createObjectRgbaColorFormatter$1(i)
}], [])];

function findColorStringifier$1(l) {
    return FORMAT_AND_STRINGIFIERS$1.reduce((i, o) => i || (equalsStringColorFormat$1(o.format, l) ? o.stringifier : null), null)
}
const cn$b$1 = ClassName$1("apl");
let APaletteView$1 = class {
        constructor(i, o) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.value = o.value, this.value.emitter.on("change", this.onValueChange_), this.element = i.createElement("div"), this.element.classList.add(cn$b$1()), o.viewProps.bindClassModifiers(this.element), o.viewProps.bindTabIndex(this.element);
            const c = i.createElement("div");
            c.classList.add(cn$b$1("b")), this.element.appendChild(c);
            const u = i.createElement("div");
            u.classList.add(cn$b$1("c")), c.appendChild(u), this.colorElem_ = u;
            const p = i.createElement("div");
            p.classList.add(cn$b$1("m")), this.element.appendChild(p), this.markerElem_ = p;
            const m = i.createElement("div");
            m.classList.add(cn$b$1("p")), this.markerElem_.appendChild(m), this.previewElem_ = m, this.update_()
        }
        update_() {
            const i = this.value.rawValue,
                o = i.getComponents("rgb"),
                c = new IntColor$1([o[0], o[1], o[2], 0], "rgb"),
                u = new IntColor$1([o[0], o[1], o[2], 255], "rgb"),
                p = ["to right", colorToFunctionalRgbaString$1(c), colorToFunctionalRgbaString$1(u)];
            this.colorElem_.style.background = `linear-gradient(${p.join(",")})`, this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString$1(i);
            const m = mapRange$2(o[3], 0, 1, 0, 100);
            this.markerElem_.style.left = `${m}%`
        }
        onValueChange_() {
            this.update_()
        }
    },
    APaletteController$1 = class {
        constructor(i, o) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.view = new APaletteView$1(i, {
                value: this.value,
                viewProps: this.viewProps
            }), this.ptHandler_ = new PointerHandler$1(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
        }
        handlePointerEvent_(i, o) {
            if (!i.point) return;
            const c = i.point.x / i.bounds.width,
                u = this.value.rawValue,
                [p, m, g] = u.getComponents("hsv");
            this.value.setRawValue(new IntColor$1([p, m, g, c], "hsv"), o)
        }
        onPointerDown_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !1,
                last: !1
            })
        }
        onPointerMove_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !1,
                last: !1
            })
        }
        onPointerUp_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !0,
                last: !0
            })
        }
        onKeyDown_(i) {
            const o = getStepForKey$1(getKeyScaleForColor$1(!0), getHorizontalStepKeys$1(i));
            if (o === 0) return;
            const c = this.value.rawValue,
                [u, p, m, g] = c.getComponents("hsv");
            this.value.setRawValue(new IntColor$1([u, p, m, g + o], "hsv"), {
                forceEmit: !1,
                last: !1
            })
        }
        onKeyUp_(i) {
            getStepForKey$1(getKeyScaleForColor$1(!0), getHorizontalStepKeys$1(i)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0
            })
        }
    };
const cn$a$1 = ClassName$1("coltxt");

function createModeSelectElement$1(l) {
    const i = l.createElement("select"),
        o = [{
            text: "RGB",
            value: "rgb"
        }, {
            text: "HSL",
            value: "hsl"
        }, {
            text: "HSV",
            value: "hsv"
        }, {
            text: "HEX",
            value: "hex"
        }];
    return i.appendChild(o.reduce((c, u) => {
        const p = l.createElement("option");
        return p.textContent = u.text, p.value = u.value, c.appendChild(p), c
    }, l.createDocumentFragment())), i
}
let ColorTextsView$1 = class {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$a$1()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$a$1("m")), this.modeElem_ = createModeSelectElement$1(i), this.modeElem_.classList.add(cn$a$1("ms")), c.appendChild(this.modeSelectElement), o.viewProps.bindDisabled(this.modeElem_);
        const u = i.createElement("div");
        u.classList.add(cn$a$1("mm")), u.appendChild(createSvgIconElement$1(i, "dropdown")), c.appendChild(u), this.element.appendChild(c);
        const p = i.createElement("div");
        p.classList.add(cn$a$1("w")), this.element.appendChild(p), this.inputsElem_ = p, this.inputViews_ = o.inputViews, this.applyInputViews_(), bindValue$1(o.mode, m => {
            this.modeElem_.value = m
        })
    }
    get modeSelectElement() {
        return this.modeElem_
    }
    get inputViews() {
        return this.inputViews_
    }
    set inputViews(i) {
        this.inputViews_ = i, this.applyInputViews_()
    }
    applyInputViews_() {
        removeChildElements$1(this.inputsElem_);
        const i = this.element.ownerDocument;
        this.inputViews_.forEach(o => {
            const c = i.createElement("div");
            c.classList.add(cn$a$1("c")), c.appendChild(o.element), this.inputsElem_.appendChild(c)
        })
    }
};

function createFormatter$2$1(l) {
    return createNumberFormatter$1(l === "float" ? 2 : 0)
}

function createConstraint$5$1(l, i, o) {
    const c = getColorMaxComponents$1(l, i)[o];
    return new DefiniteRangeConstraint$1({
        min: 0,
        max: c
    })
}

function createComponentController$1(l, i, o) {
    return new NumberTextController$1(l, {
        arrayPosition: o === 0 ? "fst" : o === 2 ? "lst" : "mid",
        parser: i.parser,
        props: ValueMap$1.fromObject({
            formatter: createFormatter$2$1(i.colorType),
            keyScale: getKeyScaleForColor$1(!1),
            pointerScale: i.colorType === "float" ? .01 : 1
        }),
        value: createValue$1(0, {
            constraint: createConstraint$5$1(i.colorMode, i.colorType, o)
        }),
        viewProps: i.viewProps
    })
}

function createComponentControllers$1(l, i) {
    const o = {
        colorMode: i.colorMode,
        colorType: i.colorType,
        parser: parseNumber$1,
        viewProps: i.viewProps
    };
    return [0, 1, 2].map(c => {
        const u = createComponentController$1(l, o, c);
        return connectValues$1({
            primary: i.value,
            secondary: u.value,
            forward(p) {
                return mapColorType$1(p, i.colorType).getComponents(i.colorMode)[c]
            },
            backward(p, m) {
                const g = i.colorMode,
                    v = mapColorType$1(p, i.colorType).getComponents(g);
                v[c] = m;
                const x = createColor$1(appendAlphaComponent$1(removeAlphaComponent$1(v), v[3]), g, i.colorType);
                return mapColorType$1(x, "int")
            }
        }), u
    })
}

function createHexController$1(l, i) {
    const o = new TextController$1(l, {
        parser: createColorStringParser$1("int"),
        props: ValueMap$1.fromObject({
            formatter: colorToHexRgbString$1
        }),
        value: createValue$1(IntColor$1.black()),
        viewProps: i.viewProps
    });
    return connectValues$1({
        primary: i.value,
        secondary: o.value,
        forward: c => new IntColor$1(removeAlphaComponent$1(c.getComponents()), c.mode),
        backward: (c, u) => new IntColor$1(appendAlphaComponent$1(removeAlphaComponent$1(u.getComponents(c.mode)), c.getComponents()[3]), c.mode)
    }), [o]
}

function isColorMode$1(l) {
    return l !== "hex"
}
let ColorTextsController$1 = class {
    constructor(i, o) {
        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = o.colorType, this.value = o.value, this.viewProps = o.viewProps, this.colorMode = createValue$1(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(i), this.view = new ColorTextsView$1(i, {
            mode: this.colorMode,
            inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
            viewProps: this.viewProps
        }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_)
    }
    createComponentControllers_(i) {
        const o = this.colorMode.rawValue;
        return isColorMode$1(o) ? createComponentControllers$1(i, {
            colorMode: o,
            colorType: this.colorType_,
            value: this.value,
            viewProps: this.viewProps
        }) : createHexController$1(i, {
            value: this.value,
            viewProps: this.viewProps
        })
    }
    onModeSelectChange_(i) {
        const o = i.currentTarget;
        this.colorMode.rawValue = o.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.inputViews = this.ccs_.map(c => c.view)
    }
};
const cn$9$1 = ClassName$1("hpl");
let HPaletteView$1 = class {
        constructor(i, o) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.value = o.value, this.value.emitter.on("change", this.onValueChange_), this.element = i.createElement("div"), this.element.classList.add(cn$9$1()), o.viewProps.bindClassModifiers(this.element), o.viewProps.bindTabIndex(this.element);
            const c = i.createElement("div");
            c.classList.add(cn$9$1("c")), this.element.appendChild(c);
            const u = i.createElement("div");
            u.classList.add(cn$9$1("m")), this.element.appendChild(u), this.markerElem_ = u, this.update_()
        }
        update_() {
            const i = this.value.rawValue,
                [o] = i.getComponents("hsv");
            this.markerElem_.style.backgroundColor = colorToFunctionalRgbString$1(new IntColor$1([o, 100, 100], "hsv"));
            const c = mapRange$2(o, 0, 360, 0, 100);
            this.markerElem_.style.left = `${c}%`
        }
        onValueChange_() {
            this.update_()
        }
    },
    HPaletteController$1 = class {
        constructor(i, o) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.view = new HPaletteView$1(i, {
                value: this.value,
                viewProps: this.viewProps
            }), this.ptHandler_ = new PointerHandler$1(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
        }
        handlePointerEvent_(i, o) {
            if (!i.point) return;
            const c = mapRange$2(constrainRange$1(i.point.x, 0, i.bounds.width), 0, i.bounds.width, 0, 360),
                u = this.value.rawValue,
                [, p, m, g] = u.getComponents("hsv");
            this.value.setRawValue(new IntColor$1([c, p, m, g], "hsv"), o)
        }
        onPointerDown_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !1,
                last: !1
            })
        }
        onPointerMove_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !1,
                last: !1
            })
        }
        onPointerUp_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !0,
                last: !0
            })
        }
        onKeyDown_(i) {
            const o = getStepForKey$1(getKeyScaleForColor$1(!1), getHorizontalStepKeys$1(i));
            if (o === 0) return;
            const c = this.value.rawValue,
                [u, p, m, g] = c.getComponents("hsv");
            this.value.setRawValue(new IntColor$1([u + o, p, m, g], "hsv"), {
                forceEmit: !1,
                last: !1
            })
        }
        onKeyUp_(i) {
            getStepForKey$1(getKeyScaleForColor$1(!1), getHorizontalStepKeys$1(i)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0
            })
        }
    };
const cn$8$1 = ClassName$1("svp"),
    CANVAS_RESOL$1 = 64;
let SvPaletteView$1 = class {
        constructor(i, o) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.value = o.value, this.value.emitter.on("change", this.onValueChange_), this.element = i.createElement("div"), this.element.classList.add(cn$8$1()), o.viewProps.bindClassModifiers(this.element), o.viewProps.bindTabIndex(this.element);
            const c = i.createElement("canvas");
            c.height = CANVAS_RESOL$1, c.width = CANVAS_RESOL$1, c.classList.add(cn$8$1("c")), this.element.appendChild(c), this.canvasElement = c;
            const u = i.createElement("div");
            u.classList.add(cn$8$1("m")), this.element.appendChild(u), this.markerElem_ = u, this.update_()
        }
        update_() {
            const i = getCanvasContext$1(this.canvasElement);
            if (!i) return;
            const c = this.value.rawValue.getComponents("hsv"),
                u = this.canvasElement.width,
                p = this.canvasElement.height,
                m = i.getImageData(0, 0, u, p),
                g = m.data;
            for (let x = 0; x < p; x++)
                for (let y = 0; y < u; y++) {
                    const b = mapRange$2(y, 0, u, 0, 100),
                        S = mapRange$2(x, 0, p, 100, 0),
                        C = hsvToRgbInt$1(c[0], b, S),
                        E = (x * u + y) * 4;
                    g[E] = C[0], g[E + 1] = C[1], g[E + 2] = C[2], g[E + 3] = 255
                }
            i.putImageData(m, 0, 0);
            const _ = mapRange$2(c[1], 0, 100, 0, 100);
            this.markerElem_.style.left = `${_}%`;
            const v = mapRange$2(c[2], 0, 100, 100, 0);
            this.markerElem_.style.top = `${v}%`
        }
        onValueChange_() {
            this.update_()
        }
    },
    SvPaletteController$1 = class {
        constructor(i, o) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.view = new SvPaletteView$1(i, {
                value: this.value,
                viewProps: this.viewProps
            }), this.ptHandler_ = new PointerHandler$1(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
        }
        handlePointerEvent_(i, o) {
            if (!i.point) return;
            const c = mapRange$2(i.point.x, 0, i.bounds.width, 0, 100),
                u = mapRange$2(i.point.y, 0, i.bounds.height, 100, 0),
                [p, , , m] = this.value.rawValue.getComponents("hsv");
            this.value.setRawValue(new IntColor$1([p, c, u, m], "hsv"), o)
        }
        onPointerDown_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !1,
                last: !1
            })
        }
        onPointerMove_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !1,
                last: !1
            })
        }
        onPointerUp_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !0,
                last: !0
            })
        }
        onKeyDown_(i) {
            isArrowKey$1(i.key) && i.preventDefault();
            const [o, c, u, p] = this.value.rawValue.getComponents("hsv"), m = getKeyScaleForColor$1(!1), g = getStepForKey$1(m, getHorizontalStepKeys$1(i)), _ = getStepForKey$1(m, getVerticalStepKeys$1(i));
            g === 0 && _ === 0 || this.value.setRawValue(new IntColor$1([o, c + g, u + _, p], "hsv"), {
                forceEmit: !1,
                last: !1
            })
        }
        onKeyUp_(i) {
            const o = getKeyScaleForColor$1(!1),
                c = getStepForKey$1(o, getHorizontalStepKeys$1(i)),
                u = getStepForKey$1(o, getVerticalStepKeys$1(i));
            c === 0 && u === 0 || this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0
            })
        }
    },
    ColorPickerController$1 = class {
        constructor(i, o) {
            this.value = o.value, this.viewProps = o.viewProps, this.hPaletteC_ = new HPaletteController$1(i, {
                value: this.value,
                viewProps: this.viewProps
            }), this.svPaletteC_ = new SvPaletteController$1(i, {
                value: this.value,
                viewProps: this.viewProps
            }), this.alphaIcs_ = o.supportsAlpha ? {
                palette: new APaletteController$1(i, {
                    value: this.value,
                    viewProps: this.viewProps
                }),
                text: new NumberTextController$1(i, {
                    parser: parseNumber$1,
                    props: ValueMap$1.fromObject({
                        pointerScale: .01,
                        keyScale: .1,
                        formatter: createNumberFormatter$1(2)
                    }),
                    value: createValue$1(0, {
                        constraint: new DefiniteRangeConstraint$1({
                            min: 0,
                            max: 1
                        })
                    }),
                    viewProps: this.viewProps
                })
            } : null, this.alphaIcs_ && connectValues$1({
                primary: this.value,
                secondary: this.alphaIcs_.text.value,
                forward: c => c.getComponents()[3],
                backward: (c, u) => {
                    const p = c.getComponents();
                    return p[3] = u, new IntColor$1(p, c.mode)
                }
            }), this.textsC_ = new ColorTextsController$1(i, {
                colorType: o.colorType,
                value: this.value,
                viewProps: this.viewProps
            }), this.view = new ColorPickerView$1(i, {
                alphaViews: this.alphaIcs_ ? {
                    palette: this.alphaIcs_.palette.view,
                    text: this.alphaIcs_.text.view
                } : null,
                hPaletteView: this.hPaletteC_.view,
                supportsAlpha: o.supportsAlpha,
                svPaletteView: this.svPaletteC_.view,
                textsView: this.textsC_.view,
                viewProps: this.viewProps
            })
        }
        get textsController() {
            return this.textsC_
        }
    };
const cn$7$1 = ClassName$1("colsw");
let ColorSwatchView$1 = class {
        constructor(i, o) {
            this.onValueChange_ = this.onValueChange_.bind(this), o.value.emitter.on("change", this.onValueChange_), this.value = o.value, this.element = i.createElement("div"), this.element.classList.add(cn$7$1()), o.viewProps.bindClassModifiers(this.element);
            const c = i.createElement("div");
            c.classList.add(cn$7$1("sw")), this.element.appendChild(c), this.swatchElem_ = c;
            const u = i.createElement("button");
            u.classList.add(cn$7$1("b")), o.viewProps.bindDisabled(u), this.element.appendChild(u), this.buttonElement = u, this.update_()
        }
        update_() {
            const i = this.value.rawValue;
            this.swatchElem_.style.backgroundColor = colorToHexRgbaString$1(i)
        }
        onValueChange_() {
            this.update_()
        }
    },
    ColorSwatchController$1 = class {
        constructor(i, o) {
            this.value = o.value, this.viewProps = o.viewProps, this.view = new ColorSwatchView$1(i, {
                value: this.value,
                viewProps: this.viewProps
            })
        }
    },
    ColorController$1 = class {
        constructor(i, o) {
            this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.foldable_ = Foldable$1.create(o.expanded), this.swatchC_ = new ColorSwatchController$1(i, {
                value: this.value,
                viewProps: this.viewProps
            });
            const c = this.swatchC_.view.buttonElement;
            c.addEventListener("blur", this.onButtonBlur_), c.addEventListener("click", this.onButtonClick_), this.textC_ = new TextController$1(i, {
                parser: o.parser,
                props: ValueMap$1.fromObject({
                    formatter: o.formatter
                }),
                value: this.value,
                viewProps: this.viewProps
            }), this.view = new ColorView$1(i, {
                foldable: this.foldable_,
                pickerLayout: o.pickerLayout
            }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = o.pickerLayout === "popup" ? new PopupController$1(i, {
                viewProps: this.viewProps
            }) : null;
            const u = new ColorPickerController$1(i, {
                colorType: o.colorType,
                supportsAlpha: o.supportsAlpha,
                value: this.value,
                viewProps: this.viewProps
            });
            u.view.allFocusableElements.forEach(p => {
                p.addEventListener("blur", this.onPopupChildBlur_), p.addEventListener("keydown", this.onPopupChildKeydown_)
            }), this.pickerC_ = u, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(u.view.element), connectValues$1({
                primary: this.foldable_.value("expanded"),
                secondary: this.popC_.shows,
                forward: p => p,
                backward: (p, m) => m
            })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), bindFoldable$1(this.foldable_, this.view.pickerElement))
        }
        get textController() {
            return this.textC_
        }
        onButtonBlur_(i) {
            if (!this.popC_) return;
            const o = this.view.element,
                c = i.relatedTarget;
            (!c || !o.contains(c)) && (this.popC_.shows.rawValue = !1)
        }
        onButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
        }
        onPopupChildBlur_(i) {
            if (!this.popC_) return;
            const o = this.popC_.view.element,
                c = findNextTarget$1(i);
            c && o.contains(c) || c && c === this.swatchC_.view.buttonElement && !supportsTouch$1(o.ownerDocument) || (this.popC_.shows.rawValue = !1)
        }
        onPopupChildKeydown_(i) {
            this.popC_ ? i.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && i.key === "Escape" && this.swatchC_.view.buttonElement.focus()
        }
    };

function colorToRgbNumber$1(l) {
    return removeAlphaComponent$1(l.getComponents("rgb")).reduce((i, o) => i << 8 | Math.floor(o) & 255, 0)
}

function colorToRgbaNumber$1(l) {
    return l.getComponents("rgb").reduce((i, o, c) => {
        const u = Math.floor(c === 3 ? o * 255 : o) & 255;
        return i << 8 | u
    }, 0) >>> 0
}

function numberToRgbColor$1(l) {
    return new IntColor$1([l >> 16 & 255, l >> 8 & 255, l & 255], "rgb")
}

function numberToRgbaColor$1(l) {
    return new IntColor$1([l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, mapRange$2(l & 255, 0, 255, 0, 1)], "rgb")
}

function colorFromRgbNumber$1(l) {
    return typeof l != "number" ? IntColor$1.black() : numberToRgbColor$1(l)
}

function colorFromRgbaNumber$1(l) {
    return typeof l != "number" ? IntColor$1.black() : numberToRgbaColor$1(l)
}

function isRgbColorComponent$1(l, i) {
    return typeof l != "object" || isEmpty$1(l) ? !1 : i in l && typeof l[i] == "number"
}

function isRgbColorObject$1(l) {
    return isRgbColorComponent$1(l, "r") && isRgbColorComponent$1(l, "g") && isRgbColorComponent$1(l, "b")
}

function isRgbaColorObject$1(l) {
    return isRgbColorObject$1(l) && isRgbColorComponent$1(l, "a")
}

function isColorObject$1(l) {
    return isRgbColorObject$1(l)
}

function equalsColor$1(l, i) {
    if (l.mode !== i.mode || l.type !== i.type) return !1;
    const o = l.getComponents(),
        c = i.getComponents();
    for (let u = 0; u < o.length; u++)
        if (o[u] !== c[u]) return !1;
    return !0
}

function createColorComponentsFromRgbObject$1(l) {
    return "a" in l ? [l.r, l.g, l.b, l.a] : [l.r, l.g, l.b]
}

function createColorStringWriter$1(l) {
    const i = findColorStringifier$1(l);
    return i ? (o, c) => {
        writePrimitive$1(o, i(c))
    } : null
}

function createColorNumberWriter$1(l) {
    const i = l ? colorToRgbaNumber$1 : colorToRgbNumber$1;
    return (o, c) => {
        writePrimitive$1(o, i(c))
    }
}

function writeRgbaColorObject$1(l, i, o) {
    const u = mapColorType$1(i, o).toRgbaObject();
    l.writeProperty("r", u.r), l.writeProperty("g", u.g), l.writeProperty("b", u.b), l.writeProperty("a", u.a)
}

function writeRgbColorObject$1(l, i, o) {
    const u = mapColorType$1(i, o).toRgbaObject();
    l.writeProperty("r", u.r), l.writeProperty("g", u.g), l.writeProperty("b", u.b)
}

function createColorObjectWriter$1(l, i) {
    return (o, c) => {
        l ? writeRgbaColorObject$1(o, c, i) : writeRgbColorObject$1(o, c, i)
    }
}

function shouldSupportAlpha$1$1(l) {
    var i;
    return !!(!((i = l ? .color) === null || i === void 0) && i.alpha)
}

function createFormatter$1$1(l) {
    return l ? i => colorToHexRgbaString$1(i, "0x") : i => colorToHexRgbString$1(i, "0x")
}

function isForColor$1(l) {
    return "color" in l || l.view === "color"
}
const NumberColorInputPlugin = createPlugin$1({
    id: "input-color-number",
    type: "input",
    accept: (l, i) => {
        if (typeof l != "number" || !isForColor$1(i)) return null;
        const o = parseColorInputParams$1(i);
        return o ? {
            initialValue: l,
            params: Object.assign(Object.assign({}, o), {
                supportsAlpha: shouldSupportAlpha$1$1(i)
            })
        } : null
    },
    binding: {
        reader: l => l.params.supportsAlpha ? colorFromRgbaNumber$1 : colorFromRgbNumber$1,
        equals: equalsColor$1,
        writer: l => createColorNumberWriter$1(l.params.supportsAlpha)
    },
    controller: l => {
        var i, o;
        return new ColorController$1(l.document, {
            colorType: "int",
            expanded: (i = l.params.expanded) !== null && i !== void 0 ? i : !1,
            formatter: createFormatter$1$1(l.params.supportsAlpha),
            parser: createColorStringParser$1("int"),
            pickerLayout: (o = l.params.picker) !== null && o !== void 0 ? o : "popup",
            supportsAlpha: l.params.supportsAlpha,
            value: l.value,
            viewProps: l.viewProps
        })
    }
});

function colorFromObject$1(l, i) {
    if (!isColorObject$1(l)) return mapColorType$1(IntColor$1.black(), i);
    if (i === "int") {
        const o = createColorComponentsFromRgbObject$1(l);
        return new IntColor$1(o, "rgb")
    }
    if (i === "float") {
        const o = createColorComponentsFromRgbObject$1(l);
        return new FloatColor$1(o, "rgb")
    }
    return mapColorType$1(IntColor$1.black(), "int")
}

function shouldSupportAlpha$2(l) {
    return isRgbaColorObject$1(l)
}

function createColorObjectBindingReader$1(l) {
    return i => {
        const o = colorFromObject$1(i, l);
        return mapColorType$1(o, "int")
    }
}

function createColorObjectFormatter$1(l, i) {
    return o => l ? colorToObjectRgbaString$1(o, i) : colorToObjectRgbString$1(o, i)
}
const ObjectColorInputPlugin = createPlugin$1({
        id: "input-color-object",
        type: "input",
        accept: (l, i) => {
            var o;
            if (!isColorObject$1(l)) return null;
            const c = parseColorInputParams$1(i);
            return c ? {
                initialValue: l,
                params: Object.assign(Object.assign({}, c), {
                    colorType: (o = extractColorType$1(i)) !== null && o !== void 0 ? o : "int"
                })
            } : null
        },
        binding: {
            reader: l => createColorObjectBindingReader$1(l.params.colorType),
            equals: equalsColor$1,
            writer: l => createColorObjectWriter$1(shouldSupportAlpha$2(l.initialValue), l.params.colorType)
        },
        controller: l => {
            var i, o;
            const c = isRgbaColorObject$1(l.initialValue);
            return new ColorController$1(l.document, {
                colorType: l.params.colorType,
                expanded: (i = l.params.expanded) !== null && i !== void 0 ? i : !1,
                formatter: createColorObjectFormatter$1(c, l.params.colorType),
                parser: createColorStringParser$1("int"),
                pickerLayout: (o = l.params.picker) !== null && o !== void 0 ? o : "popup",
                supportsAlpha: c,
                value: l.value,
                viewProps: l.viewProps
            })
        }
    }),
    StringColorInputPlugin = createPlugin$1({
        id: "input-color-string",
        type: "input",
        accept: (l, i) => {
            if (typeof l != "string" || i.view === "text") return null;
            const o = detectStringColorFormat$1(l, extractColorType$1(i));
            if (!o) return null;
            const c = findColorStringifier$1(o);
            if (!c) return null;
            const u = parseColorInputParams$1(i);
            return u ? {
                initialValue: l,
                params: Object.assign(Object.assign({}, u), {
                    format: o,
                    stringifier: c
                })
            } : null
        },
        binding: {
            reader: () => readIntColorString$1,
            equals: equalsColor$1,
            writer: l => {
                const i = createColorStringWriter$1(l.params.format);
                if (!i) throw TpError$1.notBindable();
                return i
            }
        },
        controller: l => {
            var i, o;
            return new ColorController$1(l.document, {
                colorType: l.params.format.type,
                expanded: (i = l.params.expanded) !== null && i !== void 0 ? i : !1,
                formatter: l.params.stringifier,
                parser: createColorStringParser$1("int"),
                pickerLayout: (o = l.params.picker) !== null && o !== void 0 ? o : "popup",
                supportsAlpha: l.params.format.alpha,
                value: l.value,
                viewProps: l.viewProps
            })
        }
    });
let PointNdConstraint$1 = class {
    constructor(i) {
        this.components = i.components, this.asm_ = i.assembly
    }
    constrain(i) {
        const o = this.asm_.toComponents(i).map((c, u) => {
            var p, m;
            return (m = (p = this.components[u]) === null || p === void 0 ? void 0 : p.constrain(c)) !== null && m !== void 0 ? m : c
        });
        return this.asm_.fromComponents(o)
    }
};
const cn$6$1 = ClassName$1("pndtxt");
let PointNdTextView$1 = class {
    constructor(i, o) {
        this.textViews = o.textViews, this.element = i.createElement("div"), this.element.classList.add(cn$6$1()), this.textViews.forEach(c => {
            const u = i.createElement("div");
            u.classList.add(cn$6$1("a")), u.appendChild(c.element), this.element.appendChild(u)
        })
    }
};

function createAxisController$1(l, i, o) {
    return new NumberTextController$1(l, {
        arrayPosition: o === 0 ? "fst" : o === i.axes.length - 1 ? "lst" : "mid",
        parser: i.parser,
        props: i.axes[o].textProps,
        value: createValue$1(0, {
            constraint: i.axes[o].constraint
        }),
        viewProps: i.viewProps
    })
}
let PointNdTextController$1 = class {
        constructor(i, o) {
            this.value = o.value, this.viewProps = o.viewProps, this.acs_ = o.axes.map((c, u) => createAxisController$1(i, o, u)), this.acs_.forEach((c, u) => {
                connectValues$1({
                    primary: this.value,
                    secondary: c.value,
                    forward: p => o.assembly.toComponents(p)[u],
                    backward: (p, m) => {
                        const g = o.assembly.toComponents(p);
                        return g[u] = m, o.assembly.fromComponents(g)
                    }
                })
            }), this.view = new PointNdTextView$1(i, {
                textViews: this.acs_.map(c => c.view)
            })
        }
        get textControllers() {
            return this.acs_
        }
    },
    SliderInputBindingApi$1 = class extends BindingApi$1 {
        get max() {
            return this.controller.valueController.sliderController.props.get("max")
        }
        set max(i) {
            this.controller.valueController.sliderController.props.set("max", i)
        }
        get min() {
            return this.controller.valueController.sliderController.props.get("min")
        }
        set min(i) {
            this.controller.valueController.sliderController.props.set("min", i)
        }
    };

function createConstraint$4$1(l, i) {
    const o = [],
        c = createStepConstraint$1(l, i);
    c && o.push(c);
    const u = createRangeConstraint$1(l);
    u && o.push(u);
    const p = createListConstraint$1(l.options);
    return p && o.push(p), new CompositeConstraint$1(o)
}
const NumberInputPlugin = createPlugin$1({
    id: "input-number",
    type: "input",
    accept: (l, i) => {
        if (typeof l != "number") return null;
        const o = parseRecord$1(i, c => Object.assign(Object.assign({}, createNumberTextInputParamsParser$1(c)), {
            options: c.optional.custom(parseListOptions$1),
            readonly: c.optional.constant(!1)
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => numberFromUnknown$1,
        constraint: l => createConstraint$4$1(l.params, l.initialValue),
        writer: l => writePrimitive$1
    },
    controller: l => {
        const i = l.value,
            o = l.constraint,
            c = o && findConstraint$1(o, ListConstraint$1);
        if (c) return new ListController$1(l.document, {
            props: new ValueMap$1({
                options: c.values.value("options")
            }),
            value: i,
            viewProps: l.viewProps
        });
        const u = createNumberTextPropsObject$1(l.params, i.rawValue),
            p = o && findConstraint$1(o, DefiniteRangeConstraint$1);
        return p ? new SliderTextController$1(l.document, Object.assign(Object.assign({}, createSliderTextProps$1(Object.assign(Object.assign({}, u), {
            keyScale: createValue$1(u.keyScale),
            max: p.values.value("max"),
            min: p.values.value("min")
        }))), {
            parser: parseNumber$1,
            value: i,
            viewProps: l.viewProps
        })) : new NumberTextController$1(l.document, {
            parser: parseNumber$1,
            props: ValueMap$1.fromObject(u),
            value: i,
            viewProps: l.viewProps
        })
    },
    api(l) {
        return typeof l.controller.value.rawValue != "number" ? null : l.controller.valueController instanceof SliderTextController$1 ? new SliderInputBindingApi$1(l.controller) : l.controller.valueController instanceof ListController$1 ? new ListInputBindingApi$1(l.controller) : null
    }
});
let Point2d$1 = class {
    constructor(i = 0, o = 0) {
        this.x = i, this.y = o
    }
    getComponents() {
        return [this.x, this.y]
    }
    static isObject(i) {
        if (isEmpty$1(i)) return !1;
        const o = i.x,
            c = i.y;
        return !(typeof o != "number" || typeof c != "number")
    }
    static equals(i, o) {
        return i.x === o.x && i.y === o.y
    }
    toObject() {
        return {
            x: this.x,
            y: this.y
        }
    }
};
const Point2dAssembly$1 = {
        toComponents: l => l.getComponents(),
        fromComponents: l => new Point2d$1(...l)
    },
    cn$5$1 = ClassName$1("p2d");
let Point2dView$1 = class {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$5$1()), o.viewProps.bindClassModifiers(this.element), bindValue$1(o.expanded, valueToClassName$1(this.element, cn$5$1(void 0, "expanded")));
        const c = i.createElement("div");
        c.classList.add(cn$5$1("h")), this.element.appendChild(c);
        const u = i.createElement("button");
        u.classList.add(cn$5$1("b")), u.appendChild(createSvgIconElement$1(i, "p2dpad")), o.viewProps.bindDisabled(u), c.appendChild(u), this.buttonElement = u;
        const p = i.createElement("div");
        if (p.classList.add(cn$5$1("t")), c.appendChild(p), this.textElement = p, o.pickerLayout === "inline") {
            const m = i.createElement("div");
            m.classList.add(cn$5$1("p")), this.element.appendChild(m), this.pickerElement = m
        } else this.pickerElement = null
    }
};
const cn$4$1 = ClassName$1("p2dp");
let Point2dPickerView$1 = class {
    constructor(i, o) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onPropsChange_ = this.onPropsChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = o.props, this.props_.emitter.on("change", this.onPropsChange_), this.element = i.createElement("div"), this.element.classList.add(cn$4$1()), o.layout === "popup" && this.element.classList.add(cn$4$1(void 0, "p")), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$4$1("p")), o.viewProps.bindTabIndex(c), this.element.appendChild(c), this.padElement = c;
        const u = i.createElementNS(SVG_NS$1, "svg");
        u.classList.add(cn$4$1("g")), this.padElement.appendChild(u), this.svgElem_ = u;
        const p = i.createElementNS(SVG_NS$1, "line");
        p.classList.add(cn$4$1("ax")), p.setAttributeNS(null, "x1", "0"), p.setAttributeNS(null, "y1", "50%"), p.setAttributeNS(null, "x2", "100%"), p.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(p);
        const m = i.createElementNS(SVG_NS$1, "line");
        m.classList.add(cn$4$1("ax")), m.setAttributeNS(null, "x1", "50%"), m.setAttributeNS(null, "y1", "0"), m.setAttributeNS(null, "x2", "50%"), m.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(m);
        const g = i.createElementNS(SVG_NS$1, "line");
        g.classList.add(cn$4$1("l")), g.setAttributeNS(null, "x1", "50%"), g.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(g), this.lineElem_ = g;
        const _ = i.createElement("div");
        _.classList.add(cn$4$1("m")), this.padElement.appendChild(_), this.markerElem_ = _, o.value.emitter.on("change", this.onValueChange_), this.value = o.value, this.update_()
    }
    get allFocusableElements() {
        return [this.padElement]
    }
    update_() {
        const [i, o] = this.value.rawValue.getComponents(), c = this.props_.get("max"), u = mapRange$2(i, -c, +c, 0, 100), p = mapRange$2(o, -c, +c, 0, 100), m = this.props_.get("invertsY") ? 100 - p : p;
        this.lineElem_.setAttributeNS(null, "x2", `${u}%`), this.lineElem_.setAttributeNS(null, "y2", `${m}%`), this.markerElem_.style.left = `${u}%`, this.markerElem_.style.top = `${m}%`
    }
    onValueChange_() {
        this.update_()
    }
    onPropsChange_() {
        this.update_()
    }
    onFoldableChange_() {
        this.update_()
    }
};

function computeOffset$2(l, i, o) {
    return [getStepForKey$1(i[0], getHorizontalStepKeys$1(l)), getStepForKey$1(i[1], getVerticalStepKeys$1(l)) * (o ? 1 : -1)]
}
let Point2dPickerController$1 = class {
        constructor(i, o) {
            this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.props = o.props, this.value = o.value, this.viewProps = o.viewProps, this.view = new Point2dPickerView$1(i, {
                layout: o.layout,
                props: this.props,
                value: this.value,
                viewProps: this.viewProps
            }), this.ptHandler_ = new PointerHandler$1(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_)
        }
        handlePointerEvent_(i, o) {
            if (!i.point) return;
            const c = this.props.get("max"),
                u = mapRange$2(i.point.x, 0, i.bounds.width, -c, +c),
                p = mapRange$2(this.props.get("invertsY") ? i.bounds.height - i.point.y : i.point.y, 0, i.bounds.height, -c, +c);
            this.value.setRawValue(new Point2d$1(u, p), o)
        }
        onPointerDown_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !1,
                last: !1
            })
        }
        onPointerMove_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !1,
                last: !1
            })
        }
        onPointerUp_(i) {
            this.handlePointerEvent_(i.data, {
                forceEmit: !0,
                last: !0
            })
        }
        onPadKeyDown_(i) {
            isArrowKey$1(i.key) && i.preventDefault();
            const [o, c] = computeOffset$2(i, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
            o === 0 && c === 0 || this.value.setRawValue(new Point2d$1(this.value.rawValue.x + o, this.value.rawValue.y + c), {
                forceEmit: !1,
                last: !1
            })
        }
        onPadKeyUp_(i) {
            const [o, c] = computeOffset$2(i, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
            o === 0 && c === 0 || this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0
            })
        }
    },
    Point2dController$1 = class {
        constructor(i, o) {
            var c, u;
            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.foldable_ = Foldable$1.create(o.expanded), this.popC_ = o.pickerLayout === "popup" ? new PopupController$1(i, {
                viewProps: this.viewProps
            }) : null;
            const p = new Point2dPickerController$1(i, {
                layout: o.pickerLayout,
                props: new ValueMap$1({
                    invertsY: createValue$1(o.invertsY),
                    max: createValue$1(o.max),
                    xKeyScale: o.axes[0].textProps.value("keyScale"),
                    yKeyScale: o.axes[1].textProps.value("keyScale")
                }),
                value: this.value,
                viewProps: this.viewProps
            });
            p.view.allFocusableElements.forEach(m => {
                m.addEventListener("blur", this.onPopupChildBlur_), m.addEventListener("keydown", this.onPopupChildKeydown_)
            }), this.pickerC_ = p, this.textC_ = new PointNdTextController$1(i, {
                assembly: Point2dAssembly$1,
                axes: o.axes,
                parser: o.parser,
                value: this.value,
                viewProps: this.viewProps
            }), this.view = new Point2dView$1(i, {
                expanded: this.foldable_.value("expanded"),
                pickerLayout: o.pickerLayout,
                viewProps: this.viewProps
            }), this.view.textElement.appendChild(this.textC_.view.element), (c = this.view.buttonElement) === null || c === void 0 || c.addEventListener("blur", this.onPadButtonBlur_), (u = this.view.buttonElement) === null || u === void 0 || u.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), connectValues$1({
                primary: this.foldable_.value("expanded"),
                secondary: this.popC_.shows,
                forward: m => m,
                backward: (m, g) => g
            })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), bindFoldable$1(this.foldable_, this.view.pickerElement))
        }
        get textController() {
            return this.textC_
        }
        onPadButtonBlur_(i) {
            if (!this.popC_) return;
            const o = this.view.element,
                c = i.relatedTarget;
            (!c || !o.contains(c)) && (this.popC_.shows.rawValue = !1)
        }
        onPadButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
        }
        onPopupChildBlur_(i) {
            if (!this.popC_) return;
            const o = this.popC_.view.element,
                c = findNextTarget$1(i);
            c && o.contains(c) || c && c === this.view.buttonElement && !supportsTouch$1(o.ownerDocument) || (this.popC_.shows.rawValue = !1)
        }
        onPopupChildKeydown_(i) {
            this.popC_ ? i.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && i.key === "Escape" && this.view.buttonElement.focus()
        }
    };

function point2dFromUnknown$1(l) {
    return Point2d$1.isObject(l) ? new Point2d$1(l.x, l.y) : new Point2d$1
}

function writePoint2d$1(l, i) {
    l.writeProperty("x", i.x), l.writeProperty("y", i.y)
}

function createConstraint$3$1(l, i) {
    return new PointNdConstraint$1({
        assembly: Point2dAssembly$1,
        components: [createDimensionConstraint$2(Object.assign(Object.assign({}, l), l.x), i.x), createDimensionConstraint$2(Object.assign(Object.assign({}, l), l.y), i.y)]
    })
}

function getSuitableMaxDimensionValue$1(l, i) {
    var o, c;
    if (!isEmpty$1(l.min) || !isEmpty$1(l.max)) return Math.max(Math.abs((o = l.min) !== null && o !== void 0 ? o : 0), Math.abs((c = l.max) !== null && c !== void 0 ? c : 0));
    const u = getSuitableKeyScale$1(l);
    return Math.max(Math.abs(u) * 10, Math.abs(i) * 10)
}

function getSuitableMax$1(l, i) {
    var o, c;
    const u = getSuitableMaxDimensionValue$1(deepMerge$1(l, (o = l.x) !== null && o !== void 0 ? o : {}), i.x),
        p = getSuitableMaxDimensionValue$1(deepMerge$1(l, (c = l.y) !== null && c !== void 0 ? c : {}), i.y);
    return Math.max(u, p)
}

function shouldInvertY$1(l) {
    if (!("y" in l)) return !1;
    const i = l.y;
    return i && "inverted" in i ? !!i.inverted : !1
}
const Point2dInputPlugin = createPlugin$1({
    id: "input-point2d",
    type: "input",
    accept: (l, i) => {
        if (!Point2d$1.isObject(l)) return null;
        const o = parseRecord$1(i, c => Object.assign(Object.assign({}, createPointDimensionParser$1(c)), {
            expanded: c.optional.boolean,
            picker: c.optional.custom(parsePickerLayout$1),
            readonly: c.optional.constant(!1),
            x: c.optional.custom(parsePointDimensionParams$1),
            y: c.optional.object(Object.assign(Object.assign({}, createPointDimensionParser$1(c)), {
                inverted: c.optional.boolean
            }))
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: () => point2dFromUnknown$1,
        constraint: l => createConstraint$3$1(l.params, l.initialValue),
        equals: Point2d$1.equals,
        writer: () => writePoint2d$1
    },
    controller: l => {
        var i, o;
        const c = l.document,
            u = l.value,
            p = l.constraint,
            m = [l.params.x, l.params.y];
        return new Point2dController$1(c, {
            axes: u.rawValue.getComponents().map((g, _) => {
                var v;
                return createPointAxis$1({
                    constraint: p.components[_],
                    initialValue: g,
                    params: deepMerge$1(l.params, (v = m[_]) !== null && v !== void 0 ? v : {})
                })
            }),
            expanded: (i = l.params.expanded) !== null && i !== void 0 ? i : !1,
            invertsY: shouldInvertY$1(l.params),
            max: getSuitableMax$1(l.params, u.rawValue),
            parser: parseNumber$1,
            pickerLayout: (o = l.params.picker) !== null && o !== void 0 ? o : "popup",
            value: u,
            viewProps: l.viewProps
        })
    }
});
let Point3d$1 = class {
    constructor(i = 0, o = 0, c = 0) {
        this.x = i, this.y = o, this.z = c
    }
    getComponents() {
        return [this.x, this.y, this.z]
    }
    static isObject(i) {
        if (isEmpty$1(i)) return !1;
        const o = i.x,
            c = i.y,
            u = i.z;
        return !(typeof o != "number" || typeof c != "number" || typeof u != "number")
    }
    static equals(i, o) {
        return i.x === o.x && i.y === o.y && i.z === o.z
    }
    toObject() {
        return {
            x: this.x,
            y: this.y,
            z: this.z
        }
    }
};
const Point3dAssembly$1 = {
    toComponents: l => l.getComponents(),
    fromComponents: l => new Point3d$1(...l)
};

function point3dFromUnknown$1(l) {
    return Point3d$1.isObject(l) ? new Point3d$1(l.x, l.y, l.z) : new Point3d$1
}

function writePoint3d$1(l, i) {
    l.writeProperty("x", i.x), l.writeProperty("y", i.y), l.writeProperty("z", i.z)
}

function createConstraint$2$1(l, i) {
    return new PointNdConstraint$1({
        assembly: Point3dAssembly$1,
        components: [createDimensionConstraint$2(Object.assign(Object.assign({}, l), l.x), i.x), createDimensionConstraint$2(Object.assign(Object.assign({}, l), l.y), i.y), createDimensionConstraint$2(Object.assign(Object.assign({}, l), l.z), i.z)]
    })
}
const Point3dInputPlugin = createPlugin$1({
    id: "input-point3d",
    type: "input",
    accept: (l, i) => {
        if (!Point3d$1.isObject(l)) return null;
        const o = parseRecord$1(i, c => Object.assign(Object.assign({}, createPointDimensionParser$1(c)), {
            readonly: c.optional.constant(!1),
            x: c.optional.custom(parsePointDimensionParams$1),
            y: c.optional.custom(parsePointDimensionParams$1),
            z: c.optional.custom(parsePointDimensionParams$1)
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => point3dFromUnknown$1,
        constraint: l => createConstraint$2$1(l.params, l.initialValue),
        equals: Point3d$1.equals,
        writer: l => writePoint3d$1
    },
    controller: l => {
        const i = l.value,
            o = l.constraint,
            c = [l.params.x, l.params.y, l.params.z];
        return new PointNdTextController$1(l.document, {
            assembly: Point3dAssembly$1,
            axes: i.rawValue.getComponents().map((u, p) => {
                var m;
                return createPointAxis$1({
                    constraint: o.components[p],
                    initialValue: u,
                    params: deepMerge$1(l.params, (m = c[p]) !== null && m !== void 0 ? m : {})
                })
            }),
            parser: parseNumber$1,
            value: i,
            viewProps: l.viewProps
        })
    }
});
let Point4d$1 = class {
    constructor(i = 0, o = 0, c = 0, u = 0) {
        this.x = i, this.y = o, this.z = c, this.w = u
    }
    getComponents() {
        return [this.x, this.y, this.z, this.w]
    }
    static isObject(i) {
        if (isEmpty$1(i)) return !1;
        const o = i.x,
            c = i.y,
            u = i.z,
            p = i.w;
        return !(typeof o != "number" || typeof c != "number" || typeof u != "number" || typeof p != "number")
    }
    static equals(i, o) {
        return i.x === o.x && i.y === o.y && i.z === o.z && i.w === o.w
    }
    toObject() {
        return {
            x: this.x,
            y: this.y,
            z: this.z,
            w: this.w
        }
    }
};
const Point4dAssembly$1 = {
    toComponents: l => l.getComponents(),
    fromComponents: l => new Point4d$1(...l)
};

function point4dFromUnknown$1(l) {
    return Point4d$1.isObject(l) ? new Point4d$1(l.x, l.y, l.z, l.w) : new Point4d$1
}

function writePoint4d$1(l, i) {
    l.writeProperty("x", i.x), l.writeProperty("y", i.y), l.writeProperty("z", i.z), l.writeProperty("w", i.w)
}

function createConstraint$1$1(l, i) {
    return new PointNdConstraint$1({
        assembly: Point4dAssembly$1,
        components: [createDimensionConstraint$2(Object.assign(Object.assign({}, l), l.x), i.x), createDimensionConstraint$2(Object.assign(Object.assign({}, l), l.y), i.y), createDimensionConstraint$2(Object.assign(Object.assign({}, l), l.z), i.z), createDimensionConstraint$2(Object.assign(Object.assign({}, l), l.w), i.w)]
    })
}
const Point4dInputPlugin = createPlugin$1({
    id: "input-point4d",
    type: "input",
    accept: (l, i) => {
        if (!Point4d$1.isObject(l)) return null;
        const o = parseRecord$1(i, c => Object.assign(Object.assign({}, createPointDimensionParser$1(c)), {
            readonly: c.optional.constant(!1),
            w: c.optional.custom(parsePointDimensionParams$1),
            x: c.optional.custom(parsePointDimensionParams$1),
            y: c.optional.custom(parsePointDimensionParams$1),
            z: c.optional.custom(parsePointDimensionParams$1)
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => point4dFromUnknown$1,
        constraint: l => createConstraint$1$1(l.params, l.initialValue),
        equals: Point4d$1.equals,
        writer: l => writePoint4d$1
    },
    controller: l => {
        const i = l.value,
            o = l.constraint,
            c = [l.params.x, l.params.y, l.params.z, l.params.w];
        return new PointNdTextController$1(l.document, {
            assembly: Point4dAssembly$1,
            axes: i.rawValue.getComponents().map((u, p) => {
                var m;
                return createPointAxis$1({
                    constraint: o.components[p],
                    initialValue: u,
                    params: deepMerge$1(l.params, (m = c[p]) !== null && m !== void 0 ? m : {})
                })
            }),
            parser: parseNumber$1,
            value: i,
            viewProps: l.viewProps
        })
    }
});

function createConstraint$7(l) {
    const i = [],
        o = createListConstraint$1(l.options);
    return o && i.push(o), new CompositeConstraint$1(i)
}
const StringInputPlugin = createPlugin$1({
        id: "input-string",
        type: "input",
        accept: (l, i) => {
            if (typeof l != "string") return null;
            const o = parseRecord$1(i, c => ({
                readonly: c.optional.constant(!1),
                options: c.optional.custom(parseListOptions$1)
            }));
            return o ? {
                initialValue: l,
                params: o
            } : null
        },
        binding: {
            reader: l => stringFromUnknown$1,
            constraint: l => createConstraint$7(l.params),
            writer: l => writePrimitive$1
        },
        controller: l => {
            const i = l.document,
                o = l.value,
                c = l.constraint,
                u = c && findConstraint$1(c, ListConstraint$1);
            return u ? new ListController$1(i, {
                props: new ValueMap$1({
                    options: u.values.value("options")
                }),
                value: o,
                viewProps: l.viewProps
            }) : new TextController$1(i, {
                parser: p => p,
                props: ValueMap$1.fromObject({
                    formatter: formatString$1
                }),
                value: o,
                viewProps: l.viewProps
            })
        },
        api(l) {
            return typeof l.controller.value.rawValue != "string" ? null : l.controller.valueController instanceof ListController$1 ? new ListInputBindingApi$1(l.controller) : null
        }
    }),
    Constants$1 = {
        monitor: {
            defaultInterval: 200,
            defaultRows: 3
        }
    },
    cn$3$1 = ClassName$1("mll");
let MultiLogView$1 = class {
        constructor(i, o) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = o.formatter, this.element = i.createElement("div"), this.element.classList.add(cn$3$1()), o.viewProps.bindClassModifiers(this.element);
            const c = i.createElement("textarea");
            c.classList.add(cn$3$1("i")), c.style.height = `calc(var(${getCssVar$1("containerUnitSize")}) * ${o.rows})`, c.readOnly = !0, o.viewProps.bindDisabled(c), this.element.appendChild(c), this.textareaElem_ = c, o.value.emitter.on("change", this.onValueUpdate_), this.value = o.value, this.update_()
        }
        update_() {
            const i = this.textareaElem_,
                o = i.scrollTop === i.scrollHeight - i.clientHeight,
                c = [];
            this.value.rawValue.forEach(u => {
                u !== void 0 && c.push(this.formatter_(u))
            }), i.textContent = c.join(`
`), o && (i.scrollTop = i.scrollHeight)
        }
        onValueUpdate_() {
            this.update_()
        }
    },
    MultiLogController$1 = class {
        constructor(i, o) {
            this.value = o.value, this.viewProps = o.viewProps, this.view = new MultiLogView$1(i, {
                formatter: o.formatter,
                rows: o.rows,
                value: this.value,
                viewProps: this.viewProps
            })
        }
    };
const cn$2$1 = ClassName$1("sgl");
let SingleLogView$1 = class {
        constructor(i, o) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = o.formatter, this.element = i.createElement("div"), this.element.classList.add(cn$2$1()), o.viewProps.bindClassModifiers(this.element);
            const c = i.createElement("input");
            c.classList.add(cn$2$1("i")), c.readOnly = !0, c.type = "text", o.viewProps.bindDisabled(c), this.element.appendChild(c), this.inputElement = c, o.value.emitter.on("change", this.onValueUpdate_), this.value = o.value, this.update_()
        }
        update_() {
            const i = this.value.rawValue,
                o = i[i.length - 1];
            this.inputElement.value = o !== void 0 ? this.formatter_(o) : ""
        }
        onValueUpdate_() {
            this.update_()
        }
    },
    SingleLogController$1 = class {
        constructor(i, o) {
            this.value = o.value, this.viewProps = o.viewProps, this.view = new SingleLogView$1(i, {
                formatter: o.formatter,
                value: this.value,
                viewProps: this.viewProps
            })
        }
    };
const BooleanMonitorPlugin = createPlugin$1({
    id: "monitor-bool",
    type: "monitor",
    accept: (l, i) => {
        if (typeof l != "boolean") return null;
        const o = parseRecord$1(i, c => ({
            readonly: c.required.constant(!0),
            rows: c.optional.number
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => boolFromUnknown$1
    },
    controller: l => {
        var i;
        return l.value.rawValue.length === 1 ? new SingleLogController$1(l.document, {
            formatter: BooleanFormatter$1,
            value: l.value,
            viewProps: l.viewProps
        }) : new MultiLogController$1(l.document, {
            formatter: BooleanFormatter$1,
            rows: (i = l.params.rows) !== null && i !== void 0 ? i : Constants$1.monitor.defaultRows,
            value: l.value,
            viewProps: l.viewProps
        })
    }
});
let GraphLogMonitorBindingApi$1 = class extends BindingApi$1 {
    get max() {
        return this.controller.valueController.props.get("max")
    }
    set max(i) {
        this.controller.valueController.props.set("max", i)
    }
    get min() {
        return this.controller.valueController.props.get("min")
    }
    set min(i) {
        this.controller.valueController.props.set("min", i)
    }
};
const cn$1$1 = ClassName$1("grl");
let GraphLogView$1 = class {
        constructor(i, o) {
            this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = i.createElement("div"), this.element.classList.add(cn$1$1()), o.viewProps.bindClassModifiers(this.element), this.formatter_ = o.formatter, this.props_ = o.props, this.cursor_ = o.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
            const c = i.createElementNS(SVG_NS$1, "svg");
            c.classList.add(cn$1$1("g")), c.style.height = `calc(var(${getCssVar$1("containerUnitSize")}) * ${o.rows})`, this.element.appendChild(c), this.svgElem_ = c;
            const u = i.createElementNS(SVG_NS$1, "polyline");
            this.svgElem_.appendChild(u), this.lineElem_ = u;
            const p = i.createElement("div");
            p.classList.add(cn$1$1("t"), ClassName$1("tt")()), this.element.appendChild(p), this.tooltipElem_ = p, o.value.emitter.on("change", this.onValueUpdate_), this.value = o.value, this.update_()
        }
        get graphElement() {
            return this.svgElem_
        }
        update_() {
            const {
                clientWidth: i,
                clientHeight: o
            } = this.element, c = this.value.rawValue.length - 1, u = this.props_.get("min"), p = this.props_.get("max"), m = [];
            this.value.rawValue.forEach((y, b) => {
                if (y === void 0) return;
                const S = mapRange$2(b, 0, c, 0, i),
                    C = mapRange$2(y, u, p, o, 0);
                m.push([S, C].join(","))
            }), this.lineElem_.setAttributeNS(null, "points", m.join(" "));
            const g = this.tooltipElem_,
                _ = this.value.rawValue[this.cursor_.rawValue];
            if (_ === void 0) {
                g.classList.remove(cn$1$1("t", "a"));
                return
            }
            const v = mapRange$2(this.cursor_.rawValue, 0, c, 0, i),
                x = mapRange$2(_, u, p, o, 0);
            g.style.left = `${v}px`, g.style.top = `${x}px`, g.textContent = `${this.formatter_(_)}`, g.classList.contains(cn$1$1("t", "a")) || (g.classList.add(cn$1$1("t", "a"), cn$1$1("t", "in")), forceReflow$1(g), g.classList.remove(cn$1$1("t", "in")))
        }
        onValueUpdate_() {
            this.update_()
        }
        onCursorChange_() {
            this.update_()
        }
    },
    GraphLogController$1 = class {
        constructor(i, o) {
            if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props = o.props, this.value = o.value, this.viewProps = o.viewProps, this.cursor_ = createValue$1(-1), this.view = new GraphLogView$1(i, {
                    cursor: this.cursor_,
                    formatter: o.formatter,
                    rows: o.rows,
                    props: this.props,
                    value: this.value,
                    viewProps: this.viewProps
                }), !supportsTouch$1(i)) this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
            else {
                const c = new PointerHandler$1(this.view.element);
                c.emitter.on("down", this.onGraphPointerDown_), c.emitter.on("move", this.onGraphPointerMove_), c.emitter.on("up", this.onGraphPointerUp_)
            }
        }
        importProps(i) {
            return importBladeState$1(i, null, o => ({
                max: o.required.number,
                min: o.required.number
            }), o => (this.props.set("max", o.max), this.props.set("min", o.min), !0))
        }
        exportProps() {
            return exportBladeState$1(null, {
                max: this.props.get("max"),
                min: this.props.get("min")
            })
        }
        onGraphMouseLeave_() {
            this.cursor_.rawValue = -1
        }
        onGraphMouseMove_(i) {
            const {
                clientWidth: o
            } = this.view.element;
            this.cursor_.rawValue = Math.floor(mapRange$2(i.offsetX, 0, o, 0, this.value.rawValue.length))
        }
        onGraphPointerDown_(i) {
            this.onGraphPointerMove_(i)
        }
        onGraphPointerMove_(i) {
            if (!i.data.point) {
                this.cursor_.rawValue = -1;
                return
            }
            this.cursor_.rawValue = Math.floor(mapRange$2(i.data.point.x, 0, i.data.bounds.width, 0, this.value.rawValue.length))
        }
        onGraphPointerUp_() {
            this.cursor_.rawValue = -1
        }
    };

function createFormatter$3(l) {
    return isEmpty$1(l.format) ? createNumberFormatter$1(2) : l.format
}

function createTextMonitor$1(l) {
    var i;
    return l.value.rawValue.length === 1 ? new SingleLogController$1(l.document, {
        formatter: createFormatter$3(l.params),
        value: l.value,
        viewProps: l.viewProps
    }) : new MultiLogController$1(l.document, {
        formatter: createFormatter$3(l.params),
        rows: (i = l.params.rows) !== null && i !== void 0 ? i : Constants$1.monitor.defaultRows,
        value: l.value,
        viewProps: l.viewProps
    })
}

function createGraphMonitor$1(l) {
    var i, o, c;
    return new GraphLogController$1(l.document, {
        formatter: createFormatter$3(l.params),
        rows: (i = l.params.rows) !== null && i !== void 0 ? i : Constants$1.monitor.defaultRows,
        props: ValueMap$1.fromObject({
            max: (o = l.params.max) !== null && o !== void 0 ? o : 100,
            min: (c = l.params.min) !== null && c !== void 0 ? c : 0
        }),
        value: l.value,
        viewProps: l.viewProps
    })
}

function shouldShowGraph$1(l) {
    return l.view === "graph"
}
const NumberMonitorPlugin = createPlugin$1({
        id: "monitor-number",
        type: "monitor",
        accept: (l, i) => {
            if (typeof l != "number") return null;
            const o = parseRecord$1(i, c => ({
                format: c.optional.function,
                max: c.optional.number,
                min: c.optional.number,
                readonly: c.required.constant(!0),
                rows: c.optional.number,
                view: c.optional.string
            }));
            return o ? {
                initialValue: l,
                params: o
            } : null
        },
        binding: {
            defaultBufferSize: l => shouldShowGraph$1(l) ? 64 : 1,
            reader: l => numberFromUnknown$1
        },
        controller: l => shouldShowGraph$1(l.params) ? createGraphMonitor$1(l) : createTextMonitor$1(l),
        api: l => l.controller.valueController instanceof GraphLogController$1 ? new GraphLogMonitorBindingApi$1(l.controller) : null
    }),
    StringMonitorPlugin = createPlugin$1({
        id: "monitor-string",
        type: "monitor",
        accept: (l, i) => {
            if (typeof l != "string") return null;
            const o = parseRecord$1(i, c => ({
                multiline: c.optional.boolean,
                readonly: c.required.constant(!0),
                rows: c.optional.number
            }));
            return o ? {
                initialValue: l,
                params: o
            } : null
        },
        binding: {
            reader: l => stringFromUnknown$1
        },
        controller: l => {
            var i;
            const o = l.value;
            return o.rawValue.length > 1 || l.params.multiline ? new MultiLogController$1(l.document, {
                formatter: formatString$1,
                rows: (i = l.params.rows) !== null && i !== void 0 ? i : Constants$1.monitor.defaultRows,
                value: o,
                viewProps: l.viewProps
            }) : new SingleLogController$1(l.document, {
                formatter: formatString$1,
                value: o,
                viewProps: l.viewProps
            })
        }
    });
class BladeApiCache {
    constructor() {
        this.map_ = new Map
    }
    get(i) {
        var o;
        return (o = this.map_.get(i)) !== null && o !== void 0 ? o : null
    }
    has(i) {
        return this.map_.has(i)
    }
    add(i, o) {
        return this.map_.set(i, o), i.viewProps.handleDispose(() => {
            this.map_.delete(i)
        }), o
    }
}
class ReadWriteBinding {
    constructor(i) {
        this.target = i.target, this.reader_ = i.reader, this.writer_ = i.writer
    }
    read() {
        return this.reader_(this.target.read())
    }
    write(i) {
        this.writer_(this.target, i)
    }
    inject(i) {
        this.write(this.reader_(i))
    }
}

function createInputBindingController(l, i) {
    var o;
    const c = l.accept(i.target.read(), i.params);
    if (isEmpty$1(c)) return null;
    const u = {
            target: i.target,
            initialValue: c.initialValue,
            params: c.params
        },
        p = parseRecord$1(i.params, y => ({
            disabled: y.optional.boolean,
            hidden: y.optional.boolean,
            label: y.optional.string,
            tag: y.optional.string
        })),
        m = l.binding.reader(u),
        g = l.binding.constraint ? l.binding.constraint(u) : void 0,
        _ = new ReadWriteBinding({
            reader: m,
            target: i.target,
            writer: l.binding.writer(u)
        }),
        v = new InputBindingValue(createValue$1(m(c.initialValue), {
            constraint: g,
            equals: l.binding.equals
        }), _),
        x = l.controller({
            constraint: g,
            document: i.document,
            initialValue: c.initialValue,
            params: c.params,
            value: v,
            viewProps: ViewProps$1.create({
                disabled: p ? .disabled,
                hidden: p ? .hidden
            })
        });
    return new InputBindingController(i.document, {
        blade: createBlade$1(),
        props: ValueMap$1.fromObject({
            label: "label" in i.params ? (o = p ? .label) !== null && o !== void 0 ? o : null : i.target.key
        }),
        tag: p ? .tag,
        value: v,
        valueController: x
    })
}
class ReadonlyBinding {
    constructor(i) {
        this.target = i.target, this.reader_ = i.reader
    }
    read() {
        return this.reader_(this.target.read())
    }
}

function createTicker(l, i) {
    return i === 0 ? new ManualTicker : new IntervalTicker(l, i ? ? Constants$1.monitor.defaultInterval)
}

function createMonitorBindingController(l, i) {
    var o, c, u;
    const p = l.accept(i.target.read(), i.params);
    if (isEmpty$1(p)) return null;
    const m = {
            target: i.target,
            initialValue: p.initialValue,
            params: p.params
        },
        g = parseRecord$1(i.params, b => ({
            bufferSize: b.optional.number,
            disabled: b.optional.boolean,
            hidden: b.optional.boolean,
            interval: b.optional.number,
            label: b.optional.string
        })),
        _ = l.binding.reader(m),
        v = (c = (o = g ? .bufferSize) !== null && o !== void 0 ? o : l.binding.defaultBufferSize && l.binding.defaultBufferSize(p.params)) !== null && c !== void 0 ? c : 1,
        x = new MonitorBindingValue({
            binding: new ReadonlyBinding({
                reader: _,
                target: i.target
            }),
            bufferSize: v,
            ticker: createTicker(i.document, g ? .interval)
        }),
        y = l.controller({
            document: i.document,
            params: p.params,
            value: x,
            viewProps: ViewProps$1.create({
                disabled: g ? .disabled,
                hidden: g ? .hidden
            })
        });
    return y.viewProps.bindDisabled(x.ticker), y.viewProps.handleDispose(() => {
        x.ticker.dispose()
    }), new MonitorBindingController(i.document, {
        blade: createBlade$1(),
        props: ValueMap$1.fromObject({
            label: "label" in i.params ? (u = g ? .label) !== null && u !== void 0 ? u : null : i.target.key
        }),
        value: x,
        valueController: y
    })
}
class PluginPool {
    constructor(i) {
        this.pluginsMap_ = {
            blades: [],
            inputs: [],
            monitors: []
        }, this.apiCache_ = i
    }
    getAll() {
        return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors]
    }
    register(i, o) {
        if (!isCompatible(o.core)) throw TpError$1.notCompatible(i, o.id);
        o.type === "blade" ? this.pluginsMap_.blades.unshift(o) : o.type === "input" ? this.pluginsMap_.inputs.unshift(o) : o.type === "monitor" && this.pluginsMap_.monitors.unshift(o)
    }
    createInput_(i, o, c) {
        return this.pluginsMap_.inputs.reduce((u, p) => u ? ? createInputBindingController(p, {
            document: i,
            target: o,
            params: c
        }), null)
    }
    createMonitor_(i, o, c) {
        return this.pluginsMap_.monitors.reduce((u, p) => u ? ? createMonitorBindingController(p, {
            document: i,
            params: c,
            target: o
        }), null)
    }
    createBinding(i, o, c) {
        const u = o.read();
        if (isEmpty$1(u)) throw new TpError$1({
            context: {
                key: o.key
            },
            type: "nomatchingcontroller"
        });
        const p = this.createInput_(i, o, c);
        if (p) return p;
        const m = this.createMonitor_(i, o, c);
        if (m) return m;
        throw new TpError$1({
            context: {
                key: o.key
            },
            type: "nomatchingcontroller"
        })
    }
    createBlade(i, o) {
        const c = this.pluginsMap_.blades.reduce((u, p) => u ? ? createBladeController(p, {
            document: i,
            params: o
        }), null);
        if (!c) throw new TpError$1({
            type: "nomatchingview",
            context: {
                params: o
            }
        });
        return c
    }
    createInputBindingApi_(i) {
        const o = this.pluginsMap_.inputs.reduce((c, u) => {
            var p, m;
            return c || ((m = (p = u.api) === null || p === void 0 ? void 0 : p.call(u, {
                controller: i
            })) !== null && m !== void 0 ? m : null)
        }, null);
        return this.apiCache_.add(i, o ? ? new BindingApi$1(i))
    }
    createMonitorBindingApi_(i) {
        const o = this.pluginsMap_.monitors.reduce((c, u) => {
            var p, m;
            return c || ((m = (p = u.api) === null || p === void 0 ? void 0 : p.call(u, {
                controller: i
            })) !== null && m !== void 0 ? m : null)
        }, null);
        return this.apiCache_.add(i, o ? ? new BindingApi$1(i))
    }
    createBindingApi(i) {
        if (this.apiCache_.has(i)) return this.apiCache_.get(i);
        if (isInputBindingController(i)) return this.createInputBindingApi_(i);
        if (isMonitorBindingController(i)) return this.createMonitorBindingApi_(i);
        throw TpError$1.shouldNeverHappen()
    }
    createApi(i) {
        if (this.apiCache_.has(i)) return this.apiCache_.get(i);
        if (isBindingController(i)) return this.createBindingApi(i);
        const o = this.pluginsMap_.blades.reduce((c, u) => c ? ? u.api({
            controller: i,
            pool: this
        }), null);
        if (!o) throw TpError$1.shouldNeverHappen();
        return this.apiCache_.add(i, o)
    }
}
const sharedCache = new BladeApiCache;

function createDefaultPluginPool() {
    const l = new PluginPool(sharedCache);
    return [Point2dInputPlugin, Point3dInputPlugin, Point4dInputPlugin, StringInputPlugin, NumberInputPlugin, StringColorInputPlugin, ObjectColorInputPlugin, NumberColorInputPlugin, BooleanInputPlugin, BooleanMonitorPlugin, StringMonitorPlugin, NumberMonitorPlugin, ButtonBladePlugin, FolderBladePlugin, TabBladePlugin].forEach(i => {
        l.register("core", i)
    }), l
}
class ListBladeApi extends BladeApi$1 {
    constructor(i) {
        super(i), this.emitter_ = new Emitter$1, this.controller.value.emitter.on("change", o => {
            this.emitter_.emit("change", new TpChangeEvent$1(this, o.rawValue))
        })
    }
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(i) {
        this.controller.labelController.props.set("label", i)
    }
    get options() {
        return this.controller.valueController.props.get("options")
    }
    set options(i) {
        this.controller.valueController.props.set("options", i)
    }
    get value() {
        return this.controller.value.rawValue
    }
    set value(i) {
        this.controller.value.rawValue = i
    }
    on(i, o) {
        const c = o.bind(this);
        return this.emitter_.on(i, u => {
            c(u)
        }, {
            key: o
        }), this
    }
    off(i, o) {
        return this.emitter_.off(i, o), this
    }
}
class SeparatorBladeApi extends BladeApi$1 {}
class SliderBladeApi extends BladeApi$1 {
    constructor(i) {
        super(i), this.emitter_ = new Emitter$1, this.controller.value.emitter.on("change", o => {
            this.emitter_.emit("change", new TpChangeEvent$1(this, o.rawValue))
        })
    }
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(i) {
        this.controller.labelController.props.set("label", i)
    }
    get max() {
        return this.controller.valueController.sliderController.props.get("max")
    }
    set max(i) {
        this.controller.valueController.sliderController.props.set("max", i)
    }
    get min() {
        return this.controller.valueController.sliderController.props.get("min")
    }
    set min(i) {
        this.controller.valueController.sliderController.props.set("min", i)
    }
    get value() {
        return this.controller.value.rawValue
    }
    set value(i) {
        this.controller.value.rawValue = i
    }
    on(i, o) {
        const c = o.bind(this);
        return this.emitter_.on(i, u => {
            c(u)
        }, {
            key: o
        }), this
    }
    off(i, o) {
        return this.emitter_.off(i, o), this
    }
}
class TextBladeApi extends BladeApi$1 {
    constructor(i) {
        super(i), this.emitter_ = new Emitter$1, this.controller.value.emitter.on("change", o => {
            this.emitter_.emit("change", new TpChangeEvent$1(this, o.rawValue))
        })
    }
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(i) {
        this.controller.labelController.props.set("label", i)
    }
    get formatter() {
        return this.controller.valueController.props.get("formatter")
    }
    set formatter(i) {
        this.controller.valueController.props.set("formatter", i)
    }
    get value() {
        return this.controller.value.rawValue
    }
    set value(i) {
        this.controller.value.rawValue = i
    }
    on(i, o) {
        const c = o.bind(this);
        return this.emitter_.on(i, u => {
            c(u)
        }, {
            key: o
        }), this
    }
    off(i, o) {
        return this.emitter_.off(i, o), this
    }
}
const ListBladePlugin = function() {
    return {
        id: "list",
        type: "blade",
        core: VERSION$1,
        accept(l) {
            const i = parseRecord$1(l, o => ({
                options: o.required.custom(parseListOptions$1),
                value: o.required.raw,
                view: o.required.constant("list"),
                label: o.optional.string
            }));
            return i ? {
                params: i
            } : null
        },
        controller(l) {
            const i = new ListConstraint$1(normalizeListOptions$1(l.params.options)),
                o = createValue$1(l.params.value, {
                    constraint: i
                }),
                c = new ListController$1(l.document, {
                    props: new ValueMap$1({
                        options: i.values.value("options")
                    }),
                    value: o,
                    viewProps: l.viewProps
                });
            return new LabeledValueBladeController(l.document, {
                blade: l.blade,
                props: ValueMap$1.fromObject({
                    label: l.params.label
                }),
                value: o,
                valueController: c
            })
        },
        api(l) {
            return !(l.controller instanceof LabeledValueBladeController) || !(l.controller.valueController instanceof ListController$1) ? null : new ListBladeApi(l.controller)
        }
    }
}();
class RootApi extends FolderApi$1 {
    constructor(i, o) {
        super(i, o)
    }
    get element() {
        return this.controller.view.element
    }
}
class RootController extends FolderController$1 {
    constructor(i, o) {
        super(i, {
            expanded: o.expanded,
            blade: o.blade,
            props: o.props,
            root: !0,
            viewProps: o.viewProps
        })
    }
}
const cn$s = ClassName$1("spr");
class SeparatorView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$s()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("hr");
        c.classList.add(cn$s("r")), this.element.appendChild(c)
    }
}
class SeparatorController extends BladeController$1 {
    constructor(i, o) {
        super(Object.assign(Object.assign({}, o), {
            view: new SeparatorView(i, {
                viewProps: o.viewProps
            })
        }))
    }
}
const SeparatorBladePlugin = {
        id: "separator",
        type: "blade",
        core: VERSION$1,
        accept(l) {
            const i = parseRecord$1(l, o => ({
                view: o.required.constant("separator")
            }));
            return i ? {
                params: i
            } : null
        },
        controller(l) {
            return new SeparatorController(l.document, {
                blade: l.blade,
                viewProps: l.viewProps
            })
        },
        api(l) {
            return l.controller instanceof SeparatorController ? new SeparatorBladeApi(l.controller) : null
        }
    },
    SliderBladePlugin = {
        id: "slider",
        type: "blade",
        core: VERSION$1,
        accept(l) {
            const i = parseRecord$1(l, o => ({
                max: o.required.number,
                min: o.required.number,
                view: o.required.constant("slider"),
                format: o.optional.function,
                label: o.optional.string,
                value: o.optional.number
            }));
            return i ? {
                params: i
            } : null
        },
        controller(l) {
            var i, o;
            const c = (i = l.params.value) !== null && i !== void 0 ? i : 0,
                u = new DefiniteRangeConstraint$1({
                    max: l.params.max,
                    min: l.params.min
                }),
                p = createValue$1(c, {
                    constraint: u
                }),
                m = new SliderTextController$1(l.document, Object.assign(Object.assign({}, createSliderTextProps$1({
                    formatter: (o = l.params.format) !== null && o !== void 0 ? o : numberToString,
                    keyScale: createValue$1(1),
                    max: u.values.value("max"),
                    min: u.values.value("min"),
                    pointerScale: getSuitablePointerScale$1(l.params, c)
                })), {
                    parser: parseNumber$1,
                    value: p,
                    viewProps: l.viewProps
                }));
            return new LabeledValueBladeController(l.document, {
                blade: l.blade,
                props: ValueMap$1.fromObject({
                    label: l.params.label
                }),
                value: p,
                valueController: m
            })
        },
        api(l) {
            return !(l.controller instanceof LabeledValueBladeController) || !(l.controller.valueController instanceof SliderTextController$1) ? null : new SliderBladeApi(l.controller)
        }
    },
    TextBladePlugin = function() {
        return {
            id: "text",
            type: "blade",
            core: VERSION$1,
            accept(l) {
                const i = parseRecord$1(l, o => ({
                    parse: o.required.function,
                    value: o.required.raw,
                    view: o.required.constant("text"),
                    format: o.optional.function,
                    label: o.optional.string
                }));
                return i ? {
                    params: i
                } : null
            },
            controller(l) {
                var i;
                const o = createValue$1(l.params.value),
                    c = new TextController$1(l.document, {
                        parser: l.params.parse,
                        props: ValueMap$1.fromObject({
                            formatter: (i = l.params.format) !== null && i !== void 0 ? i : u => String(u)
                        }),
                        value: o,
                        viewProps: l.viewProps
                    });
                return new LabeledValueBladeController(l.document, {
                    blade: l.blade,
                    props: ValueMap$1.fromObject({
                        label: l.params.label
                    }),
                    value: o,
                    valueController: c
                })
            },
            api(l) {
                return !(l.controller instanceof LabeledValueBladeController) || !(l.controller.valueController instanceof TextController$1) ? null : new TextBladeApi(l.controller)
            }
        }
    }();

function createDefaultWrapperElement(l) {
    const i = l.createElement("div");
    return i.classList.add(ClassName$1("dfw")()), l.body && l.body.appendChild(i), i
}

function embedStyle(l, i, o) {
    if (l.querySelector(`style[data-tp-style=${i}]`)) return;
    const c = l.createElement("style");
    c.dataset.tpStyle = i, c.textContent = o, l.head.appendChild(c)
}
class Pane extends RootApi {
    constructor(i) {
        var o, c;
        const u = i ? ? {},
            p = (o = u.document) !== null && o !== void 0 ? o : getWindowDocument(),
            m = createDefaultPluginPool(),
            g = new RootController(p, {
                expanded: u.expanded,
                blade: createBlade$1(),
                props: ValueMap$1.fromObject({
                    title: u.title
                }),
                viewProps: ViewProps$1.create()
            });
        super(g, m), this.pool_ = m, this.containerElem_ = (c = u.container) !== null && c !== void 0 ? c : createDefaultWrapperElement(p), this.containerElem_.appendChild(this.element), this.doc_ = p, this.usesDefaultWrapper_ = !u.container, this.setUpDefaultPlugins_()
    }
    get document() {
        if (!this.doc_) throw TpError$1.alreadyDisposed();
        return this.doc_
    }
    dispose() {
        const i = this.containerElem_;
        if (!i) throw TpError$1.alreadyDisposed();
        if (this.usesDefaultWrapper_) {
            const o = i.parentElement;
            o && o.removeChild(i)
        }
        this.containerElem_ = null, this.doc_ = null, super.dispose()
    }
    registerPlugin(i) {
        i.css && embedStyle(this.document, `plugin-${i.id}`, i.css), ("plugin" in i ? [i.plugin] : "plugins" in i ? i.plugins : []).forEach(c => {
            this.pool_.register(i.id, c)
        })
    }
    setUpDefaultPlugins_() {
        this.registerPlugin({
            id: "default",
            css: '.tp-tbiv_b,.tp-coltxtv_ms,.tp-colswv_b,.tp-ckbv_i,.tp-sglv_i,.tp-mllv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-rotv_b,.tp-fldv_b,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--bld-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--cnt-usz);line-height:var(--cnt-usz);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tbpv_c>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-vp))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tbpv_c>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--cnt-usp)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tbpv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tbpv_c>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tbpv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tbpv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tbpv_c>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tbpv_c>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--bld-br);border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tbpv_c .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tbpv_c>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tbpv_c>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--bld-br)}.tp-tbpv_c .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--bld-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);overflow:hidden;padding-left:var(--cnt-hp);padding-right:calc(4px + var(--cnt-usz) + var(--cnt-hp));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-hp) + (var(--cnt-usz) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-vp);padding-top:var(--cnt-vp);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--cnt-usz);line-height:var(--cnt-usz);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-sglv_i,.tp-mllv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--mo-fg);height:var(--cnt-usz);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-sglv_i::-webkit-scrollbar,.tp-mllv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-sglv_i::-webkit-scrollbar-corner,.tp-mllv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-sglv_i::-webkit-scrollbar-thumb,.tp-mllv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-rotv{--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-br: var(--tp-base-border-radius, 6px);--bs-ff: var(--tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--bld-br: var(--tp-blade-border-radius, 2px);--bld-hp: var(--tp-blade-horizontal-padding, 4px);--bld-vw: var(--tp-blade-value-width, 160px);--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--cnt-hp: var(--tp-container-horizontal-padding, 4px);--cnt-vp: var(--tp-container-vertical-padding, 4px);--cnt-usp: var(--tp-container-unit-spacing, 4px);--cnt-usz: var(--tp-container-unit-size, 20px);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--bld-br);cursor:pointer;display:block;height:var(--cnt-usz);position:relative;width:var(--cnt-usz)}.tp-ckbv_w svg{display:block;height:16px;inset:0;margin:auto;opacity:0;position:absolute;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--cnt-usz)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--cnt-usp);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--cnt-usp)}.tp-colpv_rgb{display:flex;margin-top:var(--cnt-usp);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-vp);padding-top:calc(var(--cnt-vp) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-hp));position:absolute;right:calc(-1*var(--cnt-hp));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--bld-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--cnt-usz)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{inset:0;position:absolute}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--bld-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;inset:0;position:absolute}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--bld-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{cursor:pointer;display:block;height:var(--cnt-usz);left:0;position:absolute;top:0;width:var(--cnt-usz)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--bld-br);content:"";display:block;inset:0;position:absolute}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--bld-br);color:var(--lbl-fg);cursor:pointer;height:var(--cnt-usz);line-height:var(--cnt-usz);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--cnt-usz)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-hp);padding-right:var(--cnt-hp)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:var(--bld-vw)}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 var(--bld-hp);width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--cnt-usz)*3);line-height:var(--cnt-usz);padding-left:var(--bld-hp);padding-right:var(--bld-hp);resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--cnt-usz);margin-right:4px;position:relative;width:var(--cnt-usz)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--cnt-usp);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-p2dpv{padding-left:calc(var(--cnt-usz) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:var(--bld-vw);padding:var(--cnt-vp) var(--cnt-hp);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--cnt-usz);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin:auto;position:absolute}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin-bottom:auto;margin-top:auto;position:absolute}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--bld-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--cnt-usz) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-hp) + 4px);padding-right:calc(var(--cnt-hp) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);content:"";inset:0 0 2px;pointer-events:none;position:absolute}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);opacity:.5;overflow:hidden;position:relative;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-tbpv_c{padding-bottom:var(--cnt-vp);padding-left:4px;padding-top:var(--cnt-vp)}.tp-txtv{position:relative}.tp-txtv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:calc(var(--bld-hp) - 5px);position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--cnt-usz) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--bld-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--bs-ff);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--cnt-usz) + var(--cnt-hp));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0;transition-delay:0s;transition-duration:0s}.tp-rotv.tp-rotv-not>.tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst.tp-fldv-expanded>.tp-fldv_b{transition-delay:0s;transition-duration:0s}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}',
            plugins: [ListBladePlugin, SeparatorBladePlugin, SliderBladePlugin, TabBladePlugin, TextBladePlugin]
        })
    }
}
new Semver$1("4.0.5");

function forceCast(l) {
    return l
}

function isEmpty(l) {
    return l == null
}

function isObject$1$1(l) {
    return l !== null && typeof l == "object"
}

function isRecord(l) {
    return l !== null && typeof l == "object"
}

function deepEqualsArray(l, i) {
    if (l.length !== i.length) return !1;
    for (let o = 0; o < l.length; o++)
        if (l[o] !== i[o]) return !1;
    return !0
}

function deepMerge(l, i) {
    return Array.from(new Set([...Object.keys(l), ...Object.keys(i)])).reduce((c, u) => {
        const p = l[u],
            m = i[u];
        return isRecord(p) && isRecord(m) ? Object.assign(Object.assign({}, c), {
            [u]: deepMerge(p, m)
        }) : Object.assign(Object.assign({}, c), {
            [u]: u in i ? m : p
        })
    }, {})
}

function isBinding(l) {
    return isObject$1$1(l) ? "target" in l : !1
}
const CREATE_MESSAGE_MAP = {
    alreadydisposed: () => "View has been already disposed",
    invalidparams: l => `Invalid parameters for '${l.name}'`,
    nomatchingcontroller: l => `No matching controller for '${l.key}'`,
    nomatchingview: l => `No matching view for '${JSON.stringify(l.params)}'`,
    notbindable: () => "Value is not bindable",
    notcompatible: l => `Not compatible with  plugin '${l.id}'`,
    propertynotfound: l => `Property '${l.name}' not found`,
    shouldneverhappen: () => "This error should never happen"
};
class TpError {
    static alreadyDisposed() {
        return new TpError({
            type: "alreadydisposed"
        })
    }
    static notBindable() {
        return new TpError({
            type: "notbindable"
        })
    }
    static notCompatible(i, o) {
        return new TpError({
            type: "notcompatible",
            context: {
                id: `${i}.${o}`
            }
        })
    }
    static propertyNotFound(i) {
        return new TpError({
            type: "propertynotfound",
            context: {
                name: i
            }
        })
    }
    static shouldNeverHappen() {
        return new TpError({
            type: "shouldneverhappen"
        })
    }
    constructor(i) {
        var o;
        this.message = (o = CREATE_MESSAGE_MAP[i.type](i.context)) !== null && o !== void 0 ? o : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = i.type
    }
    toString() {
        return this.message
    }
}
class BindingTarget {
    constructor(i, o) {
        this.obj_ = i, this.key = o
    }
    static isBindable(i) {
        return !(i === null || typeof i != "object" && typeof i != "function")
    }
    read() {
        return this.obj_[this.key]
    }
    write(i) {
        this.obj_[this.key] = i
    }
    writeProperty(i, o) {
        const c = this.read();
        if (!BindingTarget.isBindable(c)) throw TpError.notBindable();
        if (!(i in c)) throw TpError.propertyNotFound(i);
        c[i] = o
    }
}
class Emitter {
    constructor() {
        this.observers_ = {}
    }
    on(i, o) {
        let c = this.observers_[i];
        return c || (c = this.observers_[i] = []), c.push({
            handler: o
        }), this
    }
    off(i, o) {
        const c = this.observers_[i];
        return c && (this.observers_[i] = c.filter(u => u.handler !== o)), this
    }
    emit(i, o) {
        const c = this.observers_[i];
        c && c.forEach(u => {
            u.handler(o)
        })
    }
}
class ComplexValue {
    constructor(i, o) {
        var c;
        this.constraint_ = o ? .constraint, this.equals_ = (c = o ? .equals) !== null && c !== void 0 ? c : (u, p) => u === p, this.emitter = new Emitter, this.rawValue_ = i
    }
    get constraint() {
        return this.constraint_
    }
    get rawValue() {
        return this.rawValue_
    }
    set rawValue(i) {
        this.setRawValue(i, {
            forceEmit: !1,
            last: !0
        })
    }
    setRawValue(i, o) {
        const c = o ? ? {
                forceEmit: !1,
                last: !0
            },
            u = this.constraint_ ? this.constraint_.constrain(i) : i,
            p = this.rawValue_;
        this.equals_(p, u) && !c.forceEmit || (this.emitter.emit("beforechange", {
            sender: this
        }), this.rawValue_ = u, this.emitter.emit("change", {
            options: c,
            previousRawValue: p,
            rawValue: u,
            sender: this
        }))
    }
}
class PrimitiveValue {
    constructor(i) {
        this.emitter = new Emitter, this.value_ = i
    }
    get rawValue() {
        return this.value_
    }
    set rawValue(i) {
        this.setRawValue(i, {
            forceEmit: !1,
            last: !0
        })
    }
    setRawValue(i, o) {
        const c = o ? ? {
                forceEmit: !1,
                last: !0
            },
            u = this.value_;
        u === i && !c.forceEmit || (this.emitter.emit("beforechange", {
            sender: this
        }), this.value_ = i, this.emitter.emit("change", {
            options: c,
            previousRawValue: u,
            rawValue: this.value_,
            sender: this
        }))
    }
}
class ReadonlyPrimitiveValue {
    constructor(i) {
        this.emitter = new Emitter, this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.value_ = i, this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_)
    }
    get rawValue() {
        return this.value_.rawValue
    }
    onValueBeforeChange_(i) {
        this.emitter.emit("beforechange", Object.assign(Object.assign({}, i), {
            sender: this
        }))
    }
    onValueChange_(i) {
        this.emitter.emit("change", Object.assign(Object.assign({}, i), {
            sender: this
        }))
    }
}

function createValue(l, i) {
    const o = i ? .constraint,
        c = i ? .equals;
    return !o && !c ? new PrimitiveValue(l) : new ComplexValue(l, i)
}

function createReadonlyValue(l) {
    return [new ReadonlyPrimitiveValue(l), (i, o) => {
        l.setRawValue(i, o)
    }]
}
class ValueMap {
    constructor(i) {
        this.emitter = new Emitter, this.valMap_ = i;
        for (const o in this.valMap_) this.valMap_[o].emitter.on("change", () => {
            this.emitter.emit("change", {
                key: o,
                sender: this
            })
        })
    }
    static createCore(i) {
        return Object.keys(i).reduce((c, u) => Object.assign(c, {
            [u]: createValue(i[u])
        }), {})
    }
    static fromObject(i) {
        const o = this.createCore(i);
        return new ValueMap(o)
    }
    get(i) {
        return this.valMap_[i].rawValue
    }
    set(i, o) {
        this.valMap_[i].rawValue = o
    }
    value(i) {
        return this.valMap_[i]
    }
}
class DefiniteRangeConstraint {
    constructor(i) {
        this.values = ValueMap.fromObject({
            max: i.max,
            min: i.min
        })
    }
    constrain(i) {
        const o = this.values.get("max"),
            c = this.values.get("min");
        return Math.min(Math.max(i, c), o)
    }
}
class RangeConstraint {
    constructor(i) {
        this.values = ValueMap.fromObject({
            max: i.max,
            min: i.min
        })
    }
    constrain(i) {
        const o = this.values.get("max"),
            c = this.values.get("min");
        let u = i;
        return isEmpty(c) || (u = Math.max(u, c)), isEmpty(o) || (u = Math.min(u, o)), u
    }
}
class StepConstraint {
    constructor(i, o = 0) {
        this.step = i, this.origin = o
    }
    constrain(i) {
        const o = this.origin % this.step,
            c = Math.round((i - o) / this.step);
        return o + c * this.step
    }
}
class NumberLiteralNode {
    constructor(i) {
        this.text = i
    }
    evaluate() {
        return Number(this.text)
    }
    toString() {
        return this.text
    }
}
const BINARY_OPERATION_MAP = {
    "**": (l, i) => Math.pow(l, i),
    "*": (l, i) => l * i,
    "/": (l, i) => l / i,
    "%": (l, i) => l % i,
    "+": (l, i) => l + i,
    "-": (l, i) => l - i,
    "<<": (l, i) => l << i,
    ">>": (l, i) => l >> i,
    ">>>": (l, i) => l >>> i,
    "&": (l, i) => l & i,
    "^": (l, i) => l ^ i,
    "|": (l, i) => l | i
};
class BinaryOperationNode {
    constructor(i, o, c) {
        this.left = o, this.operator = i, this.right = c
    }
    evaluate() {
        const i = BINARY_OPERATION_MAP[this.operator];
        if (!i) throw new Error(`unexpected binary operator: '${this.operator}`);
        return i(this.left.evaluate(), this.right.evaluate())
    }
    toString() {
        return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
    }
}
const UNARY_OPERATION_MAP = {
    "+": l => l,
    "-": l => -l,
    "~": l => ~l
};
class UnaryOperationNode {
    constructor(i, o) {
        this.operator = i, this.expression = o
    }
    evaluate() {
        const i = UNARY_OPERATION_MAP[this.operator];
        if (!i) throw new Error(`unexpected unary operator: '${this.operator}`);
        return i(this.expression.evaluate())
    }
    toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
    }
}

function combineReader(l) {
    return (i, o) => {
        for (let c = 0; c < l.length; c++) {
            const u = l[c](i, o);
            if (u !== "") return u
        }
        return ""
    }
}

function readWhitespace(l, i) {
    var o;
    const c = l.substr(i).match(/^\s+/);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readNonZeroDigit(l, i) {
    const o = l.substr(i, 1);
    return o.match(/^[1-9]$/) ? o : ""
}

function readDecimalDigits(l, i) {
    var o;
    const c = l.substr(i).match(/^[0-9]+/);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readSignedInteger(l, i) {
    const o = readDecimalDigits(l, i);
    if (o !== "") return o;
    const c = l.substr(i, 1);
    if (i += 1, c !== "-" && c !== "+") return "";
    const u = readDecimalDigits(l, i);
    return u === "" ? "" : c + u
}

function readExponentPart(l, i) {
    const o = l.substr(i, 1);
    if (i += 1, o.toLowerCase() !== "e") return "";
    const c = readSignedInteger(l, i);
    return c === "" ? "" : o + c
}

function readDecimalIntegerLiteral(l, i) {
    const o = l.substr(i, 1);
    if (o === "0") return o;
    const c = readNonZeroDigit(l, i);
    return i += c.length, c === "" ? "" : c + readDecimalDigits(l, i)
}

function readDecimalLiteral1(l, i) {
    const o = readDecimalIntegerLiteral(l, i);
    if (i += o.length, o === "") return "";
    const c = l.substr(i, 1);
    if (i += c.length, c !== ".") return "";
    const u = readDecimalDigits(l, i);
    return i += u.length, o + c + u + readExponentPart(l, i)
}

function readDecimalLiteral2(l, i) {
    const o = l.substr(i, 1);
    if (i += o.length, o !== ".") return "";
    const c = readDecimalDigits(l, i);
    return i += c.length, c === "" ? "" : o + c + readExponentPart(l, i)
}

function readDecimalLiteral3(l, i) {
    const o = readDecimalIntegerLiteral(l, i);
    return i += o.length, o === "" ? "" : o + readExponentPart(l, i)
}
const readDecimalLiteral = combineReader([readDecimalLiteral1, readDecimalLiteral2, readDecimalLiteral3]);

function parseBinaryDigits(l, i) {
    var o;
    const c = l.substr(i).match(/^[01]+/);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readBinaryIntegerLiteral(l, i) {
    const o = l.substr(i, 2);
    if (i += o.length, o.toLowerCase() !== "0b") return "";
    const c = parseBinaryDigits(l, i);
    return c === "" ? "" : o + c
}

function readOctalDigits(l, i) {
    var o;
    const c = l.substr(i).match(/^[0-7]+/);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readOctalIntegerLiteral(l, i) {
    const o = l.substr(i, 2);
    if (i += o.length, o.toLowerCase() !== "0o") return "";
    const c = readOctalDigits(l, i);
    return c === "" ? "" : o + c
}

function readHexDigits(l, i) {
    var o;
    const c = l.substr(i).match(/^[0-9a-f]+/i);
    return (o = c && c[0]) !== null && o !== void 0 ? o : ""
}

function readHexIntegerLiteral(l, i) {
    const o = l.substr(i, 2);
    if (i += o.length, o.toLowerCase() !== "0x") return "";
    const c = readHexDigits(l, i);
    return c === "" ? "" : o + c
}
const readNonDecimalIntegerLiteral = combineReader([readBinaryIntegerLiteral, readOctalIntegerLiteral, readHexIntegerLiteral]),
    readNumericLiteral = combineReader([readNonDecimalIntegerLiteral, readDecimalLiteral]);

function parseLiteral(l, i) {
    const o = readNumericLiteral(l, i);
    return i += o.length, o === "" ? null : {
        evaluable: new NumberLiteralNode(o),
        cursor: i
    }
}

function parseParenthesizedExpression(l, i) {
    const o = l.substr(i, 1);
    if (i += o.length, o !== "(") return null;
    const c = parseExpression(l, i);
    if (!c) return null;
    i = c.cursor, i += readWhitespace(l, i).length;
    const u = l.substr(i, 1);
    return i += u.length, u !== ")" ? null : {
        evaluable: c.evaluable,
        cursor: i
    }
}

function parsePrimaryExpression(l, i) {
    var o;
    return (o = parseLiteral(l, i)) !== null && o !== void 0 ? o : parseParenthesizedExpression(l, i)
}

function parseUnaryExpression(l, i) {
    const o = parsePrimaryExpression(l, i);
    if (o) return o;
    const c = l.substr(i, 1);
    if (i += c.length, c !== "+" && c !== "-" && c !== "~") return null;
    const u = parseUnaryExpression(l, i);
    return u ? (i = u.cursor, {
        cursor: i,
        evaluable: new UnaryOperationNode(c, u.evaluable)
    }) : null
}

function readBinaryOperator(l, i, o) {
    o += readWhitespace(i, o).length;
    const c = l.filter(u => i.startsWith(u, o))[0];
    return c ? (o += c.length, o += readWhitespace(i, o).length, {
        cursor: o,
        operator: c
    }) : null
}

function createBinaryOperationExpressionParser(l, i) {
    return (o, c) => {
        const u = l(o, c);
        if (!u) return null;
        c = u.cursor;
        let p = u.evaluable;
        for (;;) {
            const m = readBinaryOperator(i, o, c);
            if (!m) break;
            c = m.cursor;
            const g = l(o, c);
            if (!g) return null;
            c = g.cursor, p = new BinaryOperationNode(m.operator, p, g.evaluable)
        }
        return p ? {
            cursor: c,
            evaluable: p
        } : null
    }
}
const parseBinaryOperationExpression = [
    ["**"],
    ["*", "/", "%"],
    ["+", "-"],
    ["<<", ">>>", ">>"],
    ["&"],
    ["^"],
    ["|"]
].reduce((l, i) => createBinaryOperationExpressionParser(l, i), parseUnaryExpression);

function parseExpression(l, i) {
    return i += readWhitespace(l, i).length, parseBinaryOperationExpression(l, i)
}

function parseEcmaNumberExpression(l) {
    const i = parseExpression(l, 0);
    return !i || i.cursor + readWhitespace(l, i.cursor).length !== l.length ? null : i.evaluable
}

function parseNumber(l) {
    var i;
    const o = parseEcmaNumberExpression(l);
    return (i = o ? .evaluate()) !== null && i !== void 0 ? i : null
}

function numberFromUnknown(l) {
    if (typeof l == "number") return l;
    if (typeof l == "string") {
        const i = parseNumber(l);
        if (!isEmpty(i)) return i
    }
    return 0
}

function createNumberFormatter(l) {
    return i => i.toFixed(Math.max(Math.min(l, 20), 0))
}

function mapRange$1(l, i, o, c, u) {
    const p = (l - i) / (o - i);
    return c + p * (u - c)
}

function getDecimalDigits(l) {
    return String(l.toFixed(10)).split(".")[1].replace(/0+$/, "").length
}

function constrainRange(l, i, o) {
    return Math.min(Math.max(l, i), o)
}

function loopRange(l, i) {
    return (l % i + i) % i
}

function getSuitableDecimalDigits(l, i) {
    return isEmpty(l.step) ? Math.max(getDecimalDigits(i), 2) : getDecimalDigits(l.step)
}

function getSuitableKeyScale(l) {
    var i;
    return (i = l.step) !== null && i !== void 0 ? i : 1
}

function getSuitablePointerScale(l, i) {
    var o;
    const c = Math.abs((o = l.step) !== null && o !== void 0 ? o : i);
    return c === 0 ? .1 : Math.pow(10, Math.floor(Math.log10(c)) - 1)
}

function createStepConstraint(l, i) {
    return isEmpty(l.step) ? null : new StepConstraint(l.step, i)
}

function createRangeConstraint(l) {
    return !isEmpty(l.max) && !isEmpty(l.min) ? new DefiniteRangeConstraint({
        max: l.max,
        min: l.min
    }) : !isEmpty(l.max) || !isEmpty(l.min) ? new RangeConstraint({
        max: l.max,
        min: l.min
    }) : null
}

function createNumberTextPropsObject(l, i) {
    var o, c, u;
    return {
        formatter: (o = l.format) !== null && o !== void 0 ? o : createNumberFormatter(getSuitableDecimalDigits(l, i)),
        keyScale: (c = l.keyScale) !== null && c !== void 0 ? c : getSuitableKeyScale(l),
        pointerScale: (u = l.pointerScale) !== null && u !== void 0 ? u : getSuitablePointerScale(l, i)
    }
}

function createNumberTextInputParamsParser(l) {
    return {
        format: l.optional.function,
        keyScale: l.optional.number,
        max: l.optional.number,
        min: l.optional.number,
        pointerScale: l.optional.number,
        step: l.optional.number
    }
}

function createPointAxis(l) {
    return {
        constraint: l.constraint,
        textProps: ValueMap.fromObject(createNumberTextPropsObject(l.params, l.initialValue))
    }
}
class BladeApi {
    constructor(i) {
        this.controller = i
    }
    get element() {
        return this.controller.view.element
    }
    get disabled() {
        return this.controller.viewProps.get("disabled")
    }
    set disabled(i) {
        this.controller.viewProps.set("disabled", i)
    }
    get hidden() {
        return this.controller.viewProps.get("hidden")
    }
    set hidden(i) {
        this.controller.viewProps.set("hidden", i)
    }
    dispose() {
        this.controller.viewProps.set("disposed", !0)
    }
    importState(i) {
        return this.controller.importState(i)
    }
    exportState() {
        return this.controller.exportState()
    }
}
class TpEvent {
    constructor(i) {
        this.target = i
    }
}
class TpChangeEvent extends TpEvent {
    constructor(i, o, c) {
        super(i), this.value = o, this.last = c ? ? !0
    }
}
class TpFoldEvent extends TpEvent {
    constructor(i, o) {
        super(i), this.expanded = o
    }
}
class TpTabSelectEvent extends TpEvent {
    constructor(i, o) {
        super(i), this.index = o
    }
}
class BindingApi extends BladeApi {
    constructor(i) {
        super(i), this.onValueChange_ = this.onValueChange_.bind(this), this.emitter_ = new Emitter, this.controller.value.emitter.on("change", this.onValueChange_)
    }
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(i) {
        this.controller.labelController.props.set("label", i)
    }
    get key() {
        return this.controller.value.binding.target.key
    }
    get tag() {
        return this.controller.tag
    }
    set tag(i) {
        this.controller.tag = i
    }
    on(i, o) {
        const c = o.bind(this);
        return this.emitter_.on(i, u => {
            c(u)
        }), this
    }
    refresh() {
        this.controller.value.fetch()
    }
    onValueChange_(i) {
        const o = this.controller.value;
        this.emitter_.emit("change", new TpChangeEvent(this, o.binding.target.read(), i.options.last))
    }
}

function parseObject(l, i) {
    const c = Object.keys(i).reduce((u, p) => {
        if (u === void 0) return;
        const m = i[p],
            g = m(l[p]);
        return g.succeeded ? Object.assign(Object.assign({}, u), {
            [p]: g.value
        }) : void 0
    }, {});
    return c
}

function parseArray(l, i) {
    return l.reduce((o, c) => {
        if (o === void 0) return;
        const u = i(c);
        if (!(!u.succeeded || u.value === void 0)) return [...o, u.value]
    }, [])
}

function isObject$2(l) {
    return l === null ? !1 : typeof l == "object"
}

function createMicroParserBuilder(l) {
    return i => o => {
        if (!i && o === void 0) return {
            succeeded: !1,
            value: void 0
        };
        if (i && o === void 0) return {
            succeeded: !0,
            value: void 0
        };
        const c = l(o);
        return c !== void 0 ? {
            succeeded: !0,
            value: c
        } : {
            succeeded: !1,
            value: void 0
        }
    }
}

function createMicroParserBuilders(l) {
    return {
        custom: i => createMicroParserBuilder(i)(l),
        boolean: createMicroParserBuilder(i => typeof i == "boolean" ? i : void 0)(l),
        number: createMicroParserBuilder(i => typeof i == "number" ? i : void 0)(l),
        string: createMicroParserBuilder(i => typeof i == "string" ? i : void 0)(l),
        function: createMicroParserBuilder(i => typeof i == "function" ? i : void 0)(l),
        constant: i => createMicroParserBuilder(o => o === i ? i : void 0)(l),
        raw: createMicroParserBuilder(i => i)(l),
        object: i => createMicroParserBuilder(o => {
            if (isObject$2(o)) return parseObject(o, i)
        })(l),
        array: i => createMicroParserBuilder(o => {
            if (Array.isArray(o)) return parseArray(o, i)
        })(l)
    }
}
const MicroParsers = {
    optional: createMicroParserBuilders(!0),
    required: createMicroParserBuilders(!1)
};

function parseRecord(l, i) {
    const o = i(MicroParsers),
        c = MicroParsers.required.object(o)(l);
    return c.succeeded ? c.value : void 0
}

function importBladeState(l, i, o, c) {
    if (i && !i(l)) return !1;
    const u = parseRecord(l, o);
    return u ? c(u) : !1
}

function exportBladeState(l, i) {
    var o;
    return deepMerge((o = l ? .()) !== null && o !== void 0 ? o : {}, i)
}

function isValueBladeController(l) {
    return "value" in l
}

function isBindingValue(l) {
    if (!isObject$1$1(l) || !("binding" in l)) return !1;
    const i = l.binding;
    return isBinding(i)
}
const SVG_NS = "http://www.w3.org/2000/svg";

function forceReflow(l) {
    l.offsetHeight
}

function disableTransitionTemporarily(l, i) {
    const o = l.style.transition;
    l.style.transition = "none", i(), l.style.transition = o
}

function supportsTouch(l) {
    return l.ontouchstart !== void 0
}

function getCanvasContext(l) {
    const i = l.ownerDocument.defaultView;
    return i && "document" in i ? l.getContext("2d", {
        willReadFrequently: !0
    }) : null
}
const ICON_ID_TO_INNER_HTML_MAP = {
    check: '<path d="M2 8l4 4l8 -8"/>',
    dropdown: '<path d="M5 7h6l-3 3 z"/>',
    p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
};

function createSvgIconElement(l, i) {
    const o = l.createElementNS(SVG_NS, "svg");
    return o.innerHTML = ICON_ID_TO_INNER_HTML_MAP[i], o
}

function insertElementAt(l, i, o) {
    l.insertBefore(i, l.children[o])
}

function removeElement(l) {
    l.parentElement && l.parentElement.removeChild(l)
}

function removeChildElements(l) {
    for (; l.children.length > 0;) l.removeChild(l.children[0])
}

function removeChildNodes(l) {
    for (; l.childNodes.length > 0;) l.removeChild(l.childNodes[0])
}

function findNextTarget(l) {
    return l.relatedTarget ? l.relatedTarget : "explicitOriginalTarget" in l ? l.explicitOriginalTarget : null
}

function bindValue(l, i) {
    l.emitter.on("change", o => {
        i(o.rawValue)
    }), i(l.rawValue)
}

function bindValueMap(l, i, o) {
    bindValue(l.value(i), o)
}
const PREFIX = "tp";

function ClassName(l) {
    return (o, c) => [PREFIX, "-", l, "v", o ? `_${o}` : "", c ? `-${c}` : ""].join("")
}
const cn$q = ClassName("lbl");

function createLabelNode(l, i) {
    const o = l.createDocumentFragment();
    return i.split(`
`).map(u => l.createTextNode(u)).forEach((u, p) => {
        p > 0 && o.appendChild(l.createElement("br")), o.appendChild(u)
    }), o
}
class LabelView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$q()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$q("l")), bindValueMap(o.props, "label", p => {
            isEmpty(p) ? this.element.classList.add(cn$q(void 0, "nol")) : (this.element.classList.remove(cn$q(void 0, "nol")), removeChildNodes(c), c.appendChild(createLabelNode(i, p)))
        }), this.element.appendChild(c), this.labelElement = c;
        const u = i.createElement("div");
        u.classList.add(cn$q("v")), this.element.appendChild(u), this.valueElement = u
    }
}
class LabelController {
    constructor(i, o) {
        this.props = o.props, this.valueController = o.valueController, this.viewProps = o.valueController.viewProps, this.view = new LabelView(i, {
            props: o.props,
            viewProps: this.viewProps
        }), this.view.valueElement.appendChild(this.valueController.view.element)
    }
    importProps(i) {
        return importBladeState(i, null, o => ({
            label: o.optional.string
        }), o => (this.props.set("label", o.label), !0))
    }
    exportProps() {
        return exportBladeState(null, {
            label: this.props.get("label")
        })
    }
}

function getAllBladePositions() {
    return ["veryfirst", "first", "last", "verylast"]
}
const cn$p = ClassName(""),
    POS_TO_CLASS_NAME_MAP = {
        veryfirst: "vfst",
        first: "fst",
        last: "lst",
        verylast: "vlst"
    };
class BladeController {
    constructor(i) {
        this.parent_ = null, this.blade = i.blade, this.view = i.view, this.viewProps = i.viewProps;
        const o = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
            getAllBladePositions().forEach(c => {
                o.classList.remove(cn$p(void 0, POS_TO_CLASS_NAME_MAP[c]))
            }), this.blade.get("positions").forEach(c => {
                o.classList.add(cn$p(void 0, POS_TO_CLASS_NAME_MAP[c]))
            })
        }), this.viewProps.handleDispose(() => {
            removeElement(o)
        })
    }
    get parent() {
        return this.parent_
    }
    set parent(i) {
        this.parent_ = i, this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null)
    }
    importState(i) {
        return importBladeState(i, null, o => ({
            disabled: o.required.boolean,
            hidden: o.required.boolean
        }), o => (this.viewProps.importState(o), !0))
    }
    exportState() {
        return exportBladeState(null, Object.assign({}, this.viewProps.exportState()))
    }
}
class ButtonApi extends BladeApi {
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(i) {
        this.controller.labelController.props.set("label", i)
    }
    get title() {
        var i;
        return (i = this.controller.buttonController.props.get("title")) !== null && i !== void 0 ? i : ""
    }
    set title(i) {
        this.controller.buttonController.props.set("title", i)
    }
    on(i, o) {
        const c = o.bind(this);
        return this.controller.buttonController.emitter.on(i, () => {
            c(new TpEvent(this))
        }), this
    }
}

function applyClass(l, i, o) {
    o ? l.classList.add(i) : l.classList.remove(i)
}

function valueToClassName(l, i) {
    return o => {
        applyClass(l, i, o)
    }
}

function bindValueToTextContent(l, i) {
    bindValue(l, o => {
        i.textContent = o ? ? ""
    })
}
const cn$o = ClassName("btn");
class ButtonView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$o()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("button");
        c.classList.add(cn$o("b")), o.viewProps.bindDisabled(c), this.element.appendChild(c), this.buttonElement = c;
        const u = i.createElement("div");
        u.classList.add(cn$o("t")), bindValueToTextContent(o.props.value("title"), u), this.buttonElement.appendChild(u)
    }
}
class ButtonController {
    constructor(i, o) {
        this.emitter = new Emitter, this.onClick_ = this.onClick_.bind(this), this.props = o.props, this.viewProps = o.viewProps, this.view = new ButtonView(i, {
            props: this.props,
            viewProps: this.viewProps
        }), this.view.buttonElement.addEventListener("click", this.onClick_)
    }
    importProps(i) {
        return importBladeState(i, null, o => ({
            title: o.optional.string
        }), o => (this.props.set("title", o.title), !0))
    }
    exportProps() {
        return exportBladeState(null, {
            title: this.props.get("title")
        })
    }
    onClick_() {
        this.emitter.emit("click", {
            sender: this
        })
    }
}
class ButtonBladeController extends BladeController {
    constructor(i, o) {
        const c = new ButtonController(i, {
                props: o.buttonProps,
                viewProps: o.viewProps
            }),
            u = new LabelController(i, {
                blade: o.blade,
                props: o.labelProps,
                valueController: c
            });
        super({
            blade: o.blade,
            view: u.view,
            viewProps: o.viewProps
        }), this.buttonController = c, this.labelController = u
    }
    importState(i) {
        return importBladeState(i, o => super.importState(o) && this.buttonController.importProps(o) && this.labelController.importProps(o), () => ({}), () => !0)
    }
    exportState() {
        return exportBladeState(() => super.exportState(), Object.assign(Object.assign({}, this.buttonController.exportProps()), this.labelController.exportProps()))
    }
}
class Semver {
    constructor(i) {
        const [o, c] = i.split("-"), u = o.split(".");
        this.major = parseInt(u[0], 10), this.minor = parseInt(u[1], 10), this.patch = parseInt(u[2], 10), this.prerelease = c ? ? null
    }
    toString() {
        const i = [this.major, this.minor, this.patch].join(".");
        return this.prerelease !== null ? [i, this.prerelease].join("-") : i
    }
}
const VERSION = new Semver("2.0.1");

function createPlugin(l) {
    return Object.assign({
        core: VERSION
    }, l)
}
createPlugin({
    id: "button",
    type: "blade",
    accept(l) {
        const i = parseRecord(l, o => ({
            title: o.required.string,
            view: o.required.constant("button"),
            label: o.optional.string
        }));
        return i ? {
            params: i
        } : null
    },
    controller(l) {
        return new ButtonBladeController(l.document, {
            blade: l.blade,
            buttonProps: ValueMap.fromObject({
                title: l.params.title
            }),
            labelProps: ValueMap.fromObject({
                label: l.params.label
            }),
            viewProps: l.viewProps
        })
    },
    api(l) {
        return l.controller instanceof ButtonBladeController ? new ButtonApi(l.controller) : null
    }
});

function addButtonAsBlade(l, i) {
    return l.addBlade(Object.assign(Object.assign({}, i), {
        view: "button"
    }))
}

function addFolderAsBlade(l, i) {
    return l.addBlade(Object.assign(Object.assign({}, i), {
        view: "folder"
    }))
}

function addTabAsBlade(l, i) {
    return l.addBlade(Object.assign(Object.assign({}, i), {
        view: "tab"
    }))
}

function isRefreshable(l) {
    return isObject$1$1(l) ? "refresh" in l && typeof l.refresh == "function" : !1
}

function createBindingTarget(l, i) {
    if (!BindingTarget.isBindable(l)) throw TpError.notBindable();
    return new BindingTarget(l, i)
}
class RackApi {
    constructor(i, o) {
        this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.controller_ = i, this.emitter_ = new Emitter, this.pool_ = o, this.controller_.rack.emitter.on("valuechange", this.onRackValueChange_)
    }
    get children() {
        return this.controller_.rack.children.map(i => this.pool_.createApi(i))
    }
    addBinding(i, o, c) {
        const u = c ? ? {},
            p = this.controller_.element.ownerDocument,
            m = this.pool_.createBinding(p, createBindingTarget(i, o), u),
            g = this.pool_.createBindingApi(m);
        return this.add(g, u.index)
    }
    addFolder(i) {
        return addFolderAsBlade(this, i)
    }
    addButton(i) {
        return addButtonAsBlade(this, i)
    }
    addTab(i) {
        return addTabAsBlade(this, i)
    }
    add(i, o) {
        const c = i.controller;
        return this.controller_.rack.add(c, o), i
    }
    remove(i) {
        this.controller_.rack.remove(i.controller)
    }
    addBlade(i) {
        const o = this.controller_.element.ownerDocument,
            c = this.pool_.createBlade(o, i),
            u = this.pool_.createApi(c);
        return this.add(u, i.index)
    }
    on(i, o) {
        const c = o.bind(this);
        return this.emitter_.on(i, u => {
            c(u)
        }), this
    }
    refresh() {
        this.children.forEach(i => {
            isRefreshable(i) && i.refresh()
        })
    }
    onRackValueChange_(i) {
        const o = i.bladeController,
            c = this.pool_.createApi(o),
            u = isBindingValue(o.value) ? o.value.binding : null;
        this.emitter_.emit("change", new TpChangeEvent(c, u ? u.target.read() : o.value.rawValue, i.options.last))
    }
}
class ContainerBladeApi extends BladeApi {
    constructor(i, o) {
        super(i), this.rackApi_ = new RackApi(i.rackController, o)
    }
    refresh() {
        this.rackApi_.refresh()
    }
}
class ContainerBladeController extends BladeController {
    constructor(i) {
        super({
            blade: i.blade,
            view: i.view,
            viewProps: i.rackController.viewProps
        }), this.rackController = i.rackController
    }
    importState(i) {
        return importBladeState(i, o => super.importState(o), o => ({
            children: o.required.array(o.required.raw)
        }), o => this.rackController.rack.children.every((c, u) => c.importState(o.children[u])))
    }
    exportState() {
        return exportBladeState(() => super.exportState(), {
            children: this.rackController.rack.children.map(i => i.exportState())
        })
    }
}

function isContainerBladeController(l) {
    return "rackController" in l
}
class NestedOrderedSet {
    constructor(i) {
        this.emitter = new Emitter, this.items_ = [], this.cache_ = new Set, this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = i
    }
    get items() {
        return this.items_
    }
    allItems() {
        return Array.from(this.cache_)
    }
    find(i) {
        for (const o of this.allItems())
            if (i(o)) return o;
        return null
    }
    includes(i) {
        return this.cache_.has(i)
    }
    add(i, o) {
        if (this.includes(i)) throw TpError.shouldNeverHappen();
        const c = o !== void 0 ? o : this.items_.length;
        this.items_.splice(c, 0, i), this.cache_.add(i);
        const u = this.extract_(i);
        u && (u.emitter.on("add", this.onSubListAdd_), u.emitter.on("remove", this.onSubListRemove_), u.allItems().forEach(p => {
            this.cache_.add(p)
        })), this.emitter.emit("add", {
            index: c,
            item: i,
            root: this,
            target: this
        })
    }
    remove(i) {
        const o = this.items_.indexOf(i);
        if (o < 0) return;
        this.items_.splice(o, 1), this.cache_.delete(i);
        const c = this.extract_(i);
        c && (c.allItems().forEach(u => {
            this.cache_.delete(u)
        }), c.emitter.off("add", this.onSubListAdd_), c.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
            index: o,
            item: i,
            root: this,
            target: this
        })
    }
    onSubListAdd_(i) {
        this.cache_.add(i.item), this.emitter.emit("add", {
            index: i.index,
            item: i.item,
            root: this,
            target: i.target
        })
    }
    onSubListRemove_(i) {
        this.cache_.delete(i.item), this.emitter.emit("remove", {
            index: i.index,
            item: i.item,
            root: this,
            target: i.target
        })
    }
}

function findValueBladeController(l, i) {
    for (let o = 0; o < l.length; o++) {
        const c = l[o];
        if (isValueBladeController(c) && c.value === i) return c
    }
    return null
}

function findSubBladeControllerSet(l) {
    return isContainerBladeController(l) ? l.rackController.rack.bcSet_ : null
}
class Rack {
    constructor(i) {
        var o, c;
        this.emitter = new Emitter, this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onRackLayout_ = this.onRackLayout_.bind(this), this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.blade_ = (o = i.blade) !== null && o !== void 0 ? o : null, (c = this.blade_) === null || c === void 0 || c.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = i.viewProps, this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_)
    }
    get children() {
        return this.bcSet_.items
    }
    add(i, o) {
        var c;
        (c = i.parent) === null || c === void 0 || c.remove(i), i.parent = this, this.bcSet_.add(i, o)
    }
    remove(i) {
        i.parent = null, this.bcSet_.remove(i)
    }
    find(i) {
        return this.bcSet_.allItems().filter(i)
    }
    onSetAdd_(i) {
        this.updatePositions_();
        const o = i.target === i.root;
        if (this.emitter.emit("add", {
                bladeController: i.item,
                index: i.index,
                root: o,
                sender: this
            }), !o) return;
        const c = i.item;
        if (c.viewProps.emitter.on("change", this.onChildViewPropsChange_), c.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), c.viewProps.handleDispose(this.onChildDispose_), isValueBladeController(c)) c.value.emitter.on("change", this.onChildValueChange_);
        else if (isContainerBladeController(c)) {
            const u = c.rackController.rack;
            if (u) {
                const p = u.emitter;
                p.on("layout", this.onRackLayout_), p.on("valuechange", this.onRackValueChange_)
            }
        }
    }
    onSetRemove_(i) {
        this.updatePositions_();
        const o = i.target === i.root;
        if (this.emitter.emit("remove", {
                bladeController: i.item,
                root: o,
                sender: this
            }), !o) return;
        const c = i.item;
        if (isValueBladeController(c)) c.value.emitter.off("change", this.onChildValueChange_);
        else if (isContainerBladeController(c)) {
            const u = c.rackController.rack;
            if (u) {
                const p = u.emitter;
                p.off("layout", this.onRackLayout_), p.off("valuechange", this.onRackValueChange_)
            }
        }
    }
    updatePositions_() {
        const i = this.bcSet_.items.filter(u => !u.viewProps.get("hidden")),
            o = i[0],
            c = i[i.length - 1];
        this.bcSet_.items.forEach(u => {
            const p = [];
            u === o && (p.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && p.push("veryfirst")), u === c && (p.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && p.push("verylast")), u.blade.set("positions", p)
        })
    }
    onChildPositionsChange_() {
        this.updatePositions_(), this.emitter.emit("layout", {
            sender: this
        })
    }
    onChildViewPropsChange_(i) {
        this.updatePositions_(), this.emitter.emit("layout", {
            sender: this
        })
    }
    onChildDispose_() {
        this.bcSet_.items.filter(o => o.viewProps.get("disposed")).forEach(o => {
            this.bcSet_.remove(o)
        })
    }
    onChildValueChange_(i) {
        const o = findValueBladeController(this.find(isValueBladeController), i.sender);
        if (!o) throw TpError.alreadyDisposed();
        this.emitter.emit("valuechange", {
            bladeController: o,
            options: i.options,
            sender: this
        })
    }
    onRackLayout_(i) {
        this.updatePositions_(), this.emitter.emit("layout", {
            sender: this
        })
    }
    onRackValueChange_(i) {
        this.emitter.emit("valuechange", {
            bladeController: i.bladeController,
            options: i.options,
            sender: this
        })
    }
    onBladePositionsChange_() {
        this.updatePositions_()
    }
}
class RackController {
    constructor(i) {
        this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.element = i.element, this.viewProps = i.viewProps;
        const o = new Rack({
            blade: i.root ? void 0 : i.blade,
            viewProps: i.viewProps
        });
        o.emitter.on("add", this.onRackAdd_), o.emitter.on("remove", this.onRackRemove_), this.rack = o, this.viewProps.handleDispose(() => {
            for (let c = this.rack.children.length - 1; c >= 0; c--) this.rack.children[c].viewProps.set("disposed", !0)
        })
    }
    onRackAdd_(i) {
        i.root && insertElementAt(this.element, i.bladeController.view.element, i.index)
    }
    onRackRemove_(i) {
        i.root && removeElement(i.bladeController.view.element)
    }
}

function createBlade() {
    return new ValueMap({
        positions: createValue([], {
            equals: deepEqualsArray
        })
    })
}
class Foldable extends ValueMap {
    constructor(i) {
        super(i)
    }
    static create(i) {
        const o = {
                completed: !0,
                expanded: i,
                expandedHeight: null,
                shouldFixHeight: !1,
                temporaryExpanded: null
            },
            c = ValueMap.createCore(o);
        return new Foldable(c)
    }
    get styleExpanded() {
        var i;
        return (i = this.get("temporaryExpanded")) !== null && i !== void 0 ? i : this.get("expanded")
    }
    get styleHeight() {
        if (!this.styleExpanded) return "0";
        const i = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !isEmpty(i) ? `${i}px` : "auto"
    }
    bindExpandedClass(i, o) {
        const c = () => {
            this.styleExpanded ? i.classList.add(o) : i.classList.remove(o)
        };
        bindValueMap(this, "expanded", c), bindValueMap(this, "temporaryExpanded", c)
    }
    cleanUpTransition() {
        this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0)
    }
}

function computeExpandedFolderHeight(l, i) {
    let o = 0;
    return disableTransitionTemporarily(i, () => {
        l.set("expandedHeight", null), l.set("temporaryExpanded", !0), forceReflow(i), o = i.clientHeight, l.set("temporaryExpanded", null), forceReflow(i)
    }), o
}

function applyHeight(l, i) {
    i.style.height = l.styleHeight
}

function bindFoldable(l, i) {
    l.value("expanded").emitter.on("beforechange", () => {
        if (l.set("completed", !1), isEmpty(l.get("expandedHeight"))) {
            const o = computeExpandedFolderHeight(l, i);
            o > 0 && l.set("expandedHeight", o)
        }
        l.set("shouldFixHeight", !0), forceReflow(i)
    }), l.emitter.on("change", () => {
        applyHeight(l, i)
    }), applyHeight(l, i), i.addEventListener("transitionend", o => {
        o.propertyName === "height" && l.cleanUpTransition()
    })
}
class FolderApi extends ContainerBladeApi {
    constructor(i, o) {
        super(i, o), this.emitter_ = new Emitter, this.controller.foldable.value("expanded").emitter.on("change", c => {
            this.emitter_.emit("fold", new TpFoldEvent(this, c.sender.rawValue))
        }), this.rackApi_.on("change", c => {
            this.emitter_.emit("change", c)
        })
    }
    get expanded() {
        return this.controller.foldable.get("expanded")
    }
    set expanded(i) {
        this.controller.foldable.set("expanded", i)
    }
    get title() {
        return this.controller.props.get("title")
    }
    set title(i) {
        this.controller.props.set("title", i)
    }
    get children() {
        return this.rackApi_.children
    }
    addBinding(i, o, c) {
        return this.rackApi_.addBinding(i, o, c)
    }
    addFolder(i) {
        return this.rackApi_.addFolder(i)
    }
    addButton(i) {
        return this.rackApi_.addButton(i)
    }
    addTab(i) {
        return this.rackApi_.addTab(i)
    }
    add(i, o) {
        return this.rackApi_.add(i, o)
    }
    remove(i) {
        this.rackApi_.remove(i)
    }
    addBlade(i) {
        return this.rackApi_.addBlade(i)
    }
    on(i, o) {
        const c = o.bind(this);
        return this.emitter_.on(i, u => {
            c(u)
        }), this
    }
}
const bladeContainerClassName = ClassName("cnt");
class FolderView {
    constructor(i, o) {
        var c;
        this.className_ = ClassName((c = o.viewName) !== null && c !== void 0 ? c : "fld"), this.element = i.createElement("div"), this.element.classList.add(this.className_(), bladeContainerClassName()), o.viewProps.bindClassModifiers(this.element), this.foldable_ = o.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), bindValueMap(this.foldable_, "completed", valueToClassName(this.element, this.className_(void 0, "cpl")));
        const u = i.createElement("button");
        u.classList.add(this.className_("b")), bindValueMap(o.props, "title", v => {
            isEmpty(v) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"))
        }), o.viewProps.bindDisabled(u), this.element.appendChild(u), this.buttonElement = u;
        const p = i.createElement("div");
        p.classList.add(this.className_("i")), this.element.appendChild(p);
        const m = i.createElement("div");
        m.classList.add(this.className_("t")), bindValueToTextContent(o.props.value("title"), m), this.buttonElement.appendChild(m), this.titleElement = m;
        const g = i.createElement("div");
        g.classList.add(this.className_("m")), this.buttonElement.appendChild(g);
        const _ = i.createElement("div");
        _.classList.add(this.className_("c")), this.element.appendChild(_), this.containerElement = _
    }
}
class FolderController extends ContainerBladeController {
    constructor(i, o) {
        var c;
        const u = Foldable.create((c = o.expanded) !== null && c !== void 0 ? c : !0),
            p = new FolderView(i, {
                foldable: u,
                props: o.props,
                viewName: o.root ? "rot" : void 0,
                viewProps: o.viewProps
            });
        super(Object.assign(Object.assign({}, o), {
            rackController: new RackController({
                blade: o.blade,
                element: p.containerElement,
                root: o.root,
                viewProps: o.viewProps
            }),
            view: p
        })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = o.props, this.foldable = u, bindFoldable(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
            this.foldable.cleanUpTransition()
        }), this.rackController.rack.emitter.on("remove", () => {
            this.foldable.cleanUpTransition()
        }), this.view.buttonElement.addEventListener("click", this.onTitleClick_)
    }
    get document() {
        return this.view.element.ownerDocument
    }
    importState(i) {
        return importBladeState(i, o => super.importState(o), o => ({
            expanded: o.required.boolean,
            title: o.optional.string
        }), o => (this.foldable.set("expanded", o.expanded), this.props.set("title", o.title), !0))
    }
    exportState() {
        return exportBladeState(() => super.exportState(), {
            expanded: this.foldable.get("expanded"),
            title: this.props.get("title")
        })
    }
    onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"))
    }
}
createPlugin({
    id: "folder",
    type: "blade",
    accept(l) {
        const i = parseRecord(l, o => ({
            title: o.required.string,
            view: o.required.constant("folder"),
            expanded: o.optional.boolean
        }));
        return i ? {
            params: i
        } : null
    },
    controller(l) {
        return new FolderController(l.document, {
            blade: l.blade,
            expanded: l.params.expanded,
            props: ValueMap.fromObject({
                title: l.params.title
            }),
            viewProps: l.viewProps
        })
    },
    api(l) {
        return l.controller instanceof FolderController ? new FolderApi(l.controller, l.pool) : null
    }
});
const cn$n = ClassName("");

function valueToModifier(l, i) {
    return valueToClassName(l, cn$n(void 0, i))
}
class ViewProps extends ValueMap {
    constructor(i) {
        var o;
        super(i), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue(createValue(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (o = this.get("parent")) === null || o === void 0 || o.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_)
    }
    static create(i) {
        var o, c, u;
        const p = i ? ? {};
        return new ViewProps(ValueMap.createCore({
            disabled: (o = p.disabled) !== null && o !== void 0 ? o : !1,
            disposed: !1,
            hidden: (c = p.hidden) !== null && c !== void 0 ? c : !1,
            parent: (u = p.parent) !== null && u !== void 0 ? u : null
        }))
    }
    get globalDisabled() {
        return this.globalDisabled_
    }
    bindClassModifiers(i) {
        bindValue(this.globalDisabled_, valueToModifier(i, "disabled")), bindValueMap(this, "hidden", valueToModifier(i, "hidden"))
    }
    bindDisabled(i) {
        bindValue(this.globalDisabled_, o => {
            i.disabled = o
        })
    }
    bindTabIndex(i) {
        bindValue(this.globalDisabled_, o => {
            i.tabIndex = o ? -1 : 0
        })
    }
    handleDispose(i) {
        this.value("disposed").emitter.on("change", o => {
            o && i()
        })
    }
    importState(i) {
        this.set("disabled", i.disabled), this.set("hidden", i.hidden)
    }
    exportState() {
        return {
            disabled: this.get("disabled"),
            hidden: this.get("hidden")
        }
    }
    getGlobalDisabled_() {
        const i = this.get("parent");
        return (i ? i.globalDisabled.rawValue : !1) || this.get("disabled")
    }
    updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_())
    }
    onDisabledChange_() {
        this.updateGlobalDisabled_()
    }
    onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_()
    }
    onParentChange_(i) {
        var o;
        const c = i.previousRawValue;
        c ? .globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (o = this.get("parent")) === null || o === void 0 || o.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_()
    }
}
const cn$m = ClassName("tbp");
class TabPageView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$m()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$m("c")), this.element.appendChild(c), this.containerElement = c
    }
}
const cn$l = ClassName("tbi");
class TabItemView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$l()), o.viewProps.bindClassModifiers(this.element), bindValueMap(o.props, "selected", p => {
            p ? this.element.classList.add(cn$l(void 0, "sel")) : this.element.classList.remove(cn$l(void 0, "sel"))
        });
        const c = i.createElement("button");
        c.classList.add(cn$l("b")), o.viewProps.bindDisabled(c), this.element.appendChild(c), this.buttonElement = c;
        const u = i.createElement("div");
        u.classList.add(cn$l("t")), bindValueToTextContent(o.props.value("title"), u), this.buttonElement.appendChild(u), this.titleElement = u
    }
}
class TabItemController {
    constructor(i, o) {
        this.emitter = new Emitter, this.onClick_ = this.onClick_.bind(this), this.props = o.props, this.viewProps = o.viewProps, this.view = new TabItemView(i, {
            props: o.props,
            viewProps: o.viewProps
        }), this.view.buttonElement.addEventListener("click", this.onClick_)
    }
    onClick_() {
        this.emitter.emit("click", {
            sender: this
        })
    }
}
class TabPageController extends ContainerBladeController {
    constructor(i, o) {
        const c = new TabPageView(i, {
            viewProps: o.viewProps
        });
        super(Object.assign(Object.assign({}, o), {
            rackController: new RackController({
                blade: o.blade,
                element: c.containerElement,
                viewProps: o.viewProps
            }),
            view: c
        })), this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new TabItemController(i, {
            props: o.itemProps,
            viewProps: ViewProps.create()
        }), this.ic_.emitter.on("click", this.onItemClick_), this.props = o.props, bindValueMap(this.props, "selected", u => {
            this.itemController.props.set("selected", u), this.viewProps.set("hidden", !u)
        })
    }
    get itemController() {
        return this.ic_
    }
    importState(i) {
        return importBladeState(i, o => super.importState(o), o => ({
            selected: o.required.boolean,
            title: o.required.string
        }), o => (this.ic_.props.set("selected", o.selected), this.ic_.props.set("title", o.title), !0))
    }
    exportState() {
        return exportBladeState(() => super.exportState(), {
            selected: this.ic_.props.get("selected"),
            title: this.ic_.props.get("title")
        })
    }
    onItemClick_() {
        this.props.set("selected", !0)
    }
}
class TabApi extends ContainerBladeApi {
    constructor(i, o) {
        super(i, o), this.emitter_ = new Emitter, this.onSelect_ = this.onSelect_.bind(this), this.pool_ = o, this.rackApi_.on("change", c => {
            this.emitter_.emit("change", c)
        }), this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_)
    }
    get pages() {
        return this.rackApi_.children
    }
    addPage(i) {
        const o = this.controller.view.element.ownerDocument,
            c = new TabPageController(o, {
                blade: createBlade(),
                itemProps: ValueMap.fromObject({
                    selected: !1,
                    title: i.title
                }),
                props: ValueMap.fromObject({
                    selected: !1
                }),
                viewProps: ViewProps.create()
            }),
            u = this.pool_.createApi(c);
        return this.rackApi_.add(u, i.index)
    }
    removePage(i) {
        this.rackApi_.remove(this.rackApi_.children[i])
    }
    on(i, o) {
        const c = o.bind(this);
        return this.emitter_.on(i, u => {
            c(u)
        }), this
    }
    onSelect_(i) {
        this.emitter_.emit("select", new TpTabSelectEvent(this, i.rawValue))
    }
}
class TabPageApi extends ContainerBladeApi {
    get title() {
        var i;
        return (i = this.controller.itemController.props.get("title")) !== null && i !== void 0 ? i : ""
    }
    set title(i) {
        this.controller.itemController.props.set("title", i)
    }
    get selected() {
        return this.controller.props.get("selected")
    }
    set selected(i) {
        this.controller.props.set("selected", i)
    }
    get children() {
        return this.rackApi_.children
    }
    addButton(i) {
        return this.rackApi_.addButton(i)
    }
    addFolder(i) {
        return this.rackApi_.addFolder(i)
    }
    addTab(i) {
        return this.rackApi_.addTab(i)
    }
    add(i, o) {
        this.rackApi_.add(i, o)
    }
    remove(i) {
        this.rackApi_.remove(i)
    }
    addBinding(i, o, c) {
        return this.rackApi_.addBinding(i, o, c)
    }
    addBlade(i) {
        return this.rackApi_.addBlade(i)
    }
}
const INDEX_NOT_SELECTED = -1;
class Tab {
    constructor() {
        this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = createValue(!0), this.selectedIndex = createValue(INDEX_NOT_SELECTED), this.items_ = []
    }
    add(i, o) {
        const c = o ? ? this.items_.length;
        this.items_.splice(c, 0, i), i.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_()
    }
    remove(i) {
        const o = this.items_.indexOf(i);
        o < 0 || (this.items_.splice(o, 1), i.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_())
    }
    keepSelection_() {
        if (this.items_.length === 0) {
            this.selectedIndex.rawValue = INDEX_NOT_SELECTED, this.empty.rawValue = !0;
            return
        }
        const i = this.items_.findIndex(o => o.rawValue);
        i < 0 ? (this.items_.forEach((o, c) => {
            o.rawValue = c === 0
        }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((o, c) => {
            o.rawValue = c === i
        }), this.selectedIndex.rawValue = i), this.empty.rawValue = !1
    }
    onItemSelectedChange_(i) {
        if (i.rawValue) {
            const o = this.items_.findIndex(c => c === i.sender);
            this.items_.forEach((c, u) => {
                c.rawValue = u === o
            }), this.selectedIndex.rawValue = o
        } else this.keepSelection_()
    }
}
const cn$k = ClassName("tab");
class TabView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$k(), bladeContainerClassName()), o.viewProps.bindClassModifiers(this.element), bindValue(o.empty, valueToClassName(this.element, cn$k(void 0, "nop")));
        const c = i.createElement("div");
        c.classList.add(cn$k("t")), this.element.appendChild(c), this.itemsElement = c;
        const u = i.createElement("div");
        u.classList.add(cn$k("i")), this.element.appendChild(u);
        const p = i.createElement("div");
        p.classList.add(cn$k("c")), this.element.appendChild(p), this.contentsElement = p
    }
}
class TabController extends ContainerBladeController {
    constructor(i, o) {
        const c = new Tab,
            u = new TabView(i, {
                empty: c.empty,
                viewProps: o.viewProps
            });
        super({
            blade: o.blade,
            rackController: new RackController({
                blade: o.blade,
                element: u.contentsElement,
                viewProps: o.viewProps
            }),
            view: u
        }), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
        const p = this.rackController.rack;
        p.emitter.on("add", this.onRackAdd_), p.emitter.on("remove", this.onRackRemove_), this.tab = c
    }
    add(i, o) {
        this.rackController.rack.add(i, o)
    }
    remove(i) {
        this.rackController.rack.remove(this.rackController.rack.children[i])
    }
    onRackAdd_(i) {
        if (!i.root) return;
        const o = i.bladeController;
        insertElementAt(this.view.itemsElement, o.itemController.view.element, i.index), o.itemController.viewProps.set("parent", this.viewProps), this.tab.add(o.props.value("selected"))
    }
    onRackRemove_(i) {
        if (!i.root) return;
        const o = i.bladeController;
        removeElement(o.itemController.view.element), o.itemController.viewProps.set("parent", null), this.tab.remove(o.props.value("selected"))
    }
}
createPlugin({
    id: "tab",
    type: "blade",
    accept(l) {
        const i = parseRecord(l, o => ({
            pages: o.required.array(o.required.object({
                title: o.required.string
            })),
            view: o.required.constant("tab")
        }));
        return !i || i.pages.length === 0 ? null : {
            params: i
        }
    },
    controller(l) {
        const i = new TabController(l.document, {
            blade: l.blade,
            viewProps: l.viewProps
        });
        return l.params.pages.forEach(o => {
            const c = new TabPageController(l.document, {
                blade: createBlade(),
                itemProps: ValueMap.fromObject({
                    selected: !1,
                    title: o.title
                }),
                props: ValueMap.fromObject({
                    selected: !1
                }),
                viewProps: ViewProps.create()
            });
            i.add(c)
        }), i
    },
    api(l) {
        return l.controller instanceof TabController ? new TabApi(l.controller, l.pool) : l.controller instanceof TabPageController ? new TabPageApi(l.controller, l.pool) : null
    }
});
class ListInputBindingApi extends BindingApi {
    get options() {
        return this.controller.valueController.props.get("options")
    }
    set options(i) {
        this.controller.valueController.props.set("options", i)
    }
}
class CompositeConstraint {
    constructor(i) {
        this.constraints = i
    }
    constrain(i) {
        return this.constraints.reduce((o, c) => c.constrain(o), i)
    }
}

function findConstraint(l, i) {
    if (l instanceof i) return l;
    if (l instanceof CompositeConstraint) {
        const o = l.constraints.reduce((c, u) => c || (u instanceof i ? u : null), null);
        if (o) return o
    }
    return null
}
class ListConstraint {
    constructor(i) {
        this.values = ValueMap.fromObject({
            options: i
        })
    }
    constrain(i) {
        const o = this.values.get("options");
        return o.length === 0 || o.filter(u => u.value === i).length > 0 ? i : o[0].value
    }
}

function parseListOptions(l) {
    var i;
    const o = MicroParsers;
    if (Array.isArray(l)) return (i = parseRecord({
        items: l
    }, c => ({
        items: c.required.array(c.required.object({
            text: c.required.string,
            value: c.required.raw
        }))
    }))) === null || i === void 0 ? void 0 : i.items;
    if (typeof l == "object") return o.required.raw(l).value
}

function normalizeListOptions(l) {
    if (Array.isArray(l)) return l;
    const i = [];
    return Object.keys(l).forEach(o => {
        i.push({
            text: o,
            value: l[o]
        })
    }), i
}

function createListConstraint(l) {
    return isEmpty(l) ? null : new ListConstraint(normalizeListOptions(l))
}
const cn$j = ClassName("lst");
class ListView {
    constructor(i, o) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = o.props, this.element = i.createElement("div"), this.element.classList.add(cn$j()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("select");
        c.classList.add(cn$j("s")), o.viewProps.bindDisabled(c), this.element.appendChild(c), this.selectElement = c;
        const u = i.createElement("div");
        u.classList.add(cn$j("m")), u.appendChild(createSvgIconElement(i, "dropdown")), this.element.appendChild(u), o.value.emitter.on("change", this.onValueChange_), this.value_ = o.value, bindValueMap(this.props_, "options", p => {
            removeChildElements(this.selectElement), p.forEach(m => {
                const g = i.createElement("option");
                g.textContent = m.text, this.selectElement.appendChild(g)
            }), this.update_()
        })
    }
    update_() {
        const i = this.props_.get("options").map(o => o.value);
        this.selectElement.selectedIndex = i.indexOf(this.value_.rawValue)
    }
    onValueChange_() {
        this.update_()
    }
}
class ListController {
    constructor(i, o) {
        this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = o.props, this.value = o.value, this.viewProps = o.viewProps, this.view = new ListView(i, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
        }), this.view.selectElement.addEventListener("change", this.onSelectChange_)
    }
    onSelectChange_(i) {
        const o = i.currentTarget;
        this.value.rawValue = this.props.get("options")[o.selectedIndex].value
    }
    importProps(i) {
        return importBladeState(i, null, o => ({
            options: o.required.custom(parseListOptions)
        }), o => (this.props.set("options", normalizeListOptions(o.options)), !0))
    }
    exportProps() {
        return exportBladeState(null, {
            options: this.props.get("options")
        })
    }
}
const cn$i = ClassName("pop");
class PopupView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$i()), o.viewProps.bindClassModifiers(this.element), bindValue(o.shows, valueToClassName(this.element, cn$i(void 0, "v")))
    }
}
class PopupController {
    constructor(i, o) {
        this.shows = createValue(!1), this.viewProps = o.viewProps, this.view = new PopupView(i, {
            shows: this.shows,
            viewProps: this.viewProps
        })
    }
}
const cn$h = ClassName("txt");
class TextView {
    constructor(i, o) {
        this.onChange_ = this.onChange_.bind(this), this.element = i.createElement("div"), this.element.classList.add(cn$h()), o.viewProps.bindClassModifiers(this.element), this.props_ = o.props, this.props_.emitter.on("change", this.onChange_);
        const c = i.createElement("input");
        c.classList.add(cn$h("i")), c.type = "text", o.viewProps.bindDisabled(c), this.element.appendChild(c), this.inputElement = c, o.value.emitter.on("change", this.onChange_), this.value_ = o.value, this.refresh()
    }
    refresh() {
        const i = this.props_.get("formatter");
        this.inputElement.value = i(this.value_.rawValue)
    }
    onChange_() {
        this.refresh()
    }
}
class TextController {
    constructor(i, o) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = o.parser, this.props = o.props, this.value = o.value, this.viewProps = o.viewProps, this.view = new TextView(i, {
            props: o.props,
            value: this.value,
            viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_)
    }
    onInputChange_(i) {
        const c = i.currentTarget.value,
            u = this.parser_(c);
        isEmpty(u) || (this.value.rawValue = u), this.view.refresh()
    }
}

function boolToString(l) {
    return String(l)
}

function boolFromUnknown(l) {
    return l === "false" ? !1 : !!l
}

function BooleanFormatter(l) {
    return boolToString(l)
}

function composeParsers(l) {
    return i => l.reduce((o, c) => o !== null ? o : c(i), null)
}
const innerFormatter = createNumberFormatter(0);

function formatPercentage(l) {
    return innerFormatter(l) + "%"
}

function stringFromUnknown(l) {
    return String(l)
}

function formatString(l) {
    return l
}

function connectValues({
    primary: l,
    secondary: i,
    forward: o,
    backward: c
}) {
    let u = !1;

    function p(m) {
        u || (u = !0, m(), u = !1)
    }
    l.emitter.on("change", m => {
        p(() => {
            i.setRawValue(o(l.rawValue, i.rawValue), m.options)
        })
    }), i.emitter.on("change", m => {
        p(() => {
            l.setRawValue(c(l.rawValue, i.rawValue), m.options)
        }), p(() => {
            i.setRawValue(o(l.rawValue, i.rawValue), m.options)
        })
    }), p(() => {
        i.setRawValue(o(l.rawValue, i.rawValue), {
            forceEmit: !1,
            last: !0
        })
    })
}

function getStepForKey(l, i) {
    const o = l * (i.altKey ? .1 : 1) * (i.shiftKey ? 10 : 1);
    return i.upKey ? +o : i.downKey ? -o : 0
}

function getVerticalStepKeys(l) {
    return {
        altKey: l.altKey,
        downKey: l.key === "ArrowDown",
        shiftKey: l.shiftKey,
        upKey: l.key === "ArrowUp"
    }
}

function getHorizontalStepKeys(l) {
    return {
        altKey: l.altKey,
        downKey: l.key === "ArrowLeft",
        shiftKey: l.shiftKey,
        upKey: l.key === "ArrowRight"
    }
}

function isVerticalArrowKey(l) {
    return l === "ArrowUp" || l === "ArrowDown"
}

function isArrowKey(l) {
    return isVerticalArrowKey(l) || l === "ArrowLeft" || l === "ArrowRight"
}

function computeOffset$1(l, i) {
    var o, c;
    const u = i.ownerDocument.defaultView,
        p = i.getBoundingClientRect();
    return {
        x: l.pageX - (((o = u && u.scrollX) !== null && o !== void 0 ? o : 0) + p.left),
        y: l.pageY - (((c = u && u.scrollY) !== null && c !== void 0 ? c : 0) + p.top)
    }
}
class PointerHandler {
    constructor(i) {
        this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = i, this.emitter = new Emitter, i.addEventListener("touchstart", this.onTouchStart_, {
            passive: !1
        }), i.addEventListener("touchmove", this.onTouchMove_, {
            passive: !0
        }), i.addEventListener("touchend", this.onTouchEnd_), i.addEventListener("mousedown", this.onMouseDown_)
    }
    computePosition_(i) {
        const o = this.elem_.getBoundingClientRect();
        return {
            bounds: {
                width: o.width,
                height: o.height
            },
            point: i ? {
                x: i.x,
                y: i.y
            } : null
        }
    }
    onMouseDown_(i) {
        var o;
        i.preventDefault(), (o = i.currentTarget) === null || o === void 0 || o.focus();
        const c = this.elem_.ownerDocument;
        c.addEventListener("mousemove", this.onDocumentMouseMove_), c.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
            altKey: i.altKey,
            data: this.computePosition_(computeOffset$1(i, this.elem_)),
            sender: this,
            shiftKey: i.shiftKey
        })
    }
    onDocumentMouseMove_(i) {
        this.emitter.emit("move", {
            altKey: i.altKey,
            data: this.computePosition_(computeOffset$1(i, this.elem_)),
            sender: this,
            shiftKey: i.shiftKey
        })
    }
    onDocumentMouseUp_(i) {
        const o = this.elem_.ownerDocument;
        o.removeEventListener("mousemove", this.onDocumentMouseMove_), o.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
            altKey: i.altKey,
            data: this.computePosition_(computeOffset$1(i, this.elem_)),
            sender: this,
            shiftKey: i.shiftKey
        })
    }
    onTouchStart_(i) {
        i.preventDefault();
        const o = i.targetTouches.item(0),
            c = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
            altKey: i.altKey,
            data: this.computePosition_(o ? {
                x: o.clientX - c.left,
                y: o.clientY - c.top
            } : void 0),
            sender: this,
            shiftKey: i.shiftKey
        }), this.lastTouch_ = o
    }
    onTouchMove_(i) {
        const o = i.targetTouches.item(0),
            c = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
            altKey: i.altKey,
            data: this.computePosition_(o ? {
                x: o.clientX - c.left,
                y: o.clientY - c.top
            } : void 0),
            sender: this,
            shiftKey: i.shiftKey
        }), this.lastTouch_ = o
    }
    onTouchEnd_(i) {
        var o;
        const c = (o = i.targetTouches.item(0)) !== null && o !== void 0 ? o : this.lastTouch_,
            u = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
            altKey: i.altKey,
            data: this.computePosition_(c ? {
                x: c.clientX - u.left,
                y: c.clientY - u.top
            } : void 0),
            sender: this,
            shiftKey: i.shiftKey
        })
    }
}
const cn$g = ClassName("txt");
class NumberTextView {
    constructor(i, o) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = o.props, this.props_.emitter.on("change", this.onChange_), this.element = i.createElement("div"), this.element.classList.add(cn$g(), cn$g(void 0, "num")), o.arrayPosition && this.element.classList.add(cn$g(void 0, o.arrayPosition)), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("input");
        c.classList.add(cn$g("i")), c.type = "text", o.viewProps.bindDisabled(c), this.element.appendChild(c), this.inputElement = c, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = o.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(cn$g()), this.inputElement.classList.add(cn$g("i"));
        const u = i.createElement("div");
        u.classList.add(cn$g("k")), this.element.appendChild(u), this.knobElement = u;
        const p = i.createElementNS(SVG_NS, "svg");
        p.classList.add(cn$g("g")), this.knobElement.appendChild(p);
        const m = i.createElementNS(SVG_NS, "path");
        m.classList.add(cn$g("gb")), p.appendChild(m), this.guideBodyElem_ = m;
        const g = i.createElementNS(SVG_NS, "path");
        g.classList.add(cn$g("gh")), p.appendChild(g), this.guideHeadElem_ = g;
        const _ = i.createElement("div");
        _.classList.add(ClassName("tt")()), this.knobElement.appendChild(_), this.tooltipElem_ = _, o.value.emitter.on("change", this.onChange_), this.value = o.value, this.refresh()
    }
    onDraggingChange_(i) {
        if (i.rawValue === null) {
            this.element.classList.remove(cn$g(void 0, "drg"));
            return
        }
        this.element.classList.add(cn$g(void 0, "drg"));
        const o = i.rawValue / this.props_.get("pointerScale"),
            c = o + (o > 0 ? -1 : o < 0 ? 1 : 0),
            u = constrainRange(-c, -4, 4);
        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${c+u},0 L${c},4 L${c+u},8`, `M ${o},-1 L${o},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${o},4`);
        const p = this.props_.get("formatter");
        this.tooltipElem_.textContent = p(this.value.rawValue), this.tooltipElem_.style.left = `${o}px`
    }
    refresh() {
        const i = this.props_.get("formatter");
        this.inputElement.value = i(this.value.rawValue)
    }
    onChange_() {
        this.refresh()
    }
}
class NumberTextController {
    constructor(i, o) {
        var c;
        this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.parser_ = o.parser, this.props = o.props, this.sliderProps_ = (c = o.sliderProps) !== null && c !== void 0 ? c : null, this.value = o.value, this.viewProps = o.viewProps, this.dragging_ = createValue(null), this.view = new NumberTextView(i, {
            arrayPosition: o.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const u = new PointerHandler(this.view.knobElement);
        u.emitter.on("down", this.onPointerDown_), u.emitter.on("move", this.onPointerMove_), u.emitter.on("up", this.onPointerUp_)
    }
    constrainValue_(i) {
        var o, c;
        const u = (o = this.sliderProps_) === null || o === void 0 ? void 0 : o.get("min"),
            p = (c = this.sliderProps_) === null || c === void 0 ? void 0 : c.get("max");
        let m = i;
        return u !== void 0 && (m = Math.max(m, u)), p !== void 0 && (m = Math.min(m, p)), m
    }
    onInputChange_(i) {
        const c = i.currentTarget.value,
            u = this.parser_(c);
        isEmpty(u) || (this.value.rawValue = this.constrainValue_(u)), this.view.refresh()
    }
    onInputKeyDown_(i) {
        const o = getStepForKey(this.props.get("keyScale"), getVerticalStepKeys(i));
        o !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + o), {
            forceEmit: !1,
            last: !1
        })
    }
    onInputKeyUp_(i) {
        getStepForKey(this.props.get("keyScale"), getVerticalStepKeys(i)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
    onPointerDown_() {
        this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0
    }
    computeDraggingValue_(i) {
        if (!i.point) return null;
        const o = i.point.x - i.bounds.width / 2;
        return this.constrainValue_(this.originRawValue_ + o * this.props.get("pointerScale"))
    }
    onPointerMove_(i) {
        const o = this.computeDraggingValue_(i.data);
        o !== null && (this.value.setRawValue(o, {
            forceEmit: !1,
            last: !1
        }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
    }
    onPointerUp_(i) {
        const o = this.computeDraggingValue_(i.data);
        o !== null && (this.value.setRawValue(o, {
            forceEmit: !0,
            last: !0
        }), this.dragging_.rawValue = null)
    }
}
const cn$f = ClassName("sld");
class SliderView {
    constructor(i, o) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = o.props, this.props_.emitter.on("change", this.onChange_), this.element = i.createElement("div"), this.element.classList.add(cn$f()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$f("t")), o.viewProps.bindTabIndex(c), this.element.appendChild(c), this.trackElement = c;
        const u = i.createElement("div");
        u.classList.add(cn$f("k")), this.trackElement.appendChild(u), this.knobElement = u, o.value.emitter.on("change", this.onChange_), this.value = o.value, this.update_()
    }
    update_() {
        const i = constrainRange(mapRange$1(this.value.rawValue, this.props_.get("min"), this.props_.get("max"), 0, 100), 0, 100);
        this.knobElement.style.width = `${i}%`
    }
    onChange_() {
        this.update_()
    }
}
class SliderController {
    constructor(i, o) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.props = o.props, this.view = new SliderView(i, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
        }), this.ptHandler_ = new PointerHandler(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_)
    }
    handlePointerEvent_(i, o) {
        i.point && this.value.setRawValue(mapRange$1(constrainRange(i.point.x, 0, i.bounds.width), 0, i.bounds.width, this.props.get("min"), this.props.get("max")), o)
    }
    onPointerDownOrMove_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onKeyDown_(i) {
        const o = getStepForKey(this.props.get("keyScale"), getHorizontalStepKeys(i));
        o !== 0 && this.value.setRawValue(this.value.rawValue + o, {
            forceEmit: !1,
            last: !1
        })
    }
    onKeyUp_(i) {
        getStepForKey(this.props.get("keyScale"), getHorizontalStepKeys(i)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
const cn$e = ClassName("sldtxt");
class SliderTextView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$e());
        const c = i.createElement("div");
        c.classList.add(cn$e("s")), this.sliderView_ = o.sliderView, c.appendChild(this.sliderView_.element), this.element.appendChild(c);
        const u = i.createElement("div");
        u.classList.add(cn$e("t")), this.textView_ = o.textView, u.appendChild(this.textView_.element), this.element.appendChild(u)
    }
}
class SliderTextController {
    constructor(i, o) {
        this.value = o.value, this.viewProps = o.viewProps, this.sliderC_ = new SliderController(i, {
            props: o.sliderProps,
            value: o.value,
            viewProps: this.viewProps
        }), this.textC_ = new NumberTextController(i, {
            parser: o.parser,
            props: o.textProps,
            sliderProps: o.sliderProps,
            value: o.value,
            viewProps: o.viewProps
        }), this.view = new SliderTextView(i, {
            sliderView: this.sliderC_.view,
            textView: this.textC_.view
        })
    }
    get sliderController() {
        return this.sliderC_
    }
    get textController() {
        return this.textC_
    }
    importProps(i) {
        return importBladeState(i, null, o => ({
            max: o.required.number,
            min: o.required.number
        }), o => {
            const c = this.sliderC_.props;
            return c.set("max", o.max), c.set("min", o.min), !0
        })
    }
    exportProps() {
        const i = this.sliderC_.props;
        return exportBladeState(null, {
            max: i.get("max"),
            min: i.get("min")
        })
    }
}

function createSliderTextProps(l) {
    return {
        sliderProps: new ValueMap({
            keyScale: l.keyScale,
            max: l.max,
            min: l.min
        }),
        textProps: new ValueMap({
            formatter: createValue(l.formatter),
            keyScale: l.keyScale,
            pointerScale: createValue(l.pointerScale)
        })
    }
}
const CSS_VAR_MAP = {
    containerUnitSize: "cnt-usz"
};

function getCssVar(l) {
    return `--${CSS_VAR_MAP[l]}`
}

function createPointDimensionParser(l) {
    return createNumberTextInputParamsParser(l)
}

function parsePointDimensionParams(l) {
    if (isRecord(l)) return parseRecord(l, createPointDimensionParser)
}

function createDimensionConstraint$1(l, i) {
    if (!l) return;
    const o = [],
        c = createStepConstraint(l, i);
    c && o.push(c);
    const u = createRangeConstraint(l);
    return u && o.push(u), new CompositeConstraint(o)
}

function parsePickerLayout(l) {
    if (l === "inline" || l === "popup") return l
}

function writePrimitive(l, i) {
    l.write(i)
}
const cn$d = ClassName("ckb");
class CheckboxView {
    constructor(i, o) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.element = i.createElement("div"), this.element.classList.add(cn$d()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("label");
        c.classList.add(cn$d("l")), this.element.appendChild(c);
        const u = i.createElement("input");
        u.classList.add(cn$d("i")), u.type = "checkbox", c.appendChild(u), this.inputElement = u, o.viewProps.bindDisabled(this.inputElement);
        const p = i.createElement("div");
        p.classList.add(cn$d("w")), c.appendChild(p);
        const m = createSvgIconElement(i, "check");
        p.appendChild(m), o.value.emitter.on("change", this.onValueChange_), this.value = o.value, this.update_()
    }
    update_() {
        this.inputElement.checked = this.value.rawValue
    }
    onValueChange_() {
        this.update_()
    }
}
class CheckboxController {
    constructor(i, o) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.view = new CheckboxView(i, {
            value: this.value,
            viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_)
    }
    onInputChange_(i) {
        const o = i.currentTarget;
        this.value.rawValue = o.checked
    }
}

function createConstraint$6(l) {
    const i = [],
        o = createListConstraint(l.options);
    return o && i.push(o), new CompositeConstraint(i)
}
createPlugin({
    id: "input-bool",
    type: "input",
    accept: (l, i) => {
        if (typeof l != "boolean") return null;
        const o = parseRecord(i, c => ({
            options: c.optional.custom(parseListOptions),
            readonly: c.optional.constant(!1)
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => boolFromUnknown,
        constraint: l => createConstraint$6(l.params),
        writer: l => writePrimitive
    },
    controller: l => {
        const i = l.document,
            o = l.value,
            c = l.constraint,
            u = c && findConstraint(c, ListConstraint);
        return u ? new ListController(i, {
            props: new ValueMap({
                options: u.values.value("options")
            }),
            value: o,
            viewProps: l.viewProps
        }) : new CheckboxController(i, {
            value: o,
            viewProps: l.viewProps
        })
    },
    api(l) {
        return typeof l.controller.value.rawValue != "boolean" ? null : l.controller.valueController instanceof ListController ? new ListInputBindingApi(l.controller) : null
    }
});
const cn$c = ClassName("col");
class ColorView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$c()), o.foldable.bindExpandedClass(this.element, cn$c(void 0, "expanded")), bindValueMap(o.foldable, "completed", valueToClassName(this.element, cn$c(void 0, "cpl")));
        const c = i.createElement("div");
        c.classList.add(cn$c("h")), this.element.appendChild(c);
        const u = i.createElement("div");
        u.classList.add(cn$c("s")), c.appendChild(u), this.swatchElement = u;
        const p = i.createElement("div");
        if (p.classList.add(cn$c("t")), c.appendChild(p), this.textElement = p, o.pickerLayout === "inline") {
            const m = i.createElement("div");
            m.classList.add(cn$c("p")), this.element.appendChild(m), this.pickerElement = m
        } else this.pickerElement = null
    }
}

function rgbToHslInt(l, i, o) {
    const c = constrainRange(l / 255, 0, 1),
        u = constrainRange(i / 255, 0, 1),
        p = constrainRange(o / 255, 0, 1),
        m = Math.max(c, u, p),
        g = Math.min(c, u, p),
        _ = m - g;
    let v = 0,
        x = 0;
    const y = (g + m) / 2;
    return _ !== 0 && (x = _ / (1 - Math.abs(m + g - 1)), c === m ? v = (u - p) / _ : u === m ? v = 2 + (p - c) / _ : v = 4 + (c - u) / _, v = v / 6 + (v < 0 ? 1 : 0)), [v * 360, x * 100, y * 100]
}

function hslToRgbInt(l, i, o) {
    const c = (l % 360 + 360) % 360,
        u = constrainRange(i / 100, 0, 1),
        p = constrainRange(o / 100, 0, 1),
        m = (1 - Math.abs(2 * p - 1)) * u,
        g = m * (1 - Math.abs(c / 60 % 2 - 1)),
        _ = p - m / 2;
    let v, x, y;
    return c >= 0 && c < 60 ? [v, x, y] = [m, g, 0] : c >= 60 && c < 120 ? [v, x, y] = [g, m, 0] : c >= 120 && c < 180 ? [v, x, y] = [0, m, g] : c >= 180 && c < 240 ? [v, x, y] = [0, g, m] : c >= 240 && c < 300 ? [v, x, y] = [g, 0, m] : [v, x, y] = [m, 0, g], [(v + _) * 255, (x + _) * 255, (y + _) * 255]
}

function rgbToHsvInt(l, i, o) {
    const c = constrainRange(l / 255, 0, 1),
        u = constrainRange(i / 255, 0, 1),
        p = constrainRange(o / 255, 0, 1),
        m = Math.max(c, u, p),
        g = Math.min(c, u, p),
        _ = m - g;
    let v;
    _ === 0 ? v = 0 : m === c ? v = 60 * (((u - p) / _ % 6 + 6) % 6) : m === u ? v = 60 * ((p - c) / _ + 2) : v = 60 * ((c - u) / _ + 4);
    const x = m === 0 ? 0 : _ / m,
        y = m;
    return [v, x * 100, y * 100]
}

function hsvToRgbInt(l, i, o) {
    const c = loopRange(l, 360),
        u = constrainRange(i / 100, 0, 1),
        p = constrainRange(o / 100, 0, 1),
        m = p * u,
        g = m * (1 - Math.abs(c / 60 % 2 - 1)),
        _ = p - m;
    let v, x, y;
    return c >= 0 && c < 60 ? [v, x, y] = [m, g, 0] : c >= 60 && c < 120 ? [v, x, y] = [g, m, 0] : c >= 120 && c < 180 ? [v, x, y] = [0, m, g] : c >= 180 && c < 240 ? [v, x, y] = [0, g, m] : c >= 240 && c < 300 ? [v, x, y] = [g, 0, m] : [v, x, y] = [m, 0, g], [(v + _) * 255, (x + _) * 255, (y + _) * 255]
}

function hslToHsvInt(l, i, o) {
    const c = o + i * (100 - Math.abs(2 * o - 100)) / 200;
    return [l, c !== 0 ? i * (100 - Math.abs(2 * o - 100)) / c : 0, o + i * (100 - Math.abs(2 * o - 100)) / (2 * 100)]
}

function hsvToHslInt(l, i, o) {
    const c = 100 - Math.abs(o * (200 - i) / 100 - 100);
    return [l, c !== 0 ? i * o / c : 0, o * (200 - i) / (2 * 100)]
}

function removeAlphaComponent(l) {
    return [l[0], l[1], l[2]]
}

function appendAlphaComponent(l, i) {
    return [l[0], l[1], l[2], i]
}
const MODE_CONVERTER_MAP = {
    hsl: {
        hsl: (l, i, o) => [l, i, o],
        hsv: hslToHsvInt,
        rgb: hslToRgbInt
    },
    hsv: {
        hsl: hsvToHslInt,
        hsv: (l, i, o) => [l, i, o],
        rgb: hsvToRgbInt
    },
    rgb: {
        hsl: rgbToHslInt,
        hsv: rgbToHsvInt,
        rgb: (l, i, o) => [l, i, o]
    }
};

function getColorMaxComponents(l, i) {
    return [i === "float" ? 1 : l === "rgb" ? 255 : 360, i === "float" ? 1 : l === "rgb" ? 255 : 100, i === "float" ? 1 : l === "rgb" ? 255 : 100]
}

function loopHueRange(l, i) {
    return l === i ? i : loopRange(l, i)
}

function constrainColorComponents(l, i, o) {
    var c;
    const u = getColorMaxComponents(i, o);
    return [i === "rgb" ? constrainRange(l[0], 0, u[0]) : loopHueRange(l[0], u[0]), constrainRange(l[1], 0, u[1]), constrainRange(l[2], 0, u[2]), constrainRange((c = l[3]) !== null && c !== void 0 ? c : 1, 0, 1)]
}

function convertColorType(l, i, o, c) {
    const u = getColorMaxComponents(i, o),
        p = getColorMaxComponents(i, c);
    return l.map((m, g) => m / u[g] * p[g])
}

function convertColor(l, i, o) {
    const c = convertColorType(l, i.mode, i.type, "int"),
        u = MODE_CONVERTER_MAP[i.mode][o.mode](...c);
    return convertColorType(u, o.mode, "int", o.type)
}
class IntColor {
    static black() {
        return new IntColor([0, 0, 0], "rgb")
    }
    constructor(i, o) {
        this.type = "int", this.mode = o, this.comps_ = constrainColorComponents(i, o, this.type)
    }
    getComponents(i) {
        return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), {
            mode: this.mode,
            type: this.type
        }, {
            mode: i ? ? this.mode,
            type: this.type
        }), this.comps_[3])
    }
    toRgbaObject() {
        const i = this.getComponents("rgb");
        return {
            r: i[0],
            g: i[1],
            b: i[2],
            a: i[3]
        }
    }
}
const cn$b = ClassName("colp");
class ColorPickerView {
    constructor(i, o) {
        this.alphaViews_ = null, this.element = i.createElement("div"), this.element.classList.add(cn$b()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$b("hsv"));
        const u = i.createElement("div");
        u.classList.add(cn$b("sv")), this.svPaletteView_ = o.svPaletteView, u.appendChild(this.svPaletteView_.element), c.appendChild(u);
        const p = i.createElement("div");
        p.classList.add(cn$b("h")), this.hPaletteView_ = o.hPaletteView, p.appendChild(this.hPaletteView_.element), c.appendChild(p), this.element.appendChild(c);
        const m = i.createElement("div");
        if (m.classList.add(cn$b("rgb")), this.textsView_ = o.textsView, m.appendChild(this.textsView_.element), this.element.appendChild(m), o.alphaViews) {
            this.alphaViews_ = {
                palette: o.alphaViews.palette,
                text: o.alphaViews.text
            };
            const g = i.createElement("div");
            g.classList.add(cn$b("a"));
            const _ = i.createElement("div");
            _.classList.add(cn$b("ap")), _.appendChild(this.alphaViews_.palette.element), g.appendChild(_);
            const v = i.createElement("div");
            v.classList.add(cn$b("at")), v.appendChild(this.alphaViews_.text.element), g.appendChild(v), this.element.appendChild(g)
        }
    }
    get allFocusableElements() {
        const i = [this.svPaletteView_.element, this.hPaletteView_.element, this.textsView_.modeSelectElement, ...this.textsView_.inputViews.map(o => o.inputElement)];
        return this.alphaViews_ && i.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), i
    }
}

function parseColorType(l) {
    return l === "int" ? "int" : l === "float" ? "float" : void 0
}

function parseColorInputParams(l) {
    return parseRecord(l, i => ({
        color: i.optional.object({
            alpha: i.optional.boolean,
            type: i.optional.custom(parseColorType)
        }),
        expanded: i.optional.boolean,
        picker: i.optional.custom(parsePickerLayout),
        readonly: i.optional.constant(!1)
    }))
}

function getKeyScaleForColor(l) {
    return l ? .1 : 1
}

function extractColorType(l) {
    var i;
    return (i = l.color) === null || i === void 0 ? void 0 : i.type
}
class FloatColor {
    constructor(i, o) {
        this.type = "float", this.mode = o, this.comps_ = constrainColorComponents(i, o, this.type)
    }
    getComponents(i) {
        return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), {
            mode: this.mode,
            type: this.type
        }, {
            mode: i ? ? this.mode,
            type: this.type
        }), this.comps_[3])
    }
    toRgbaObject() {
        const i = this.getComponents("rgb");
        return {
            r: i[0],
            g: i[1],
            b: i[2],
            a: i[3]
        }
    }
}
const TYPE_TO_CONSTRUCTOR_MAP = {
    int: (l, i) => new IntColor(l, i),
    float: (l, i) => new FloatColor(l, i)
};

function createColor(l, i, o) {
    return TYPE_TO_CONSTRUCTOR_MAP[o](l, i)
}

function isFloatColor(l) {
    return l.type === "float"
}

function isIntColor(l) {
    return l.type === "int"
}

function convertFloatToInt(l) {
    const i = l.getComponents(),
        o = getColorMaxComponents(l.mode, "int");
    return new IntColor([Math.round(mapRange$1(i[0], 0, 1, 0, o[0])), Math.round(mapRange$1(i[1], 0, 1, 0, o[1])), Math.round(mapRange$1(i[2], 0, 1, 0, o[2])), i[3]], l.mode)
}

function convertIntToFloat(l) {
    const i = l.getComponents(),
        o = getColorMaxComponents(l.mode, "int");
    return new FloatColor([mapRange$1(i[0], 0, o[0], 0, 1), mapRange$1(i[1], 0, o[1], 0, 1), mapRange$1(i[2], 0, o[2], 0, 1), i[3]], l.mode)
}

function mapColorType(l, i) {
    if (l.type === i) return l;
    if (isIntColor(l) && i === "float") return convertIntToFloat(l);
    if (isFloatColor(l) && i === "int") return convertFloatToInt(l);
    throw TpError.shouldNeverHappen()
}

function equalsStringColorFormat(l, i) {
    return l.alpha === i.alpha && l.mode === i.mode && l.notation === i.notation && l.type === i.type
}

function parseCssNumberOrPercentage(l, i) {
    const o = l.match(/^(.+)%$/);
    return Math.min(o ? parseFloat(o[1]) * .01 * i : parseFloat(l), i)
}
const ANGLE_TO_DEG_MAP = {
    deg: l => l,
    grad: l => l * 360 / 400,
    rad: l => l * 360 / (2 * Math.PI),
    turn: l => l * 360
};

function parseCssNumberOrAngle(l) {
    const i = l.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
    if (!i) return parseFloat(l);
    const o = parseFloat(i[1]),
        c = i[2];
    return ANGLE_TO_DEG_MAP[c](o)
}

function parseFunctionalRgbColorComponents(l) {
    const i = l.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!i) return null;
    const o = [parseCssNumberOrPercentage(i[1], 255), parseCssNumberOrPercentage(i[2], 255), parseCssNumberOrPercentage(i[3], 255)];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) ? null : o
}

function parseFunctionalRgbColor(l) {
    const i = parseFunctionalRgbColorComponents(l);
    return i ? new IntColor(i, "rgb") : null
}

function parseFunctionalRgbaColorComponents(l) {
    const i = l.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!i) return null;
    const o = [parseCssNumberOrPercentage(i[1], 255), parseCssNumberOrPercentage(i[2], 255), parseCssNumberOrPercentage(i[3], 255), parseCssNumberOrPercentage(i[4], 1)];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) || isNaN(o[3]) ? null : o
}

function parseFunctionalRgbaColor(l) {
    const i = parseFunctionalRgbaColorComponents(l);
    return i ? new IntColor(i, "rgb") : null
}

function parseFunctionalHslColorComponents(l) {
    const i = l.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!i) return null;
    const o = [parseCssNumberOrAngle(i[1]), parseCssNumberOrPercentage(i[2], 100), parseCssNumberOrPercentage(i[3], 100)];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) ? null : o
}

function parseFunctionalHslColor(l) {
    const i = parseFunctionalHslColorComponents(l);
    return i ? new IntColor(i, "hsl") : null
}

function parseHslaColorComponents(l) {
    const i = l.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!i) return null;
    const o = [parseCssNumberOrAngle(i[1]), parseCssNumberOrPercentage(i[2], 100), parseCssNumberOrPercentage(i[3], 100), parseCssNumberOrPercentage(i[4], 1)];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) || isNaN(o[3]) ? null : o
}

function parseFunctionalHslaColor(l) {
    const i = parseHslaColorComponents(l);
    return i ? new IntColor(i, "hsl") : null
}

function parseHexRgbColorComponents(l) {
    const i = l.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
    if (i) return [parseInt(i[1] + i[1], 16), parseInt(i[2] + i[2], 16), parseInt(i[3] + i[3], 16)];
    const o = l.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
    return o ? [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)] : null
}

function parseHexRgbColor(l) {
    const i = parseHexRgbColorComponents(l);
    return i ? new IntColor(i, "rgb") : null
}

function parseHexRgbaColorComponents(l) {
    const i = l.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
    if (i) return [parseInt(i[1] + i[1], 16), parseInt(i[2] + i[2], 16), parseInt(i[3] + i[3], 16), mapRange$1(parseInt(i[4] + i[4], 16), 0, 255, 0, 1)];
    const o = l.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
    return o ? [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16), mapRange$1(parseInt(o[4], 16), 0, 255, 0, 1)] : null
}

function parseHexRgbaColor(l) {
    const i = parseHexRgbaColorComponents(l);
    return i ? new IntColor(i, "rgb") : null
}

function parseObjectRgbColorComponents(l) {
    const i = l.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
    if (!i) return null;
    const o = [parseFloat(i[1]), parseFloat(i[2]), parseFloat(i[3])];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) ? null : o
}

function createObjectRgbColorParser(l) {
    return i => {
        const o = parseObjectRgbColorComponents(i);
        return o ? createColor(o, "rgb", l) : null
    }
}

function parseObjectRgbaColorComponents(l) {
    const i = l.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
    if (!i) return null;
    const o = [parseFloat(i[1]), parseFloat(i[2]), parseFloat(i[3]), parseFloat(i[4])];
    return isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2]) || isNaN(o[3]) ? null : o
}

function createObjectRgbaColorParser(l) {
    return i => {
        const o = parseObjectRgbaColorComponents(i);
        return o ? createColor(o, "rgb", l) : null
    }
}
const PARSER_AND_RESULT = [{
    parser: parseHexRgbColorComponents,
    result: {
        alpha: !1,
        mode: "rgb",
        notation: "hex"
    }
}, {
    parser: parseHexRgbaColorComponents,
    result: {
        alpha: !0,
        mode: "rgb",
        notation: "hex"
    }
}, {
    parser: parseFunctionalRgbColorComponents,
    result: {
        alpha: !1,
        mode: "rgb",
        notation: "func"
    }
}, {
    parser: parseFunctionalRgbaColorComponents,
    result: {
        alpha: !0,
        mode: "rgb",
        notation: "func"
    }
}, {
    parser: parseFunctionalHslColorComponents,
    result: {
        alpha: !1,
        mode: "hsl",
        notation: "func"
    }
}, {
    parser: parseHslaColorComponents,
    result: {
        alpha: !0,
        mode: "hsl",
        notation: "func"
    }
}, {
    parser: parseObjectRgbColorComponents,
    result: {
        alpha: !1,
        mode: "rgb",
        notation: "object"
    }
}, {
    parser: parseObjectRgbaColorComponents,
    result: {
        alpha: !0,
        mode: "rgb",
        notation: "object"
    }
}];

function detectStringColor(l) {
    return PARSER_AND_RESULT.reduce((i, {
        parser: o,
        result: c
    }) => i || (o(l) ? c : null), null)
}

function detectStringColorFormat(l, i = "int") {
    const o = detectStringColor(l);
    return o ? o.notation === "hex" && i !== "float" ? Object.assign(Object.assign({}, o), {
        type: "int"
    }) : o.notation === "func" ? Object.assign(Object.assign({}, o), {
        type: i
    }) : null : null
}

function createColorStringParser(l) {
    const i = [parseHexRgbColor, parseHexRgbaColor, parseFunctionalRgbColor, parseFunctionalRgbaColor, parseFunctionalHslColor, parseFunctionalHslaColor];
    i.push(createObjectRgbColorParser("int"), createObjectRgbaColorParser("int"));
    const o = composeParsers(i);
    return c => {
        const u = o(c);
        return u ? mapColorType(u, l) : null
    }
}

function readIntColorString(l) {
    const i = createColorStringParser("int");
    if (typeof l != "string") return IntColor.black();
    const o = i(l);
    return o ? ? IntColor.black()
}

function zerofill(l) {
    const i = constrainRange(Math.floor(l), 0, 255).toString(16);
    return i.length === 1 ? `0${i}` : i
}

function colorToHexRgbString(l, i = "#") {
    const o = removeAlphaComponent(l.getComponents("rgb")).map(zerofill).join("");
    return `${i}${o}`
}

function colorToHexRgbaString(l, i = "#") {
    const o = l.getComponents("rgb"),
        c = [o[0], o[1], o[2], o[3] * 255].map(zerofill).join("");
    return `${i}${c}`
}

function colorToFunctionalRgbString(l) {
    const i = createNumberFormatter(0),
        o = mapColorType(l, "int");
    return `rgb(${removeAlphaComponent(o.getComponents("rgb")).map(u=>i(u)).join(", ")})`
}

function colorToFunctionalRgbaString(l) {
    const i = createNumberFormatter(2),
        o = createNumberFormatter(0);
    return `rgba(${mapColorType(l,"int").getComponents("rgb").map((p,m)=>(m===3?i:o)(p)).join(", ")})`
}

function colorToFunctionalHslString(l) {
    const i = [createNumberFormatter(0), formatPercentage, formatPercentage],
        o = mapColorType(l, "int");
    return `hsl(${removeAlphaComponent(o.getComponents("hsl")).map((u,p)=>i[p](u)).join(", ")})`
}

function colorToFunctionalHslaString(l) {
    const i = [createNumberFormatter(0), formatPercentage, formatPercentage, createNumberFormatter(2)];
    return `hsla(${mapColorType(l,"int").getComponents("hsl").map((u,p)=>i[p](u)).join(", ")})`
}

function colorToObjectRgbString(l, i) {
    const o = createNumberFormatter(i === "float" ? 2 : 0),
        c = ["r", "g", "b"],
        u = mapColorType(l, i);
    return `{${removeAlphaComponent(u.getComponents("rgb")).map((m,g)=>`${c[g]}: ${o(m)}`).join(", ")}}`
}

function createObjectRgbColorFormatter(l) {
    return i => colorToObjectRgbString(i, l)
}

function colorToObjectRgbaString(l, i) {
    const o = createNumberFormatter(2),
        c = createNumberFormatter(i === "float" ? 2 : 0),
        u = ["r", "g", "b", "a"];
    return `{${mapColorType(l,i).getComponents("rgb").map((g,_)=>{const v=_===3?o:c;return`${u[_]}: ${v(g)}`}).join(", ")}}`
}

function createObjectRgbaColorFormatter(l) {
    return i => colorToObjectRgbaString(i, l)
}
const FORMAT_AND_STRINGIFIERS = [{
    format: {
        alpha: !1,
        mode: "rgb",
        notation: "hex",
        type: "int"
    },
    stringifier: colorToHexRgbString
}, {
    format: {
        alpha: !0,
        mode: "rgb",
        notation: "hex",
        type: "int"
    },
    stringifier: colorToHexRgbaString
}, {
    format: {
        alpha: !1,
        mode: "rgb",
        notation: "func",
        type: "int"
    },
    stringifier: colorToFunctionalRgbString
}, {
    format: {
        alpha: !0,
        mode: "rgb",
        notation: "func",
        type: "int"
    },
    stringifier: colorToFunctionalRgbaString
}, {
    format: {
        alpha: !1,
        mode: "hsl",
        notation: "func",
        type: "int"
    },
    stringifier: colorToFunctionalHslString
}, {
    format: {
        alpha: !0,
        mode: "hsl",
        notation: "func",
        type: "int"
    },
    stringifier: colorToFunctionalHslaString
}, ...["int", "float"].reduce((l, i) => [...l, {
    format: {
        alpha: !1,
        mode: "rgb",
        notation: "object",
        type: i
    },
    stringifier: createObjectRgbColorFormatter(i)
}, {
    format: {
        alpha: !0,
        mode: "rgb",
        notation: "object",
        type: i
    },
    stringifier: createObjectRgbaColorFormatter(i)
}], [])];

function findColorStringifier(l) {
    return FORMAT_AND_STRINGIFIERS.reduce((i, o) => i || (equalsStringColorFormat(o.format, l) ? o.stringifier : null), null)
}
const cn$a = ClassName("apl");
class APaletteView {
    constructor(i, o) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = o.value, this.value.emitter.on("change", this.onValueChange_), this.element = i.createElement("div"), this.element.classList.add(cn$a()), o.viewProps.bindClassModifiers(this.element), o.viewProps.bindTabIndex(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$a("b")), this.element.appendChild(c);
        const u = i.createElement("div");
        u.classList.add(cn$a("c")), c.appendChild(u), this.colorElem_ = u;
        const p = i.createElement("div");
        p.classList.add(cn$a("m")), this.element.appendChild(p), this.markerElem_ = p;
        const m = i.createElement("div");
        m.classList.add(cn$a("p")), this.markerElem_.appendChild(m), this.previewElem_ = m, this.update_()
    }
    update_() {
        const i = this.value.rawValue,
            o = i.getComponents("rgb"),
            c = new IntColor([o[0], o[1], o[2], 0], "rgb"),
            u = new IntColor([o[0], o[1], o[2], 255], "rgb"),
            p = ["to right", colorToFunctionalRgbaString(c), colorToFunctionalRgbaString(u)];
        this.colorElem_.style.background = `linear-gradient(${p.join(",")})`, this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(i);
        const m = mapRange$1(o[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${m}%`
    }
    onValueChange_() {
        this.update_()
    }
}
class APaletteController {
    constructor(i, o) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.view = new APaletteView(i, {
            value: this.value,
            viewProps: this.viewProps
        }), this.ptHandler_ = new PointerHandler(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
    }
    handlePointerEvent_(i, o) {
        if (!i.point) return;
        const c = i.point.x / i.bounds.width,
            u = this.value.rawValue,
            [p, m, g] = u.getComponents("hsv");
        this.value.setRawValue(new IntColor([p, m, g, c], "hsv"), o)
    }
    onPointerDown_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerMove_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onKeyDown_(i) {
        const o = getStepForKey(getKeyScaleForColor(!0), getHorizontalStepKeys(i));
        if (o === 0) return;
        const c = this.value.rawValue,
            [u, p, m, g] = c.getComponents("hsv");
        this.value.setRawValue(new IntColor([u, p, m, g + o], "hsv"), {
            forceEmit: !1,
            last: !1
        })
    }
    onKeyUp_(i) {
        getStepForKey(getKeyScaleForColor(!0), getHorizontalStepKeys(i)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
const cn$9 = ClassName("coltxt");

function createModeSelectElement(l) {
    const i = l.createElement("select"),
        o = [{
            text: "RGB",
            value: "rgb"
        }, {
            text: "HSL",
            value: "hsl"
        }, {
            text: "HSV",
            value: "hsv"
        }, {
            text: "HEX",
            value: "hex"
        }];
    return i.appendChild(o.reduce((c, u) => {
        const p = l.createElement("option");
        return p.textContent = u.text, p.value = u.value, c.appendChild(p), c
    }, l.createDocumentFragment())), i
}
class ColorTextsView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$9()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$9("m")), this.modeElem_ = createModeSelectElement(i), this.modeElem_.classList.add(cn$9("ms")), c.appendChild(this.modeSelectElement), o.viewProps.bindDisabled(this.modeElem_);
        const u = i.createElement("div");
        u.classList.add(cn$9("mm")), u.appendChild(createSvgIconElement(i, "dropdown")), c.appendChild(u), this.element.appendChild(c);
        const p = i.createElement("div");
        p.classList.add(cn$9("w")), this.element.appendChild(p), this.inputsElem_ = p, this.inputViews_ = o.inputViews, this.applyInputViews_(), bindValue(o.mode, m => {
            this.modeElem_.value = m
        })
    }
    get modeSelectElement() {
        return this.modeElem_
    }
    get inputViews() {
        return this.inputViews_
    }
    set inputViews(i) {
        this.inputViews_ = i, this.applyInputViews_()
    }
    applyInputViews_() {
        removeChildElements(this.inputsElem_);
        const i = this.element.ownerDocument;
        this.inputViews_.forEach(o => {
            const c = i.createElement("div");
            c.classList.add(cn$9("c")), c.appendChild(o.element), this.inputsElem_.appendChild(c)
        })
    }
}

function createFormatter$2(l) {
    return createNumberFormatter(l === "float" ? 2 : 0)
}

function createConstraint$5(l, i, o) {
    const c = getColorMaxComponents(l, i)[o];
    return new DefiniteRangeConstraint({
        min: 0,
        max: c
    })
}

function createComponentController(l, i, o) {
    return new NumberTextController(l, {
        arrayPosition: o === 0 ? "fst" : o === 2 ? "lst" : "mid",
        parser: i.parser,
        props: ValueMap.fromObject({
            formatter: createFormatter$2(i.colorType),
            keyScale: getKeyScaleForColor(!1),
            pointerScale: i.colorType === "float" ? .01 : 1
        }),
        value: createValue(0, {
            constraint: createConstraint$5(i.colorMode, i.colorType, o)
        }),
        viewProps: i.viewProps
    })
}

function createComponentControllers(l, i) {
    const o = {
        colorMode: i.colorMode,
        colorType: i.colorType,
        parser: parseNumber,
        viewProps: i.viewProps
    };
    return [0, 1, 2].map(c => {
        const u = createComponentController(l, o, c);
        return connectValues({
            primary: i.value,
            secondary: u.value,
            forward(p) {
                return mapColorType(p, i.colorType).getComponents(i.colorMode)[c]
            },
            backward(p, m) {
                const g = i.colorMode,
                    v = mapColorType(p, i.colorType).getComponents(g);
                v[c] = m;
                const x = createColor(appendAlphaComponent(removeAlphaComponent(v), v[3]), g, i.colorType);
                return mapColorType(x, "int")
            }
        }), u
    })
}

function createHexController(l, i) {
    const o = new TextController(l, {
        parser: createColorStringParser("int"),
        props: ValueMap.fromObject({
            formatter: colorToHexRgbString
        }),
        value: createValue(IntColor.black()),
        viewProps: i.viewProps
    });
    return connectValues({
        primary: i.value,
        secondary: o.value,
        forward: c => new IntColor(removeAlphaComponent(c.getComponents()), c.mode),
        backward: (c, u) => new IntColor(appendAlphaComponent(removeAlphaComponent(u.getComponents(c.mode)), c.getComponents()[3]), c.mode)
    }), [o]
}

function isColorMode(l) {
    return l !== "hex"
}
class ColorTextsController {
    constructor(i, o) {
        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = o.colorType, this.value = o.value, this.viewProps = o.viewProps, this.colorMode = createValue(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(i), this.view = new ColorTextsView(i, {
            mode: this.colorMode,
            inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
            viewProps: this.viewProps
        }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_)
    }
    createComponentControllers_(i) {
        const o = this.colorMode.rawValue;
        return isColorMode(o) ? createComponentControllers(i, {
            colorMode: o,
            colorType: this.colorType_,
            value: this.value,
            viewProps: this.viewProps
        }) : createHexController(i, {
            value: this.value,
            viewProps: this.viewProps
        })
    }
    onModeSelectChange_(i) {
        const o = i.currentTarget;
        this.colorMode.rawValue = o.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.inputViews = this.ccs_.map(c => c.view)
    }
}
const cn$8 = ClassName("hpl");
class HPaletteView {
    constructor(i, o) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = o.value, this.value.emitter.on("change", this.onValueChange_), this.element = i.createElement("div"), this.element.classList.add(cn$8()), o.viewProps.bindClassModifiers(this.element), o.viewProps.bindTabIndex(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$8("c")), this.element.appendChild(c);
        const u = i.createElement("div");
        u.classList.add(cn$8("m")), this.element.appendChild(u), this.markerElem_ = u, this.update_()
    }
    update_() {
        const i = this.value.rawValue,
            [o] = i.getComponents("hsv");
        this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new IntColor([o, 100, 100], "hsv"));
        const c = mapRange$1(o, 0, 360, 0, 100);
        this.markerElem_.style.left = `${c}%`
    }
    onValueChange_() {
        this.update_()
    }
}
class HPaletteController {
    constructor(i, o) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.view = new HPaletteView(i, {
            value: this.value,
            viewProps: this.viewProps
        }), this.ptHandler_ = new PointerHandler(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
    }
    handlePointerEvent_(i, o) {
        if (!i.point) return;
        const c = mapRange$1(constrainRange(i.point.x, 0, i.bounds.width), 0, i.bounds.width, 0, 360),
            u = this.value.rawValue,
            [, p, m, g] = u.getComponents("hsv");
        this.value.setRawValue(new IntColor([c, p, m, g], "hsv"), o)
    }
    onPointerDown_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerMove_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onKeyDown_(i) {
        const o = getStepForKey(getKeyScaleForColor(!1), getHorizontalStepKeys(i));
        if (o === 0) return;
        const c = this.value.rawValue,
            [u, p, m, g] = c.getComponents("hsv");
        this.value.setRawValue(new IntColor([u + o, p, m, g], "hsv"), {
            forceEmit: !1,
            last: !1
        })
    }
    onKeyUp_(i) {
        getStepForKey(getKeyScaleForColor(!1), getHorizontalStepKeys(i)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
const cn$7 = ClassName("svp"),
    CANVAS_RESOL = 64;
class SvPaletteView {
    constructor(i, o) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = o.value, this.value.emitter.on("change", this.onValueChange_), this.element = i.createElement("div"), this.element.classList.add(cn$7()), o.viewProps.bindClassModifiers(this.element), o.viewProps.bindTabIndex(this.element);
        const c = i.createElement("canvas");
        c.height = CANVAS_RESOL, c.width = CANVAS_RESOL, c.classList.add(cn$7("c")), this.element.appendChild(c), this.canvasElement = c;
        const u = i.createElement("div");
        u.classList.add(cn$7("m")), this.element.appendChild(u), this.markerElem_ = u, this.update_()
    }
    update_() {
        const i = getCanvasContext(this.canvasElement);
        if (!i) return;
        const c = this.value.rawValue.getComponents("hsv"),
            u = this.canvasElement.width,
            p = this.canvasElement.height,
            m = i.getImageData(0, 0, u, p),
            g = m.data;
        for (let x = 0; x < p; x++)
            for (let y = 0; y < u; y++) {
                const b = mapRange$1(y, 0, u, 0, 100),
                    S = mapRange$1(x, 0, p, 100, 0),
                    C = hsvToRgbInt(c[0], b, S),
                    E = (x * u + y) * 4;
                g[E] = C[0], g[E + 1] = C[1], g[E + 2] = C[2], g[E + 3] = 255
            }
        i.putImageData(m, 0, 0);
        const _ = mapRange$1(c[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${_}%`;
        const v = mapRange$1(c[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${v}%`
    }
    onValueChange_() {
        this.update_()
    }
}
class SvPaletteController {
    constructor(i, o) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.view = new SvPaletteView(i, {
            value: this.value,
            viewProps: this.viewProps
        }), this.ptHandler_ = new PointerHandler(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
    }
    handlePointerEvent_(i, o) {
        if (!i.point) return;
        const c = mapRange$1(i.point.x, 0, i.bounds.width, 0, 100),
            u = mapRange$1(i.point.y, 0, i.bounds.height, 100, 0),
            [p, , , m] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new IntColor([p, c, u, m], "hsv"), o)
    }
    onPointerDown_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerMove_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onKeyDown_(i) {
        isArrowKey(i.key) && i.preventDefault();
        const [o, c, u, p] = this.value.rawValue.getComponents("hsv"), m = getKeyScaleForColor(!1), g = getStepForKey(m, getHorizontalStepKeys(i)), _ = getStepForKey(m, getVerticalStepKeys(i));
        g === 0 && _ === 0 || this.value.setRawValue(new IntColor([o, c + g, u + _, p], "hsv"), {
            forceEmit: !1,
            last: !1
        })
    }
    onKeyUp_(i) {
        const o = getKeyScaleForColor(!1),
            c = getStepForKey(o, getHorizontalStepKeys(i)),
            u = getStepForKey(o, getVerticalStepKeys(i));
        c === 0 && u === 0 || this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
class ColorPickerController {
    constructor(i, o) {
        this.value = o.value, this.viewProps = o.viewProps, this.hPaletteC_ = new HPaletteController(i, {
            value: this.value,
            viewProps: this.viewProps
        }), this.svPaletteC_ = new SvPaletteController(i, {
            value: this.value,
            viewProps: this.viewProps
        }), this.alphaIcs_ = o.supportsAlpha ? {
            palette: new APaletteController(i, {
                value: this.value,
                viewProps: this.viewProps
            }),
            text: new NumberTextController(i, {
                parser: parseNumber,
                props: ValueMap.fromObject({
                    pointerScale: .01,
                    keyScale: .1,
                    formatter: createNumberFormatter(2)
                }),
                value: createValue(0, {
                    constraint: new DefiniteRangeConstraint({
                        min: 0,
                        max: 1
                    })
                }),
                viewProps: this.viewProps
            })
        } : null, this.alphaIcs_ && connectValues({
            primary: this.value,
            secondary: this.alphaIcs_.text.value,
            forward: c => c.getComponents()[3],
            backward: (c, u) => {
                const p = c.getComponents();
                return p[3] = u, new IntColor(p, c.mode)
            }
        }), this.textsC_ = new ColorTextsController(i, {
            colorType: o.colorType,
            value: this.value,
            viewProps: this.viewProps
        }), this.view = new ColorPickerView(i, {
            alphaViews: this.alphaIcs_ ? {
                palette: this.alphaIcs_.palette.view,
                text: this.alphaIcs_.text.view
            } : null,
            hPaletteView: this.hPaletteC_.view,
            supportsAlpha: o.supportsAlpha,
            svPaletteView: this.svPaletteC_.view,
            textsView: this.textsC_.view,
            viewProps: this.viewProps
        })
    }
    get textsController() {
        return this.textsC_
    }
}
const cn$6 = ClassName("colsw");
class ColorSwatchView {
    constructor(i, o) {
        this.onValueChange_ = this.onValueChange_.bind(this), o.value.emitter.on("change", this.onValueChange_), this.value = o.value, this.element = i.createElement("div"), this.element.classList.add(cn$6()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$6("sw")), this.element.appendChild(c), this.swatchElem_ = c;
        const u = i.createElement("button");
        u.classList.add(cn$6("b")), o.viewProps.bindDisabled(u), this.element.appendChild(u), this.buttonElement = u, this.update_()
    }
    update_() {
        const i = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = colorToHexRgbaString(i)
    }
    onValueChange_() {
        this.update_()
    }
}
class ColorSwatchController {
    constructor(i, o) {
        this.value = o.value, this.viewProps = o.viewProps, this.view = new ColorSwatchView(i, {
            value: this.value,
            viewProps: this.viewProps
        })
    }
}
class ColorController {
    constructor(i, o) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.foldable_ = Foldable.create(o.expanded), this.swatchC_ = new ColorSwatchController(i, {
            value: this.value,
            viewProps: this.viewProps
        });
        const c = this.swatchC_.view.buttonElement;
        c.addEventListener("blur", this.onButtonBlur_), c.addEventListener("click", this.onButtonClick_), this.textC_ = new TextController(i, {
            parser: o.parser,
            props: ValueMap.fromObject({
                formatter: o.formatter
            }),
            value: this.value,
            viewProps: this.viewProps
        }), this.view = new ColorView(i, {
            foldable: this.foldable_,
            pickerLayout: o.pickerLayout
        }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = o.pickerLayout === "popup" ? new PopupController(i, {
            viewProps: this.viewProps
        }) : null;
        const u = new ColorPickerController(i, {
            colorType: o.colorType,
            supportsAlpha: o.supportsAlpha,
            value: this.value,
            viewProps: this.viewProps
        });
        u.view.allFocusableElements.forEach(p => {
            p.addEventListener("blur", this.onPopupChildBlur_), p.addEventListener("keydown", this.onPopupChildKeydown_)
        }), this.pickerC_ = u, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(u.view.element), connectValues({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: p => p,
            backward: (p, m) => m
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), bindFoldable(this.foldable_, this.view.pickerElement))
    }
    get textController() {
        return this.textC_
    }
    onButtonBlur_(i) {
        if (!this.popC_) return;
        const o = this.view.element,
            c = i.relatedTarget;
        (!c || !o.contains(c)) && (this.popC_.shows.rawValue = !1)
    }
    onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
    }
    onPopupChildBlur_(i) {
        if (!this.popC_) return;
        const o = this.popC_.view.element,
            c = findNextTarget(i);
        c && o.contains(c) || c && c === this.swatchC_.view.buttonElement && !supportsTouch(o.ownerDocument) || (this.popC_.shows.rawValue = !1)
    }
    onPopupChildKeydown_(i) {
        this.popC_ ? i.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && i.key === "Escape" && this.swatchC_.view.buttonElement.focus()
    }
}

function colorToRgbNumber(l) {
    return removeAlphaComponent(l.getComponents("rgb")).reduce((i, o) => i << 8 | Math.floor(o) & 255, 0)
}

function colorToRgbaNumber(l) {
    return l.getComponents("rgb").reduce((i, o, c) => {
        const u = Math.floor(c === 3 ? o * 255 : o) & 255;
        return i << 8 | u
    }, 0) >>> 0
}

function numberToRgbColor(l) {
    return new IntColor([l >> 16 & 255, l >> 8 & 255, l & 255], "rgb")
}

function numberToRgbaColor(l) {
    return new IntColor([l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, mapRange$1(l & 255, 0, 255, 0, 1)], "rgb")
}

function colorFromRgbNumber(l) {
    return typeof l != "number" ? IntColor.black() : numberToRgbColor(l)
}

function colorFromRgbaNumber(l) {
    return typeof l != "number" ? IntColor.black() : numberToRgbaColor(l)
}

function isRgbColorComponent(l, i) {
    return typeof l != "object" || isEmpty(l) ? !1 : i in l && typeof l[i] == "number"
}

function isRgbColorObject(l) {
    return isRgbColorComponent(l, "r") && isRgbColorComponent(l, "g") && isRgbColorComponent(l, "b")
}

function isRgbaColorObject(l) {
    return isRgbColorObject(l) && isRgbColorComponent(l, "a")
}

function isColorObject(l) {
    return isRgbColorObject(l)
}

function equalsColor(l, i) {
    if (l.mode !== i.mode || l.type !== i.type) return !1;
    const o = l.getComponents(),
        c = i.getComponents();
    for (let u = 0; u < o.length; u++)
        if (o[u] !== c[u]) return !1;
    return !0
}

function createColorComponentsFromRgbObject(l) {
    return "a" in l ? [l.r, l.g, l.b, l.a] : [l.r, l.g, l.b]
}

function createColorStringWriter(l) {
    const i = findColorStringifier(l);
    return i ? (o, c) => {
        writePrimitive(o, i(c))
    } : null
}

function createColorNumberWriter(l) {
    const i = l ? colorToRgbaNumber : colorToRgbNumber;
    return (o, c) => {
        writePrimitive(o, i(c))
    }
}

function writeRgbaColorObject(l, i, o) {
    const u = mapColorType(i, o).toRgbaObject();
    l.writeProperty("r", u.r), l.writeProperty("g", u.g), l.writeProperty("b", u.b), l.writeProperty("a", u.a)
}

function writeRgbColorObject(l, i, o) {
    const u = mapColorType(i, o).toRgbaObject();
    l.writeProperty("r", u.r), l.writeProperty("g", u.g), l.writeProperty("b", u.b)
}

function createColorObjectWriter(l, i) {
    return (o, c) => {
        l ? writeRgbaColorObject(o, c, i) : writeRgbColorObject(o, c, i)
    }
}

function shouldSupportAlpha$1(l) {
    var i;
    return !!(!((i = l ? .color) === null || i === void 0) && i.alpha)
}

function createFormatter$1(l) {
    return l ? i => colorToHexRgbaString(i, "0x") : i => colorToHexRgbString(i, "0x")
}

function isForColor(l) {
    return "color" in l || l.view === "color"
}
createPlugin({
    id: "input-color-number",
    type: "input",
    accept: (l, i) => {
        if (typeof l != "number" || !isForColor(i)) return null;
        const o = parseColorInputParams(i);
        return o ? {
            initialValue: l,
            params: Object.assign(Object.assign({}, o), {
                supportsAlpha: shouldSupportAlpha$1(i)
            })
        } : null
    },
    binding: {
        reader: l => l.params.supportsAlpha ? colorFromRgbaNumber : colorFromRgbNumber,
        equals: equalsColor,
        writer: l => createColorNumberWriter(l.params.supportsAlpha)
    },
    controller: l => {
        var i, o;
        return new ColorController(l.document, {
            colorType: "int",
            expanded: (i = l.params.expanded) !== null && i !== void 0 ? i : !1,
            formatter: createFormatter$1(l.params.supportsAlpha),
            parser: createColorStringParser("int"),
            pickerLayout: (o = l.params.picker) !== null && o !== void 0 ? o : "popup",
            supportsAlpha: l.params.supportsAlpha,
            value: l.value,
            viewProps: l.viewProps
        })
    }
});

function colorFromObject(l, i) {
    if (!isColorObject(l)) return mapColorType(IntColor.black(), i);
    if (i === "int") {
        const o = createColorComponentsFromRgbObject(l);
        return new IntColor(o, "rgb")
    }
    if (i === "float") {
        const o = createColorComponentsFromRgbObject(l);
        return new FloatColor(o, "rgb")
    }
    return mapColorType(IntColor.black(), "int")
}

function shouldSupportAlpha(l) {
    return isRgbaColorObject(l)
}

function createColorObjectBindingReader(l) {
    return i => {
        const o = colorFromObject(i, l);
        return mapColorType(o, "int")
    }
}

function createColorObjectFormatter(l, i) {
    return o => l ? colorToObjectRgbaString(o, i) : colorToObjectRgbString(o, i)
}
createPlugin({
    id: "input-color-object",
    type: "input",
    accept: (l, i) => {
        var o;
        if (!isColorObject(l)) return null;
        const c = parseColorInputParams(i);
        return c ? {
            initialValue: l,
            params: Object.assign(Object.assign({}, c), {
                colorType: (o = extractColorType(i)) !== null && o !== void 0 ? o : "int"
            })
        } : null
    },
    binding: {
        reader: l => createColorObjectBindingReader(l.params.colorType),
        equals: equalsColor,
        writer: l => createColorObjectWriter(shouldSupportAlpha(l.initialValue), l.params.colorType)
    },
    controller: l => {
        var i, o;
        const c = isRgbaColorObject(l.initialValue);
        return new ColorController(l.document, {
            colorType: l.params.colorType,
            expanded: (i = l.params.expanded) !== null && i !== void 0 ? i : !1,
            formatter: createColorObjectFormatter(c, l.params.colorType),
            parser: createColorStringParser("int"),
            pickerLayout: (o = l.params.picker) !== null && o !== void 0 ? o : "popup",
            supportsAlpha: c,
            value: l.value,
            viewProps: l.viewProps
        })
    }
});
createPlugin({
    id: "input-color-string",
    type: "input",
    accept: (l, i) => {
        if (typeof l != "string" || i.view === "text") return null;
        const o = detectStringColorFormat(l, extractColorType(i));
        if (!o) return null;
        const c = findColorStringifier(o);
        if (!c) return null;
        const u = parseColorInputParams(i);
        return u ? {
            initialValue: l,
            params: Object.assign(Object.assign({}, u), {
                format: o,
                stringifier: c
            })
        } : null
    },
    binding: {
        reader: () => readIntColorString,
        equals: equalsColor,
        writer: l => {
            const i = createColorStringWriter(l.params.format);
            if (!i) throw TpError.notBindable();
            return i
        }
    },
    controller: l => {
        var i, o;
        return new ColorController(l.document, {
            colorType: l.params.format.type,
            expanded: (i = l.params.expanded) !== null && i !== void 0 ? i : !1,
            formatter: l.params.stringifier,
            parser: createColorStringParser("int"),
            pickerLayout: (o = l.params.picker) !== null && o !== void 0 ? o : "popup",
            supportsAlpha: l.params.format.alpha,
            value: l.value,
            viewProps: l.viewProps
        })
    }
});
class PointNdConstraint {
    constructor(i) {
        this.components = i.components, this.asm_ = i.assembly
    }
    constrain(i) {
        const o = this.asm_.toComponents(i).map((c, u) => {
            var p, m;
            return (m = (p = this.components[u]) === null || p === void 0 ? void 0 : p.constrain(c)) !== null && m !== void 0 ? m : c
        });
        return this.asm_.fromComponents(o)
    }
}
const cn$5 = ClassName("pndtxt");
class PointNdTextView {
    constructor(i, o) {
        this.textViews = o.textViews, this.element = i.createElement("div"), this.element.classList.add(cn$5()), this.textViews.forEach(c => {
            const u = i.createElement("div");
            u.classList.add(cn$5("a")), u.appendChild(c.element), this.element.appendChild(u)
        })
    }
}

function createAxisController(l, i, o) {
    return new NumberTextController(l, {
        arrayPosition: o === 0 ? "fst" : o === i.axes.length - 1 ? "lst" : "mid",
        parser: i.parser,
        props: i.axes[o].textProps,
        value: createValue(0, {
            constraint: i.axes[o].constraint
        }),
        viewProps: i.viewProps
    })
}
class PointNdTextController {
    constructor(i, o) {
        this.value = o.value, this.viewProps = o.viewProps, this.acs_ = o.axes.map((c, u) => createAxisController(i, o, u)), this.acs_.forEach((c, u) => {
            connectValues({
                primary: this.value,
                secondary: c.value,
                forward: p => o.assembly.toComponents(p)[u],
                backward: (p, m) => {
                    const g = o.assembly.toComponents(p);
                    return g[u] = m, o.assembly.fromComponents(g)
                }
            })
        }), this.view = new PointNdTextView(i, {
            textViews: this.acs_.map(c => c.view)
        })
    }
    get textControllers() {
        return this.acs_
    }
}
class SliderInputBindingApi extends BindingApi {
    get max() {
        return this.controller.valueController.sliderController.props.get("max")
    }
    set max(i) {
        this.controller.valueController.sliderController.props.set("max", i)
    }
    get min() {
        return this.controller.valueController.sliderController.props.get("min")
    }
    set min(i) {
        this.controller.valueController.sliderController.props.set("min", i)
    }
}

function createConstraint$4(l, i) {
    const o = [],
        c = createStepConstraint(l, i);
    c && o.push(c);
    const u = createRangeConstraint(l);
    u && o.push(u);
    const p = createListConstraint(l.options);
    return p && o.push(p), new CompositeConstraint(o)
}
createPlugin({
    id: "input-number",
    type: "input",
    accept: (l, i) => {
        if (typeof l != "number") return null;
        const o = parseRecord(i, c => Object.assign(Object.assign({}, createNumberTextInputParamsParser(c)), {
            options: c.optional.custom(parseListOptions),
            readonly: c.optional.constant(!1)
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => numberFromUnknown,
        constraint: l => createConstraint$4(l.params, l.initialValue),
        writer: l => writePrimitive
    },
    controller: l => {
        const i = l.value,
            o = l.constraint,
            c = o && findConstraint(o, ListConstraint);
        if (c) return new ListController(l.document, {
            props: new ValueMap({
                options: c.values.value("options")
            }),
            value: i,
            viewProps: l.viewProps
        });
        const u = createNumberTextPropsObject(l.params, i.rawValue),
            p = o && findConstraint(o, DefiniteRangeConstraint);
        return p ? new SliderTextController(l.document, Object.assign(Object.assign({}, createSliderTextProps(Object.assign(Object.assign({}, u), {
            keyScale: createValue(u.keyScale),
            max: p.values.value("max"),
            min: p.values.value("min")
        }))), {
            parser: parseNumber,
            value: i,
            viewProps: l.viewProps
        })) : new NumberTextController(l.document, {
            parser: parseNumber,
            props: ValueMap.fromObject(u),
            value: i,
            viewProps: l.viewProps
        })
    },
    api(l) {
        return typeof l.controller.value.rawValue != "number" ? null : l.controller.valueController instanceof SliderTextController ? new SliderInputBindingApi(l.controller) : l.controller.valueController instanceof ListController ? new ListInputBindingApi(l.controller) : null
    }
});
class Point2d {
    constructor(i = 0, o = 0) {
        this.x = i, this.y = o
    }
    getComponents() {
        return [this.x, this.y]
    }
    static isObject(i) {
        if (isEmpty(i)) return !1;
        const o = i.x,
            c = i.y;
        return !(typeof o != "number" || typeof c != "number")
    }
    static equals(i, o) {
        return i.x === o.x && i.y === o.y
    }
    toObject() {
        return {
            x: this.x,
            y: this.y
        }
    }
}
const Point2dAssembly = {
        toComponents: l => l.getComponents(),
        fromComponents: l => new Point2d(...l)
    },
    cn$4 = ClassName("p2d");
class Point2dView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(cn$4()), o.viewProps.bindClassModifiers(this.element), bindValue(o.expanded, valueToClassName(this.element, cn$4(void 0, "expanded")));
        const c = i.createElement("div");
        c.classList.add(cn$4("h")), this.element.appendChild(c);
        const u = i.createElement("button");
        u.classList.add(cn$4("b")), u.appendChild(createSvgIconElement(i, "p2dpad")), o.viewProps.bindDisabled(u), c.appendChild(u), this.buttonElement = u;
        const p = i.createElement("div");
        if (p.classList.add(cn$4("t")), c.appendChild(p), this.textElement = p, o.pickerLayout === "inline") {
            const m = i.createElement("div");
            m.classList.add(cn$4("p")), this.element.appendChild(m), this.pickerElement = m
        } else this.pickerElement = null
    }
}
const cn$3 = ClassName("p2dp");
class Point2dPickerView {
    constructor(i, o) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onPropsChange_ = this.onPropsChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = o.props, this.props_.emitter.on("change", this.onPropsChange_), this.element = i.createElement("div"), this.element.classList.add(cn$3()), o.layout === "popup" && this.element.classList.add(cn$3(void 0, "p")), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("div");
        c.classList.add(cn$3("p")), o.viewProps.bindTabIndex(c), this.element.appendChild(c), this.padElement = c;
        const u = i.createElementNS(SVG_NS, "svg");
        u.classList.add(cn$3("g")), this.padElement.appendChild(u), this.svgElem_ = u;
        const p = i.createElementNS(SVG_NS, "line");
        p.classList.add(cn$3("ax")), p.setAttributeNS(null, "x1", "0"), p.setAttributeNS(null, "y1", "50%"), p.setAttributeNS(null, "x2", "100%"), p.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(p);
        const m = i.createElementNS(SVG_NS, "line");
        m.classList.add(cn$3("ax")), m.setAttributeNS(null, "x1", "50%"), m.setAttributeNS(null, "y1", "0"), m.setAttributeNS(null, "x2", "50%"), m.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(m);
        const g = i.createElementNS(SVG_NS, "line");
        g.classList.add(cn$3("l")), g.setAttributeNS(null, "x1", "50%"), g.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(g), this.lineElem_ = g;
        const _ = i.createElement("div");
        _.classList.add(cn$3("m")), this.padElement.appendChild(_), this.markerElem_ = _, o.value.emitter.on("change", this.onValueChange_), this.value = o.value, this.update_()
    }
    get allFocusableElements() {
        return [this.padElement]
    }
    update_() {
        const [i, o] = this.value.rawValue.getComponents(), c = this.props_.get("max"), u = mapRange$1(i, -c, +c, 0, 100), p = mapRange$1(o, -c, +c, 0, 100), m = this.props_.get("invertsY") ? 100 - p : p;
        this.lineElem_.setAttributeNS(null, "x2", `${u}%`), this.lineElem_.setAttributeNS(null, "y2", `${m}%`), this.markerElem_.style.left = `${u}%`, this.markerElem_.style.top = `${m}%`
    }
    onValueChange_() {
        this.update_()
    }
    onPropsChange_() {
        this.update_()
    }
    onFoldableChange_() {
        this.update_()
    }
}

function computeOffset(l, i, o) {
    return [getStepForKey(i[0], getHorizontalStepKeys(l)), getStepForKey(i[1], getVerticalStepKeys(l)) * (o ? 1 : -1)]
}
class Point2dPickerController {
    constructor(i, o) {
        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.props = o.props, this.value = o.value, this.viewProps = o.viewProps, this.view = new Point2dPickerView(i, {
            layout: o.layout,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
        }), this.ptHandler_ = new PointerHandler(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_)
    }
    handlePointerEvent_(i, o) {
        if (!i.point) return;
        const c = this.props.get("max"),
            u = mapRange$1(i.point.x, 0, i.bounds.width, -c, +c),
            p = mapRange$1(this.props.get("invertsY") ? i.bounds.height - i.point.y : i.point.y, 0, i.bounds.height, -c, +c);
        this.value.setRawValue(new Point2d(u, p), o)
    }
    onPointerDown_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerMove_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(i) {
        this.handlePointerEvent_(i.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onPadKeyDown_(i) {
        isArrowKey(i.key) && i.preventDefault();
        const [o, c] = computeOffset(i, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
        o === 0 && c === 0 || this.value.setRawValue(new Point2d(this.value.rawValue.x + o, this.value.rawValue.y + c), {
            forceEmit: !1,
            last: !1
        })
    }
    onPadKeyUp_(i) {
        const [o, c] = computeOffset(i, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
        o === 0 && c === 0 || this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
class Point2dController {
    constructor(i, o) {
        var c, u;
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.foldable_ = Foldable.create(o.expanded), this.popC_ = o.pickerLayout === "popup" ? new PopupController(i, {
            viewProps: this.viewProps
        }) : null;
        const p = new Point2dPickerController(i, {
            layout: o.pickerLayout,
            props: new ValueMap({
                invertsY: createValue(o.invertsY),
                max: createValue(o.max),
                xKeyScale: o.axes[0].textProps.value("keyScale"),
                yKeyScale: o.axes[1].textProps.value("keyScale")
            }),
            value: this.value,
            viewProps: this.viewProps
        });
        p.view.allFocusableElements.forEach(m => {
            m.addEventListener("blur", this.onPopupChildBlur_), m.addEventListener("keydown", this.onPopupChildKeydown_)
        }), this.pickerC_ = p, this.textC_ = new PointNdTextController(i, {
            assembly: Point2dAssembly,
            axes: o.axes,
            parser: o.parser,
            value: this.value,
            viewProps: this.viewProps
        }), this.view = new Point2dView(i, {
            expanded: this.foldable_.value("expanded"),
            pickerLayout: o.pickerLayout,
            viewProps: this.viewProps
        }), this.view.textElement.appendChild(this.textC_.view.element), (c = this.view.buttonElement) === null || c === void 0 || c.addEventListener("blur", this.onPadButtonBlur_), (u = this.view.buttonElement) === null || u === void 0 || u.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), connectValues({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: m => m,
            backward: (m, g) => g
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), bindFoldable(this.foldable_, this.view.pickerElement))
    }
    get textController() {
        return this.textC_
    }
    onPadButtonBlur_(i) {
        if (!this.popC_) return;
        const o = this.view.element,
            c = i.relatedTarget;
        (!c || !o.contains(c)) && (this.popC_.shows.rawValue = !1)
    }
    onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
    }
    onPopupChildBlur_(i) {
        if (!this.popC_) return;
        const o = this.popC_.view.element,
            c = findNextTarget(i);
        c && o.contains(c) || c && c === this.view.buttonElement && !supportsTouch(o.ownerDocument) || (this.popC_.shows.rawValue = !1)
    }
    onPopupChildKeydown_(i) {
        this.popC_ ? i.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && i.key === "Escape" && this.view.buttonElement.focus()
    }
}

function point2dFromUnknown(l) {
    return Point2d.isObject(l) ? new Point2d(l.x, l.y) : new Point2d
}

function writePoint2d(l, i) {
    l.writeProperty("x", i.x), l.writeProperty("y", i.y)
}

function createConstraint$3(l, i) {
    return new PointNdConstraint({
        assembly: Point2dAssembly,
        components: [createDimensionConstraint$1(Object.assign(Object.assign({}, l), l.x), i.x), createDimensionConstraint$1(Object.assign(Object.assign({}, l), l.y), i.y)]
    })
}

function getSuitableMaxDimensionValue(l, i) {
    var o, c;
    if (!isEmpty(l.min) || !isEmpty(l.max)) return Math.max(Math.abs((o = l.min) !== null && o !== void 0 ? o : 0), Math.abs((c = l.max) !== null && c !== void 0 ? c : 0));
    const u = getSuitableKeyScale(l);
    return Math.max(Math.abs(u) * 10, Math.abs(i) * 10)
}

function getSuitableMax(l, i) {
    var o, c;
    const u = getSuitableMaxDimensionValue(deepMerge(l, (o = l.x) !== null && o !== void 0 ? o : {}), i.x),
        p = getSuitableMaxDimensionValue(deepMerge(l, (c = l.y) !== null && c !== void 0 ? c : {}), i.y);
    return Math.max(u, p)
}

function shouldInvertY(l) {
    if (!("y" in l)) return !1;
    const i = l.y;
    return i && "inverted" in i ? !!i.inverted : !1
}
createPlugin({
    id: "input-point2d",
    type: "input",
    accept: (l, i) => {
        if (!Point2d.isObject(l)) return null;
        const o = parseRecord(i, c => Object.assign(Object.assign({}, createPointDimensionParser(c)), {
            expanded: c.optional.boolean,
            picker: c.optional.custom(parsePickerLayout),
            readonly: c.optional.constant(!1),
            x: c.optional.custom(parsePointDimensionParams),
            y: c.optional.object(Object.assign(Object.assign({}, createPointDimensionParser(c)), {
                inverted: c.optional.boolean
            }))
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: () => point2dFromUnknown,
        constraint: l => createConstraint$3(l.params, l.initialValue),
        equals: Point2d.equals,
        writer: () => writePoint2d
    },
    controller: l => {
        var i, o;
        const c = l.document,
            u = l.value,
            p = l.constraint,
            m = [l.params.x, l.params.y];
        return new Point2dController(c, {
            axes: u.rawValue.getComponents().map((g, _) => {
                var v;
                return createPointAxis({
                    constraint: p.components[_],
                    initialValue: g,
                    params: deepMerge(l.params, (v = m[_]) !== null && v !== void 0 ? v : {})
                })
            }),
            expanded: (i = l.params.expanded) !== null && i !== void 0 ? i : !1,
            invertsY: shouldInvertY(l.params),
            max: getSuitableMax(l.params, u.rawValue),
            parser: parseNumber,
            pickerLayout: (o = l.params.picker) !== null && o !== void 0 ? o : "popup",
            value: u,
            viewProps: l.viewProps
        })
    }
});
class Point3d {
    constructor(i = 0, o = 0, c = 0) {
        this.x = i, this.y = o, this.z = c
    }
    getComponents() {
        return [this.x, this.y, this.z]
    }
    static isObject(i) {
        if (isEmpty(i)) return !1;
        const o = i.x,
            c = i.y,
            u = i.z;
        return !(typeof o != "number" || typeof c != "number" || typeof u != "number")
    }
    static equals(i, o) {
        return i.x === o.x && i.y === o.y && i.z === o.z
    }
    toObject() {
        return {
            x: this.x,
            y: this.y,
            z: this.z
        }
    }
}
const Point3dAssembly = {
    toComponents: l => l.getComponents(),
    fromComponents: l => new Point3d(...l)
};

function point3dFromUnknown(l) {
    return Point3d.isObject(l) ? new Point3d(l.x, l.y, l.z) : new Point3d
}

function writePoint3d(l, i) {
    l.writeProperty("x", i.x), l.writeProperty("y", i.y), l.writeProperty("z", i.z)
}

function createConstraint$2(l, i) {
    return new PointNdConstraint({
        assembly: Point3dAssembly,
        components: [createDimensionConstraint$1(Object.assign(Object.assign({}, l), l.x), i.x), createDimensionConstraint$1(Object.assign(Object.assign({}, l), l.y), i.y), createDimensionConstraint$1(Object.assign(Object.assign({}, l), l.z), i.z)]
    })
}
createPlugin({
    id: "input-point3d",
    type: "input",
    accept: (l, i) => {
        if (!Point3d.isObject(l)) return null;
        const o = parseRecord(i, c => Object.assign(Object.assign({}, createPointDimensionParser(c)), {
            readonly: c.optional.constant(!1),
            x: c.optional.custom(parsePointDimensionParams),
            y: c.optional.custom(parsePointDimensionParams),
            z: c.optional.custom(parsePointDimensionParams)
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => point3dFromUnknown,
        constraint: l => createConstraint$2(l.params, l.initialValue),
        equals: Point3d.equals,
        writer: l => writePoint3d
    },
    controller: l => {
        const i = l.value,
            o = l.constraint,
            c = [l.params.x, l.params.y, l.params.z];
        return new PointNdTextController(l.document, {
            assembly: Point3dAssembly,
            axes: i.rawValue.getComponents().map((u, p) => {
                var m;
                return createPointAxis({
                    constraint: o.components[p],
                    initialValue: u,
                    params: deepMerge(l.params, (m = c[p]) !== null && m !== void 0 ? m : {})
                })
            }),
            parser: parseNumber,
            value: i,
            viewProps: l.viewProps
        })
    }
});
class Point4d {
    constructor(i = 0, o = 0, c = 0, u = 0) {
        this.x = i, this.y = o, this.z = c, this.w = u
    }
    getComponents() {
        return [this.x, this.y, this.z, this.w]
    }
    static isObject(i) {
        if (isEmpty(i)) return !1;
        const o = i.x,
            c = i.y,
            u = i.z,
            p = i.w;
        return !(typeof o != "number" || typeof c != "number" || typeof u != "number" || typeof p != "number")
    }
    static equals(i, o) {
        return i.x === o.x && i.y === o.y && i.z === o.z && i.w === o.w
    }
    toObject() {
        return {
            x: this.x,
            y: this.y,
            z: this.z,
            w: this.w
        }
    }
}
const Point4dAssembly = {
    toComponents: l => l.getComponents(),
    fromComponents: l => new Point4d(...l)
};

function point4dFromUnknown(l) {
    return Point4d.isObject(l) ? new Point4d(l.x, l.y, l.z, l.w) : new Point4d
}

function writePoint4d(l, i) {
    l.writeProperty("x", i.x), l.writeProperty("y", i.y), l.writeProperty("z", i.z), l.writeProperty("w", i.w)
}

function createConstraint$1(l, i) {
    return new PointNdConstraint({
        assembly: Point4dAssembly,
        components: [createDimensionConstraint$1(Object.assign(Object.assign({}, l), l.x), i.x), createDimensionConstraint$1(Object.assign(Object.assign({}, l), l.y), i.y), createDimensionConstraint$1(Object.assign(Object.assign({}, l), l.z), i.z), createDimensionConstraint$1(Object.assign(Object.assign({}, l), l.w), i.w)]
    })
}
createPlugin({
    id: "input-point4d",
    type: "input",
    accept: (l, i) => {
        if (!Point4d.isObject(l)) return null;
        const o = parseRecord(i, c => Object.assign(Object.assign({}, createPointDimensionParser(c)), {
            readonly: c.optional.constant(!1),
            w: c.optional.custom(parsePointDimensionParams),
            x: c.optional.custom(parsePointDimensionParams),
            y: c.optional.custom(parsePointDimensionParams),
            z: c.optional.custom(parsePointDimensionParams)
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => point4dFromUnknown,
        constraint: l => createConstraint$1(l.params, l.initialValue),
        equals: Point4d.equals,
        writer: l => writePoint4d
    },
    controller: l => {
        const i = l.value,
            o = l.constraint,
            c = [l.params.x, l.params.y, l.params.z, l.params.w];
        return new PointNdTextController(l.document, {
            assembly: Point4dAssembly,
            axes: i.rawValue.getComponents().map((u, p) => {
                var m;
                return createPointAxis({
                    constraint: o.components[p],
                    initialValue: u,
                    params: deepMerge(l.params, (m = c[p]) !== null && m !== void 0 ? m : {})
                })
            }),
            parser: parseNumber,
            value: i,
            viewProps: l.viewProps
        })
    }
});

function createConstraint(l) {
    const i = [],
        o = createListConstraint(l.options);
    return o && i.push(o), new CompositeConstraint(i)
}
createPlugin({
    id: "input-string",
    type: "input",
    accept: (l, i) => {
        if (typeof l != "string") return null;
        const o = parseRecord(i, c => ({
            readonly: c.optional.constant(!1),
            options: c.optional.custom(parseListOptions)
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => stringFromUnknown,
        constraint: l => createConstraint(l.params),
        writer: l => writePrimitive
    },
    controller: l => {
        const i = l.document,
            o = l.value,
            c = l.constraint,
            u = c && findConstraint(c, ListConstraint);
        return u ? new ListController(i, {
            props: new ValueMap({
                options: u.values.value("options")
            }),
            value: o,
            viewProps: l.viewProps
        }) : new TextController(i, {
            parser: p => p,
            props: ValueMap.fromObject({
                formatter: formatString
            }),
            value: o,
            viewProps: l.viewProps
        })
    },
    api(l) {
        return typeof l.controller.value.rawValue != "string" ? null : l.controller.valueController instanceof ListController ? new ListInputBindingApi(l.controller) : null
    }
});
const Constants = {
        monitor: {
            defaultRows: 3
        }
    },
    cn$2 = ClassName("mll");
class MultiLogView {
    constructor(i, o) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = o.formatter, this.element = i.createElement("div"), this.element.classList.add(cn$2()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("textarea");
        c.classList.add(cn$2("i")), c.style.height = `calc(var(${getCssVar("containerUnitSize")}) * ${o.rows})`, c.readOnly = !0, o.viewProps.bindDisabled(c), this.element.appendChild(c), this.textareaElem_ = c, o.value.emitter.on("change", this.onValueUpdate_), this.value = o.value, this.update_()
    }
    update_() {
        const i = this.textareaElem_,
            o = i.scrollTop === i.scrollHeight - i.clientHeight,
            c = [];
        this.value.rawValue.forEach(u => {
            u !== void 0 && c.push(this.formatter_(u))
        }), i.textContent = c.join(`
`), o && (i.scrollTop = i.scrollHeight)
    }
    onValueUpdate_() {
        this.update_()
    }
}
class MultiLogController {
    constructor(i, o) {
        this.value = o.value, this.viewProps = o.viewProps, this.view = new MultiLogView(i, {
            formatter: o.formatter,
            rows: o.rows,
            value: this.value,
            viewProps: this.viewProps
        })
    }
}
const cn$1 = ClassName("sgl");
class SingleLogView {
    constructor(i, o) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = o.formatter, this.element = i.createElement("div"), this.element.classList.add(cn$1()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("input");
        c.classList.add(cn$1("i")), c.readOnly = !0, c.type = "text", o.viewProps.bindDisabled(c), this.element.appendChild(c), this.inputElement = c, o.value.emitter.on("change", this.onValueUpdate_), this.value = o.value, this.update_()
    }
    update_() {
        const i = this.value.rawValue,
            o = i[i.length - 1];
        this.inputElement.value = o !== void 0 ? this.formatter_(o) : ""
    }
    onValueUpdate_() {
        this.update_()
    }
}
class SingleLogController {
    constructor(i, o) {
        this.value = o.value, this.viewProps = o.viewProps, this.view = new SingleLogView(i, {
            formatter: o.formatter,
            value: this.value,
            viewProps: this.viewProps
        })
    }
}
createPlugin({
    id: "monitor-bool",
    type: "monitor",
    accept: (l, i) => {
        if (typeof l != "boolean") return null;
        const o = parseRecord(i, c => ({
            readonly: c.required.constant(!0),
            rows: c.optional.number
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => boolFromUnknown
    },
    controller: l => {
        var i;
        return l.value.rawValue.length === 1 ? new SingleLogController(l.document, {
            formatter: BooleanFormatter,
            value: l.value,
            viewProps: l.viewProps
        }) : new MultiLogController(l.document, {
            formatter: BooleanFormatter,
            rows: (i = l.params.rows) !== null && i !== void 0 ? i : Constants.monitor.defaultRows,
            value: l.value,
            viewProps: l.viewProps
        })
    }
});
class GraphLogMonitorBindingApi extends BindingApi {
    get max() {
        return this.controller.valueController.props.get("max")
    }
    set max(i) {
        this.controller.valueController.props.set("max", i)
    }
    get min() {
        return this.controller.valueController.props.get("min")
    }
    set min(i) {
        this.controller.valueController.props.set("min", i)
    }
}
const cn = ClassName("grl");
class GraphLogView {
    constructor(i, o) {
        this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = i.createElement("div"), this.element.classList.add(cn()), o.viewProps.bindClassModifiers(this.element), this.formatter_ = o.formatter, this.props_ = o.props, this.cursor_ = o.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
        const c = i.createElementNS(SVG_NS, "svg");
        c.classList.add(cn("g")), c.style.height = `calc(var(${getCssVar("containerUnitSize")}) * ${o.rows})`, this.element.appendChild(c), this.svgElem_ = c;
        const u = i.createElementNS(SVG_NS, "polyline");
        this.svgElem_.appendChild(u), this.lineElem_ = u;
        const p = i.createElement("div");
        p.classList.add(cn("t"), ClassName("tt")()), this.element.appendChild(p), this.tooltipElem_ = p, o.value.emitter.on("change", this.onValueUpdate_), this.value = o.value, this.update_()
    }
    get graphElement() {
        return this.svgElem_
    }
    update_() {
        const i = this.svgElem_.getBoundingClientRect(),
            o = this.value.rawValue.length - 1,
            c = this.props_.get("min"),
            u = this.props_.get("max"),
            p = [];
        this.value.rawValue.forEach((x, y) => {
            if (x === void 0) return;
            const b = mapRange$1(y, 0, o, 0, i.width),
                S = mapRange$1(x, c, u, i.height, 0);
            p.push([b, S].join(","))
        }), this.lineElem_.setAttributeNS(null, "points", p.join(" "));
        const m = this.tooltipElem_,
            g = this.value.rawValue[this.cursor_.rawValue];
        if (g === void 0) {
            m.classList.remove(cn("t", "a"));
            return
        }
        const _ = mapRange$1(this.cursor_.rawValue, 0, o, 0, i.width),
            v = mapRange$1(g, c, u, i.height, 0);
        m.style.left = `${_}px`, m.style.top = `${v}px`, m.textContent = `${this.formatter_(g)}`, m.classList.contains(cn("t", "a")) || (m.classList.add(cn("t", "a"), cn("t", "in")), forceReflow(m), m.classList.remove(cn("t", "in")))
    }
    onValueUpdate_() {
        this.update_()
    }
    onCursorChange_() {
        this.update_()
    }
}
class GraphLogController {
    constructor(i, o) {
        if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props = o.props, this.value = o.value, this.viewProps = o.viewProps, this.cursor_ = createValue(-1), this.view = new GraphLogView(i, {
                cursor: this.cursor_,
                formatter: o.formatter,
                rows: o.rows,
                props: this.props,
                value: this.value,
                viewProps: this.viewProps
            }), !supportsTouch(i)) this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
        else {
            const c = new PointerHandler(this.view.element);
            c.emitter.on("down", this.onGraphPointerDown_), c.emitter.on("move", this.onGraphPointerMove_), c.emitter.on("up", this.onGraphPointerUp_)
        }
    }
    importProps(i) {
        return importBladeState(i, null, o => ({
            max: o.required.number,
            min: o.required.number
        }), o => (this.props.set("max", o.max), this.props.set("min", o.min), !0))
    }
    exportProps() {
        return exportBladeState(null, {
            max: this.props.get("max"),
            min: this.props.get("min")
        })
    }
    onGraphMouseLeave_() {
        this.cursor_.rawValue = -1
    }
    onGraphMouseMove_(i) {
        const o = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(mapRange$1(i.offsetX, 0, o.width, 0, this.value.rawValue.length))
    }
    onGraphPointerDown_(i) {
        this.onGraphPointerMove_(i)
    }
    onGraphPointerMove_(i) {
        if (!i.data.point) {
            this.cursor_.rawValue = -1;
            return
        }
        this.cursor_.rawValue = Math.floor(mapRange$1(i.data.point.x, 0, i.data.bounds.width, 0, this.value.rawValue.length))
    }
    onGraphPointerUp_() {
        this.cursor_.rawValue = -1
    }
}

function createFormatter(l) {
    return isEmpty(l.format) ? createNumberFormatter(2) : l.format
}

function createTextMonitor(l) {
    var i;
    return l.value.rawValue.length === 1 ? new SingleLogController(l.document, {
        formatter: createFormatter(l.params),
        value: l.value,
        viewProps: l.viewProps
    }) : new MultiLogController(l.document, {
        formatter: createFormatter(l.params),
        rows: (i = l.params.rows) !== null && i !== void 0 ? i : Constants.monitor.defaultRows,
        value: l.value,
        viewProps: l.viewProps
    })
}

function createGraphMonitor(l) {
    var i, o, c;
    return new GraphLogController(l.document, {
        formatter: createFormatter(l.params),
        rows: (i = l.params.rows) !== null && i !== void 0 ? i : Constants.monitor.defaultRows,
        props: ValueMap.fromObject({
            max: (o = l.params.max) !== null && o !== void 0 ? o : 100,
            min: (c = l.params.min) !== null && c !== void 0 ? c : 0
        }),
        value: l.value,
        viewProps: l.viewProps
    })
}

function shouldShowGraph(l) {
    return l.view === "graph"
}
createPlugin({
    id: "monitor-number",
    type: "monitor",
    accept: (l, i) => {
        if (typeof l != "number") return null;
        const o = parseRecord(i, c => ({
            format: c.optional.function,
            max: c.optional.number,
            min: c.optional.number,
            readonly: c.required.constant(!0),
            rows: c.optional.number,
            view: c.optional.string
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        defaultBufferSize: l => shouldShowGraph(l) ? 64 : 1,
        reader: l => numberFromUnknown
    },
    controller: l => shouldShowGraph(l.params) ? createGraphMonitor(l) : createTextMonitor(l),
    api: l => l.controller.valueController instanceof GraphLogController ? new GraphLogMonitorBindingApi(l.controller) : null
});
createPlugin({
    id: "monitor-string",
    type: "monitor",
    accept: (l, i) => {
        if (typeof l != "string") return null;
        const o = parseRecord(i, c => ({
            multiline: c.optional.boolean,
            readonly: c.required.constant(!0),
            rows: c.optional.number
        }));
        return o ? {
            initialValue: l,
            params: o
        } : null
    },
    binding: {
        reader: l => stringFromUnknown
    },
    controller: l => {
        var i;
        const o = l.value;
        return o.rawValue.length > 1 || l.params.multiline ? new MultiLogController(l.document, {
            formatter: formatString,
            rows: (i = l.params.rows) !== null && i !== void 0 ? i : Constants.monitor.defaultRows,
            value: o,
            viewProps: l.viewProps
        }) : new SingleLogController(l.document, {
            formatter: formatString,
            value: o,
            viewProps: l.viewProps
        })
    }
});
class Rotation {
    multiply(i) {
        return this.format(this.quat.multiply(i.quat))
    }
    premultiply(i) {
        return this.format(i.multiply(this))
    }
    slerp(i, o) {
        return this.format(this.quat.slerp(i.quat, o))
    }
}

function clamp$1(l, i, o) {
    return Math.min(Math.max(l, i), o)
}

function lofi(l, i) {
    return Math.floor(l / i) * i
}

function mod(l, i) {
    return l - lofi(l, i)
}

function sanitizeAngle(l) {
    return mod(l + Math.PI, Math.PI * 2) - Math.PI
}
class Euler extends Rotation {
    static fromQuaternion(i, o, c) {
        const u = i.toMat3(),
            [p, m, g, _] = o === "XYZ" ? [0, 1, 2, 1] : o === "XZY" ? [0, 2, 1, -1] : o === "YXZ" ? [1, 0, 2, -1] : o === "YZX" ? [1, 2, 0, 1] : o === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1],
            v = [0, 0, 0],
            x = u[g + p * 3];
        return v[m] = -_ * Math.asin(clamp$1(x, -1, 1)), Math.abs(x) < .999999 ? (v[p] = _ * Math.atan2(u[g + m * 3], u[g * 4]), v[g] = _ * Math.atan2(u[m + p * 3], u[p * 4])) : v[p] = _ * Math.atan2(-u[m + g * 3], u[m * 4]), Math.abs(v[p]) + Math.abs(v[g]) > Math.PI && (v[p] = sanitizeAngle(v[p] + Math.PI), v[m] = sanitizeAngle(Math.PI - v[m]), v[g] = sanitizeAngle(v[g] + Math.PI)), new Euler(...v, o).reunit(c)
    }
    constructor(i, o, c, u, p) {
        super(), this.x = i ? ? 0, this.y = o ? ? 0, this.z = c ? ? 0, this.order = u ? ? "XYZ", this.unit = p ? ? "rad"
    }
    get quat() {
        return Quaternion.fromEuler(this)
    }
    getComponents() {
        return [this.x, this.y, this.z]
    }
    toEuler(i, o) {
        return this.reorder(i).reunit(o)
    }
    format(i) {
        return i instanceof Euler ? i.reorder(this.order) : i.toEuler(this.order, this.unit)
    }
    reorder(i) {
        return i === this.order ? this : this.quat.toEuler(i, this.unit)
    }
    reunit(i) {
        const o = {
                deg: Math.PI / 180,
                rad: 1,
                turn: 2 * Math.PI
            }[this.unit],
            c = {
                deg: 180 / Math.PI,
                rad: 1,
                turn: .5 / Math.PI
            }[i],
            u = o * c;
        return new Euler(u * this.x, u * this.y, u * this.z, this.order, i)
    }
}
class Quaternion extends Rotation {
    static fromAxisAngle(i, o) {
        const c = o / 2,
            u = Math.sin(c);
        return new Quaternion(i.x * u, i.y * u, i.z * u, Math.cos(c))
    }
    static fromEuler(i) {
        const o = i.reunit("rad"),
            [c, u, p, m] = o.order === "XYZ" ? [0, 1, 2, 1] : o.order === "XZY" ? [0, 2, 1, -1] : o.order === "YXZ" ? [1, 0, 2, -1] : o.order === "YZX" ? [1, 2, 0, 1] : o.order === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1],
            g = o.getComponents(),
            _ = .5 * g[c],
            v = .5 * m * g[u],
            x = .5 * g[p],
            y = Math.cos(_),
            b = Math.cos(v),
            S = Math.cos(x),
            C = Math.sin(_),
            E = Math.sin(v),
            P = Math.sin(x),
            w = [0, 0, 0, S * b * y + P * E * C];
        return w[c] = S * b * C - P * E * y, w[u] = m * (S * E * y + P * b * C), w[p] = P * b * y - S * E * C, new Quaternion(...w)
    }
    static lookRotation(i, o) {
        const {
            normal: c,
            tangent: u,
            binormal: p
        } = i.orthoNormalize(o), m = p.x, g = u.x, _ = c.x, v = p.y, x = u.y, y = c.y, b = p.z, S = u.z, C = c.z, E = m + x + C;
        if (E > 0) {
            const P = .5 / Math.sqrt(E + 1);
            return new Quaternion((S - y) * P, (_ - b) * P, (v - g) * P, .25 / P)
        } else if (m > x && m > C) {
            const P = 2 * Math.sqrt(1 + m - x - C);
            return new Quaternion(.25 * P, (g + v) / P, (_ + b) / P, (S - y) / P)
        } else if (x > C) {
            const P = 2 * Math.sqrt(1 + x - m - C);
            return new Quaternion((g + v) / P, .25 * P, (y + S) / P, (_ - b) / P)
        } else {
            const P = 2 * Math.sqrt(1 + C - m - x);
            return new Quaternion((_ + b) / P, (y + S) / P, .25 * P, (v - g) / P)
        }
    }
    constructor(i, o, c, u) {
        super(), this.x = i ? ? 0, this.y = o ? ? 0, this.z = c ? ? 0, this.w = u ? ? 1
    }
    get quat() {
        return this
    }
    getComponents() {
        return [this.x, this.y, this.z, this.w]
    }
    toEuler(i, o) {
        return Euler.fromQuaternion(this, i, o)
    }
    get lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    get length() {
        return Math.sqrt(this.lengthSq)
    }
    get normalized() {
        const i = this.length;
        return i === 0 ? new Quaternion : new Quaternion(this.x / i, this.y / i, this.z / i, this.w / i)
    }
    get negated() {
        return new Quaternion(-this.x, -this.y, -this.z, -this.w)
    }
    get ban360s() {
        return this.w < 0 ? this.negated : this
    }
    multiply(i) {
        const o = i.quat;
        return new Quaternion(this.w * o.x + this.x * o.w + this.y * o.z - this.z * o.y, this.w * o.y - this.x * o.z + this.y * o.w + this.z * o.x, this.w * o.z + this.x * o.y - this.y * o.x + this.z * o.w, this.w * o.w - this.x * o.x - this.y * o.y - this.z * o.z)
    }
    format(i) {
        return i.quat
    }
    slerp(i, o) {
        let c = i.quat;
        if (o === 0) return this;
        if (o === 1) return c;
        const u = this.ban360s;
        c = c.ban360s;
        let p = u.w * c.w + u.x * c.x + u.y * c.y + u.z * c.z;
        if (p < 0 && (c = c.negated, p = -p), p >= 1) return u;
        const m = 1 - p * p;
        if (m <= Number.EPSILON) {
            const y = 1 - o;
            return new Quaternion(y * u.x + o * c.x, y * u.y + o * c.y, y * u.z + o * c.z, y * u.w + o * c.w).normalized
        }
        const g = Math.sqrt(m),
            _ = Math.atan2(g, p),
            v = Math.sin((1 - o) * _) / g,
            x = Math.sin(o * _) / g;
        return new Quaternion(u.x * v + c.x * x, u.y * v + c.y * x, u.z * v + c.z * x, u.w * v + c.w * x)
    }
    toMat3() {
        const {
            x: i,
            y: o,
            z: c,
            w: u
        } = this;
        return [1 - 2 * o * o - 2 * c * c, 2 * i * o + 2 * c * u, 2 * i * c - 2 * o * u, 2 * i * o - 2 * c * u, 1 - 2 * i * i - 2 * c * c, 2 * o * c + 2 * i * u, 2 * i * c + 2 * o * u, 2 * o * c - 2 * i * u, 1 - 2 * i * i - 2 * o * o]
    }
}
class PointProjector {
    constructor() {
        this.offset = [0, 0, -5], this.fov = 30, this.aspect = 1, this.viewport = [0, 0, 1, 1]
    }
    project(i) {
        const o = (this.viewport[0] + this.viewport[2]) * .5,
            c = (this.viewport[1] + this.viewport[3]) * .5,
            u = this.viewport[2] - this.viewport[0],
            p = this.viewport[3] - this.viewport[1],
            m = 1 / Math.tan(this.fov * Math.PI / 360),
            g = -(i.z + this.offset[2]),
            _ = o + (i.x + this.offset[0]) / g * m * u * .5 / this.aspect,
            v = c - (i.y + this.offset[1]) / g * m * p * .5;
        return [_, v]
    }
}
class SVGLineStrip {
    constructor(i, o, c) {
        this.element = i.createElementNS(SVG_NS, "path"), this.vertices = o, this.projector = c
    }
    setRotation(i) {
        let o = "";
        return this.vertices.forEach((c, u) => {
            const p = c.applyQuaternion(i),
                [m, g] = this.projector.project(p);
            o += `${u===0?"M":"L"}${m} ${g}`
        }), this.element.setAttributeNS(null, "d", o), this
    }
}
class Vector3 {
    constructor(i, o, c) {
        this.x = i ? ? 0, this.y = o ? ? 0, this.z = c ? ? 0
    }
    getComponents() {
        return [this.x, this.y, this.z]
    }
    get lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    get length() {
        return Math.sqrt(this.lengthSq)
    }
    get normalized() {
        const i = this.length;
        return i === 0 ? new Vector3 : new Vector3(this.x / i, this.y / i, this.z / i)
    }
    get negated() {
        return new Vector3(-this.x, -this.y, -this.z)
    }
    add(i) {
        return new Vector3(this.x + i.x, this.y + i.y, this.z + i.z)
    }
    sub(i) {
        return new Vector3(this.x - i.x, this.y - i.y, this.z - i.z)
    }
    scale(i) {
        return new Vector3(this.x * i, this.y * i, this.z * i)
    }
    dot(i) {
        return this.x * i.x + this.y * i.y + this.z * i.z
    }
    cross(i) {
        return new Vector3(this.y * i.z - this.z * i.y, this.z * i.x - this.x * i.z, this.x * i.y - this.y * i.x)
    }
    orthoNormalize(i) {
        const o = this.normalized;
        i = i.normalized;
        let c = o.dot(i);
        c === 1 && (Math.abs(o.y) > Math.abs(o.z) ? i = new Vector3(0, 0, 1) : i = new Vector3(0, 1, 0), c = o.dot(i)), i = i.sub(o.scale(c)).normalized;
        const u = i.cross(o);
        return {
            normal: o,
            tangent: i,
            binormal: u
        }
    }
    applyQuaternion(i) {
        const o = i.w * this.x + i.y * this.z - i.z * this.y,
            c = i.w * this.y + i.z * this.x - i.x * this.z,
            u = i.w * this.z + i.x * this.y - i.y * this.x,
            p = -i.x * this.x - i.y * this.y - i.z * this.z;
        return new Vector3(o * i.w + p * -i.x + c * -i.z - u * -i.y, c * i.w + p * -i.y + u * -i.x - o * -i.z, u * i.w + p * -i.z + o * -i.y - c * -i.x)
    }
}

function createArcRotation(l, i) {
    const o = i.z > 0 ? new Quaternion(0, 0, 0, 1) : new Quaternion(0, 0, 1, 0);
    return Math.abs(l.z) > .9999 ? o : Quaternion.lookRotation(l, i)
}

function createArcVerticesArray(l, i, o, c, u, p = 1) {
    const m = [];
    for (let g = 0; g < o; g++) {
        const _ = l + i * g / (o - 1),
            v = new Vector3;
        v[c] = p * Math.cos(_), v[u] = p * Math.sin(_), m.push(v)
    }
    return m
}
const className$2 = ClassName("rotationgizmo"),
    VEC3_ZERO = new Vector3(0, 0, 0),
    VEC3_XP$2 = new Vector3(1, 0, 0),
    VEC3_YP$2 = new Vector3(0, 1, 0),
    VEC3_ZP$2 = new Vector3(0, 0, 1),
    VEC3_ZN = new Vector3(0, 0, -1),
    VEC3_XP70 = new Vector3(.7, 0, 0),
    VEC3_YP70 = new Vector3(0, .7, 0),
    VEC3_ZP70 = new Vector3(0, 0, .7),
    VEC3_XN70 = new Vector3(-.7, 0, 0),
    VEC3_YN70 = new Vector3(0, -.7, 0),
    VEC3_ZN70 = new Vector3(0, 0, -.7),
    QUAT_IDENTITY$2 = new Quaternion(0, 0, 0, 1);

function createLabel(l, i, o) {
    const c = l.createElementNS(SVG_NS, "g"),
        u = l.createElementNS(SVG_NS, "circle");
    u.classList.add(className$2(i)), u.setAttributeNS(null, "cx", "0"), u.setAttributeNS(null, "cy", "0"), u.setAttributeNS(null, "r", "8"), c.appendChild(u);
    const p = l.createElementNS(SVG_NS, "text");
    return p.classList.add(className$2("labeltext")), p.setAttributeNS(null, "y", "4"), p.setAttributeNS(null, "text-anchor", "middle"), p.setAttributeNS(null, "font-size", "10"), p.textContent = o, c.appendChild(p), c
}
class RotationInputGizmoView {
    get xArcBElement() {
        return this.xArcBC_.element
    }
    get yArcBElement() {
        return this.yArcBC_.element
    }
    get zArcBElement() {
        return this.zArcBC_.element
    }
    get xArcFElement() {
        return this.xArcFC_.element
    }
    get yArcFElement() {
        return this.yArcFC_.element
    }
    get zArcFElement() {
        return this.zArcFC_.element
    }
    get rArcElement() {
        return this.rArcC_.element
    }
    constructor(i, o) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.onModeChange_ = this.onModeChange_.bind(this), this.element = i.createElement("div"), this.element.classList.add(className$2()), o.pickerLayout === "popup" && this.element.classList.add(className$2(void 0, "p"));
        const c = i.createElement("div");
        c.classList.add(className$2("p")), o.viewProps.bindTabIndex(c), this.element.appendChild(c), this.padElement = c;
        const u = i.createElementNS(SVG_NS, "svg");
        u.classList.add(className$2("g")), this.padElement.appendChild(u), this.svgElem_ = u, this.projector_ = new PointProjector, this.projector_.viewport = [0, 0, 136, 136];
        const p = createArcVerticesArray(0, Math.PI, 33, "x", "y"),
            m = createArcVerticesArray(0, 2 * Math.PI, 65, "x", "y", 1.1);
        this.xArcB_ = new SVGLineStrip(i, p, this.projector_), this.xArcB_.element.classList.add(className$2("arcx")), this.svgElem_.appendChild(this.xArcB_.element), this.yArcB_ = new SVGLineStrip(i, p, this.projector_), this.yArcB_.element.classList.add(className$2("arcy")), this.svgElem_.appendChild(this.yArcB_.element), this.zArcB_ = new SVGLineStrip(i, p, this.projector_), this.zArcB_.element.classList.add(className$2("arcz")), this.svgElem_.appendChild(this.zArcB_.element), this.xArcBC_ = new SVGLineStrip(i, p, this.projector_), this.xArcBC_.element.classList.add(className$2("arcc")), this.svgElem_.appendChild(this.xArcBC_.element), this.yArcBC_ = new SVGLineStrip(i, p, this.projector_), this.yArcBC_.element.classList.add(className$2("arcc")), this.svgElem_.appendChild(this.yArcBC_.element), this.zArcBC_ = new SVGLineStrip(i, p, this.projector_), this.zArcBC_.element.classList.add(className$2("arcc")), this.svgElem_.appendChild(this.zArcBC_.element);
        const g = i.createElementNS(SVG_NS, "g");
        u.classList.add(className$2("axes")), this.svgElem_.appendChild(g), this.axesElem_ = g, this.xAxis_ = new SVGLineStrip(i, [VEC3_ZERO, VEC3_XP70], this.projector_), this.xAxis_.element.classList.add(className$2("axisx")), this.axesElem_.appendChild(this.xAxis_.element), this.yAxis_ = new SVGLineStrip(i, [VEC3_ZERO, VEC3_YP70], this.projector_), this.yAxis_.element.classList.add(className$2("axisy")), this.axesElem_.appendChild(this.yAxis_.element), this.zAxis_ = new SVGLineStrip(i, [VEC3_ZERO, VEC3_ZP70], this.projector_), this.zAxis_.element.classList.add(className$2("axisz")), this.axesElem_.appendChild(this.zAxis_.element), this.xnAxis_ = new SVGLineStrip(i, [VEC3_ZERO, VEC3_XN70], this.projector_), this.xnAxis_.element.classList.add(className$2("axisn")), this.axesElem_.appendChild(this.xnAxis_.element), this.ynAxis_ = new SVGLineStrip(i, [VEC3_ZERO, VEC3_YN70], this.projector_), this.ynAxis_.element.classList.add(className$2("axisn")), this.axesElem_.appendChild(this.ynAxis_.element), this.znAxis_ = new SVGLineStrip(i, [VEC3_ZERO, VEC3_ZN70], this.projector_), this.znAxis_.element.classList.add(className$2("axisn")), this.axesElem_.appendChild(this.znAxis_.element), this.xArcF_ = new SVGLineStrip(i, p, this.projector_), this.xArcF_.element.classList.add(className$2("arcx")), this.svgElem_.appendChild(this.xArcF_.element), this.yArcF_ = new SVGLineStrip(i, p, this.projector_), this.yArcF_.element.classList.add(className$2("arcy")), this.svgElem_.appendChild(this.yArcF_.element), this.zArcF_ = new SVGLineStrip(i, p, this.projector_), this.zArcF_.element.classList.add(className$2("arcz")), this.svgElem_.appendChild(this.zArcF_.element), this.xArcFC_ = new SVGLineStrip(i, p, this.projector_), this.xArcFC_.element.classList.add(className$2("arcc")), this.svgElem_.appendChild(this.xArcFC_.element), this.yArcFC_ = new SVGLineStrip(i, p, this.projector_), this.yArcFC_.element.classList.add(className$2("arcc")), this.svgElem_.appendChild(this.yArcFC_.element), this.zArcFC_ = new SVGLineStrip(i, p, this.projector_), this.zArcFC_.element.classList.add(className$2("arcc")), this.svgElem_.appendChild(this.zArcFC_.element), this.rArc_ = new SVGLineStrip(i, m, this.projector_), this.rArc_.element.classList.add(className$2("arcr")), this.rArc_.setRotation(QUAT_IDENTITY$2), this.svgElem_.appendChild(this.rArc_.element), this.rArcC_ = new SVGLineStrip(i, m, this.projector_), this.rArcC_.element.classList.add(className$2("arcc")), this.rArcC_.setRotation(QUAT_IDENTITY$2), this.svgElem_.appendChild(this.rArcC_.element);
        const _ = i.createElementNS(SVG_NS, "g");
        u.classList.add(className$2("labels")), this.svgElem_.appendChild(_), this.labelsElem_ = _, this.xLabel = createLabel(i, "labelcirclex", "X"), this.labelsElem_.appendChild(this.xLabel), this.yLabel = createLabel(i, "labelcircley", "Y"), this.labelsElem_.appendChild(this.yLabel), this.zLabel = createLabel(i, "labelcirclez", "Z"), this.labelsElem_.appendChild(this.zLabel), this.xnLabel = createLabel(i, "labelcirclen", "-X"), this.labelsElem_.appendChild(this.xnLabel), this.ynLabel = createLabel(i, "labelcirclen", "-Y"), this.labelsElem_.appendChild(this.ynLabel), this.znLabel = createLabel(i, "labelcirclen", "-Z"), this.labelsElem_.appendChild(this.znLabel);
        const v = () => {
                this.xArcB_.element.classList.add(className$2("arcx_hover")), this.xArcF_.element.classList.add(className$2("arcx_hover"))
            },
            x = () => {
                this.xArcB_.element.classList.remove(className$2("arcx_hover")), this.xArcF_.element.classList.remove(className$2("arcx_hover"))
            };
        this.xArcBC_.element.addEventListener("mouseenter", v), this.xArcBC_.element.addEventListener("mouseleave", x), this.xArcFC_.element.addEventListener("mouseenter", v), this.xArcFC_.element.addEventListener("mouseleave", x);
        const y = () => {
                this.yArcB_.element.classList.add(className$2("arcy_hover")), this.yArcF_.element.classList.add(className$2("arcy_hover"))
            },
            b = () => {
                this.yArcB_.element.classList.remove(className$2("arcy_hover")), this.yArcF_.element.classList.remove(className$2("arcy_hover"))
            };
        this.yArcBC_.element.addEventListener("mouseenter", y), this.yArcBC_.element.addEventListener("mouseleave", b), this.yArcFC_.element.addEventListener("mouseenter", y), this.yArcFC_.element.addEventListener("mouseleave", b);
        const S = () => {
                this.zArcB_.element.classList.add(className$2("arcz_hover")), this.zArcF_.element.classList.add(className$2("arcz_hover"))
            },
            C = () => {
                this.zArcB_.element.classList.remove(className$2("arcz_hover")), this.zArcF_.element.classList.remove(className$2("arcz_hover"))
            };
        this.zArcBC_.element.addEventListener("mouseenter", S), this.zArcBC_.element.addEventListener("mouseleave", C), this.zArcFC_.element.addEventListener("mouseenter", S), this.zArcFC_.element.addEventListener("mouseleave", C);
        const E = () => {
                this.rArc_.element.classList.add(className$2("arcr_hover"))
            },
            P = () => {
                this.rArc_.element.classList.remove(className$2("arcr_hover"))
            };
        this.rArcC_.element.addEventListener("mouseenter", E), this.rArcC_.element.addEventListener("mouseleave", P), o.value.emitter.on("change", this.onValueChange_), this.value = o.value, o.mode.emitter.on("change", this.onModeChange_), this.mode_ = o.mode, this.update_()
    }
    get allFocusableElements() {
        return [this.padElement]
    }
    update_() {
        const i = this.value.rawValue.quat.normalized;
        this.xAxis_.setRotation(i), this.yAxis_.setRotation(i), this.zAxis_.setRotation(i), this.xnAxis_.setRotation(i), this.ynAxis_.setRotation(i), this.znAxis_.setRotation(i);
        const o = VEC3_XP$2.applyQuaternion(i),
            c = VEC3_YP$2.applyQuaternion(i),
            u = VEC3_ZP$2.applyQuaternion(i),
            p = o.negated,
            m = c.negated,
            g = u.negated;
        [{
            el: this.xAxis_.element,
            v: o
        }, {
            el: this.yAxis_.element,
            v: c
        }, {
            el: this.zAxis_.element,
            v: u
        }, {
            el: this.xnAxis_.element,
            v: p
        }, {
            el: this.ynAxis_.element,
            v: m
        }, {
            el: this.znAxis_.element,
            v: g
        }].map(({
            el: _,
            v
        }) => (this.axesElem_.removeChild(_), {
            el: _,
            v
        })).sort((_, v) => _.v.z - v.v.z).forEach(({
            el: _
        }) => {
            this.axesElem_.appendChild(_)
        }), this.xArcB_.setRotation(createArcRotation(o, VEC3_ZN)), this.yArcB_.setRotation(createArcRotation(c, VEC3_ZN)), this.zArcB_.setRotation(createArcRotation(u, VEC3_ZN)), this.xArcBC_.setRotation(createArcRotation(o, VEC3_ZN)), this.yArcBC_.setRotation(createArcRotation(c, VEC3_ZN)), this.zArcBC_.setRotation(createArcRotation(u, VEC3_ZN)), this.xArcF_.setRotation(createArcRotation(o, VEC3_ZP$2)), this.yArcF_.setRotation(createArcRotation(c, VEC3_ZP$2)), this.zArcF_.setRotation(createArcRotation(u, VEC3_ZP$2)), this.xArcFC_.setRotation(createArcRotation(o, VEC3_ZP$2)), this.yArcFC_.setRotation(createArcRotation(c, VEC3_ZP$2)), this.zArcFC_.setRotation(createArcRotation(u, VEC3_ZP$2)), [{
            el: this.xLabel,
            v: VEC3_XP70
        }, {
            el: this.yLabel,
            v: VEC3_YP70
        }, {
            el: this.zLabel,
            v: VEC3_ZP70
        }, {
            el: this.xnLabel,
            v: VEC3_XN70
        }, {
            el: this.ynLabel,
            v: VEC3_YN70
        }, {
            el: this.znLabel,
            v: VEC3_ZN70
        }].forEach(({
            el: _,
            v
        }) => {
            const [x, y] = this.projector_.project(v.applyQuaternion(i));
            _.setAttributeNS(null, "transform", `translate( ${x}, ${y} )`)
        }), [{
            el: this.xLabel,
            v: o
        }, {
            el: this.yLabel,
            v: c
        }, {
            el: this.zLabel,
            v: u
        }, {
            el: this.xnLabel,
            v: p
        }, {
            el: this.ynLabel,
            v: m
        }, {
            el: this.znLabel,
            v: g
        }].map(({
            el: _,
            v
        }) => (this.labelsElem_.removeChild(_), {
            el: _,
            v
        })).sort((_, v) => _.v.z - v.v.z).forEach(({
            el: _
        }) => {
            this.labelsElem_.appendChild(_)
        })
    }
    onValueChange_() {
        this.update_()
    }
    onFoldableChange_() {
        this.update_()
    }
    onModeChange_() {
        const i = this.mode_.rawValue,
            o = i === "angle-x" ? "add" : "remove",
            c = i === "angle-y" ? "add" : "remove",
            u = i === "angle-z" ? "add" : "remove",
            p = i === "angle-r" ? "add" : "remove";
        this.xArcB_.element.classList[o](className$2("arcx_active")), this.yArcB_.element.classList[c](className$2("arcy_active")), this.zArcB_.element.classList[u](className$2("arcz_active")), this.xArcF_.element.classList[o](className$2("arcx_active")), this.yArcF_.element.classList[c](className$2("arcy_active")), this.zArcF_.element.classList[u](className$2("arcz_active")), this.rArc_.element.classList[p](className$2("arcr_active"))
    }
}

function saturate(l) {
    return clamp$1(l, 0, 1)
}

function iikanjiEaseout(l) {
    if (l <= 0) return 0;
    if (l >= 1) return 1;
    const i = 1 - l,
        o = i * (i * (i * (i * (i * (i * (i * -6 + 7))))));
    return saturate(1 - o)
}

function linearstep(l, i, o) {
    return saturate((o - l) / (i - l))
}
const INV_SQRT2 = 1 / Math.sqrt(2),
    VEC3_XP$1 = new Vector3(1, 0, 0),
    VEC3_YP$1 = new Vector3(0, 1, 0),
    VEC3_ZP$1 = new Vector3(0, 0, 1),
    QUAT_IDENTITY$1 = new Quaternion(0, 0, 0, 1),
    QUAT_TOP = new Quaternion(INV_SQRT2, 0, 0, INV_SQRT2),
    QUAT_RIGHT = new Quaternion(0, -INV_SQRT2, 0, INV_SQRT2),
    QUAT_BOTTOM = new Quaternion(-INV_SQRT2, 0, 0, INV_SQRT2),
    QUAT_LEFT = new Quaternion(0, INV_SQRT2, 0, INV_SQRT2),
    QUAT_BACK = new Quaternion(0, 1, 0, 0);
class RotationInputGizmoController {
    constructor(i, o) {
        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.mode_ = createValue("free"), this.view = new RotationInputGizmoView(i, {
            value: this.value,
            mode: this.mode_,
            viewProps: this.viewProps,
            pickerLayout: o.pickerLayout
        }), this.ptHandler_ = new PointerHandler(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
        const c = new PointerHandler(this.view.xArcBElement);
        c.emitter.on("down", () => this.changeModeIfNotAuto_("angle-x")), c.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
        const u = new PointerHandler(this.view.xArcFElement);
        u.emitter.on("down", () => this.changeModeIfNotAuto_("angle-x")), u.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
        const p = new PointerHandler(this.view.yArcBElement);
        p.emitter.on("down", () => this.changeModeIfNotAuto_("angle-y")), p.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
        const m = new PointerHandler(this.view.yArcFElement);
        m.emitter.on("down", () => this.changeModeIfNotAuto_("angle-y")), m.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
        const g = new PointerHandler(this.view.zArcBElement);
        g.emitter.on("down", () => this.changeModeIfNotAuto_("angle-z")), g.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
        const _ = new PointerHandler(this.view.zArcFElement);
        _.emitter.on("down", () => this.changeModeIfNotAuto_("angle-z")), _.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
        const v = new PointerHandler(this.view.rArcElement);
        v.emitter.on("down", () => this.changeModeIfNotAuto_("angle-r")), v.emitter.on("up", () => this.changeModeIfNotAuto_("free")), [{
            el: this.view.xLabel,
            q: QUAT_RIGHT
        }, {
            el: this.view.yLabel,
            q: QUAT_TOP
        }, {
            el: this.view.zLabel,
            q: QUAT_IDENTITY$1
        }, {
            el: this.view.xnLabel,
            q: QUAT_LEFT
        }, {
            el: this.view.ynLabel,
            q: QUAT_BOTTOM
        }, {
            el: this.view.znLabel,
            q: QUAT_BACK
        }].forEach(({
            el: x,
            q: y
        }) => {
            new PointerHandler(x).emitter.on("down", () => this.autoRotate_(y))
        }), this.px_ = null, this.py_ = null, this.angleState_ = null
    }
    handlePointerEvent_(i) {
        if (!i.point) return;
        const o = this.mode_.rawValue,
            c = i.point.x,
            u = i.point.y;
        if (o !== "auto")
            if (o === "free") {
                if (this.px_ != null && this.py_ != null) {
                    const p = c - this.px_,
                        m = u - this.py_,
                        g = Math.sqrt(p * p + m * m);
                    if (g === 0) return;
                    const _ = new Vector3(m / g, p / g, 0),
                        v = Quaternion.fromAxisAngle(_, g / 68);
                    this.value.rawValue = this.value.rawValue.premultiply(v)
                }
                this.px_ = c, this.py_ = u
            } else if (o === "angle-r") {
            const p = i.bounds.width / 2,
                m = i.bounds.height / 2,
                g = Math.atan2(u - m, c - p);
            if (this.angleState_ == null) {
                const _ = new Vector3(0, 0, 1);
                this.angleState_ = {
                    initialRotation: this.value.rawValue,
                    initialAngle: g,
                    axis: _,
                    reverseAngle: !0
                }
            } else {
                const {
                    initialRotation: _,
                    initialAngle: v,
                    axis: x
                } = this.angleState_, y = -sanitizeAngle(g - v), b = Quaternion.fromAxisAngle(x, y);
                this.value.rawValue = _.premultiply(b)
            }
        } else {
            const p = i.bounds.width / 2,
                m = i.bounds.height / 2,
                g = Math.atan2(u - m, c - p);
            if (this.angleState_ == null) {
                const _ = o === "angle-x" ? VEC3_XP$1 : o === "angle-y" ? VEC3_YP$1 : VEC3_ZP$1,
                    v = _.applyQuaternion(this.value.rawValue.quat).z > 0;
                this.angleState_ = {
                    initialRotation: this.value.rawValue,
                    initialAngle: g,
                    axis: _,
                    reverseAngle: v
                }
            } else {
                const {
                    initialRotation: _,
                    initialAngle: v,
                    axis: x,
                    reverseAngle: y
                } = this.angleState_;
                let b = sanitizeAngle(g - v);
                b = y ? -b : b;
                const S = Quaternion.fromAxisAngle(x, b);
                this.value.rawValue = _.multiply(S)
            }
        }
    }
    onPointerDown_(i) {
        this.handlePointerEvent_(i.data)
    }
    onPointerMove_(i) {
        this.handlePointerEvent_(i.data)
    }
    onPointerUp_() {
        this.px_ = null, this.py_ = null, this.angleState_ = null
    }
    onPadKeyDown_(i) {
        isArrowKey(i.key) && i.preventDefault();
        const o = getStepForKey(1, getHorizontalStepKeys(i)),
            c = getStepForKey(1, getVerticalStepKeys(i));
        if (o !== 0 || c !== 0) {
            const u = new Vector3(-c, o, 0),
                p = Quaternion.fromAxisAngle(u, Math.PI / 16);
            this.value.rawValue = this.value.rawValue.premultiply(p)
        }
    }
    changeModeIfNotAuto_(i) {
        this.mode_.rawValue !== "auto" && (this.mode_.rawValue = i)
    }
    autoRotate_(i) {
        this.mode_.rawValue = "auto";
        const o = this.value.rawValue,
            c = Date.now(),
            u = () => {
                const p = Date.now(),
                    m = iikanjiEaseout(linearstep(0, 300, p - c));
                if (this.value.rawValue = o.slerp(i, m), m === 1) {
                    this.mode_.rawValue = "free";
                    return
                }
                requestAnimationFrame(u)
            };
        requestAnimationFrame(u)
    }
}
const className$1 = ClassName("rotationswatch"),
    VEC3_XP = new Vector3(1, 0, 0),
    VEC3_YP = new Vector3(0, 1, 0),
    VEC3_ZP = new Vector3(0, 0, 1),
    QUAT_IDENTITY = new Quaternion(0, 0, 0, 1);
class RotationInputSwatchView {
    constructor(i, o) {
        this.onValueChange_ = this.onValueChange_.bind(this), o.value.emitter.on("change", this.onValueChange_), this.value = o.value, this.element = i.createElement("div"), this.element.classList.add(className$1()), o.viewProps.bindClassModifiers(this.element);
        const c = i.createElement("button");
        c.classList.add(className$1("b")), o.viewProps.bindDisabled(c), this.element.appendChild(c), this.buttonElement = c;
        const u = i.createElementNS(SVG_NS, "svg");
        u.classList.add(className$1("g")), c.appendChild(u), this.svgElem_ = u, this.projector_ = new PointProjector, this.projector_.viewport = [0, 0, 20, 20];
        const p = createArcVerticesArray(0, Math.PI, 33, "x", "y"),
            m = createArcVerticesArray(0, 2 * Math.PI, 65, "x", "y");
        this.rArc_ = new SVGLineStrip(i, m, this.projector_), this.rArc_.element.classList.add(className$1("arcr")), u.appendChild(this.rArc_.element), this.rArc_.setRotation(QUAT_IDENTITY), this.xArc_ = new SVGLineStrip(i, p, this.projector_), this.xArc_.element.classList.add(className$1("arc")), u.appendChild(this.xArc_.element), this.yArc_ = new SVGLineStrip(i, p, this.projector_), this.yArc_.element.classList.add(className$1("arc")), u.appendChild(this.yArc_.element), this.zArc_ = new SVGLineStrip(i, p, this.projector_), this.zArc_.element.classList.add(className$1("arc")), u.appendChild(this.zArc_.element), this.update_()
    }
    update_() {
        const i = this.value.rawValue.quat.normalized,
            o = VEC3_XP.applyQuaternion(i),
            c = VEC3_YP.applyQuaternion(i),
            u = VEC3_ZP.applyQuaternion(i);
        this.xArc_.setRotation(createArcRotation(o, VEC3_ZP)), this.yArc_.setRotation(createArcRotation(c, VEC3_ZP)), this.zArc_.setRotation(createArcRotation(u, VEC3_ZP))
    }
    onValueChange_() {
        this.update_()
    }
}
class RotationInputSwatchController {
    constructor(i, o) {
        this.value = o.value, this.viewProps = o.viewProps, this.view = new RotationInputSwatchView(i, {
            value: this.value,
            viewProps: this.viewProps
        })
    }
}
const className = ClassName("rotation");
class RotationInputView {
    constructor(i, o) {
        this.element = i.createElement("div"), this.element.classList.add(className()), o.foldable.bindExpandedClass(this.element, className(void 0, "expanded")), bindValueMap(o.foldable, "completed", valueToClassName(this.element, className(void 0, "cpl"))), o.rotationMode === "quaternion" && this.element.classList.add(className("quat"));
        const c = i.createElement("div");
        c.classList.add(className("h")), this.element.appendChild(c);
        const u = i.createElement("div");
        u.classList.add(className("s")), c.appendChild(u), this.swatchElement = u;
        const p = i.createElement("div");
        if (p.classList.add(className("t")), c.appendChild(p), this.textElement = p, o.pickerLayout === "inline") {
            const m = i.createElement("div");
            m.classList.add(className("g")), this.element.appendChild(m), this.pickerElement = m
        } else this.pickerElement = null
    }
}
class RotationInputController {
    constructor(i, o) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = o.value, this.viewProps = o.viewProps, this.foldable_ = Foldable.create(o.expanded), this.swatchC_ = new RotationInputSwatchController(i, {
            value: this.value,
            viewProps: this.viewProps
        });
        const c = this.swatchC_.view.buttonElement;
        c.addEventListener("blur", this.onButtonBlur_), c.addEventListener("click", this.onButtonClick_), this.textC_ = new PointNdTextController(i, {
            assembly: o.assembly,
            axes: o.axes,
            parser: o.parser,
            value: this.value,
            viewProps: this.viewProps
        }), this.view = new RotationInputView(i, {
            rotationMode: o.rotationMode,
            foldable: this.foldable_,
            pickerLayout: o.pickerLayout
        }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = o.pickerLayout === "popup" ? new PopupController(i, {
            viewProps: this.viewProps
        }) : null;
        const u = new RotationInputGizmoController(i, {
            value: this.value,
            viewProps: this.viewProps,
            pickerLayout: o.pickerLayout
        });
        u.view.allFocusableElements.forEach(p => {
            p.addEventListener("blur", this.onPopupChildBlur_), p.addEventListener("keydown", this.onPopupChildKeydown_)
        }), this.gizmoC_ = u, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(u.view.element), connectValues({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: p => p,
            backward: (p, m) => m
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.gizmoC_.view.element), bindFoldable(this.foldable_, this.view.pickerElement))
    }
    onButtonBlur_(i) {
        if (!this.popC_) return;
        const o = this.view.element,
            c = i.relatedTarget;
        (!c || !o.contains(c)) && (this.popC_.shows.rawValue = !1)
    }
    onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.gizmoC_.view.allFocusableElements[0].focus()
    }
    onPopupChildBlur_(i) {
        if (!this.popC_) return;
        const o = this.popC_.view.element,
            c = findNextTarget(i);
        c && o.contains(c) || c && c === this.swatchC_.view.buttonElement && !supportsTouch(o.ownerDocument) || (this.popC_.shows.rawValue = !1)
    }
    onPopupChildKeydown_(i) {
        this.popC_ ? i.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && i.key === "Escape" && this.swatchC_.view.buttonElement.focus()
    }
}

function createAxisEuler(l, i) {
    const o = Math.pow(.1, l);
    return {
        baseStep: o,
        constraint: i,
        textProps: ValueMap.fromObject({
            formatter: createNumberFormatter(l),
            keyScale: o,
            pointerScale: o
        })
    }
}

function createDimensionConstraint(l) {
    if (!l) return;
    const i = [];
    return isEmpty(l.step) || i.push(new StepConstraint(l.step)), (!isEmpty(l.max) || !isEmpty(l.min)) && i.push(new RangeConstraint({
        max: l.max,
        min: l.min
    })), new CompositeConstraint(i)
}

function createEulerAssembly(l, i) {
    return {
        toComponents: o => o.getComponents(),
        fromComponents: o => new Euler(o[0], o[1], o[2], l, i)
    }
}

function parseEuler(l, i, o) {
    return typeof l ? .x == "number" && typeof l ? .y == "number" && typeof l ? .z == "number" ? new Euler(l.x, l.y, l.z, i, o) : new Euler(0, 0, 0, i, o)
}

function parseEulerOrder(l) {
    switch (l) {
        case "XYZ":
        case "XZY":
        case "YXZ":
        case "YZX":
        case "ZXY":
        case "ZYX":
            return l;
        default:
            return
    }
}

function parseEulerUnit(l) {
    switch (l) {
        case "rad":
        case "deg":
        case "turn":
            return l;
        default:
            return
    }
}
const RotationInputPluginEuler = createPlugin({
        id: "rotation",
        type: "input",
        accept(l, i) {
            var o, c;
            const u = parseRecord(i, p => ({
                view: p.required.constant("rotation"),
                label: p.optional.string,
                picker: p.optional.custom(parsePickerLayout),
                expanded: p.optional.boolean,
                rotationMode: p.required.constant("euler"),
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.custom(parsePointDimensionParams),
                z: p.optional.custom(parsePointDimensionParams),
                order: p.optional.custom(parseEulerOrder),
                unit: p.optional.custom(parseEulerUnit)
            }));
            return u ? {
                initialValue: parseEuler(l, (o = u.order) !== null && o !== void 0 ? o : "XYZ", (c = u.unit) !== null && c !== void 0 ? c : "rad"),
                params: u
            } : null
        },
        binding: {
            reader({
                params: l
            }) {
                return i => {
                    var o, c;
                    return parseEuler(i, (o = l.order) !== null && o !== void 0 ? o : "XYZ", (c = l.unit) !== null && c !== void 0 ? c : "rad")
                }
            },
            constraint({
                params: l
            }) {
                var i, o;
                return new PointNdConstraint({
                    assembly: createEulerAssembly((i = l.order) !== null && i !== void 0 ? i : "XYZ", (o = l.unit) !== null && o !== void 0 ? o : "rad"),
                    components: [createDimensionConstraint("x" in l ? l.x : void 0), createDimensionConstraint("y" in l ? l.y : void 0), createDimensionConstraint("z" in l ? l.z : void 0)]
                })
            },
            writer(l) {
                return (i, o) => {
                    i.writeProperty("x", o.x), i.writeProperty("y", o.y), i.writeProperty("z", o.z)
                }
            }
        },
        controller({
            document: l,
            value: i,
            constraint: o,
            params: c,
            viewProps: u
        }) {
            var p, m;
            if (!(o instanceof PointNdConstraint)) throw TpError.shouldNeverHappen();
            const g = "expanded" in c ? c.expanded : void 0,
                _ = "picker" in c ? c.picker : void 0,
                v = (p = c.unit) !== null && p !== void 0 ? p : "rad",
                x = {
                    rad: 2,
                    deg: 0,
                    turn: 2
                }[v];
            return new RotationInputController(l, {
                axes: [createAxisEuler(x, o.components[0]), createAxisEuler(x, o.components[1]), createAxisEuler(x, o.components[2])],
                assembly: createEulerAssembly((m = c.order) !== null && m !== void 0 ? m : "XYZ", v),
                rotationMode: "euler",
                expanded: g ? ? !1,
                parser: parseNumber,
                pickerLayout: _ ? ? "popup",
                value: i,
                viewProps: u
            })
        }
    }),
    QuaternionAssembly = {
        toComponents: l => [l.x, l.y, l.z, l.w],
        fromComponents: l => new Quaternion(l[0], l[1], l[2], l[3])
    };

function createAxisQuaternion(l) {
    return {
        baseStep: .01,
        constraint: l,
        textProps: ValueMap.fromObject({
            formatter: i => Math.abs(i) < .995 ? i.toFixed(2).replace("0.", ".") : i.toFixed(1),
            keyScale: .01,
            pointerScale: .01
        })
    }
}

function parseQuaternion(l) {
    return typeof l ? .x == "number" && typeof l ? .y == "number" && typeof l ? .z == "number" && typeof l ? .w == "number" ? new Quaternion(l.x, l.y, l.z, l.w) : new Quaternion(0, 0, 0, 1)
}
const RotationInputPluginQuaternion = createPlugin({
        id: "rotation",
        type: "input",
        accept(l, i) {
            const o = parseRecord(i, c => ({
                view: c.required.constant("rotation"),
                label: c.optional.string,
                picker: c.optional.custom(parsePickerLayout),
                expanded: c.optional.boolean,
                rotationMode: c.optional.constant("quaternion"),
                x: c.optional.custom(parsePointDimensionParams),
                y: c.optional.custom(parsePointDimensionParams),
                z: c.optional.custom(parsePointDimensionParams),
                w: c.optional.custom(parsePointDimensionParams)
            }));
            return o ? {
                initialValue: parseQuaternion(l),
                params: o
            } : null
        },
        binding: {
            reader(l) {
                return i => parseQuaternion(i)
            },
            constraint({
                params: l
            }) {
                return new PointNdConstraint({
                    assembly: QuaternionAssembly,
                    components: [createDimensionConstraint("x" in l ? l.x : void 0), createDimensionConstraint("y" in l ? l.y : void 0), createDimensionConstraint("z" in l ? l.z : void 0), createDimensionConstraint("w" in l ? l.w : void 0)]
                })
            },
            writer(l) {
                return (i, o) => {
                    i.writeProperty("x", o.x), i.writeProperty("y", o.y), i.writeProperty("z", o.z), i.writeProperty("w", o.w)
                }
            }
        },
        controller({
            document: l,
            value: i,
            constraint: o,
            params: c,
            viewProps: u
        }) {
            if (!(o instanceof PointNdConstraint)) throw TpError.shouldNeverHappen();
            const p = "expanded" in c ? c.expanded : void 0,
                m = "picker" in c ? c.picker : void 0;
            return new RotationInputController(l, {
                axes: [createAxisQuaternion(o.components[0]), createAxisQuaternion(o.components[1]), createAxisQuaternion(o.components[2]), createAxisQuaternion(o.components[3])],
                assembly: QuaternionAssembly,
                rotationMode: "quaternion",
                expanded: p ? ? !1,
                parser: parseNumber,
                pickerLayout: m ? ? "popup",
                value: i,
                viewProps: u
            })
        }
    }),
    id = "rotation",
    css = ".tp-rotationgizmov_p,.tp-rotationswatchv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-rotationswatchv_b{background-color:var(--btn-bg);border-radius:var(--bld-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--cnt-usz);line-height:var(--cnt-usz);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-rotationswatchv_b:hover{background-color:var(--btn-bg-h)}.tp-rotationswatchv_b:focus{background-color:var(--btn-bg-f)}.tp-rotationswatchv_b:active{background-color:var(--btn-bg-a)}.tp-rotationswatchv_b:disabled{opacity:.5}.tp-rotationgizmov_p{background-color:var(--in-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--cnt-usz);line-height:var(--cnt-usz);min-width:0;width:100%}.tp-rotationgizmov_p:hover{background-color:var(--in-bg-h)}.tp-rotationgizmov_p:focus{background-color:var(--in-bg-f)}.tp-rotationgizmov_p:active{background-color:var(--in-bg-a)}.tp-rotationgizmov_p:disabled{opacity:.5}.tp-rotationv{position:relative}.tp-rotationv_quat .tp-txtv_i{padding-left:0}.tp-rotationv_root{background-color:var(--mo-bg);width:100%;height:calc(2*var(--cnt-usz))}.tp-rotationv_h{display:flex}.tp-rotationv_s{flex-grow:0;flex-shrink:0;width:var(--cnt-usz);margin-right:4px}.tp-rotationv_g{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-rotationv.tp-rotationv-expanded .tp-rotationv_g{margin-top:var(--cnt-usp);opacity:1}.tp-rotationv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-rotationswatchv path{stroke-linecap:round;stroke-linejoin:round}.tp-rotationswatchv_b{height:var(--cnt-usz);margin-right:4px;position:relative;width:var(--cnt-usz)}.tp-rotationswatchv_arc{fill:none;stroke:var(--btn-bg);stroke-width:1px}.tp-rotationswatchv_arcr{fill:var(--btn-fg);stroke:var(--btn-bg);stroke-width:1px}.tp-rotationgizmov{padding-left:calc(var(--cnt-usz) + 4px)}.tp-rotationgizmov path{stroke-linecap:round;stroke-linejoin:round}.tp-rotationgizmov_p{cursor:move;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-rotationgizmov_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-rotationgizmov_axisx{stroke:#eb103f;stroke-width:2px}.tp-rotationgizmov_axisy{stroke:#4eeb10;stroke-width:2px}.tp-rotationgizmov_axisz{stroke:#1068eb;stroke-width:2px}.tp-rotationgizmov_axisn{stroke:var(--in-fg);stroke-width:2px}.tp-rotationgizmov_arcx{fill:none;stroke:var(--in-fg)}.tp-rotationgizmov_arcx.tp-rotationgizmov_arcx_hover{stroke:#eb103f}.tp-rotationgizmov_arcx.tp-rotationgizmov_arcx_active{stroke:#eb103f;stroke-width:2px}.tp-rotationgizmov_arcy{fill:none;stroke:var(--in-fg)}.tp-rotationgizmov_arcy.tp-rotationgizmov_arcy_hover{stroke:#4eeb10}.tp-rotationgizmov_arcy.tp-rotationgizmov_arcy_active{stroke:#4eeb10;stroke-width:2px}.tp-rotationgizmov_arcz{fill:none;stroke:var(--in-fg)}.tp-rotationgizmov_arcz.tp-rotationgizmov_arcz_hover{stroke:#1068eb}.tp-rotationgizmov_arcz.tp-rotationgizmov_arcz_active{stroke:#1068eb;stroke-width:2px}.tp-rotationgizmov_arcr{fill:none;stroke:var(--in-fg)}.tp-rotationgizmov_arcr.tp-rotationgizmov_arcr_hover{stroke:#ebd510}.tp-rotationgizmov_arcr.tp-rotationgizmov_arcr_active{stroke:#ebd510;stroke-width:2px}.tp-rotationgizmov_arcc{fill:none;stroke:rgba(0,0,0,0);stroke-width:5px;pointer-events:auto}.tp-rotationgizmov_labelcirclex{fill:#eb103f;cursor:pointer;pointer-events:auto}.tp-rotationgizmov_labelcirclex:hover{opacity:.7}.tp-rotationgizmov_labelcircley{fill:#4eeb10;cursor:pointer;pointer-events:auto}.tp-rotationgizmov_labelcircley:hover{opacity:.7}.tp-rotationgizmov_labelcirclez{fill:#1068eb;cursor:pointer;pointer-events:auto}.tp-rotationgizmov_labelcirclez:hover{opacity:.7}.tp-rotationgizmov_labelcirclen{fill:var(--in-fg);cursor:pointer;pointer-events:auto}.tp-rotationgizmov_labelcirclen:hover{opacity:.7}.tp-rotationgizmov_labeltext{fill:var(--btn-fg);stroke:var(--btn-fg);stroke-width:1px}.tp-rotationgizmov_p:focus .tp-rotationgizmov_m{background-color:var(--in-fg);border-width:0}",
    plugins = [RotationInputPluginEuler, RotationInputPluginQuaternion],
    TweakpaneRotationInputPlugin = Object.freeze(Object.defineProperty({
        __proto__: null,
        RotationInputPluginEuler,
        RotationInputPluginQuaternion,
        css,
        id,
        plugins
    }, Symbol.toStringTag, {
        value: "Module"
    }));
var ThemeType = (l => (l.DARK = "dark", l.LIGHT = "light", l))(ThemeType || {});
class TweakPaneManager {
    static _instance;
    _windows = new Map;
    _currentTheme = "dark";
    _isDeviceControlEnabled = !0;
    _sectionWindowFilter = () => !0;
    constructor() {
        this.setupKeyboardShortcuts(), this.setupWindowStyles(), this.setupDeviceControl()
    }
    static getInstance() {
        return TweakPaneManager._instance || (TweakPaneManager._instance = new TweakPaneManager), TweakPaneManager._instance
    }
    setupKeyboardShortcuts() {
        document.addEventListener("keydown", i => {
            i.ctrlKey && i.key === "t" && (i.preventDefault(), this.toggleAllWindows()), i.key === "T" && (i.preventDefault(), this.toggleTheme())
        })
    }
    createWindow(i, o, c) {
        if (this._windows.has(i)) return this._windows.get(i);
        const u = document.getElementById(c);
        if (!u) return console.warn(`Container with id "${c}" not found`), null;
        const p = new Pane({
            title: o,
            expanded: !0
        });
        p.registerPlugin(TweakpaneRotationInputPlugin);
        const m = p.element;
        m.style.width = "100%", m.style.height = "100%", m.style.position = "relative", this.applyTheme(m), u.appendChild(m);
        const g = {
            pane: p,
            element: m,
            container: u,
            isVisible: !0
        };
        return this._windows.set(i, g), g
    }
    applyTheme(i) {
        if (this._currentTheme === "dark") {
            const o = "rgba(255, 255, 255, 0.6)";
            i.style.setProperty("--tp-base-background-color", "rgba(0, 0, 0, 0.1)"), i.style.setProperty("--tp-container-background-color", "transparent"), i.style.setProperty("--tp-container-foreground-color", o), i.style.setProperty("--tp-input-background-color", "rgba(255, 255, 255, 0.0)"), i.style.setProperty("--tp-button-background-color", "rgba(255, 255, 255, 0.0)"), i.style.setProperty("--tp-button-foreground-color", o), i.style.setProperty("--tp-label-foreground-color", o), i.style.setProperty("--tp-input-foreground-color", o), i.style.setProperty("--tp-button-foreground-color", o), i.style.setProperty("--tp-input-background-color-active", "rgba(0, 0, 0, 0.0)"), i.style.setProperty("--tp-input-background-color-focus", "rgba(0, 0, 0, 0.0)"), i.style.setProperty("--tp-input-background-color-hover", "rgba(0, 0, 0, 0.0)")
        } else {
            const o = "rgba(0, 0, 0, 0.6)";
            i.style.setProperty("--tp-base-background-color", "rgba(255,255,255, 0.1)"), i.style.setProperty("--tp-container-background-color", "transparent"), i.style.setProperty("--tp-container-foreground-color", "rgba(0, 0, 0, 0.6)"), i.style.setProperty("--tp-input-background-color", "rgba(255, 255, 255, 0.0)"), i.style.setProperty("--tp-button-background-color", "rgba(255, 255, 255, 0.0)"), i.style.setProperty("--tp-button-foreground-color", o), i.style.setProperty("--tp-label-foreground-color", o), i.style.setProperty("--tp-input-foreground-color", o), i.style.setProperty("--tp-button-foreground-color", o), i.style.setProperty("--tp-input-background-color-active", "rgba(0, 0, 0, 0.0)"), i.style.setProperty("--tp-input-background-color-focus", "rgba(0, 0, 0, 0.0)"), i.style.setProperty("--tp-input-background-color-hover", "rgba(0, 0, 0, 0.0)")
        }
    }
    reloadStyles() {
        this._windows.forEach(i => {
            this.applyTheme(i.element)
        })
    }
    reloadWindow(i) {
        const o = this._windows.get(i);
        o && this.applyTheme(o.element)
    }
    setupWindowStyles() {}
    setupDeviceControl() {
        this.updateVisibilityForDevice()
    }
    updateVisibilityForDevice() {
        deviceManager.isSPLayout ? this.hideAllWindows() : this.showWindowsForCurrentSection()
    }
    setDeviceControlEnabled(i) {
        this._isDeviceControlEnabled = i, i && this.updateVisibilityForDevice()
    }
    isDeviceControlEnabled() {
        return this._isDeviceControlEnabled
    }
    getWindow(i) {
        return this._windows.get(i) || null
    }
    toggleWindow(i) {
        const o = this._windows.get(i);
        o && (o.isVisible = !o.isVisible, o.container.setAttribute("data-visible", o.isVisible ? "true" : "false"))
    }
    toggleAllWindows() {
        const i = Array.from(this._windows.values()).some(o => o.isVisible);
        this._windows.forEach(o => {
            o.isVisible = !i, o.container.setAttribute("data-visible", o.isVisible ? "true" : "false")
        })
    }
    removeWindow(i) {
        const o = this._windows.get(i);
        o && (o.pane.dispose(), o.element.remove(), this._windows.delete(i))
    }
    setTheme(i) {
        this._currentTheme = i, this.reloadStyles()
    }
    getTheme() {
        return this._currentTheme
    }
    toggleTheme() {
        const i = this._currentTheme === "dark" ? "light" : "dark";
        this.setTheme(i)
    }
    hideAllWindows() {
        this._windows.forEach(i => {
            i.pane.expanded = !1, i.isVisible = !1, i.container.setAttribute("data-visible", "false")
        })
    }
    showAllWindows() {
        this._windows.forEach(i => {
            i.pane.expanded = !0, i.isVisible = !0, i.container.setAttribute("data-visible", "true")
        })
    }
    setSectionWindowFilter(i) {
        this._sectionWindowFilter = i
    }
    showWindowsForCurrentSection() {
        this._windows.forEach((i, o) => {
            this._sectionWindowFilter(o) ? (i.pane.expanded = !0, i.isVisible = !0, i.container.setAttribute("data-visible", "true")) : (i.pane.expanded = !1, i.isVisible = !1, i.container.setAttribute("data-visible", "false"))
        })
    }
    dispose() {
        this._windows.forEach(i => {
            i.pane.dispose(), i.element.remove()
        }), this._windows.clear()
    }
    static quaternionToEuler(i) {
        const o = new Euler$1().setFromQuaternion(i);
        return {
            x: MathUtils.radToDeg(o.x),
            y: MathUtils.radToDeg(o.y),
            z: MathUtils.radToDeg(o.z)
        }
    }
    static eulerToQuaternion(i) {
        const o = new Euler$1(MathUtils.degToRad(i.x), MathUtils.degToRad(i.y), MathUtils.degToRad(i.z));
        return new Quaternion$1().setFromEuler(o)
    }
}
class TweakPaneSectionManager extends EventEmitter$1 {
    static _instance;
    _tweakPaneManager;
    _config;
    _currentSection = null;
    _registeredWindows = new Map;
    constructor() {
        super(), this._tweakPaneManager = TweakPaneManager.getInstance(), this._config = {
            sections: {}
        }, this._tweakPaneManager.setSectionWindowFilter(i => this.isWindowInCurrentSection(i))
    }
    get currentSection() {
        return this._currentSection
    }
    static getInstance() {
        return TweakPaneSectionManager._instance || (TweakPaneSectionManager._instance = new TweakPaneSectionManager), TweakPaneSectionManager._instance
    }
    configure(i) {
        this._config = i, this.setSection(this._currentSection)
    }
    registerWindow(i, o) {
        this._registeredWindows.set(i, o), this.isWindowInCurrentSection(i) ? this.showWindow(i) : this.hideWindow(i)
    }
    createAndRegisterWindow(i, o, c) {
        const u = this._tweakPaneManager.createWindow(i, o, c);
        return u && this.registerWindow(i, u), u
    }
    setSection(i) {
        const o = this._currentSection,
            c = Array.from(this._registeredWindows.entries()).filter(([, g]) => g.isVisible).map(([g]) => g),
            u = i && this._config.sections[i] ? this._config.sections[i].windows : [],
            p = c.filter(g => !u.includes(g)),
            m = u.filter(g => !c.includes(g));
        if (this._currentSection = i, i && this._config.sections[i] ? .theme) {
            const g = this._config.sections[i].theme === "light" ? ThemeType.LIGHT : ThemeType.DARK;
            this._tweakPaneManager.setTheme(g)
        }
        p.forEach(g => {
            this.hideWindow(g)
        }), m.forEach(g => {
            this.showWindow(g)
        }), this.emit("section/change", {
            previousSection: o,
            currentSection: i
        })
    }
    getCurrentSection() {
        return this._currentSection
    }
    setSectionTheme(i, o) {
        if (this._config.sections[i] && (this._config.sections[i].theme = o, this._currentSection === i)) {
            const c = o === "light" ? ThemeType.LIGHT : ThemeType.DARK;
            this._tweakPaneManager.setTheme(c)
        }
    }
    getSectionTheme(i) {
        return this._config.sections[i] ? .theme
    }
    showWindow(i) {
        const o = this._registeredWindows.get(i);
        if (o) {
            if (deviceManager.isSPLayout) return;
            o.pane.expanded = !1, o.isVisible = !0, o.container.setAttribute("data-visible", "true"), setTimeout(() => {
                o.pane.expanded = !0
            }, 50)
        }
    }
    hideWindow(i) {
        const o = this._registeredWindows.get(i);
        o && (o.pane.expanded = !1, setTimeout(() => {
            o.isVisible = !1, o.container.setAttribute("data-visible", "false")
        }, 200))
    }
    toggleWindow(i) {
        const o = this._registeredWindows.get(i);
        o && (o.isVisible ? this.hideWindow(i) : this.showWindow(i))
    }
    getWindowsForSection(i) {
        const o = this._config.sections[i];
        return o ? o.windows : []
    }
    isWindowInCurrentSection(i) {
        return this._currentSection ? this.getWindowsForSection(this._currentSection).includes(i) : this._registeredWindows.has(i)
    }
    dispose() {
        this._registeredWindows.forEach((i, o) => {
            this._tweakPaneManager.removeWindow(o)
        }), this._registeredWindows.clear(), this._currentSection = null
    }
}
class TweakPaneStore {
    _params;
    _bindings = new Map;
    _listeners = new Map;
    _bindingConfigs = new Map;
    _isUpdatingBinding = !1;
    constructor(i) {
        this._params = i || {}
    }
    setInitialValues(i) {
        return this._params = { ...i
        }, this
    }
    addBinding(i, o) {
        return this._bindingConfigs.set(i, o || {}), this
    }
    onUpdate(i, o) {
        return this.addListener(i, o), this
    }
    get params() {
        return this._params
    }
    getValue(i) {
        return this._params[i]
    }
    setValue(i, o) {
        this._params[i] = o, this.updateBinding(String(i), o), this.notifyListeners(String(i))
    }
    getNestedValue(i) {
        const o = i.split(".");
        let c = this._params;
        for (const u of o)
            if (c && typeof c == "object" && u in c) c = c[u];
            else return;
        return c
    }
    setNestedValue(i, o) {
        const c = i.split("."),
            u = c.pop();
        let p = this._params;
        for (const m of c)(!p[m] || typeof p[m] != "object") && (p[m] = {}), p = p[m];
        p[u] = o, this.updateBinding(i, o), this.notifyListeners(i)
    }
    createBindings(i, o) {
        const c = o || this._params;
        this._bindingConfigs.forEach((u, p) => {
            const m = p.split(".");
            let g = c,
                _ = "";
            for (let y = 0; y < m.length - 1; y++) _ += (y > 0 ? "." : "") + m[y], g = g[m[y]];
            const v = m[m.length - 1],
                x = i.addBinding(g, v, u);
            x.on("change", () => {
                this._isUpdatingBinding || this.setNestedValue(p, g[v])
            }), this.registerBinding(p, x)
        })
    }
    registerBinding(i, o) {
        this._bindings.set(i, o)
    }
    updateBinding(i, o) {
        const c = this._bindings.get(i);
        c && (this._isUpdatingBinding = !0, c.refresh(), this._isUpdatingBinding = !1)
    }
    addListener(i, o) {
        this._listeners.has(i) || this._listeners.set(i, new Set), this._listeners.get(i).add(o)
    }
    removeListener(i, o) {
        const c = this._listeners.get(i);
        c && c.delete(o)
    }
    notifyListeners(i) {
        const o = this._listeners.get(i);
        o && o.forEach(u => u());
        const c = i.split(".").slice(0, -1).join(".");
        if (c) {
            const u = this._listeners.get(c);
            u && u.forEach(p => p())
        }
    }
    dispose() {
        this._bindings.clear(), this._listeners.clear(), this._bindingConfigs.clear()
    }
}
const sectionRotationSettings = {
    default: {
        animationIntensity: 0,
        baseRotationSpeed: 0,
        returnToOriginForce: 2,
        velocityMultiplier: 0,
        scrollSpeedRotationFactor: 0,
        hoverRotationMultiplier: 0
    },
    kv: {
        animationIntensity: 0,
        baseRotationSpeed: 0,
        returnToOriginForce: 2,
        velocityMultiplier: 0,
        scrollSpeedRotationFactor: 0,
        hoverRotationMultiplier: 1
    },
    works_intro: {
        animationIntensity: 1,
        baseRotationSpeed: .5,
        returnToOriginForce: .4,
        velocityMultiplier: .01,
        scrollSpeedRotationFactor: .001,
        hoverRotationMultiplier: .2
    },
    works: {
        animationIntensity: 1,
        baseRotationSpeed: .5,
        returnToOriginForce: .1,
        velocityMultiplier: .01,
        scrollSpeedRotationFactor: .001,
        hoverRotationMultiplier: .2
    },
    mission: {
        animationIntensity: 0,
        baseRotationSpeed: 0,
        returnToOriginForce: 2,
        velocityMultiplier: 0,
        scrollSpeedRotationFactor: 0,
        hoverRotationMultiplier: 0
    },
    vision: {
        animationIntensity: 0,
        baseRotationSpeed: 0,
        returnToOriginForce: 1.5,
        velocityMultiplier: 0,
        scrollSpeedRotationFactor: 0,
        hoverRotationMultiplier: 0
    },
    service: {
        animationIntensity: 0,
        baseRotationSpeed: 0,
        returnToOriginForce: 1.8,
        velocityMultiplier: 0,
        scrollSpeedRotationFactor: 0,
        hoverRotationMultiplier: 1
    }
};
class MainLogo extends Object3D {
    _commonUniforms;
    _animator;
    _currentSectionConfig;
    _logoMesh;
    _logoOutlineMeshContainer;
    _logoOutlineMeshBase;
    _logoOutlineMeshLine;
    _logoScreenMesh;
    _tmpEuler;
    _mouseRotQua;
    _visionTrigger;
    _serviceInTrigger;
    _tweakPaneManager;
    _tweakPaneSectionManager;
    _materialStore;
    _rotationStore;
    _screenStore;
    _quaternionStore;
    constructor(i) {
        super(), this._animator = new Animator, this._animator.add({
            name: "worksRotate",
            initValue: 0
        }), this._commonUniforms = UniformsLib.mergeUniforms(i, {
            uVisionRotate: {
                value: 0
            },
            uServiceIn: {
                value: 0
            },
            uServiceRotate: {
                value: 0
            }
        }), this._mouseRotQua = new Quaternion$1, this._tmpEuler = new Euler$1, this._logoMesh = null, this._logoOutlineMeshBase = null, this._logoOutlineMeshLine = null, this._logoOutlineMeshContainer = new Object3D, this._logoOutlineMeshContainer.matrixAutoUpdate = !1, this._logoOutlineMeshContainer.matrixWorldAutoUpdate = !1, this._visionTrigger = null, this._serviceInTrigger = null, this._logoScreenMesh = null, this._currentSectionConfig = sectionRotationSettings.default, this._tweakPaneManager = TweakPaneManager.getInstance(), this._tweakPaneSectionManager = TweakPaneSectionManager.getInstance(), this._materialStore = new TweakPaneStore({
            roughness: .1,
            noiseScale: 9,
            color: {
                r: 255,
                g: 255,
                b: 255
            }
        }), this._rotationStore = new TweakPaneStore({
            x: 0,
            y: 0,
            z: 0
        }), this._screenStore = new TweakPaneStore({
            noiseScale: 1
        }), this._quaternionStore = new TweakPaneStore({
            quat: {
                x: 0,
                y: 0,
                z: 0,
                w: 1
            }
        });
        const o = new ShaderMaterial({
                vertexShader: mainLogoVert,
                fragmentShader: mainLogoFrag,
                uniforms: UniformsLib.mergeUniforms(this._commonUniforms, transparentRenderer1.uniformset, {
                    uEnvMap: resources.getTextureUniform("envMap"),
                    uNoiseTex: {
                        value: resources.getTexture("noise").texture
                    },
                    uRoughness: {
                        value: this._materialStore.getValue("roughness")
                    },
                    uNoiseScale: {
                        value: this._materialStore.getValue("noiseScale")
                    },
                    uMaterialColor: {
                        value: new Vector3$1(this._materialStore.getValue("color").r, this._materialStore.getValue("color").g, this._materialStore.getValue("color").b)
                    }
                }),
                transparent: !0
            }),
            c = new ShaderMaterial({
                vertexShader: mainLogoVert,
                fragmentShader: mainLogoOutlineFrag,
                uniforms: UniformsLib.mergeUniforms(this._commonUniforms),
                defines: {
                    IS_BASE: ""
                },
                transparent: !0
            }),
            u = new ShaderMaterial({
                vertexShader: mainLogoVert,
                fragmentShader: mainLogoOutlineFrag,
                uniforms: UniformsLib.mergeUniforms(this._commonUniforms),
                side: DoubleSide,
                defines: {
                    IS_OUTLINE: ""
                },
                transparent: !0
            }),
            p = new ShaderMaterial({
                vertexShader: mainLogoVert,
                fragmentShader: mainLogoScreenFrag,
                uniforms: UniformsLib.mergeUniforms(this._commonUniforms, {
                    uSceneTex: {
                        value: rtServiceScene.texture
                    },
                    uNoiseTex: {
                        value: resources.getTexture("noise") ? .texture
                    },
                    uScreenNoiseScale: {
                        value: this._screenStore.getValue("noiseScale")
                    }
                }),
                defines: {
                    IS_SCREEN: ""
                },
                transparent: !0
            });
        gltfPrm.then(m => {
            const _ = m.scene.getObjectByName("Alche_A").geometry;
            this._logoMesh = new Mesh(_, o), this._logoMesh.scale.setScalar(3), this.add(this._logoMesh), this._logoMesh.renderOrder = transparentRenderer1.renderOrder + 1;
            const v = m.scene.getObjectByName("Alche_Outline");
            this._logoOutlineMeshBase = new Mesh(_, c), this._logoOutlineMeshBase.matrixAutoUpdate = !1, this._logoOutlineMeshBase.renderOrder = 10, this._logoOutlineMeshContainer.add(this._logoOutlineMeshBase), this._logoOutlineMeshLine = new Mesh(v.geometry, u), this._logoOutlineMeshLine.matrixAutoUpdate = !1, this._logoOutlineMeshLine.renderOrder = 11, this._logoOutlineMeshContainer.add(this._logoOutlineMeshLine);
            const x = m.scene.getObjectByName("Alche_SideScreen");
            this._logoScreenMesh = new Mesh(x.geometry, p), this.logoMeshOutline.matrixAutoUpdate = !1, this.logoMeshOutline.renderOrder = 12, this.logoMeshOutline.add(this._logoScreenMesh)
        }), this.setupTweakPane()
    }
    setupTweakPane() {
        this._materialStore.addBinding("roughness", {
            min: 0,
            max: 1,
            step: .01
        }).addBinding("noiseScale", {
            min: .1,
            max: 20,
            step: .1
        }).addBinding("color", {
            view: "color",
            picker: "inline",
            expanded: !1
        }).onUpdate("roughness", () => this.updateMaterialUniforms()).onUpdate("noiseScale", () => this.updateMaterialUniforms()).onUpdate("color", () => this.updateMaterialUniforms()), this._rotationStore.addBinding("x", {
            min: -180,
            max: 180,
            step: .01
        }).addBinding("y", {
            min: -180,
            max: 180,
            step: .01
        }).addBinding("z", {
            min: -180,
            max: 180,
            step: .01
        }).onUpdate("x", () => this.updateRotation()).onUpdate("y", () => this.updateRotation()).onUpdate("z", () => this.updateRotation()), this._screenStore.addBinding("noiseScale", {
            min: .1,
            max: 5,
            step: .1
        }).onUpdate("noiseScale", () => this.updateScreenUniforms()), this._quaternionStore.addBinding("quat", {
            view: "rotation",
            step: .001,
            picker: "inline",
            expanded: !0
        }).onUpdate("quat", () => this.updateQuaternion());
        const i = this._tweakPaneSectionManager.createAndRegisterWindow("mainlogo-material", "MainLogo Material", "tweakpane-mainlogo-material");
        i && this._materialStore.createBindings(i.pane);
        const o = this._tweakPaneSectionManager.createAndRegisterWindow("mainlogo-screen", "MainLogo Screen", "tweakpane-mainlogo-screen");
        o && this._screenStore.createBindings(o.pane);
        const c = this._tweakPaneSectionManager.createAndRegisterWindow("mainlogo-quaternion", "MainLogo Quaternion", "tweakpane-mainlogo-quaternion");
        c && (this._quaternionStore.createBindings(c.pane), c.pane.addButton({
            title: "Reset Quaternion"
        }).on("click", () => {
            this._quaternionStore.setValue("quat", {
                x: 0,
                y: 0,
                z: 0,
                w: 1
            }), this.updateQuaternion()
        }))
    }
    updateMaterialUniforms() {
        if (!this._logoMesh) return;
        const i = this._logoMesh.material;
        i.uniforms.uRoughness.value = this._materialStore.getValue("roughness"), i.uniforms.uNoiseScale.value = this._materialStore.getValue("noiseScale");
        const o = this._materialStore.getValue("color");
        o && (i.uniforms.uMaterialColor.value = new Vector3$1(o.r, o.g, o.b))
    }
    updateRotation() {
        if (!this._logoMesh) return;
        const i = {
                x: this._rotationStore.getValue("x"),
                y: this._rotationStore.getValue("y"),
                z: this._rotationStore.getValue("z")
            },
            o = TweakPaneManager.eulerToQuaternion(i);
        this._logoMesh.quaternion.copy(o)
    }
    updateQuaternion() {
        if (!this._logoMesh) return;
        const i = this._quaternionStore.getValue("quat");
        this._logoMesh.quaternion.set(i.x, i.y, i.z, i.w)
    }
    updateScreenUniforms() {
        if (!this._logoScreenMesh) return;
        const i = this._logoScreenMesh.material;
        i.uniforms.uScreenNoiseScale.value = this._screenStore.getValue("noiseScale")
    }
    get logoMeshOutline() {
        return this._logoOutlineMeshContainer
    }
    hover(i) {
        const o = new Vector2(i.clientX / window.innerWidth * 2 - 1, -(i.clientY / window.innerHeight * 2 - 1));
        lerper.set("mainLogo_hover_x", o.x, 1);
        const c = lerper.get("mainLogo_hover_x") ? .velocity || 0;
        lerper.set("mainLogo_hover_y", o.y, 1);
        const u = lerper.get("mainLogo_hover_y") ? .velocity || 0,
            m = .01 * Math.max(0, 1 - o.length() * 1.5) * this._currentSectionConfig.hoverRotationMultiplier,
            g = this._animator.get("worksRotate") || 0;
        this._tmpEuler.set(this._tmpEuler.x - u * m * (1 - g * .7), this._tmpEuler.y + c * m, 0), this._mouseRotQua.setFromEuler(this._tmpEuler)
    }
    update(i) {
        if (this._animator.update(i.deltaTime), this._logoMesh === null || this._logoOutlineMeshBase === null || this._logoOutlineMeshLine === null) return;
        const o = 1 - i.deltaTime;
        this._tmpEuler.x *= o, this._tmpEuler.y *= o, this._mouseRotQua.setFromEuler(this._tmpEuler);
        const c = this._currentSectionConfig,
            u = this._animator.get("worksRotate") || 0,
            p = lenis ? lerper.set("mainLogo_lenisVelocity", Math.max(Math.min(lenis.velocity, 30), -30), .5) : 0,
            m = new Quaternion$1().setFromAxisAngle(new Vector3$1(0, 1, 0), -i.deltaTime * c.baseRotationSpeed * u - p * c.scrollSpeedRotationFactor);
        this._logoMesh.quaternion.premultiply(this._mouseRotQua), this._logoMesh.quaternion.premultiply(m);
        const g = c.returnToOriginForce * (1 - u * .8);
        if (this._logoMesh.quaternion.slerp(new Quaternion$1, i.deltaTime * g), this._commonUniforms.uVisionRotate.value = lerper.set("mainLogo_vision", this._visionTrigger ? .progress || 0, .5), this._commonUniforms.uServiceIn.value = lerper.get("service_renderer") ? .current || 0, this._commonUniforms.uServiceRotate.value = lerper.set("mainLogo_serviceRotate", this._serviceInTrigger ? .progress || 0, 1), this._logoMesh.updateMatrixWorld(), this._logoOutlineMeshContainer.matrixWorld.copy(this._logoMesh.matrixWorld), !deviceManager.isSPLayout) {
            const _ = new Euler$1().setFromQuaternion(this._logoMesh.quaternion, "XYZ");
            this._rotationStore.setValue("x", MathUtils.radToDeg(_.x)), this._rotationStore.setValue("y", MathUtils.radToDeg(_.y)), this._rotationStore.setValue("z", MathUtils.radToDeg(_.z)), this._quaternionStore.setValue("quat", {
                x: this._logoMesh.quaternion.x,
                y: this._logoMesh.quaternion.y,
                z: this._logoMesh.quaternion.z,
                w: this._logoMesh.quaternion.w
            })
        }
    } in () {
        this._visionTrigger = topScrollManager.getTrigger("vision"), this._serviceInTrigger = topScrollManager.getTrigger("service_in")
    }
    out() {}
    changeSection(i) {
        const o = i || "default";
        this._currentSectionConfig = sectionRotationSettings[o] || sectionRotationSettings.default, this._animator.animate("worksRotate", this._currentSectionConfig.animationIntensity, 1), this._tweakPaneSectionManager.setSection(i)
    }
}
const logo2DFrag = `#define GLSLIFY 1
varying vec2 vUv;uniform sampler2D uTex;uniform float uVisibility;
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
void main(void){vec4 logo=texture2D(uTex,vUv);vec4 o=vec4(0.0);o=logo;o.xyz*=1.5;o.w*=uVisibility;gl_FragColor=o;}`,
    logo2DVert = `#define GLSLIFY 1
varying vec2 vUv;void main(void){vec3 pos=position;vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);gl_Position=projectionMatrix*mvPosition;vUv=uv;}`;
class AlcheLogo2D extends Mesh {
    commonUniforms;
    _animator;
    _layoutController;
    constructor(i) {
        const c = new Animator,
            u = UniformsLib.mergeUniforms(i, {
                uTex: {
                    value: 0
                },
                uVisibility: c.add({
                    name: "visibility",
                    initValue: 0
                })
            }),
            p = new PlaneGeometry(28, 28 * (250 / 1204)),
            m = new ShaderMaterial({
                vertexShader: logo2DVert,
                fragmentShader: logo2DFrag,
                uniforms: UniformsLib.mergeUniforms(u),
                transparent: !0,
                side: DoubleSide,
                depthWrite: !1
            });
        super(p, m), this.commonUniforms = u, this._animator = c, textureLoader.load("/top/logo.png", g => {
            this.commonUniforms.uTex.value = g, this.material.needsUpdate = !0
        })
    }
    changeSection(i) {
        this._animator.animate("visibility", i == "kv" ? 1 : 0, .5)
    }
    update(i) {
        this._animator.update(i.deltaTime)
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
const pattern1Frag = `#define GLSLIFY 1
uniform sampler2D uNoiseTex;uniform float uNoise;uniform float uContour;uniform float uTheme;uniform int uPatternType;varying vec2 vUv;float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}void main(void){vec3 o=vec3(0.0);vec2 uv=vUv;vec4 noise=texture2D(uNoiseTex,uv*1.0);o.x+=smoothstep(0.5,1.0,noise.x);o.y+=smoothstep(0.2,1.0,noise.y);o.z+=smoothstep(0.0,1.0,noise.z);o.xyz*=vec3(0.3,0.4,0.6)*2.0;gl_FragColor=vec4(o,1.0);}`,
    pattern2Frag = `#define GLSLIFY 1
uniform sampler2D uNoiseTex;uniform sampler2D uFluidsTex;varying vec2 vUv;float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}void main(void){vec3 o=vec3(0.0);vec2 uv=vUv;vec4 noise=texture2D(uNoiseTex,uv*1.0);float w=fract(noise.w*9.0);w=step(0.5,w);o+=w;gl_FragColor=vec4(o,1.0);}`,
    pattern3Frag = `#define GLSLIFY 1
uniform sampler2D uNoiseTex;varying vec2 vUv;float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}vec3 hsv2rgb(vec3 hsv){return((clamp(abs(fract(hsv.x+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*hsv.y+1.)*hsv.z;}vec3 rgb2hsv(vec3 rgb){vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=mix(vec4(rgb.bg,K.wz),vec4(rgb.gb,K.xy),step(rgb.b,rgb.g));vec4 q=mix(vec4(p.xyw,rgb.r),vec4(rgb.r,p.yzx),step(p.x,rgb.r));float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);}void main(void){vec3 o=vec3(0.0);vec2 uv=vUv;vec4 noise=texture2D(uNoiseTex,uv*1.0);vec3 c=vec3(0.34509803921568627,0.09803921568627451,0.9921568627450981)*vec3(0.6,0.6,1.0);c=mix(c,vec3(0.6980392156862745,0.9294117647058824,1.),smoothstep(0.5,0.9,noise.w));c=mix(c,vec3(0.9921568627450981,0.37254901960784315,0.047058823529411764),smoothstep(0.5,1.0,noise.y));o+=vec3(c);gl_FragColor=vec4(o,1.0);}`;
class BGQuadTreePatterns extends EventEmitter$1 {
    commonUniforms;
    list;
    currentIndex;
    current;
    next;
    constructor(i, o) {
        super(), this.commonUniforms = UniformsLib.mergeUniforms(o, {}), this.list = [];
        const c = new ProceduralTexture({
            renderer: i,
            resolution: new Vector2(1, 1),
            fragmentShader: pattern1Frag,
            uniforms: UniformsLib.mergeUniforms(this.commonUniforms, {
                uNoiseTex: {
                    value: resources.getTexture("noise").texture
                }
            })
        });
        c.resolutionRatio = .3, c.userData.param = {
            blackOut: 0,
            blakcOutRandom: 0,
            blackOutInterval: 1,
            blackOutIntervalRandom: 0,
            uvShift: 0,
            uvShiftRandom: 0,
            uvShiftInterval: .2,
            uvShiftIntervalRandom: .5
        }, this.list.push(c);
        const u = new ProceduralTexture({
            renderer: i,
            resolution: new Vector2(1, 1),
            fragmentShader: pattern2Frag,
            uniforms: UniformsLib.mergeUniforms(this.commonUniforms, {
                uNoiseTex: {
                    value: resources.getTexture("noise").texture
                }
            })
        });
        u.resolutionRatio = .8, u.userData.param = {
            blackOut: 0,
            blakcOutRandom: .5,
            blackOutInterval: 1,
            blackOutIntervalRandom: 0,
            uvShift: .5,
            uvShiftRandom: 0,
            uvShiftInterval: .1,
            uvShiftIntervalRandom: 5
        }, this.list.push(u);
        const p = new ProceduralTexture({
            renderer: i,
            resolution: new Vector2(1, 1),
            fragmentShader: pattern3Frag,
            uniforms: UniformsLib.mergeUniforms(this.commonUniforms, {
                uNoiseTex: {
                    value: resources.getTexture("noise").texture
                }
            })
        });
        p.resolutionRatio = .8, p.userData.param = {
            blackOut: 0,
            blakcOutRandom: .5,
            blackOutInterval: 1,
            blackOutIntervalRandom: 0,
            uvShift: .5,
            uvShiftRandom: 0,
            uvShiftInterval: .1,
            uvShiftIntervalRandom: 5
        }, this.list.push(p), this.current = this.list[0], this.next = this.list[0], this.currentIndex = 0
    }
    changeRandom() {
        let i = Math.floor(Math.random() * this.list.length);
        return i === this.commonUniforms.uPatternType.value && (i = (i + 1) % this.list.length), this.change(i)
    }
    change(i) {
        this.current = this.next, this.next = this.list[i]
    }
    getCurrentParams = () => this.next ? this.next.userData.param : {
        blackOut: 0,
        blakcOutRandom: 0,
        blackOutInterval: 2,
        blackOutIntervalRandom: 0,
        uvShift: 0,
        uvShiftRandom: 0,
        uvShiftInterval: 2,
        uvShiftIntervalRandom: 0
    };
    update(i) {
        this.current && this.current.render(), this.next && this.next.render()
    }
    dispose() {
        this.list.forEach(i => {
            i.dispose()
        }), this.list = [], this.emitEvent("dispose")
    }
    resize(i) {
        this.list.forEach(o => {
            o.resize(i.sceneResolution.clone().multiplyScalar(.5))
        })
    }
}
const guassWeight = l => {
        const i = new Array(l);
        let o = 0;
        const c = 100;
        for (let u = 0; u < i.length; u++) {
            const p = 1 + 2 * u;
            let m = Math.exp(-.5 * (p * p) / c);
            i[u] = m, u > 0 && (m *= 2), o += m
        }
        for (let u = 0; u < i.length; u++) i[u] /= o;
        return i
    },
    blurFrag = `#define GLSLIFY 1
in vec2 vUv;uniform sampler2D uBackBuffer;uniform vec2 uResolution;uniform bool uIsVertical;uniform float blurRange;layout(location=0)out vec4 outColor;uniform float[GAUSS_WEIGHTS]uWeights;void main(void){vec2 coord=vec2(gl_FragCoord.xy);vec3 sum=uWeights[0]*texture(uBackBuffer,vUv).rgb;for(int i=1;i<GAUSS_WEIGHTS;i++){vec2 offset=(uIsVertical ? vec2(0,i): vec2(i,0))*0.0;sum+=uWeights[i]*texture(uBackBuffer,vUv+offset/uResolution).rgb;sum+=uWeights[i]*texture(uBackBuffer,vUv-offset/uResolution).rgb;}outColor=vec4(sum,1.0);}`;
class BGQuadWorks extends EventEmitter$1 {
    uniforms;
    _renderer;
    _animator;
    _blurPP;
    _worksWrapperElment;
    _resizeObserver;
    _elmTransform;
    _worksData;
    _worksTextures;
    currentWorksIndex;
    currentDisplayinfoIndex;
    constructor(i) {
        super(), this._animator = new Animator, this._renderer = i;
        const o = 2,
            c = UniformsLib.mergeUniforms({
                uWeights: {
                    value: guassWeight(2)
                }
            });
        this._blurPP = new PostProcess({
            renderer: i,
            passes: [new PostProcessPass({
                glslVersion: GLSL3,
                fragmentShader: blurFrag,
                uniforms: UniformsLib.mergeUniforms(c, {
                    uIsVertical: {
                        value: !0
                    }
                }),
                defines: {
                    GAUSS_WEIGHTS: o.toString()
                },
                resolutionRatio: .5
            }), new PostProcessPass({
                glslVersion: GLSL3,
                fragmentShader: blurFrag,
                uniforms: UniformsLib.mergeUniforms(c, {
                    uIsVertical: {
                        value: !1
                    }
                }),
                defines: {
                    GAUSS_WEIGHTS: o.toString()
                },
                resolutionRatio: .5
            })]
        }), this.uniforms = UniformsLib.mergeUniforms({
            uScroll: {
                value: 0
            },
            uScrollPage: {
                value: 0
            },
            uScrollPageLerp: {
                value: 0
            },
            uWorks1Tex: {
                value: null
            },
            uWorks1Loaded: {
                value: 0
            },
            uWorks1Aspect: {
                value: 1
            },
            uWorks2Tex: {
                value: null
            },
            uWorks2Loaded: {
                value: 0
            },
            uWorks2Aspect: {
                value: 1
            }
        }), this._worksWrapperElment = null, this._resizeObserver = null, this._elmTransform = new Vector4, this._worksData = [], this._worksTextures = new Map, this.currentWorksIndex = 0, this.currentDisplayinfoIndex = 0
    }
    get worksCount() {
        return this._worksData && this._worksData.length || 0
    }
    resize() {
        if (this._worksWrapperElment) {
            const i = this._worksWrapperElment.getBoundingClientRect();
            this._elmTransform.set(this._worksWrapperElment.offsetTop, this._worksWrapperElment.offsetLeft, i.width, i.height)
        }
    }
    setElement(i, o) {
        this._worksData = o, this._worksWrapperElment = i, this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), this.resize(), this._resizeObserver = new ResizeObserver(() => {
            this.resize()
        }), this._resizeObserver.observe(this._worksWrapperElment), this.emitEvent("changeWorksData", [o]);
        const c = new TextureLoader;
        o.forEach((u, p) => {
            const m = this._worksTextures.get(p);
            if (m && m.texture.userData.path === u.img) return;
            const g = "worksTexLoaded" + p + "quad",
                _ = this._animator.add({
                    name: g,
                    initValue: 0
                }),
                v = {
                    value: 1
                },
                x = c.load(u.img, b => {
                    this._animator.animate(g, 1, .5), v.value = b.image.width / b.image.height, this._blurPP.passes[1].renderTarget = y, this._blurPP.resize(new Vector2(512, 512)), this._blurPP.render(b)
                });
            x.userData.path = u.img;
            const y = new WebGLRenderTarget(1, 1);
            this._worksTextures.set(p, {
                texture: x,
                blurTexture: y,
                loaded: _,
                aspect: v
            })
        })
    }
    update(i) {
        this._animator.update(i.deltaTime);
        const o = topScrollManager.getTrigger("works_progress");
        if (!o) return;
        const c = o.progress || 0;
        this.uniforms.uScroll.value = c;
        const u = lerper.set("bgQuadProgress", c, .7) * (this._worksTextures.size + 1),
            p = u % 1,
            m = p,
            g = Math.floor(u),
            _ = Math.floor(Math.max(0, Math.min(this.worksCount - 1, u - .5)));
        this.uniforms.uScrollPage.value = p, this.uniforms.uScrollPageLerp.value = m, this.currentDisplayinfoIndex !== _ && this.emitEvent("changeWorks", [_]), this.currentWorksIndex = g, this.currentDisplayinfoIndex = _;
        const v = this._worksTextures.get(Math.max(0, g - 1));
        v && (this.uniforms.uWorks1Tex.value = v.blurTexture.texture || null, this.uniforms.uWorks1Loaded.value = v.loaded.value, this.uniforms.uWorks1Aspect.value = v.aspect.value);
        const x = this._worksTextures.get(g);
        x && (this.uniforms.uWorks2Tex.value = x.blurTexture.texture || null, this.uniforms.uWorks2Loaded.value = x.loaded.value, this.uniforms.uWorks2Aspect.value = x.aspect.value)
    }
    dispose() {
        this._resizeObserver && this._resizeObserver.disconnect()
    }
}
const createQuadTreeGeometry = () => {
        const l = new BoxGeometry(1, 1, .005, 4, 4, 1),
            i = new InstancedBufferGeometry;
        i.setAttribute("position", l.attributes.position), i.setAttribute("uv", l.attributes.uv), i.setAttribute("normal", l.attributes.normal), i.setIndex(l.index);
        const o = [],
            c = [],
            u = [],
            p = [],
            m = 3,
            g = (_, v) => {
                const x = 1 / Math.pow(2, v);
                if (v > 2 && Math.random() < .5 || v > m) {
                    o.push(_.x, _.y, 0), c.push(x, x), u.push(Math.random(), Math.random(), Math.random(), Math.random()), p.push(v);
                    return
                }
                for (let y = 0; y < 2; y++) {
                    const b = (y * 2 - 1) * .5;
                    for (let S = 0; S < 2; S++) {
                        const C = (S * 2 - 1) * .5,
                            E = new Vector2(_.x + b * x / 2, _.y + C * x / 2);
                        g(E, v + 1)
                    }
                }
            };
        return g(new Vector2(0, 0), 0), i.setAttribute("instancePosition", new InstancedBufferAttribute(new Float32Array(o), 3)), i.setAttribute("instanceScale", new InstancedBufferAttribute(new Float32Array(c), 2)), i.setAttribute("instanceID", new InstancedBufferAttribute(new Float32Array(u), 4)), i.setAttribute("instanceDepth", new InstancedBufferAttribute(new Float32Array(p), 1)), i
    },
    bgQuadFrag = `#define GLSLIFY 1
uniform float uTime;uniform vec2 uScreenResolution;uniform sampler2D uLogoTex;uniform sampler2D uPatternCurrent;uniform sampler2D uPatternNext;uniform float uLogoDisplayType;uniform float uScrollPage;uniform sampler2D uWorks1Tex;uniform float uWorks1Loaded;uniform sampler2D uWorks2Tex;uniform float uWorks2Loaded;uniform sampler2D uWorksTitleTex;uniform float uWorksTitleProgress;uniform float uHideQuad;varying vec2 vUv;varying vec2 vGlobalUv;varying float vSideFace;varying float vEmitSide;varying vec2 vScreenUv;varying float vBlackOut;varying float vPatternSelect;varying vec4 vInstanceID;varying vec2 vWorksTitleUv;varying vec2 vWorksUv1;varying vec2 vWorksUv2;varying float vDisplayWorks;
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}vec3 hsv2rgb(vec3 hsv){return((clamp(abs(fract(hsv.x+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*hsv.y+1.)*hsv.z;}vec3 rgb2hsv(vec3 rgb){vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=mix(vec4(rgb.bg,K.wz),vec4(rgb.gb,K.xy),step(rgb.b,rgb.g));vec4 q=mix(vec4(p.xyw,rgb.r),vec4(rgb.r,p.yzx),step(p.x,rgb.r));float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);}void main(void){vec4 o=vec4(0.0,0.0,0.0,1.0);vec2 fragUV=gl_FragCoord.xy/uScreenResolution;float wtVisibility=smoothstep(0.1,0.3,uWorksTitleProgress)*smoothstep(1.0,0.9,uWorksTitleProgress);vec4 pat1=texture2D(uPatternCurrent,vScreenUv);vec4 pat2=texture2D(uPatternNext,vScreenUv);o.xyz=mix(pat1.xyz,pat2.xyz,vPatternSelect);o.xyz*=(1.0-wtVisibility*0.5);o.xyz*=(1.0-vBlackOut);vec2 logoUv=vScreenUv;if(uLogoDisplayType==0.0){logoUv=vGlobalUv;logoUv-=0.5;logoUv.y*=1204.0/250.0;logoUv*=1.0;logoUv+=0.5;vec2 tileUv=logoUv.xy*2.0;tileUv.x+=sin(floor(tileUv.y)*3.0+uTime)*0.1;logoUv=fract(tileUv)*1.3;}else if(uLogoDisplayType==1.0){logoUv=vGlobalUv;logoUv-=0.5;logoUv.y*=1204.0/250.0;logoUv*=1.1;logoUv+=0.5;vec2 tileUv=logoUv.xy*1.0;tileUv.x+=uTime*0.05*sign(floor(tileUv.y));logoUv=fract(tileUv)*1.0;if(abs(floor(tileUv.y))<0.5){logoUv=vec2(0.0);}}else if(uLogoDisplayType==2.0){logoUv=vUv;logoUv-=0.5;logoUv.x/=1204.0/250.0;logoUv+=0.5;logoUv.y-=uTime*0.5*vInstanceID.x;logoUv.y=fract(logoUv.y);logoUv-=0.5;logoUv*=1.3+vInstanceID.z*5.0;logoUv+=0.5;logoUv.x-=0.38;if(logoUv.x>0.23||logoUv.x<0.00||logoUv.y>1.0||logoUv.y<0.0||vInstanceID.y<0.0){logoUv=vec2(0.0);}}vec4 logo=texture2D(uLogoTex,logoUv);float logoW=step(0.5,logo.w)*step(0.0,logoUv.y)*step(logoUv.y,1.0);o.xyz+=logoW*0.2*(1.0-wtVisibility);float hideKv=smoothstep(0.0,1.0,-vInstanceID.x+uHideQuad*2.0);vec2 flashUv=(vUv-0.5)*vec2(1.0,1.0+hideKv*50.0);o.xyz=mix(o.xyz,(o.xyz+0.1)*20.0*vInstanceID.z,step(0.01,hideKv));float turnOff=1.0;turnOff*=step(length(flashUv.y)+hideKv*0.9,1.0);turnOff*=step(length(flashUv.x)+pow(hideKv,3.0),1.0);o.xyz*=turnOff;vec2 worksTitleUv=vWorksTitleUv;vec3 worksTitleCol=texture2D(uWorksTitleTex,worksTitleUv).xyz;worksTitleCol*=wtVisibility;float num=float(WORKS_NUM);float numP=float(WORKS_NUM+1);vec3 t1=(texture2D(uWorks1Tex,vWorksUv1).xyz)*uWorks1Loaded;vec3 t2=(texture2D(uWorks2Tex,vWorksUv2).xyz)*uWorks2Loaded;float blurSize=0.03;vec3 worksCol=mix(t1,t2,smoothstep(fragUV.x-blurSize,fragUV.x+blurSize,uScrollPage*(1.0+blurSize*2.0)-blurSize));worksCol*=mix(1.0,(random(gl_FragCoord.xy/1000.0)),0.1)*1.0;vec3 worksColHSV=rgb2hsv(worksCol);worksCol=hsv2rgb(vec3(worksColHSV.x,worksColHSV.y*2.0,worksColHSV.z));o.xyz=mix(o.xyz,worksCol,vDisplayWorks);o.w+=vDisplayWorks;o.w=min(o.w,1.0);o.xyz*=smoothstep(1.9,0.1,length(vUv-0.5));o.xyz+=worksTitleCol*step(worksTitleUv.x,1.0)*step(0.01,worksTitleUv.x)*1.0;float dotw=smoothstep(0.5,0.2,length(fract(vGlobalUv.xy*1800.0*vec2(1.0,1.0)*0.23)-0.5));dotw=mix(dotw,1.0,0.6)*0.9;o.xyz*=dotw;o.xyz*=smoothstep(0.55,0.05,length(vGlobalUv-0.5));o.xyz*=vSideFace;o.xyz+=(1.0-vSideFace)*0.8*vEmitSide*(mix(0.05,1.0,turnOff)+vDisplayWorks);o.xyz*=0.5;gl_FragColor=o;}`,
    bgQuadVert = `#define GLSLIFY 1
attribute vec3 instancePosition;attribute vec2 instanceScale;attribute vec4 instanceID;attribute float instanceDepth;uniform float uTime;uniform vec3 uScale;uniform sampler2D uFluidsTex;uniform float uUVShift;uniform float uUVShiftPower;uniform float uUVShiftHash;uniform float uBlackOut;uniform float uBlackOutHash;uniform float uPatternSelect;uniform float uPatternSelectType;uniform float uWorks1Aspect;uniform float uWorks2Aspect;uniform float uScreenAspectRatio;uniform float uScroll;uniform float uScrollPageLerp;uniform float uScrollPage;uniform float uHide;uniform float uWorksTitleProgress;varying vec2 vWorksUv1;varying vec2 vWorksUv2;varying float vDisplayWorks;varying vec2 vUv;varying vec2 vScreenUv;varying vec2 vGlobalUv;varying vec3 vScreenOffsetPos;varying vec3 vNormal;varying float vSideFace;varying float vEmitSide;varying float vBlackOut;varying float vPatternSelect;varying vec4 vInstanceID;varying vec2 vWorksTitleUv;mat2 rotate(float rad){return mat2(cos(rad),sin(rad),-sin(rad),cos(rad));}float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
float cubicIn(float t){return t*t*t;}float cubicOut(float t){float f=t-1.0;return f*f*f+1.0;}float cubicInOut(float t){return t<0.5? 4.0*t*t*t: 0.5*pow(2.0*t-2.0,3.0)+1.0;}float circularIn(float t){return 1.0-sqrt(1.0-t*t);}float circularOut(float t){return sqrt((2.0-t)*t);}float circularInOut(float t){return t<0.5? 0.5*(1.0-sqrt(1.0-4.0*t*t)): 0.5*(sqrt((3.0-2.0*t)*(2.0*t-1.0))+1.0);}float quarticIn(float t){return pow(t,4.0);}float quarticOut(float t){return pow(t-1.0,3.0)*(1.0-t)+1.0;}float quarticInOut(float t){return t<0.5?+8.0*pow(t,4.0):-8.0*pow(t-1.0,4.0)+1.0;}float exponentialIn(float t){return t==0.0 ? t : pow(2.0,10.0*(t-1.0));}float exponentialOut(float t){return t==1.0 ? t : 1.0-pow(2.0,-10.0*t);}float exponentialInOut(float t){return t==0.0||t==1.0? t: t<0.5?+0.5*pow(2.0,(20.0*t)-10.0):-0.5*pow(2.0,10.0-(t*20.0))+1.0;}void main(void){vec3 pos=position;float hide=smoothstep(0.2,0.8,-instanceID.z+uHide*2.0);pos*=1.0-hide;pos.xy*=1.0-0.003*pow(2.0,instanceDepth);pos.xy*=instanceScale;pos.xz*=rotate((instanceID.x-0.5)*hide*PI*2.0);pos.y+=hide*0.05*instanceID.z;vec3 pos2=pos;vec4 offsetMVPosition=modelViewMatrix*vec4(instancePosition*uScale,1.0);vec4 offsetScreenPosition=projectionMatrix*offsetMVPosition;offsetScreenPosition.xyz/=offsetScreenPosition.w;vScreenOffsetPos=offsetScreenPosition.xyz;vec4 fluids=texture2D(uFluidsTex,offsetScreenPosition.xy*0.5+0.5);vec2 screenPosUv=(offsetScreenPosition.xy*0.5+0.5);float displayWorks=smoothstep(0.0,0.3,-(screenPosUv.x)+(uScroll*float(WORKS_NUM))*1.6);float worksUvShiftW=smoothstep(0.0,0.4,-(screenPosUv.x)+(uScroll*float(WORKS_NUM))*1.6);float fadeOut=smoothstep(1.0,0.9,uScroll);vDisplayWorks=displayWorks*fadeOut;vPatternSelect=0.0;if(uPatternSelectType==0.0){vPatternSelect=step(0.5,uPatternSelect);}else if(uPatternSelectType==1.0){float fade=step(instanceID.x,uPatternSelect);vPatternSelect=fade;}else if(uPatternSelectType==2.0){float fade=smoothstep(0.0,1.0,-(instancePosition.x+0.5)+uPatternSelect*2.0);fade=exponentialOut(fade);vPatternSelect=fade;pos.xz*=rotate(fade*TPI);}float r=smoothstep(vScreenOffsetPos.y*0.5+0.5-0.4,vScreenOffsetPos.y*0.5+0.5+0.4,uScrollPage*(1.0+0.4*2.0)-0.4);pos+=instancePosition;pos2+=instancePosition;pos2.x*=uScale.x;pos2.y*=uScale.y;float roundTheta=pos.x*PI;vec3 resultPos=pos;resultPos.x*=0.0;resultPos.xz*=rotate(HPI);resultPos.z-=uScale.x/2.0;resultPos.y*=uScale.y*1.5;resultPos.xz*=rotate(-roundTheta);vec4 mvPosition=modelViewMatrix*vec4(resultPos,1.0);gl_Position=projectionMatrix*mvPosition;vSideFace=abs(normal.z);vEmitSide=length(fluids.xy);vUv=uv;vGlobalUv=instancePosition.xy+0.5+(uv-0.5)*instanceScale;vec4 screenUVMVPosition=modelViewMatrix*vec4(pos2*0.5,1.0);vec4 screenUVScreenPosition=projectionMatrix*screenUVMVPosition;vScreenUv=screenUVScreenPosition.xy/screenUVScreenPosition.w*0.5+0.5;float shiftUvHash=floor(uUVShiftHash*5.0)/5.0;vec2 us=vec2(random(instanceID.xy+shiftUvHash),random(instanceID.xy+shiftUvHash+10.0))-0.5;us*=(uUVShiftPower)*step(random(instanceID.xy+shiftUvHash),uUVShift);vScreenUv+=us;float blackOutHash=floor(uBlackOutHash*5.0)/5.0;vBlackOut=step(random(instanceID.xy+blackOutHash),uBlackOut);vec2 worksUvShift=vec2(0.0,0.0+random(instanceID.yz)-0.5)*1.0;float worksTitleScale=max(1.0,0.8/uScreenAspectRatio*2.0);vec2 worksTitleUv=vScreenUv;worksTitleUv-=0.5;worksTitleUv*=worksTitleScale;worksTitleUv.x*=uScreenAspectRatio;worksTitleUv*=rotate(-0.15);worksTitleUv.y*=4.5;worksTitleUv.x*=1.2;worksTitleUv*=rotate(-0.015);worksTitleUv.x-=-0.18+uWorksTitleProgress*0.3;worksTitleUv+=0.5;vWorksTitleUv=worksTitleUv;float slide=0.5;vWorksUv1=vScreenUv-us-worksUvShift*pow((1.0,uScrollPageLerp),2.0);vWorksUv1.x=vWorksUv1.x;vWorksUv1.x-=uScrollPageLerp*slide;vWorksUv2=vScreenUv-us-worksUvShift*pow((1.0,1.0-uScrollPageLerp),2.0);vWorksUv2.x=vWorksUv2.x;vWorksUv2.x+=(1.0-uScrollPageLerp)*slide;if(uScreenAspectRatio<uWorks1Aspect){vWorksUv1.x-=0.5;vWorksUv1.x*=uScreenAspectRatio/uWorks1Aspect;vWorksUv1.x+=0.5;}else{vWorksUv1.y-=0.5;vWorksUv1.y/=uScreenAspectRatio/uWorks1Aspect;vWorksUv1.y+=0.5;}if(uScreenAspectRatio<uWorks2Aspect){vWorksUv2.x-=0.5;vWorksUv2.x*=uScreenAspectRatio/uWorks2Aspect;vWorksUv2.x+=0.5;}else{vWorksUv2.y-=0.5;vWorksUv2.y/=uScreenAspectRatio/uWorks2Aspect;vWorksUv2.y+=0.5;}vInstanceID=instanceID;}`;
class BGQuadTree extends Mesh {
    works;
    _currentSection;
    _commonUniforms;
    _geoList = [];
    _patterns;
    constructor(i, o) {
        const c = new BGQuadWorks(i);
        c.addListener("changeWorksData", C => {
            p.defines.WORKS_NUM = C.length, p.needsUpdate = !0
        }), c.addListener("changeWorks", () => {
            b()
        });
        const u = UniformsLib.mergeUniforms(o, c.uniforms, {
                uPatternCurrent: {
                    value: null
                },
                uPatternNext: {
                    value: null
                },
                uPatternSelect: animator.add({
                    name: "bgQuad_pattern",
                    initValue: 0,
                    easing: Easings.linear
                }),
                uLogoTex: {
                    value: null
                },
                uPatternSelectType: {
                    value: 0
                },
                uPatternType: {
                    value: 0
                },
                uUVShift: animator.add({
                    name: "bgQuad_uvShift",
                    initValue: 0,
                    easing: Easings.linear
                }),
                uUVShiftPower: animator.add({
                    name: "bgQuad_uvShift_power",
                    initValue: 0,
                    easing: Easings.easeOutCubic
                }),
                uUVShiftHash: animator.add({
                    name: "bgQuad_uvShift_hash",
                    initValue: 0,
                    easing: Easings.linear
                }),
                uBlackOut: animator.add({
                    name: "bgQuad_blackOut",
                    initValue: 0,
                    easing: Easings.linear
                }),
                uBlackOutHash: animator.add({
                    name: "bgQuad_blackOut_hash",
                    initValue: 0,
                    easing: Easings.linear
                }),
                uTileRotate: animator.add({
                    name: "bgQuad_tileRotate",
                    initValue: 0,
                    easing: Easings.linear
                }),
                uLogoDisplayType: {
                    value: 0
                },
                uDark: animator.add({
                    name: "bgQuad_dark",
                    initValue: 0,
                    easing: Easings.linear
                }),
                uHide: animator.add({
                    name: "bgQuad_hide",
                    initValue: 0,
                    easing: Easings.cubicBezier(.06, .59, .04, .99)
                }),
                uWorksBlockAnim: animator.add({
                    name: "bgQuad_worksBlockAnim",
                    initValue: 0,
                    easing: Easings.cubicBezier(.01, .68, .19, 1)
                }),
                uWOrksBlockAnimHash1: {
                    value: 0
                },
                uWOrksBlockAnimHash2: {
                    value: 0
                },
                uWorksTitleTex: {
                    value: null
                },
                uWorksTitleProgress: {
                    value: 0
                },
                uScale: {
                    value: new Vector3$1(1, 1, 1)
                }
            }),
            p = new ShaderMaterial({
                fragmentShader: bgQuadFrag,
                vertexShader: bgQuadVert,
                uniforms: UniformsLib.mergeUniforms(u),
                defines: {
                    WORKS_NUM: "1"
                },
                transparent: !0,
                depthWrite: !1
            });
        textureLoader.load("/top/logo.png", C => {
            u.uLogoTex.value = C
        }), textureLoader.load("/top/works-title.png", C => {
            C.wrapS = RepeatWrapping, u.uWorksTitleTex.value = C
        }), super(void 0, p), this._commonUniforms = u, this.works = c, this._patterns = new BGQuadTreePatterns(i, u), this._geoList.push(createQuadTreeGeometry(), createQuadTreeGeometry(), createQuadTreeGeometry(), createQuadTreeGeometry());
        let m = !0;
        const g = C => {
            (!m || this._currentSection != "kv") && !C || (this.geometry = this._geoList[Math.floor(Math.random() * this._geoList.length)], setTimeout(g, 4e3))
        };
        g(!0);
        const _ = () => {
            this._commonUniforms.uLogoDisplayType.value = Math.floor(Math.random() * 3)
        };
        _();
        const v = () => {
            if (!m) return;
            _();
            const C = this._patterns.getCurrentParams();
            animator.setValue("bgQuad_blackOut", C.blackOut + Math.random() * C.blakcOutRandom), animator.animate("bgQuad_blackOut_hash", Math.random(), .3).catch(() => {}), setTimeout(v, (C.blackOutInterval + C.blackOutIntervalRandom * Math.random()) * 1e3)
        };
        v();
        const x = () => {
            if (!m) return;
            const C = this._patterns.getCurrentParams();
            animator.setValue("bgQuad_uvShift", C.uvShift + C.uvShiftRandom * Math.random()), animator.animate("bgQuad_uvShift_power", Math.random(), .8).catch(() => {}), animator.animate("bgQuad_uvShift_hash", Math.random(), .3).catch(() => {}), setTimeout(x, (C.uvShiftInterval + C.uvShiftIntervalRandom * Math.random()) * 1e3)
        };
        x();
        const y = () => {
            if (!m) return;
            const {
                fadeDuration: C
            } = this.changePattern();
            setTimeout(y, (Math.random() + C + 1) * 1e3)
        };
        y();
        const b = () => {
            m && (this._commonUniforms.uWOrksBlockAnimHash1.value = this._commonUniforms.uWOrksBlockAnimHash2.value, this._commonUniforms.uWOrksBlockAnimHash2.value = Math.random(), animator.setValue("bgQuad_worksBlockAnim", 0), animator.animate("bgQuad_worksBlockAnim", 1, 2).catch(() => {}))
        };
        this._currentSection = null;
        const S = () => {
            m = !1, this.removeEventListener("dispose", S)
        };
        this.addEventListener("dispose", S)
    }
    changePattern(i) {
        i === void 0 ? this._patterns.changeRandom() : this._patterns.change(i), this._commonUniforms.uPatternCurrent.value = this._patterns.current.texture, this._commonUniforms.uPatternNext.value = this._patterns.next.texture, this._commonUniforms.uPatternType.value = this._patterns.current;
        let o = Math.floor(Math.random() * 3);
        this._currentSection != "kv" && (o = 0);
        const c = [0, .3, 3][o];
        return this._commonUniforms.uPatternSelectType.value = o, animator.setValue("bgQuad_pattern", 0), animator.animate("bgQuad_pattern", 1, c), {
            fadeDuration: c
        }
    }
    changeSection(i) {
        this._currentSection = i
    }
    update(i) {
        this._commonUniforms.uWorksTitleProgress.value = lerper.get("works_title_visibility") ? .current || 0, this._patterns.update(i), this.works.update(i)
    }
    resize(i) {
        const o = i.camera,
            c = o.userData.baseFov || o.fov,
            u = o.userData.basePos || o.position,
            p = Math.abs(u.z),
            m = MathUtils.degToRad(c),
            g = 2 * p * Math.tan(m / 2),
            _ = g * o.aspect;
        _ < g ? this._commonUniforms.uScale.value.set(g, g, 1) : this._commonUniforms.uScale.value.set(_, _, 1), this._patterns.resize(i)
    }
    dispose() {
        this._patterns.dispose(), this.works.dispose(), this.dispatchEvent({
            type: "dispose"
        })
    }
}
class CameraController {
    _animator;
    _camera;
    _mousePosition;
    _mouseOffset;
    _targetMouseOffset;
    _mouseMoveRange;
    _mouseLerpSpeed;
    _basePosition;
    _worksOutroTrigger;
    constructor(i) {
        this._camera = i, this._animator = new Animator, this._animator.add({
            name: "kvZoom",
            initValue: 1
        }), this._basePosition = new Vector3$1(0, 0, 10), this._camera.userData.basePos = this._basePosition.clone(), this._mousePosition = new Vector2(0, 0), this._mouseOffset = new Vector2(0, 0), this._targetMouseOffset = new Vector2(0, 0), this._mouseMoveRange = .5, this._mouseLerpSpeed = 3, this._setupMouseEvents(), this._worksOutroTrigger = null
    }
    _setupMouseEvents() {
        const i = o => {
            this._mousePosition.x = o.clientX / window.innerWidth * 2 - 1, this._mousePosition.y = -(o.clientY / window.innerHeight) * 2 + 1, this._targetMouseOffset.x = this._mousePosition.x, this._targetMouseOffset.y = this._mousePosition.y
        };
        window.addEventListener("mousemove", i)
    }
    update(i) {
        const o = i.deltaTime;
        this._animator.update(o);
        const c = Math.min(this._mouseLerpSpeed * o, 1),
            u = this._targetMouseOffset.clone().multiplyScalar(this._mouseMoveRange).multiplyScalar(1 - lerper.set("cameraController_worksOutro", this._worksOutroTrigger ? .progress || 0, .5));
        this._mouseOffset.lerp(u, c), this._camera.position.set(this._basePosition.x + this._mouseOffset.x, this._basePosition.y + this._mouseOffset.y, this._basePosition.z - this._animator.get("kvZoom") * .5), this._camera.fov = this._camera.userData.baseFov - this._animator.get("kvZoom") * 4, this._camera.updateProjectionMatrix(), this._camera.lookAt(0, 0, 0)
    }
    setMouseMoveRange(i) {
        this._mouseMoveRange = i
    }
    getMouseMoveRange() {
        return this._mouseMoveRange
    }
    setMouseLerpSpeed(i) {
        this._mouseLerpSpeed = i
    }
    getMouseLerpSpeed() {
        return this._mouseLerpSpeed
    }
    resize(i) {
        this._camera.aspect = i.aspectRatio, this._camera.userData.baseFov = 35 + 1 / i.aspectRatio * 18
    } in () {
        this._worksOutroTrigger = topScrollManager.getTrigger("works_outro")
    }
    out() {}
    changeSection(i) {
        i == "kv" ? this._animator.animate("kvZoom", 1, 1) : this._animator.animate("kvZoom", 0, 1)
    }
    dispose() {}
}
const worksTitleVert = `#define GLSLIFY 1
#define linearstep(edge0, edge1, x) min(max(((x) - (edge0)) / ((edge1) - (edge0)), 0.0), 1.0)
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
mat2 rotate(float rad){return mat2(cos(rad),sin(rad),-sin(rad),cos(rad));}uniform float uProgress;varying vec2 vUv;varying float vAlpha;varying vec3 vPos;varying vec4 vGLPosition;void main(void){vec3 pos=vec3(0.0);float rotMul=TPI*1.3;float theta=rotMul+position.x*TPI;theta-=(uProgress*3.0)*rotMul;float clampedTheta=clamp(theta,-TPI-PI,PI);float rad=3.0;pos.x=sin(clampedTheta+PI)*rad;pos.z=cos(clampedTheta+PI)*rad;pos.y=position.y;float viewIn=max(0.0,theta-PI);float viewOut=min(0.0,theta+TPI+PI);pos.x+=viewIn*2.0;pos.x+=viewOut*2.0;pos.xy*=rotate(0.2);vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);gl_Position=projectionMatrix*mvPosition;vUv=uv;vAlpha=smoothstep(2.5,0.0,viewIn)*smoothstep(-2.5,0.0,viewOut);vPos=pos;vGLPosition=gl_Position;}`,
    worksTitleFrag = `#define GLSLIFY 1
uniform float uProgress;uniform sampler2D uTex;uniform float uTime;varying vec2 vUv;varying float vAlpha;varying vec3 vPos;varying vec4 vGLPosition;void main(void){vec4 texCol=texture2D(uTex,vUv*vec2(4.0,1.0)+vec2(uTime*0.1-uProgress*13.0,0.0));float p3=uProgress*3.0;float alphadayo=smoothstep(1.0,0.0,p3);alphadayo+=smoothstep(2.0,3.0,p3);texCol.w*=smoothstep(0.0,0.2*alphadayo,vUv.x);texCol.w*=smoothstep(1.0,1.0-0.2*alphadayo,vUv.x);gl_FragColor=vec4(vec3(1.0),texCol.w*vAlpha);gl_FragDepth=vGLPosition.z;if(vPos.z>0.4){gl_FragDepth=0.0;}}`;
class WorksTitle extends Mesh {
    _commonUniforms;
    _worksIntroTrigger;
    constructor(i) {
        const o = UniformsLib.mergeUniforms(i, {
                uProgress: {
                    value: 0
                },
                uTex: {
                    value: 0
                }
            }),
            c = new PlaneGeometry(1, 1, 64, 1),
            u = new ShaderMaterial({
                vertexShader: worksTitleVert,
                fragmentShader: worksTitleFrag,
                uniforms: o,
                transparent: !0,
                side: DoubleSide,
                depthWrite: !1,
                blending: AdditiveBlending
            });
        textureLoader.load("/top/works-title.png", p => {
            p.wrapS = RepeatWrapping, o.uTex.value = p
        }), super(c, u), this._commonUniforms = o, this._worksIntroTrigger = null, this.renderOrder = 999, this.visible = !1
    }
    update(i) {
        this._commonUniforms.uProgress.value = lerper.set("works_title_visibility", this._worksIntroTrigger ? .progress || 0, .3)
    } in () {
        this._worksIntroTrigger = topScrollManager.getTrigger("works_intro")
    }
    out() {}
}
class TopPageMainScene extends BaseScene {
    _commonUniforms;
    _cameraContorller;
    _grid;
    _mainLogo;
    _alcheLogo2D;
    _bgQuadTree;
    _worksTitle;
    constructor(i) {
        super(), this._cameraContorller = new CameraController(this._camera), this._commonUniforms = UniformsLib.mergeUniforms(i), this._grid = new Grid("light", "round", this._commonUniforms), this.add(this._grid), this.add(transparentRenderer1), this._mainLogo = new MainLogo(this._commonUniforms), this._mainLogo.scale.setScalar(4.3), this._mainLogo.position.set(0, -.3, 0), this.add(this._mainLogo), this.addLayoutController(this._mainLogo, {
            position: new Vector3$1(0, .5, 0)
        }), this._alcheLogo2D = new AlcheLogo2D(this._commonUniforms), this._alcheLogo2D.position.set(0, 0, -15), this.add(this._alcheLogo2D), this.addLayoutController(this._alcheLogo2D, {
            scale: .55,
            position: new Vector3$1(0, 1, 0)
        }), this._bgQuadTree = new BGQuadTree(renderer, this._commonUniforms), this._bgQuadTree.renderOrder = -1e3, this.add(this._bgQuadTree), this._worksTitle = new WorksTitle(this._commonUniforms), this._worksTitle.position.set(0, 0, 0), this.add(this._worksTitle)
    }
    get mainLogo() {
        return this._mainLogo
    }
    get cameraController() {
        return this._cameraContorller
    }
    get alcheLogo2D() {
        return this._alcheLogo2D
    }
    get bgQuadTree() {
        return this._bgQuadTree
    }
    get worksTitle() {
        return this._worksTitle
    }
    update(i) {
        this._mainLogo.update(i), this._alcheLogo2D.update(i), this._bgQuadTree.update(i), this._cameraContorller.update(i), this._worksTitle.update(i)
    }
    hover(i) {
        this._mainLogo.hover(i)
    }
    changeSection(i) {
        this.mainLogo.changeSection(i), this._alcheLogo2D.changeSection(i), this._cameraContorller.changeSection(i)
    }
    resize(i) {
        super.resize(i), this._grid.resize(this.camera), this._cameraContorller.resize(i), this._bgQuadTree.resize(i)
    }
}
const gridFrag = `#define GLSLIFY 1
varying vec2 vUv;uniform vec2 uGrid;uniform float uTime;uniform float uThumbnailScroll;void main(void){float line=0.0;vec2 gridUv=vUv*uGrid;gridUv.x*=0.6;gridUv.x+=uTime+uThumbnailScroll*2.5;line+=smoothstep(0.48,0.5,abs(fract(gridUv.x)-0.5));line=max(line,smoothstep(0.48,0.5,abs(fract(gridUv.y)-0.5)));
#ifdef IS_DARK
gl_FragColor=vec4(vec3(0.0),0.7);
#else
gl_FragColor=vec4(vec3(1.0),0.5);
#endif
gl_FragColor.a*=line*0.2;}`,
    crossFrag = `#define GLSLIFY 1
varying vec2 vUv;uniform float uTime;void main(void){float line=0.0;vec2 gridUv=vUv-0.5;float w=0.08;line+=smoothstep(w,0.01,abs(gridUv.x));line=max(line,smoothstep(w,w*0.1,abs(gridUv.y)));
#ifdef IS_DARK
gl_FragColor=vec4(vec3(0.0),1.0);
#else
gl_FragColor=vec4(vec3(1.0),0.7);
#endif
gl_FragColor.a*=line*0.6;}`,
    serviceListVert = `#define GLSLIFY 1
varying vec2 vUv;varying vec3 vNormal;uniform float uServiceIn;uniform vec3 uScale;uniform float uTime;uniform float uThumbnailScroll;uniform float uStelllaIn;uniform float uStelllaView;uniform float uSPWeight;
#define PI 3.14159265359
#define TPI 6.28318530718
#define HPI 1.57079632679
mat2 rotate(float rad){return mat2(cos(rad),sin(rad),-sin(rad),cos(rad));}
#ifdef IS_CROSS
attribute vec2 instanceId;
#endif
#ifdef IS_THUMBNAIL
uniform float uInstanceId;
#endif
#ifdef IS_STELLLA
uniform float uCanvasAspect;uniform float uVideoAspect;
#endif
float ease(float x){return-(cos(PI*x)-1.0)/2.0;}float ease2(float x){return x<0.5 ? 4.0*x*x*x : 1.0-pow(-2.0*x+2.0,3.0)/2.0;}vec2 getCoverUV(vec2 uv,float canvasAspect,float videoAspect){vec2 newUv=uv;float scaleX=1.0;float scaleY=1.0;newUv-=0.5;if(canvasAspect>videoAspect){newUv.y/=canvasAspect;newUv.y*=videoAspect;}else{newUv.x*=canvasAspect;newUv.x/=videoAspect;}newUv+=0.5;return newUv;}void main(void){vUv=uv;vec2 localPos=position.xy;
#ifdef IS_CROSS
vec2 loopPos=instanceId.xy;loopPos.x=mod(loopPos.x-uTime*0.01-uThumbnailScroll*0.3-uServiceIn*0.2,1.0);localPos=(loopPos-0.5)*1.0;
#endif
#ifdef IS_THUMBNAIL
float x=uInstanceId-(uThumbnailScroll-1.0);x+=0.09*uSPWeight;localPos=position.xy*0.3;localPos.x*=(16.0/9.0)*0.85;localPos.x+=x*0.95;localPos.x+=-0.05*(1.0-uStelllaIn);
#ifndef IS_STELLLA
localPos.x-=uStelllaView*0.5;
#endif
#endif
#ifndef IS_THUMBNAIL
localPos.x*=1.4;
#endif
float theta=localPos.x*PI+(1.0-uServiceIn)*8.0+-uStelllaIn*2.0;float wavePow=(4.0*uServiceIn);wavePow*=1.0-uStelllaIn;wavePow*=(1.0-uSPWeight*0.2);vec3 curvedPos=vec3(0.0);curvedPos=vec3(localPos.x*uScale.x,localPos.y*uScale.y,-sin(theta)*wavePow);
#ifndef IS_THUMBNAIL
curvedPos.y*=1.7;
#endif
#ifdef IS_THUMBNAIL
curvedPos.y+=0.6*uSPWeight;
#endif
vNormal=vec3(0.0,0.0,1.0);float directionTheta=cos(theta)*(uServiceIn*(1.0-uStelllaIn))*0.7;vNormal.xz*=rotate(directionTheta);vec3 pos=vec3(0.0);
#ifdef IS_GRID
pos=curvedPos;
#endif
#ifdef IS_CROSS
pos=position*0.2;pos.xz*=rotate(directionTheta);pos+=curvedPos;
#endif
#ifdef IS_THUMBNAIL
pos=curvedPos;
#endif
#ifdef IS_TITLE
pos=curvedPos;
#endif
gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);
#ifdef IS_STELLLA
float stelllaFit=uStelllaView;float curve=mix(0.3,0.2,uSPWeight);float w=smoothstep(0.0,1.0,-uv.x*curve+stelllaFit*(1.0+curve));gl_Position=mix(gl_Position,vec4(position.xy*2.0,0.0,1.0),w);vUv=mix(vUv,getCoverUV(vUv,uCanvasAspect,uVideoAspect),w);
#endif
}`,
    serviceTitleFrag = `#define GLSLIFY 1
uniform sampler2D uServiceTitleTex;uniform sampler2D uPrevTexture;uniform sampler2D uNextTexture;uniform float uTextureBlend;uniform float uHasPrevTexture;uniform float uHasNextTexture;varying vec2 vUv;uniform float uServiceIn;uniform float uThumbnailScroll;uniform float uTime;void main(void){vec2 serviceTitleUv=vUv;serviceTitleUv.y*=4.5;serviceTitleUv.x*=1.1;serviceTitleUv.x+=uThumbnailScroll*0.2+uTime*0.015;serviceTitleUv.x=fract(serviceTitleUv.x)*1.1;serviceTitleUv.y=fract(serviceTitleUv.y);float titleCol=texture2D(uServiceTitleTex,serviceTitleUv).w;titleCol*=mix(0.8,(1.0-vUv.x)*0.0,uServiceIn);vec2 texUv=vUv;texUv.x-=0.5;texUv.x*=0.7;texUv.x+=0.5;vec3 prevTexture=vec3(0.0);vec3 nextTexture=vec3(0.0);if(uHasPrevTexture>0.5){prevTexture=texture2D(uPrevTexture,texUv+vec2(uTextureBlend*0.05,0.0)).rgb;}if(uHasNextTexture>0.5){nextTexture=texture2D(uNextTexture,texUv-vec2((1.0-uTextureBlend)*0.05,0.0)).rgb;}vec3 blendedTexture=mix(prevTexture,nextTexture,uTextureBlend);vec3 col=vec3(0.0);col+=blendedTexture*(1.0-vUv.x)*0.4;col+=titleCol;gl_FragColor=vec4(col,1.0);}`,
    thumbnailFrag = `#define GLSLIFY 1
uniform sampler2D uTextureA;uniform sampler2D uTextureB;uniform float uTextureAlpha;uniform float uMixWeight;uniform float uServiceIn;varying vec2 vUv;varying vec3 vNormal;void main(void){vec2 uv=vUv;vec4 texColorA=texture2D(uTextureA,uv);vec4 texColorB=texture2D(uTextureB,uv);vec4 mixedColor=mix(texColorA,texColorB,uMixWeight);
#ifndef IS_STELLLA
mixedColor.w*=smoothstep(1.0,0.3,length(vUv-0.5));
#endif
mixedColor.rgb*=0.7;gl_FragColor=vec4(mixedColor.rgb,mixedColor.a*uTextureAlpha*smoothstep(0.5,1.0,uServiceIn));}`;
class ServiceThumbnail extends Mesh {
    _instanceId;
    _texturePaths;
    _textures = [];
    _videoElements = [];
    _currentTextureIndex = 0;
    _nextTextureIndex = 1;
    _textureLoader;
    _switchTimer = 0;
    _switchInterval = 5;
    _isStelllaLogo;
    _animator;
    _fadeTransition = !1;
    _pendingVideos = [];
    _clickHandler;
    constructor(i, o, c, u) {
        const p = new PlaneGeometry(1, 1, 16, 8),
            m = new ShaderMaterial({
                vertexShader: serviceListVert,
                fragmentShader: thumbnailFrag,
                uniforms: UniformsLib.mergeUniforms(c, {
                    uInstanceId: {
                        value: i
                    },
                    uTextureA: {
                        value: null
                    },
                    uTextureB: {
                        value: null
                    },
                    uTextureAlpha: {
                        value: 1
                    },
                    uCanvasAspect: {
                        value: 1
                    },
                    uVideoAspect: {
                        value: 16 / 9
                    }
                }),
                defines: {
                    IS_THUMBNAIL: ""
                },
                transparent: !0,
                depthTest: !1
            });
        u && (m.defines.IS_STELLLA = ""), super(p, m), this._instanceId = i, this._texturePaths = o, this._isStelllaLogo = u, this._textureLoader = new TextureLoader, this._animator = new Animator, this._clickHandler = this.handleUserInteraction.bind(this), document.addEventListener("pointerdown", this._clickHandler, {
            once: !0
        }), this.material instanceof ShaderMaterial && (this.material.uniforms.uMixWeight = this._animator.add({
            name: "mixWeight",
            initValue: 0
        })), this._texturePaths.length > 0 && this.loadTextures()
    }
    loadTextures() {
        this._texturePaths.forEach((i, o) => {
            this.isVideoPath(i) ? this.loadVideoTexture(i, o) : this.loadImageTexture(i, o)
        })
    }
    isVideoPath(i) {
        return [".mp4", ".webm", ".ogv", ".mov", ".avi"].some(c => i.toLowerCase().endsWith(c))
    }
    loadImageTexture(i, o) {
        this._textureLoader.load(i, c => {
            c.colorSpace = SRGBColorSpace, this._textures.push(c), this.setTextureToSlot(c, o)
        })
    }
    loadVideoTexture(i, o) {
        const c = document.createElement("video");
        c.src = i, c.crossOrigin = "anonymous", c.loop = !0, c.muted = !0, c.autoplay = !0, c.playsInline = !0, c.addEventListener("canplaythrough", () => {
            const u = new VideoTexture(c);
            if (u.colorSpace = SRGBColorSpace, u.wrapS = ClampToEdgeWrapping, u.wrapT = ClampToEdgeWrapping, u.minFilter = LinearFilter, u.magFilter = LinearFilter, this._textures.push(u), this._videoElements.push(c), this.setTextureToSlot(u, o), this.material instanceof ShaderMaterial) {
                const p = c.videoWidth / c.videoHeight;
                this.material.uniforms.uVideoAspect.value = p
            }
            c.play().catch(p => {
                console.warn("Video autoplay failed, waiting for user interaction:", p), this._pendingVideos.includes(c) || this._pendingVideos.push(c)
            })
        })
    }
    setTextureToSlot(i, o) {
        this.material instanceof ShaderMaterial && (o === 0 ? this.material.uniforms.uTextureA.value = i : o === 1 && (this.material.uniforms.uTextureB.value = i))
    }
    update(i) {
        this._animator.update(i), !(this._textures.length <= 1) && (this._fadeTransition || (this._switchTimer += i, this._switchTimer >= this._switchInterval && this.startFadeTransition()))
    }
    startFadeTransition() {
        this._textures.length <= 1 || !(this.material instanceof ShaderMaterial) || (this._switchTimer = 0, this._fadeTransition = !0, this._nextTextureIndex = (this._currentTextureIndex + 1) % this._textures.length, this.material.uniforms.uTextureA.value = this._textures[this._currentTextureIndex], this.material.uniforms.uTextureB.value = this._textures[this._nextTextureIndex], this._animator.animate("mixWeight", 1, .5).then(() => {
            this._currentTextureIndex = this._nextTextureIndex, this._animator.setValue("mixWeight", 0), this.material instanceof ShaderMaterial && (this.material.uniforms.uTextureA.value = this._textures[this._currentTextureIndex]), this._fadeTransition = !1
        }))
    }
    handleUserInteraction() {
        this._pendingVideos.forEach(i => {
            i.play().catch(console.error)
        }), this._pendingVideos = []
    }
    resize(i) {
        this.material instanceof ShaderMaterial && (this.material.uniforms.uCanvasAspect.value = i)
    }
    get instanceId() {
        return this._instanceId
    }
    get isStellla() {
        return this._isStelllaLogo
    }
    get firstTexture() {
        return this._textures.length > 0 ? this._textures[0] : null
    }
    dispose() {
        document.removeEventListener("click", this._clickHandler), this._videoElements.forEach(i => {
            i.pause(), i.removeAttribute("src"), i.load()
        }), this._videoElements = [], this._pendingVideos = [], this._textures.forEach(i => {
            i.dispose()
        }), this._textures = [], this.material instanceof ShaderMaterial && this.material.dispose(), this.geometry && this.geometry.dispose()
    }
}
const NUM_THUMBNAILS = 3;
class ServiceList extends Mesh {
    _commonUniforms;
    _cross;
    _thumbnails;
    _title;
    _serviceInTrigger;
    _serviceProgressTrigger;
    _stellaInTrigger;
    _stellaTrigger;
    constructor(i) {
        const o = new Vector2(15, 10).multiplyScalar(5),
            c = 5,
            u = UniformsLib.mergeUniforms(i, {
                uServiceIn: {
                    value: 0
                },
                uGrid: {
                    value: o
                },
                uScale: {
                    value: new Vector3$1(1, 1, 1)
                },
                uThumbnailScroll: {
                    value: 0
                },
                uStelllaIn: {
                    value: 0
                },
                uStelllaView: {
                    value: 0
                }
            }),
            p = new PlaneGeometry(1, 1, 64, 64),
            m = new ShaderMaterial({
                name: "ServiceListMaterial",
                uniforms: u,
                vertexShader: serviceListVert,
                fragmentShader: gridFrag,
                transparent: !0,
                defines: {
                    IS_GRID: ""
                },
                depthWrite: !1,
                depthTest: !1
            });
        super(p, m), this.renderOrder = -999, this._commonUniforms = u, this._serviceInTrigger = null, this._serviceProgressTrigger = null, this._stellaTrigger = null, this._stellaInTrigger = null;
        const g = [],
            _ = new Vector2(o.x / c, o.y / c);
        for (let P = 0; P <= _.y; P++)
            for (let w = 0; w <= _.x; w++) g.push(w / _.x, P / _.y);
        const v = new PlaneGeometry(1, 1, 8, 8),
            x = new InstancedBufferGeometry;
        x.setAttribute("position", v.getAttribute("position")), x.setAttribute("uv", v.getAttribute("uv")), x.setAttribute("instanceId", new InstancedBufferAttribute(new Float32Array(g), 2)), x.setIndex(v.getIndex());
        const y = new ShaderMaterial({
            name: "ServiceListCrossMaterial",
            uniforms: UniformsLib.mergeUniforms(this._commonUniforms, {
                uGridCross: {
                    value: _
                }
            }),
            transparent: !0,
            fragmentShader: crossFrag,
            vertexShader: serviceListVert,
            defines: {
                IS_CROSS: ""
            },
            depthWrite: !1,
            depthTest: !1
        });
        this._cross = new Mesh(x, y), this._cross.renderOrder = -999, this.add(this._cross), this._thumbnails = [];
        const b = "/top/service/",
            S = [
                [`${b}uefn.mp4`],
                [`${b}ue.mp4`],
                [`${b}stellla.mp4`]
            ];
        for (let P = 0; P < NUM_THUMBNAILS; P++) {
            const w = new ServiceThumbnail(P, S[P], this._commonUniforms, P == NUM_THUMBNAILS - 1);
            this.add(w), this._thumbnails.push(w)
        }
        const C = new PlaneGeometry(1, 1, 64, 1),
            E = new ShaderMaterial({
                uniforms: UniformsLib.mergeUniforms(this._commonUniforms, {
                    uServiceTitleTex: {
                        value: null
                    },
                    uPrevTexture: {
                        value: null
                    },
                    uNextTexture: {
                        value: null
                    },
                    uTextureBlend: {
                        value: 0
                    },
                    uHasPrevTexture: {
                        value: 0
                    },
                    uHasNextTexture: {
                        value: 0
                    }
                }),
                vertexShader: serviceListVert,
                fragmentShader: serviceTitleFrag,
                depthWrite: !1,
                defines: {
                    IS_TITLE: ""
                }
            });
        this._title = new Mesh(C, E), this._title.renderOrder = -999, this.add(this._title), textureLoader.load("/top/service-title.png", P => {
            E.uniforms.uServiceTitleTex.value = P, P.magFilter = NearestFilter, P.minFilter = NearestFilter
        }), this.waitForThumbnailTextures(E)
    }
    update(i) {
        if (!this._serviceInTrigger || !this._serviceProgressTrigger || !this._stellaInTrigger || !this._stellaTrigger) return;
        this._commonUniforms.uServiceIn.value = lerper.set("serviceList_serviceIn", this._serviceInTrigger.progress, .3), this.visible = this._commonUniforms.uServiceIn.value > .01;
        let o = (lerper.set("serviceList_thumbnailScroll", this._serviceProgressTrigger.progress, 1) * 7 + 1) / 2;
        o < 1 && (o -= (1 - (lerper.get("service_renderer") ? .current || 0)) * .4);
        const c = Math.round(o);
        let u = lerper.set("serviceList_current_index", c - (c - o) * .4, .5);
        debugController.enabled && (u = o), this._commonUniforms.uThumbnailScroll.value = Math.min(NUM_THUMBNAILS, u), this._commonUniforms.uStelllaIn.value = lerper.set("serviceList_stellaIn", this._stellaInTrigger.progress, .7), this._commonUniforms.uStelllaView.value = lerper.set("serviceList_stellaView", Math.max(0, Math.min(1, this._commonUniforms.uThumbnailScroll.value - 2.5)), .7) + this._commonUniforms.uStelllaIn.value * .5, this.updateTextureBlending(), this._thumbnails.forEach(p => {
            p.update(i.deltaTime)
        })
    }
    resize(i) {
        let o = 1;
        if (i instanceof PerspectiveCamera) {
            const c = Math.abs(i.position.z),
                u = MathUtils.degToRad(i.fov),
                p = 2 * c * Math.tan(u / 2),
                m = p * i.aspect;
            o = window.innerWidth / window.innerHeight, m < p ? this._commonUniforms.uScale.value.set(p, p, 1) : this._commonUniforms.uScale.value.set(m, m, 1)
        } else if (i instanceof OrthographicCamera) {
            const c = i.right - i.left,
                u = i.top - i.bottom;
            o = c / u, c < u ? this._commonUniforms.uScale.value.set(u, u, 1) : this._commonUniforms.uScale.value.set(c, c, 1)
        }
        this._thumbnails.forEach(c => {
            c.resize(o)
        })
    } in () {
        this._serviceInTrigger = topScrollManager.getTrigger("service_in"), this._serviceProgressTrigger = topScrollManager.getTrigger("service_progress"), this._stellaTrigger = topScrollManager.getTrigger("stellla"), this._stellaInTrigger = topScrollManager.getTrigger("stellla_in")
    }
    waitForThumbnailTextures(i) {
        const o = setInterval(() => {
            let c = !0;
            this._thumbnails.forEach((u, p) => {
                const m = u.firstTexture;
                if (m) {
                    const g = `uServiceTexture${p}`;
                    i.uniforms[g] && i.uniforms[g].value === null && (i.uniforms[g].value = m)
                } else c = !1
            }), c && clearInterval(o)
        }, 100)
    }
    updateTextureBlending() {
        const i = this._title.material,
            o = this._commonUniforms.uThumbnailScroll.value,
            c = this.getServiceTextures(),
            u = Math.max(0, Math.min(NUM_THUMBNAILS, o)),
            p = this.calculateBlendInfo(u, c);
        this.updateShaderUniforms(i, p)
    }
    getServiceTextures() {
        return [this._thumbnails[0] ? .firstTexture ? ? null, this._thumbnails[1] ? .firstTexture ? ? null, this._thumbnails[2] ? .firstTexture ? ? null]
    }
    calculateBlendInfo(i, o) {
        return i === 0 ? {
            prevTexture: null,
            nextTexture: o[0],
            blendFactor: 0
        } : i <= 1 ? {
            prevTexture: null,
            nextTexture: o[0],
            blendFactor: i
        } : i <= 2 ? {
            prevTexture: o[0],
            nextTexture: o[1],
            blendFactor: i - 1
        } : {
            prevTexture: o[1],
            nextTexture: o[2],
            blendFactor: i - 2
        }
    }
    updateShaderUniforms(i, o) {
        const {
            uniforms: c
        } = i;
        c.uPrevTexture.value = o.prevTexture, c.uNextTexture.value = o.nextTexture, c.uTextureBlend.value = o.blendFactor, c.uHasPrevTexture.value = o.prevTexture ? 1 : 0, c.uHasNextTexture.value = o.nextTexture ? 1 : 0
    }
}
class TopPageServiceScene extends BaseScene {
    _commonUniforms;
    _serviceList;
    constructor(i) {
        super(), this._commonUniforms = i, this._serviceList = new ServiceList(this._commonUniforms), this.add(this._serviceList), this.camera.position.set(0, 0, 10), this.camera.fov = 50, this.camera.updateProjectionMatrix()
    }
    get serviceList() {
        return this._serviceList
    }
    update(i) {
        super.update(i), this._serviceList.update(i)
    }
    resize(i) {
        super.resize(i), this._serviceList.resize(this.camera)
    }
}

function toTrianglesDrawMode(l, i) {
    if (i === TrianglesDrawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), l;
    if (i === TriangleFanDrawMode || i === TriangleStripDrawMode) {
        let o = l.getIndex();
        if (o === null) {
            const m = [],
                g = l.getAttribute("position");
            if (g !== void 0) {
                for (let _ = 0; _ < g.count; _++) m.push(_);
                l.setIndex(m), o = l.getIndex()
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), l
        }
        const c = o.count - 2,
            u = [];
        if (i === TriangleFanDrawMode)
            for (let m = 1; m <= c; m++) u.push(o.getX(0)), u.push(o.getX(m)), u.push(o.getX(m + 1));
        else
            for (let m = 0; m < c; m++) m % 2 === 0 ? (u.push(o.getX(m)), u.push(o.getX(m + 1)), u.push(o.getX(m + 2))) : (u.push(o.getX(m + 2)), u.push(o.getX(m + 1)), u.push(o.getX(m)));
        u.length / 3 !== c && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const p = l.clone();
        return p.setIndex(u), p.clearGroups(), p
    } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", i), l
}
class GLTFLoader extends Loader {
    constructor(i) {
        super(i), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(o) {
            return new GLTFMaterialsClearcoatExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsDispersionExtension(o)
        }), this.register(function(o) {
            return new GLTFTextureBasisUExtension(o)
        }), this.register(function(o) {
            return new GLTFTextureWebPExtension(o)
        }), this.register(function(o) {
            return new GLTFTextureAVIFExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsSheenExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsTransmissionExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsVolumeExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsIorExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsEmissiveStrengthExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsSpecularExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsIridescenceExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsAnisotropyExtension(o)
        }), this.register(function(o) {
            return new GLTFMaterialsBumpExtension(o)
        }), this.register(function(o) {
            return new GLTFLightsExtension(o)
        }), this.register(function(o) {
            return new GLTFMeshoptCompression(o)
        }), this.register(function(o) {
            return new GLTFMeshGpuInstancing(o)
        })
    }
    load(i, o, c, u) {
        const p = this;
        let m;
        if (this.resourcePath !== "") m = this.resourcePath;
        else if (this.path !== "") {
            const v = LoaderUtils.extractUrlBase(i);
            m = LoaderUtils.resolveURL(v, this.path)
        } else m = LoaderUtils.extractUrlBase(i);
        this.manager.itemStart(i);
        const g = function(v) {
                u ? u(v) : console.error(v), p.manager.itemError(i), p.manager.itemEnd(i)
            },
            _ = new FileLoader(this.manager);
        _.setPath(this.path), _.setResponseType("arraybuffer"), _.setRequestHeader(this.requestHeader), _.setWithCredentials(this.withCredentials), _.load(i, function(v) {
            try {
                p.parse(v, m, function(x) {
                    o(x), p.manager.itemEnd(i)
                }, g)
            } catch (x) {
                g(x)
            }
        }, c, g)
    }
    setDRACOLoader(i) {
        return this.dracoLoader = i, this
    }
    setKTX2Loader(i) {
        return this.ktx2Loader = i, this
    }
    setMeshoptDecoder(i) {
        return this.meshoptDecoder = i, this
    }
    register(i) {
        return this.pluginCallbacks.indexOf(i) === -1 && this.pluginCallbacks.push(i), this
    }
    unregister(i) {
        return this.pluginCallbacks.indexOf(i) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(i), 1), this
    }
    parse(i, o, c, u) {
        let p;
        const m = {},
            g = {},
            _ = new TextDecoder;
        if (typeof i == "string") p = JSON.parse(i);
        else if (i instanceof ArrayBuffer)
            if (_.decode(new Uint8Array(i, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) {
                try {
                    m[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(i)
                } catch (y) {
                    u && u(y);
                    return
                }
                p = JSON.parse(m[EXTENSIONS.KHR_BINARY_GLTF].content)
            } else p = JSON.parse(_.decode(i));
        else p = i;
        if (p.asset === void 0 || p.asset.version[0] < 2) {
            u && u(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const v = new GLTFParser(p, {
            path: o || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        v.fileLoader.setRequestHeader(this.requestHeader);
        for (let x = 0; x < this.pluginCallbacks.length; x++) {
            const y = this.pluginCallbacks[x](v);
            y.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), g[y.name] = y, m[y.name] = !0
        }
        if (p.extensionsUsed)
            for (let x = 0; x < p.extensionsUsed.length; ++x) {
                const y = p.extensionsUsed[x],
                    b = p.extensionsRequired || [];
                switch (y) {
                    case EXTENSIONS.KHR_MATERIALS_UNLIT:
                        m[y] = new GLTFMaterialsUnlitExtension;
                        break;
                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                        m[y] = new GLTFDracoMeshCompressionExtension(p, this.dracoLoader);
                        break;
                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                        m[y] = new GLTFTextureTransformExtension;
                        break;
                    case EXTENSIONS.KHR_MESH_QUANTIZATION:
                        m[y] = new GLTFMeshQuantizationExtension;
                        break;
                    default:
                        b.indexOf(y) >= 0 && g[y] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + y + '".')
                }
            }
        v.setExtensions(m), v.setPlugins(g), v.parse(c, u)
    }
    parseAsync(i, o) {
        const c = this;
        return new Promise(function(u, p) {
            c.parse(i, o, u, p)
        })
    }
}

function GLTFRegistry() {
    let l = {};
    return {
        get: function(i) {
            return l[i]
        },
        add: function(i, o) {
            l[i] = o
        },
        remove: function(i) {
            delete l[i]
        },
        removeAll: function() {
            l = {}
        }
    }
}
const EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class GLTFLightsExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const i = this.parser,
            o = this.parser.json.nodes || [];
        for (let c = 0, u = o.length; c < u; c++) {
            const p = o[c];
            p.extensions && p.extensions[this.name] && p.extensions[this.name].light !== void 0 && i._addNodeRef(this.cache, p.extensions[this.name].light)
        }
    }
    _loadLight(i) {
        const o = this.parser,
            c = "light:" + i;
        let u = o.cache.get(c);
        if (u) return u;
        const p = o.json,
            _ = ((p.extensions && p.extensions[this.name] || {}).lights || [])[i];
        let v;
        const x = new Color(16777215);
        _.color !== void 0 && x.setRGB(_.color[0], _.color[1], _.color[2], LinearSRGBColorSpace);
        const y = _.range !== void 0 ? _.range : 0;
        switch (_.type) {
            case "directional":
                v = new DirectionalLight(x), v.target.position.set(0, 0, -1), v.add(v.target);
                break;
            case "point":
                v = new PointLight(x), v.distance = y;
                break;
            case "spot":
                v = new SpotLight(x), v.distance = y, _.spot = _.spot || {}, _.spot.innerConeAngle = _.spot.innerConeAngle !== void 0 ? _.spot.innerConeAngle : 0, _.spot.outerConeAngle = _.spot.outerConeAngle !== void 0 ? _.spot.outerConeAngle : Math.PI / 4, v.angle = _.spot.outerConeAngle, v.penumbra = 1 - _.spot.innerConeAngle / _.spot.outerConeAngle, v.target.position.set(0, 0, -1), v.add(v.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + _.type)
        }
        return v.position.set(0, 0, 0), assignExtrasToUserData(v, _), _.intensity !== void 0 && (v.intensity = _.intensity), v.name = o.createUniqueName(_.name || "light_" + i), u = Promise.resolve(v), o.cache.add(c, u), u
    }
    getDependency(i, o) {
        if (i === "light") return this._loadLight(o)
    }
    createNodeAttachment(i) {
        const o = this,
            c = this.parser,
            p = c.json.nodes[i],
            g = (p.extensions && p.extensions[this.name] || {}).light;
        return g === void 0 ? null : this._loadLight(g).then(function(_) {
            return c._getNodeRef(o.cache, g, _)
        })
    }
}
class GLTFMaterialsUnlitExtension {
    constructor() {
        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return MeshBasicMaterial
    }
    extendParams(i, o, c) {
        const u = [];
        i.color = new Color(1, 1, 1), i.opacity = 1;
        const p = o.pbrMetallicRoughness;
        if (p) {
            if (Array.isArray(p.baseColorFactor)) {
                const m = p.baseColorFactor;
                i.color.setRGB(m[0], m[1], m[2], LinearSRGBColorSpace), i.opacity = m[3]
            }
            p.baseColorTexture !== void 0 && u.push(c.assignTexture(i, "map", p.baseColorTexture, SRGBColorSpace))
        }
        return Promise.all(u)
    }
}
class GLTFMaterialsEmissiveStrengthExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(i, o) {
        const u = this.parser.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = u.extensions[this.name].emissiveStrength;
        return p !== void 0 && (o.emissiveIntensity = p), Promise.resolve()
    }
}
class GLTFMaterialsClearcoatExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const c = this.parser,
            u = c.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = [],
            m = u.extensions[this.name];
        if (m.clearcoatFactor !== void 0 && (o.clearcoat = m.clearcoatFactor), m.clearcoatTexture !== void 0 && p.push(c.assignTexture(o, "clearcoatMap", m.clearcoatTexture)), m.clearcoatRoughnessFactor !== void 0 && (o.clearcoatRoughness = m.clearcoatRoughnessFactor), m.clearcoatRoughnessTexture !== void 0 && p.push(c.assignTexture(o, "clearcoatRoughnessMap", m.clearcoatRoughnessTexture)), m.clearcoatNormalTexture !== void 0 && (p.push(c.assignTexture(o, "clearcoatNormalMap", m.clearcoatNormalTexture)), m.clearcoatNormalTexture.scale !== void 0)) {
            const g = m.clearcoatNormalTexture.scale;
            o.clearcoatNormalScale = new Vector2(g, g)
        }
        return Promise.all(p)
    }
}
class GLTFMaterialsDispersionExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const u = this.parser.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = u.extensions[this.name];
        return o.dispersion = p.dispersion !== void 0 ? p.dispersion : 0, Promise.resolve()
    }
}
class GLTFMaterialsIridescenceExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const c = this.parser,
            u = c.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = [],
            m = u.extensions[this.name];
        return m.iridescenceFactor !== void 0 && (o.iridescence = m.iridescenceFactor), m.iridescenceTexture !== void 0 && p.push(c.assignTexture(o, "iridescenceMap", m.iridescenceTexture)), m.iridescenceIor !== void 0 && (o.iridescenceIOR = m.iridescenceIor), o.iridescenceThicknessRange === void 0 && (o.iridescenceThicknessRange = [100, 400]), m.iridescenceThicknessMinimum !== void 0 && (o.iridescenceThicknessRange[0] = m.iridescenceThicknessMinimum), m.iridescenceThicknessMaximum !== void 0 && (o.iridescenceThicknessRange[1] = m.iridescenceThicknessMaximum), m.iridescenceThicknessTexture !== void 0 && p.push(c.assignTexture(o, "iridescenceThicknessMap", m.iridescenceThicknessTexture)), Promise.all(p)
    }
}
class GLTFMaterialsSheenExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_SHEEN
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const c = this.parser,
            u = c.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = [];
        o.sheenColor = new Color(0, 0, 0), o.sheenRoughness = 0, o.sheen = 1;
        const m = u.extensions[this.name];
        if (m.sheenColorFactor !== void 0) {
            const g = m.sheenColorFactor;
            o.sheenColor.setRGB(g[0], g[1], g[2], LinearSRGBColorSpace)
        }
        return m.sheenRoughnessFactor !== void 0 && (o.sheenRoughness = m.sheenRoughnessFactor), m.sheenColorTexture !== void 0 && p.push(c.assignTexture(o, "sheenColorMap", m.sheenColorTexture, SRGBColorSpace)), m.sheenRoughnessTexture !== void 0 && p.push(c.assignTexture(o, "sheenRoughnessMap", m.sheenRoughnessTexture)), Promise.all(p)
    }
}
class GLTFMaterialsTransmissionExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const c = this.parser,
            u = c.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = [],
            m = u.extensions[this.name];
        return m.transmissionFactor !== void 0 && (o.transmission = m.transmissionFactor), m.transmissionTexture !== void 0 && p.push(c.assignTexture(o, "transmissionMap", m.transmissionTexture)), Promise.all(p)
    }
}
class GLTFMaterialsVolumeExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_VOLUME
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const c = this.parser,
            u = c.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = [],
            m = u.extensions[this.name];
        o.thickness = m.thicknessFactor !== void 0 ? m.thicknessFactor : 0, m.thicknessTexture !== void 0 && p.push(c.assignTexture(o, "thicknessMap", m.thicknessTexture)), o.attenuationDistance = m.attenuationDistance || 1 / 0;
        const g = m.attenuationColor || [1, 1, 1];
        return o.attenuationColor = new Color().setRGB(g[0], g[1], g[2], LinearSRGBColorSpace), Promise.all(p)
    }
}
class GLTFMaterialsIorExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_IOR
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const u = this.parser.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = u.extensions[this.name];
        return o.ior = p.ior !== void 0 ? p.ior : 1.5, Promise.resolve()
    }
}
class GLTFMaterialsSpecularExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const c = this.parser,
            u = c.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = [],
            m = u.extensions[this.name];
        o.specularIntensity = m.specularFactor !== void 0 ? m.specularFactor : 1, m.specularTexture !== void 0 && p.push(c.assignTexture(o, "specularIntensityMap", m.specularTexture));
        const g = m.specularColorFactor || [1, 1, 1];
        return o.specularColor = new Color().setRGB(g[0], g[1], g[2], LinearSRGBColorSpace), m.specularColorTexture !== void 0 && p.push(c.assignTexture(o, "specularColorMap", m.specularColorTexture, SRGBColorSpace)), Promise.all(p)
    }
}
class GLTFMaterialsBumpExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.EXT_MATERIALS_BUMP
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const c = this.parser,
            u = c.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = [],
            m = u.extensions[this.name];
        return o.bumpScale = m.bumpFactor !== void 0 ? m.bumpFactor : 1, m.bumpTexture !== void 0 && p.push(c.assignTexture(o, "bumpMap", m.bumpTexture)), Promise.all(p)
    }
}
class GLTFMaterialsAnisotropyExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(i) {
        const c = this.parser.json.materials[i];
        return !c.extensions || !c.extensions[this.name] ? null : MeshPhysicalMaterial
    }
    extendMaterialParams(i, o) {
        const c = this.parser,
            u = c.json.materials[i];
        if (!u.extensions || !u.extensions[this.name]) return Promise.resolve();
        const p = [],
            m = u.extensions[this.name];
        return m.anisotropyStrength !== void 0 && (o.anisotropy = m.anisotropyStrength), m.anisotropyRotation !== void 0 && (o.anisotropyRotation = m.anisotropyRotation), m.anisotropyTexture !== void 0 && p.push(c.assignTexture(o, "anisotropyMap", m.anisotropyTexture)), Promise.all(p)
    }
}
class GLTFTextureBasisUExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.KHR_TEXTURE_BASISU
    }
    loadTexture(i) {
        const o = this.parser,
            c = o.json,
            u = c.textures[i];
        if (!u.extensions || !u.extensions[this.name]) return null;
        const p = u.extensions[this.name],
            m = o.options.ktx2Loader;
        if (!m) {
            if (c.extensionsRequired && c.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return o.loadTextureImage(i, p.source, m)
    }
}
class GLTFTextureWebPExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.EXT_TEXTURE_WEBP
    }
    loadTexture(i) {
        const o = this.name,
            c = this.parser,
            u = c.json,
            p = u.textures[i];
        if (!p.extensions || !p.extensions[o]) return null;
        const m = p.extensions[o],
            g = u.images[m.source];
        let _ = c.textureLoader;
        if (g.uri) {
            const v = c.options.manager.getHandler(g.uri);
            v !== null && (_ = v)
        }
        return c.loadTextureImage(i, m.source, _)
    }
}
class GLTFTextureAVIFExtension {
    constructor(i) {
        this.parser = i, this.name = EXTENSIONS.EXT_TEXTURE_AVIF
    }
    loadTexture(i) {
        const o = this.name,
            c = this.parser,
            u = c.json,
            p = u.textures[i];
        if (!p.extensions || !p.extensions[o]) return null;
        const m = p.extensions[o],
            g = u.images[m.source];
        let _ = c.textureLoader;
        if (g.uri) {
            const v = c.options.manager.getHandler(g.uri);
            v !== null && (_ = v)
        }
        return c.loadTextureImage(i, m.source, _)
    }
}
class GLTFMeshoptCompression {
    constructor(i) {
        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION, this.parser = i
    }
    loadBufferView(i) {
        const o = this.parser.json,
            c = o.bufferViews[i];
        if (c.extensions && c.extensions[this.name]) {
            const u = c.extensions[this.name],
                p = this.parser.getDependency("buffer", u.buffer),
                m = this.parser.options.meshoptDecoder;
            if (!m || !m.supported) {
                if (o.extensionsRequired && o.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return p.then(function(g) {
                const _ = u.byteOffset || 0,
                    v = u.byteLength || 0,
                    x = u.count,
                    y = u.byteStride,
                    b = new Uint8Array(g, _, v);
                return m.decodeGltfBufferAsync ? m.decodeGltfBufferAsync(x, y, b, u.mode, u.filter).then(function(S) {
                    return S.buffer
                }) : m.ready.then(function() {
                    const S = new ArrayBuffer(x * y);
                    return m.decodeGltfBuffer(new Uint8Array(S), x, y, b, u.mode, u.filter), S
                })
            })
        } else return null
    }
}
class GLTFMeshGpuInstancing {
    constructor(i) {
        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING, this.parser = i
    }
    createNodeMesh(i) {
        const o = this.parser.json,
            c = o.nodes[i];
        if (!c.extensions || !c.extensions[this.name] || c.mesh === void 0) return null;
        const u = o.meshes[c.mesh];
        for (const v of u.primitives)
            if (v.mode !== WEBGL_CONSTANTS.TRIANGLES && v.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && v.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && v.mode !== void 0) return null;
        const m = c.extensions[this.name].attributes,
            g = [],
            _ = {};
        for (const v in m) g.push(this.parser.getDependency("accessor", m[v]).then(x => (_[v] = x, _[v])));
        return g.length < 1 ? null : (g.push(this.parser.createNodeMesh(i)), Promise.all(g).then(v => {
            const x = v.pop(),
                y = x.isGroup ? x.children : [x],
                b = v[0].count,
                S = [];
            for (const C of y) {
                const E = new Matrix4,
                    P = new Vector3$1,
                    w = new Quaternion$1,
                    T = new Vector3$1(1, 1, 1),
                    M = new InstancedMesh(C.geometry, C.material, b);
                for (let A = 0; A < b; A++) _.TRANSLATION && P.fromBufferAttribute(_.TRANSLATION, A), _.ROTATION && w.fromBufferAttribute(_.ROTATION, A), _.SCALE && T.fromBufferAttribute(_.SCALE, A), M.setMatrixAt(A, E.compose(P, w, T));
                for (const A in _)
                    if (A === "_COLOR_0") {
                        const D = _[A];
                        M.instanceColor = new InstancedBufferAttribute(D.array, D.itemSize, D.normalized)
                    } else A !== "TRANSLATION" && A !== "ROTATION" && A !== "SCALE" && C.geometry.setAttribute(A, _[A]);
                Object3D.prototype.copy.call(M, C), this.parser.assignFinalMaterial(M), S.push(M)
            }
            return x.isGroup ? (x.clear(), x.add(...S), x) : S[0]
        }))
    }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF",
    BINARY_EXTENSION_HEADER_LENGTH = 12,
    BINARY_EXTENSION_CHUNK_TYPES = {
        JSON: 1313821514,
        BIN: 5130562
    };
class GLTFBinaryExtension {
    constructor(i) {
        this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const o = new DataView(i, 0, BINARY_EXTENSION_HEADER_LENGTH),
            c = new TextDecoder;
        if (this.header = {
                magic: c.decode(new Uint8Array(i.slice(0, 4))),
                version: o.getUint32(4, !0),
                length: o.getUint32(8, !0)
            }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const u = this.header.length - BINARY_EXTENSION_HEADER_LENGTH,
            p = new DataView(i, BINARY_EXTENSION_HEADER_LENGTH);
        let m = 0;
        for (; m < u;) {
            const g = p.getUint32(m, !0);
            m += 4;
            const _ = p.getUint32(m, !0);
            if (m += 4, _ === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
                const v = new Uint8Array(i, BINARY_EXTENSION_HEADER_LENGTH + m, g);
                this.content = c.decode(v)
            } else if (_ === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
                const v = BINARY_EXTENSION_HEADER_LENGTH + m;
                this.body = i.slice(v, v + g)
            }
            m += g
        }
        if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class GLTFDracoMeshCompressionExtension {
    constructor(i, o) {
        if (!o) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION, this.json = i, this.dracoLoader = o, this.dracoLoader.preload()
    }
    decodePrimitive(i, o) {
        const c = this.json,
            u = this.dracoLoader,
            p = i.extensions[this.name].bufferView,
            m = i.extensions[this.name].attributes,
            g = {},
            _ = {},
            v = {};
        for (const x in m) {
            const y = ATTRIBUTES[x] || x.toLowerCase();
            g[y] = m[x]
        }
        for (const x in i.attributes) {
            const y = ATTRIBUTES[x] || x.toLowerCase();
            if (m[x] !== void 0) {
                const b = c.accessors[i.attributes[x]],
                    S = WEBGL_COMPONENT_TYPES[b.componentType];
                v[y] = S.name, _[y] = b.normalized === !0
            }
        }
        return o.getDependency("bufferView", p).then(function(x) {
            return new Promise(function(y, b) {
                u.decodeDracoFile(x, function(S) {
                    for (const C in S.attributes) {
                        const E = S.attributes[C],
                            P = _[C];
                        P !== void 0 && (E.normalized = P)
                    }
                    y(S)
                }, g, v, LinearSRGBColorSpace, b)
            })
        })
    }
}
class GLTFTextureTransformExtension {
    constructor() {
        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(i, o) {
        return (o.texCoord === void 0 || o.texCoord === i.channel) && o.offset === void 0 && o.rotation === void 0 && o.scale === void 0 || (i = i.clone(), o.texCoord !== void 0 && (i.channel = o.texCoord), o.offset !== void 0 && i.offset.fromArray(o.offset), o.rotation !== void 0 && (i.rotation = o.rotation), o.scale !== void 0 && i.repeat.fromArray(o.scale), i.needsUpdate = !0), i
    }
}
class GLTFMeshQuantizationExtension {
    constructor() {
        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION
    }
}
class GLTFCubicSplineInterpolant extends Interpolant {
    constructor(i, o, c, u) {
        super(i, o, c, u)
    }
    copySampleValue_(i) {
        const o = this.resultBuffer,
            c = this.sampleValues,
            u = this.valueSize,
            p = i * u * 3 + u;
        for (let m = 0; m !== u; m++) o[m] = c[p + m];
        return o
    }
    interpolate_(i, o, c, u) {
        const p = this.resultBuffer,
            m = this.sampleValues,
            g = this.valueSize,
            _ = g * 2,
            v = g * 3,
            x = u - o,
            y = (c - o) / x,
            b = y * y,
            S = b * y,
            C = i * v,
            E = C - v,
            P = -2 * S + 3 * b,
            w = S - b,
            T = 1 - P,
            M = w - b + y;
        for (let A = 0; A !== g; A++) {
            const D = m[E + A + g],
                R = m[E + A + _] * x,
                I = m[C + A + g],
                k = m[C + A] * x;
            p[A] = T * D + M * R + P * I + w * k
        }
        return p
    }
}
const _quaternion = new Quaternion$1;
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
    interpolate_(i, o, c, u) {
        const p = super.interpolate_(i, o, c, u);
        return _quaternion.fromArray(p).normalize().toArray(p), p
    }
}
const WEBGL_CONSTANTS = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
    },
    WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    },
    WEBGL_FILTERS = {
        9728: NearestFilter,
        9729: LinearFilter,
        9984: NearestMipmapNearestFilter,
        9985: LinearMipmapNearestFilter,
        9986: NearestMipmapLinearFilter,
        9987: LinearMipmapLinearFilter
    },
    WEBGL_WRAPPINGS = {
        33071: ClampToEdgeWrapping,
        33648: MirroredRepeatWrapping,
        10497: RepeatWrapping
    },
    WEBGL_TYPE_SIZES = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    },
    ATTRIBUTES = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    },
    PATH_PROPERTIES = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    },
    INTERPOLATION = {
        CUBICSPLINE: void 0,
        LINEAR: InterpolateLinear,
        STEP: InterpolateDiscrete
    },
    ALPHA_MODES = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };

function createDefaultMaterial(l) {
    return l.DefaultMaterial === void 0 && (l.DefaultMaterial = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: FrontSide
    })), l.DefaultMaterial
}

function addUnknownExtensionsToUserData(l, i, o) {
    for (const c in o.extensions) l[c] === void 0 && (i.userData.gltfExtensions = i.userData.gltfExtensions || {}, i.userData.gltfExtensions[c] = o.extensions[c])
}

function assignExtrasToUserData(l, i) {
    i.extras !== void 0 && (typeof i.extras == "object" ? Object.assign(l.userData, i.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + i.extras))
}

function addMorphTargets(l, i, o) {
    let c = !1,
        u = !1,
        p = !1;
    for (let v = 0, x = i.length; v < x; v++) {
        const y = i[v];
        if (y.POSITION !== void 0 && (c = !0), y.NORMAL !== void 0 && (u = !0), y.COLOR_0 !== void 0 && (p = !0), c && u && p) break
    }
    if (!c && !u && !p) return Promise.resolve(l);
    const m = [],
        g = [],
        _ = [];
    for (let v = 0, x = i.length; v < x; v++) {
        const y = i[v];
        if (c) {
            const b = y.POSITION !== void 0 ? o.getDependency("accessor", y.POSITION) : l.attributes.position;
            m.push(b)
        }
        if (u) {
            const b = y.NORMAL !== void 0 ? o.getDependency("accessor", y.NORMAL) : l.attributes.normal;
            g.push(b)
        }
        if (p) {
            const b = y.COLOR_0 !== void 0 ? o.getDependency("accessor", y.COLOR_0) : l.attributes.color;
            _.push(b)
        }
    }
    return Promise.all([Promise.all(m), Promise.all(g), Promise.all(_)]).then(function(v) {
        const x = v[0],
            y = v[1],
            b = v[2];
        return c && (l.morphAttributes.position = x), u && (l.morphAttributes.normal = y), p && (l.morphAttributes.color = b), l.morphTargetsRelative = !0, l
    })
}

function updateMorphTargets(l, i) {
    if (l.updateMorphTargets(), i.weights !== void 0)
        for (let o = 0, c = i.weights.length; o < c; o++) l.morphTargetInfluences[o] = i.weights[o];
    if (i.extras && Array.isArray(i.extras.targetNames)) {
        const o = i.extras.targetNames;
        if (l.morphTargetInfluences.length === o.length) {
            l.morphTargetDictionary = {};
            for (let c = 0, u = o.length; c < u; c++) l.morphTargetDictionary[o[c]] = c
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}

function createPrimitiveKey(l) {
    let i;
    const o = l.extensions && l.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    if (o ? i = "draco:" + o.bufferView + ":" + o.indices + ":" + createAttributesKey(o.attributes) : i = l.indices + ":" + createAttributesKey(l.attributes) + ":" + l.mode, l.targets !== void 0)
        for (let c = 0, u = l.targets.length; c < u; c++) i += ":" + createAttributesKey(l.targets[c]);
    return i
}

function createAttributesKey(l) {
    let i = "";
    const o = Object.keys(l).sort();
    for (let c = 0, u = o.length; c < u; c++) i += o[c] + ":" + l[o[c]] + ";";
    return i
}

function getNormalizedComponentScale(l) {
    switch (l) {
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}

function getImageURIMimeType(l) {
    return l.search(/\.jpe?g($|\?)/i) > 0 || l.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : l.search(/\.webp($|\?)/i) > 0 || l.search(/^data\:image\/webp/) === 0 ? "image/webp" : l.search(/\.ktx2($|\?)/i) > 0 || l.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png"
}
const _identityMatrix = new Matrix4;
class GLTFParser {
    constructor(i = {}, o = {}) {
        this.json = i, this.extensions = {}, this.plugins = {}, this.options = o, this.cache = new GLTFRegistry, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
            refs: {},
            uses: {}
        }, this.cameraCache = {
            refs: {},
            uses: {}
        }, this.lightCache = {
            refs: {},
            uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
        let c = !1,
            u = -1,
            p = !1,
            m = -1;
        if (typeof navigator < "u") {
            const g = navigator.userAgent;
            c = /^((?!chrome|android).)*safari/i.test(g) === !0;
            const _ = g.match(/Version\/(\d+)/);
            u = c && _ ? parseInt(_[1], 10) : -1, p = g.indexOf("Firefox") > -1, m = p ? g.match(/Firefox\/([0-9]+)\./)[1] : -1
        }
        typeof createImageBitmap > "u" || c && u < 17 || p && m < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(i) {
        this.extensions = i
    }
    setPlugins(i) {
        this.plugins = i
    }
    parse(i, o) {
        const c = this,
            u = this.json,
            p = this.extensions;
        this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(m) {
            return m._markDefs && m._markDefs()
        }), Promise.all(this._invokeAll(function(m) {
            return m.beforeRoot && m.beforeRoot()
        })).then(function() {
            return Promise.all([c.getDependencies("scene"), c.getDependencies("animation"), c.getDependencies("camera")])
        }).then(function(m) {
            const g = {
                scene: m[0][u.scene || 0],
                scenes: m[0],
                animations: m[1],
                cameras: m[2],
                asset: u.asset,
                parser: c,
                userData: {}
            };
            return addUnknownExtensionsToUserData(p, g, u), assignExtrasToUserData(g, u), Promise.all(c._invokeAll(function(_) {
                return _.afterRoot && _.afterRoot(g)
            })).then(function() {
                for (const _ of g.scenes) _.updateMatrixWorld();
                i(g)
            })
        }).catch(o)
    }
    _markDefs() {
        const i = this.json.nodes || [],
            o = this.json.skins || [],
            c = this.json.meshes || [];
        for (let u = 0, p = o.length; u < p; u++) {
            const m = o[u].joints;
            for (let g = 0, _ = m.length; g < _; g++) i[m[g]].isBone = !0
        }
        for (let u = 0, p = i.length; u < p; u++) {
            const m = i[u];
            m.mesh !== void 0 && (this._addNodeRef(this.meshCache, m.mesh), m.skin !== void 0 && (c[m.mesh].isSkinnedMesh = !0)), m.camera !== void 0 && this._addNodeRef(this.cameraCache, m.camera)
        }
    }
    _addNodeRef(i, o) {
        o !== void 0 && (i.refs[o] === void 0 && (i.refs[o] = i.uses[o] = 0), i.refs[o]++)
    }
    _getNodeRef(i, o, c) {
        if (i.refs[o] <= 1) return c;
        const u = c.clone(),
            p = (m, g) => {
                const _ = this.associations.get(m);
                _ != null && this.associations.set(g, _);
                for (const [v, x] of m.children.entries()) p(x, g.children[v])
            };
        return p(c, u), u.name += "_instance_" + i.uses[o]++, u
    }
    _invokeOne(i) {
        const o = Object.values(this.plugins);
        o.push(this);
        for (let c = 0; c < o.length; c++) {
            const u = i(o[c]);
            if (u) return u
        }
        return null
    }
    _invokeAll(i) {
        const o = Object.values(this.plugins);
        o.unshift(this);
        const c = [];
        for (let u = 0; u < o.length; u++) {
            const p = i(o[u]);
            p && c.push(p)
        }
        return c
    }
    getDependency(i, o) {
        const c = i + ":" + o;
        let u = this.cache.get(c);
        if (!u) {
            switch (i) {
                case "scene":
                    u = this.loadScene(o);
                    break;
                case "node":
                    u = this._invokeOne(function(p) {
                        return p.loadNode && p.loadNode(o)
                    });
                    break;
                case "mesh":
                    u = this._invokeOne(function(p) {
                        return p.loadMesh && p.loadMesh(o)
                    });
                    break;
                case "accessor":
                    u = this.loadAccessor(o);
                    break;
                case "bufferView":
                    u = this._invokeOne(function(p) {
                        return p.loadBufferView && p.loadBufferView(o)
                    });
                    break;
                case "buffer":
                    u = this.loadBuffer(o);
                    break;
                case "material":
                    u = this._invokeOne(function(p) {
                        return p.loadMaterial && p.loadMaterial(o)
                    });
                    break;
                case "texture":
                    u = this._invokeOne(function(p) {
                        return p.loadTexture && p.loadTexture(o)
                    });
                    break;
                case "skin":
                    u = this.loadSkin(o);
                    break;
                case "animation":
                    u = this._invokeOne(function(p) {
                        return p.loadAnimation && p.loadAnimation(o)
                    });
                    break;
                case "camera":
                    u = this.loadCamera(o);
                    break;
                default:
                    if (u = this._invokeOne(function(p) {
                            return p != this && p.getDependency && p.getDependency(i, o)
                        }), !u) throw new Error("Unknown type: " + i);
                    break
            }
            this.cache.add(c, u)
        }
        return u
    }
    getDependencies(i) {
        let o = this.cache.get(i);
        if (!o) {
            const c = this,
                u = this.json[i + (i === "mesh" ? "es" : "s")] || [];
            o = Promise.all(u.map(function(p, m) {
                return c.getDependency(i, m)
            })), this.cache.add(i, o)
        }
        return o
    }
    loadBuffer(i) {
        const o = this.json.buffers[i],
            c = this.fileLoader;
        if (o.type && o.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + o.type + " buffer type is not supported.");
        if (o.uri === void 0 && i === 0) return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
        const u = this.options;
        return new Promise(function(p, m) {
            c.load(LoaderUtils.resolveURL(o.uri, u.path), p, void 0, function() {
                m(new Error('THREE.GLTFLoader: Failed to load buffer "' + o.uri + '".'))
            })
        })
    }
    loadBufferView(i) {
        const o = this.json.bufferViews[i];
        return this.getDependency("buffer", o.buffer).then(function(c) {
            const u = o.byteLength || 0,
                p = o.byteOffset || 0;
            return c.slice(p, p + u)
        })
    }
    loadAccessor(i) {
        const o = this,
            c = this.json,
            u = this.json.accessors[i];
        if (u.bufferView === void 0 && u.sparse === void 0) {
            const m = WEBGL_TYPE_SIZES[u.type],
                g = WEBGL_COMPONENT_TYPES[u.componentType],
                _ = u.normalized === !0,
                v = new g(u.count * m);
            return Promise.resolve(new BufferAttribute(v, m, _))
        }
        const p = [];
        return u.bufferView !== void 0 ? p.push(this.getDependency("bufferView", u.bufferView)) : p.push(null), u.sparse !== void 0 && (p.push(this.getDependency("bufferView", u.sparse.indices.bufferView)), p.push(this.getDependency("bufferView", u.sparse.values.bufferView))), Promise.all(p).then(function(m) {
            const g = m[0],
                _ = WEBGL_TYPE_SIZES[u.type],
                v = WEBGL_COMPONENT_TYPES[u.componentType],
                x = v.BYTES_PER_ELEMENT,
                y = x * _,
                b = u.byteOffset || 0,
                S = u.bufferView !== void 0 ? c.bufferViews[u.bufferView].byteStride : void 0,
                C = u.normalized === !0;
            let E, P;
            if (S && S !== y) {
                const w = Math.floor(b / S),
                    T = "InterleavedBuffer:" + u.bufferView + ":" + u.componentType + ":" + w + ":" + u.count;
                let M = o.cache.get(T);
                M || (E = new v(g, w * S, u.count * S / x), M = new InterleavedBuffer(E, S / x), o.cache.add(T, M)), P = new InterleavedBufferAttribute(M, _, b % S / x, C)
            } else g === null ? E = new v(u.count * _) : E = new v(g, b, u.count * _), P = new BufferAttribute(E, _, C);
            if (u.sparse !== void 0) {
                const w = WEBGL_TYPE_SIZES.SCALAR,
                    T = WEBGL_COMPONENT_TYPES[u.sparse.indices.componentType],
                    M = u.sparse.indices.byteOffset || 0,
                    A = u.sparse.values.byteOffset || 0,
                    D = new T(m[1], M, u.sparse.count * w),
                    R = new v(m[2], A, u.sparse.count * _);
                g !== null && (P = new BufferAttribute(P.array.slice(), P.itemSize, P.normalized)), P.normalized = !1;
                for (let I = 0, k = D.length; I < k; I++) {
                    const F = D[I];
                    if (P.setX(F, R[I * _]), _ >= 2 && P.setY(F, R[I * _ + 1]), _ >= 3 && P.setZ(F, R[I * _ + 2]), _ >= 4 && P.setW(F, R[I * _ + 3]), _ >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
                P.normalized = C
            }
            return P
        })
    }
    loadTexture(i) {
        const o = this.json,
            c = this.options,
            p = o.textures[i].source,
            m = o.images[p];
        let g = this.textureLoader;
        if (m.uri) {
            const _ = c.manager.getHandler(m.uri);
            _ !== null && (g = _)
        }
        return this.loadTextureImage(i, p, g)
    }
    loadTextureImage(i, o, c) {
        const u = this,
            p = this.json,
            m = p.textures[i],
            g = p.images[o],
            _ = (g.uri || g.bufferView) + ":" + m.sampler;
        if (this.textureCache[_]) return this.textureCache[_];
        const v = this.loadImageSource(o, c).then(function(x) {
            x.flipY = !1, x.name = m.name || g.name || "", x.name === "" && typeof g.uri == "string" && g.uri.startsWith("data:image/") === !1 && (x.name = g.uri);
            const b = (p.samplers || {})[m.sampler] || {};
            return x.magFilter = WEBGL_FILTERS[b.magFilter] || LinearFilter, x.minFilter = WEBGL_FILTERS[b.minFilter] || LinearMipmapLinearFilter, x.wrapS = WEBGL_WRAPPINGS[b.wrapS] || RepeatWrapping, x.wrapT = WEBGL_WRAPPINGS[b.wrapT] || RepeatWrapping, x.generateMipmaps = !x.isCompressedTexture && x.minFilter !== NearestFilter && x.minFilter !== LinearFilter, u.associations.set(x, {
                textures: i
            }), x
        }).catch(function() {
            return null
        });
        return this.textureCache[_] = v, v
    }
    loadImageSource(i, o) {
        const c = this,
            u = this.json,
            p = this.options;
        if (this.sourceCache[i] !== void 0) return this.sourceCache[i].then(y => y.clone());
        const m = u.images[i],
            g = self.URL || self.webkitURL;
        let _ = m.uri || "",
            v = !1;
        if (m.bufferView !== void 0) _ = c.getDependency("bufferView", m.bufferView).then(function(y) {
            v = !0;
            const b = new Blob([y], {
                type: m.mimeType
            });
            return _ = g.createObjectURL(b), _
        });
        else if (m.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + i + " is missing URI and bufferView");
        const x = Promise.resolve(_).then(function(y) {
            return new Promise(function(b, S) {
                let C = b;
                o.isImageBitmapLoader === !0 && (C = function(E) {
                    const P = new Texture(E);
                    P.needsUpdate = !0, b(P)
                }), o.load(LoaderUtils.resolveURL(y, p.path), C, void 0, S)
            })
        }).then(function(y) {
            return v === !0 && g.revokeObjectURL(_), assignExtrasToUserData(y, m), y.userData.mimeType = m.mimeType || getImageURIMimeType(m.uri), y
        }).catch(function(y) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", _), y
        });
        return this.sourceCache[i] = x, x
    }
    assignTexture(i, o, c, u) {
        const p = this;
        return this.getDependency("texture", c.index).then(function(m) {
            if (!m) return null;
            if (c.texCoord !== void 0 && c.texCoord > 0 && (m = m.clone(), m.channel = c.texCoord), p.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
                const g = c.extensions !== void 0 ? c.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
                if (g) {
                    const _ = p.associations.get(m);
                    m = p.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(m, g), p.associations.set(m, _)
                }
            }
            return u !== void 0 && (m.colorSpace = u), i[o] = m, m
        })
    }
    assignFinalMaterial(i) {
        const o = i.geometry;
        let c = i.material;
        const u = o.attributes.tangent === void 0,
            p = o.attributes.color !== void 0,
            m = o.attributes.normal === void 0;
        if (i.isPoints) {
            const g = "PointsMaterial:" + c.uuid;
            let _ = this.cache.get(g);
            _ || (_ = new PointsMaterial, Material.prototype.copy.call(_, c), _.color.copy(c.color), _.map = c.map, _.sizeAttenuation = !1, this.cache.add(g, _)), c = _
        } else if (i.isLine) {
            const g = "LineBasicMaterial:" + c.uuid;
            let _ = this.cache.get(g);
            _ || (_ = new LineBasicMaterial, Material.prototype.copy.call(_, c), _.color.copy(c.color), _.map = c.map, this.cache.add(g, _)), c = _
        }
        if (u || p || m) {
            let g = "ClonedMaterial:" + c.uuid + ":";
            u && (g += "derivative-tangents:"), p && (g += "vertex-colors:"), m && (g += "flat-shading:");
            let _ = this.cache.get(g);
            _ || (_ = c.clone(), p && (_.vertexColors = !0), m && (_.flatShading = !0), u && (_.normalScale && (_.normalScale.y *= -1), _.clearcoatNormalScale && (_.clearcoatNormalScale.y *= -1)), this.cache.add(g, _), this.associations.set(_, this.associations.get(c))), c = _
        }
        i.material = c
    }
    getMaterialType() {
        return MeshStandardMaterial
    }
    loadMaterial(i) {
        const o = this,
            c = this.json,
            u = this.extensions,
            p = c.materials[i];
        let m;
        const g = {},
            _ = p.extensions || {},
            v = [];
        if (_[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
            const y = u[EXTENSIONS.KHR_MATERIALS_UNLIT];
            m = y.getMaterialType(), v.push(y.extendParams(g, p, o))
        } else {
            const y = p.pbrMetallicRoughness || {};
            if (g.color = new Color(1, 1, 1), g.opacity = 1, Array.isArray(y.baseColorFactor)) {
                const b = y.baseColorFactor;
                g.color.setRGB(b[0], b[1], b[2], LinearSRGBColorSpace), g.opacity = b[3]
            }
            y.baseColorTexture !== void 0 && v.push(o.assignTexture(g, "map", y.baseColorTexture, SRGBColorSpace)), g.metalness = y.metallicFactor !== void 0 ? y.metallicFactor : 1, g.roughness = y.roughnessFactor !== void 0 ? y.roughnessFactor : 1, y.metallicRoughnessTexture !== void 0 && (v.push(o.assignTexture(g, "metalnessMap", y.metallicRoughnessTexture)), v.push(o.assignTexture(g, "roughnessMap", y.metallicRoughnessTexture))), m = this._invokeOne(function(b) {
                return b.getMaterialType && b.getMaterialType(i)
            }), v.push(Promise.all(this._invokeAll(function(b) {
                return b.extendMaterialParams && b.extendMaterialParams(i, g)
            })))
        }
        p.doubleSided === !0 && (g.side = DoubleSide);
        const x = p.alphaMode || ALPHA_MODES.OPAQUE;
        if (x === ALPHA_MODES.BLEND ? (g.transparent = !0, g.depthWrite = !1) : (g.transparent = !1, x === ALPHA_MODES.MASK && (g.alphaTest = p.alphaCutoff !== void 0 ? p.alphaCutoff : .5)), p.normalTexture !== void 0 && m !== MeshBasicMaterial && (v.push(o.assignTexture(g, "normalMap", p.normalTexture)), g.normalScale = new Vector2(1, 1), p.normalTexture.scale !== void 0)) {
            const y = p.normalTexture.scale;
            g.normalScale.set(y, y)
        }
        if (p.occlusionTexture !== void 0 && m !== MeshBasicMaterial && (v.push(o.assignTexture(g, "aoMap", p.occlusionTexture)), p.occlusionTexture.strength !== void 0 && (g.aoMapIntensity = p.occlusionTexture.strength)), p.emissiveFactor !== void 0 && m !== MeshBasicMaterial) {
            const y = p.emissiveFactor;
            g.emissive = new Color().setRGB(y[0], y[1], y[2], LinearSRGBColorSpace)
        }
        return p.emissiveTexture !== void 0 && m !== MeshBasicMaterial && v.push(o.assignTexture(g, "emissiveMap", p.emissiveTexture, SRGBColorSpace)), Promise.all(v).then(function() {
            const y = new m(g);
            return p.name && (y.name = p.name), assignExtrasToUserData(y, p), o.associations.set(y, {
                materials: i
            }), p.extensions && addUnknownExtensionsToUserData(u, y, p), y
        })
    }
    createUniqueName(i) {
        const o = PropertyBinding.sanitizeNodeName(i || "");
        return o in this.nodeNamesUsed ? o + "_" + ++this.nodeNamesUsed[o] : (this.nodeNamesUsed[o] = 0, o)
    }
    loadGeometries(i) {
        const o = this,
            c = this.extensions,
            u = this.primitiveCache;

        function p(g) {
            return c[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(g, o).then(function(_) {
                return addPrimitiveAttributes(_, g, o)
            })
        }
        const m = [];
        for (let g = 0, _ = i.length; g < _; g++) {
            const v = i[g],
                x = createPrimitiveKey(v),
                y = u[x];
            if (y) m.push(y.promise);
            else {
                let b;
                v.extensions && v.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? b = p(v) : b = addPrimitiveAttributes(new BufferGeometry, v, o), u[x] = {
                    primitive: v,
                    promise: b
                }, m.push(b)
            }
        }
        return Promise.all(m)
    }
    loadMesh(i) {
        const o = this,
            c = this.json,
            u = this.extensions,
            p = c.meshes[i],
            m = p.primitives,
            g = [];
        for (let _ = 0, v = m.length; _ < v; _++) {
            const x = m[_].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", m[_].material);
            g.push(x)
        }
        return g.push(o.loadGeometries(m)), Promise.all(g).then(function(_) {
            const v = _.slice(0, _.length - 1),
                x = _[_.length - 1],
                y = [];
            for (let S = 0, C = x.length; S < C; S++) {
                const E = x[S],
                    P = m[S];
                let w;
                const T = v[S];
                if (P.mode === WEBGL_CONSTANTS.TRIANGLES || P.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || P.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || P.mode === void 0) w = p.isSkinnedMesh === !0 ? new SkinnedMesh(E, T) : new Mesh(E, T), w.isSkinnedMesh === !0 && w.normalizeSkinWeights(), P.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? w.geometry = toTrianglesDrawMode(w.geometry, TriangleStripDrawMode) : P.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (w.geometry = toTrianglesDrawMode(w.geometry, TriangleFanDrawMode));
                else if (P.mode === WEBGL_CONSTANTS.LINES) w = new LineSegments(E, T);
                else if (P.mode === WEBGL_CONSTANTS.LINE_STRIP) w = new Line(E, T);
                else if (P.mode === WEBGL_CONSTANTS.LINE_LOOP) w = new LineLoop(E, T);
                else if (P.mode === WEBGL_CONSTANTS.POINTS) w = new Points(E, T);
                else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + P.mode);
                Object.keys(w.geometry.morphAttributes).length > 0 && updateMorphTargets(w, p), w.name = o.createUniqueName(p.name || "mesh_" + i), assignExtrasToUserData(w, p), P.extensions && addUnknownExtensionsToUserData(u, w, P), o.assignFinalMaterial(w), y.push(w)
            }
            for (let S = 0, C = y.length; S < C; S++) o.associations.set(y[S], {
                meshes: i,
                primitives: S
            });
            if (y.length === 1) return p.extensions && addUnknownExtensionsToUserData(u, y[0], p), y[0];
            const b = new Group;
            p.extensions && addUnknownExtensionsToUserData(u, b, p), o.associations.set(b, {
                meshes: i
            });
            for (let S = 0, C = y.length; S < C; S++) b.add(y[S]);
            return b
        })
    }
    loadCamera(i) {
        let o;
        const c = this.json.cameras[i],
            u = c[c.type];
        if (!u) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return c.type === "perspective" ? o = new PerspectiveCamera(MathUtils.radToDeg(u.yfov), u.aspectRatio || 1, u.znear || 1, u.zfar || 2e6) : c.type === "orthographic" && (o = new OrthographicCamera(-u.xmag, u.xmag, u.ymag, -u.ymag, u.znear, u.zfar)), c.name && (o.name = this.createUniqueName(c.name)), assignExtrasToUserData(o, c), Promise.resolve(o)
    }
    loadSkin(i) {
        const o = this.json.skins[i],
            c = [];
        for (let u = 0, p = o.joints.length; u < p; u++) c.push(this._loadNodeShallow(o.joints[u]));
        return o.inverseBindMatrices !== void 0 ? c.push(this.getDependency("accessor", o.inverseBindMatrices)) : c.push(null), Promise.all(c).then(function(u) {
            const p = u.pop(),
                m = u,
                g = [],
                _ = [];
            for (let v = 0, x = m.length; v < x; v++) {
                const y = m[v];
                if (y) {
                    g.push(y);
                    const b = new Matrix4;
                    p !== null && b.fromArray(p.array, v * 16), _.push(b)
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', o.joints[v])
            }
            return new Skeleton(g, _)
        })
    }
    loadAnimation(i) {
        const o = this.json,
            c = this,
            u = o.animations[i],
            p = u.name ? u.name : "animation_" + i,
            m = [],
            g = [],
            _ = [],
            v = [],
            x = [];
        for (let y = 0, b = u.channels.length; y < b; y++) {
            const S = u.channels[y],
                C = u.samplers[S.sampler],
                E = S.target,
                P = E.node,
                w = u.parameters !== void 0 ? u.parameters[C.input] : C.input,
                T = u.parameters !== void 0 ? u.parameters[C.output] : C.output;
            E.node !== void 0 && (m.push(this.getDependency("node", P)), g.push(this.getDependency("accessor", w)), _.push(this.getDependency("accessor", T)), v.push(C), x.push(E))
        }
        return Promise.all([Promise.all(m), Promise.all(g), Promise.all(_), Promise.all(v), Promise.all(x)]).then(function(y) {
            const b = y[0],
                S = y[1],
                C = y[2],
                E = y[3],
                P = y[4],
                w = [];
            for (let T = 0, M = b.length; T < M; T++) {
                const A = b[T],
                    D = S[T],
                    R = C[T],
                    I = E[T],
                    k = P[T];
                if (A === void 0) continue;
                A.updateMatrix && A.updateMatrix();
                const F = c._createAnimationTracks(A, D, R, I, k);
                if (F)
                    for (let V = 0; V < F.length; V++) w.push(F[V])
            }
            return new AnimationClip(p, void 0, w)
        })
    }
    createNodeMesh(i) {
        const o = this.json,
            c = this,
            u = o.nodes[i];
        return u.mesh === void 0 ? null : c.getDependency("mesh", u.mesh).then(function(p) {
            const m = c._getNodeRef(c.meshCache, u.mesh, p);
            return u.weights !== void 0 && m.traverse(function(g) {
                if (g.isMesh)
                    for (let _ = 0, v = u.weights.length; _ < v; _++) g.morphTargetInfluences[_] = u.weights[_]
            }), m
        })
    }
    loadNode(i) {
        const o = this.json,
            c = this,
            u = o.nodes[i],
            p = c._loadNodeShallow(i),
            m = [],
            g = u.children || [];
        for (let v = 0, x = g.length; v < x; v++) m.push(c.getDependency("node", g[v]));
        const _ = u.skin === void 0 ? Promise.resolve(null) : c.getDependency("skin", u.skin);
        return Promise.all([p, Promise.all(m), _]).then(function(v) {
            const x = v[0],
                y = v[1],
                b = v[2];
            b !== null && x.traverse(function(S) {
                S.isSkinnedMesh && S.bind(b, _identityMatrix)
            });
            for (let S = 0, C = y.length; S < C; S++) x.add(y[S]);
            return x
        })
    }
    _loadNodeShallow(i) {
        const o = this.json,
            c = this.extensions,
            u = this;
        if (this.nodeCache[i] !== void 0) return this.nodeCache[i];
        const p = o.nodes[i],
            m = p.name ? u.createUniqueName(p.name) : "",
            g = [],
            _ = u._invokeOne(function(v) {
                return v.createNodeMesh && v.createNodeMesh(i)
            });
        return _ && g.push(_), p.camera !== void 0 && g.push(u.getDependency("camera", p.camera).then(function(v) {
            return u._getNodeRef(u.cameraCache, p.camera, v)
        })), u._invokeAll(function(v) {
            return v.createNodeAttachment && v.createNodeAttachment(i)
        }).forEach(function(v) {
            g.push(v)
        }), this.nodeCache[i] = Promise.all(g).then(function(v) {
            let x;
            if (p.isBone === !0 ? x = new Bone : v.length > 1 ? x = new Group : v.length === 1 ? x = v[0] : x = new Object3D, x !== v[0])
                for (let y = 0, b = v.length; y < b; y++) x.add(v[y]);
            if (p.name && (x.userData.name = p.name, x.name = m), assignExtrasToUserData(x, p), p.extensions && addUnknownExtensionsToUserData(c, x, p), p.matrix !== void 0) {
                const y = new Matrix4;
                y.fromArray(p.matrix), x.applyMatrix4(y)
            } else p.translation !== void 0 && x.position.fromArray(p.translation), p.rotation !== void 0 && x.quaternion.fromArray(p.rotation), p.scale !== void 0 && x.scale.fromArray(p.scale);
            if (!u.associations.has(x)) u.associations.set(x, {});
            else if (p.mesh !== void 0 && u.meshCache.refs[p.mesh] > 1) {
                const y = u.associations.get(x);
                u.associations.set(x, { ...y
                })
            }
            return u.associations.get(x).nodes = i, x
        }), this.nodeCache[i]
    }
    loadScene(i) {
        const o = this.extensions,
            c = this.json.scenes[i],
            u = this,
            p = new Group;
        c.name && (p.name = u.createUniqueName(c.name)), assignExtrasToUserData(p, c), c.extensions && addUnknownExtensionsToUserData(o, p, c);
        const m = c.nodes || [],
            g = [];
        for (let _ = 0, v = m.length; _ < v; _++) g.push(u.getDependency("node", m[_]));
        return Promise.all(g).then(function(_) {
            for (let x = 0, y = _.length; x < y; x++) p.add(_[x]);
            const v = x => {
                const y = new Map;
                for (const [b, S] of u.associations)(b instanceof Material || b instanceof Texture) && y.set(b, S);
                return x.traverse(b => {
                    const S = u.associations.get(b);
                    S != null && y.set(b, S)
                }), y
            };
            return u.associations = v(p), p
        })
    }
    _createAnimationTracks(i, o, c, u, p) {
        const m = [],
            g = i.name ? i.name : i.uuid,
            _ = [];
        PATH_PROPERTIES[p.path] === PATH_PROPERTIES.weights ? i.traverse(function(b) {
            b.morphTargetInfluences && _.push(b.name ? b.name : b.uuid)
        }) : _.push(g);
        let v;
        switch (PATH_PROPERTIES[p.path]) {
            case PATH_PROPERTIES.weights:
                v = NumberKeyframeTrack;
                break;
            case PATH_PROPERTIES.rotation:
                v = QuaternionKeyframeTrack;
                break;
            case PATH_PROPERTIES.translation:
            case PATH_PROPERTIES.scale:
                v = VectorKeyframeTrack;
                break;
            default:
                switch (c.itemSize) {
                    case 1:
                        v = NumberKeyframeTrack;
                        break;
                    case 2:
                    case 3:
                    default:
                        v = VectorKeyframeTrack;
                        break
                }
                break
        }
        const x = u.interpolation !== void 0 ? INTERPOLATION[u.interpolation] : InterpolateLinear,
            y = this._getArrayFromAccessor(c);
        for (let b = 0, S = _.length; b < S; b++) {
            const C = new v(_[b] + "." + PATH_PROPERTIES[p.path], o.array, y, x);
            u.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(C), m.push(C)
        }
        return m
    }
    _getArrayFromAccessor(i) {
        let o = i.array;
        if (i.normalized) {
            const c = getNormalizedComponentScale(o.constructor),
                u = new Float32Array(o.length);
            for (let p = 0, m = o.length; p < m; p++) u[p] = o[p] * c;
            o = u
        }
        return o
    }
    _createCubicSplineTrackInterpolant(i) {
        i.createInterpolant = function(c) {
            const u = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
            return new u(this.times, this.values, this.getValueSize() / 3, c)
        }, i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}

function computeBounds(l, i, o) {
    const c = i.attributes,
        u = new Box3;
    if (c.POSITION !== void 0) {
        const g = o.json.accessors[c.POSITION],
            _ = g.min,
            v = g.max;
        if (_ !== void 0 && v !== void 0) {
            if (u.set(new Vector3$1(_[0], _[1], _[2]), new Vector3$1(v[0], v[1], v[2])), g.normalized) {
                const x = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[g.componentType]);
                u.min.multiplyScalar(x), u.max.multiplyScalar(x)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else return;
    const p = i.targets;
    if (p !== void 0) {
        const g = new Vector3$1,
            _ = new Vector3$1;
        for (let v = 0, x = p.length; v < x; v++) {
            const y = p[v];
            if (y.POSITION !== void 0) {
                const b = o.json.accessors[y.POSITION],
                    S = b.min,
                    C = b.max;
                if (S !== void 0 && C !== void 0) {
                    if (_.setX(Math.max(Math.abs(S[0]), Math.abs(C[0]))), _.setY(Math.max(Math.abs(S[1]), Math.abs(C[1]))), _.setZ(Math.max(Math.abs(S[2]), Math.abs(C[2]))), b.normalized) {
                        const E = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[b.componentType]);
                        _.multiplyScalar(E)
                    }
                    g.max(_)
                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        u.expandByVector(g)
    }
    l.boundingBox = u;
    const m = new Sphere;
    u.getCenter(m.center), m.radius = u.min.distanceTo(u.max) / 2, l.boundingSphere = m
}

function addPrimitiveAttributes(l, i, o) {
    const c = i.attributes,
        u = [];

    function p(m, g) {
        return o.getDependency("accessor", m).then(function(_) {
            l.setAttribute(g, _)
        })
    }
    for (const m in c) {
        const g = ATTRIBUTES[m] || m.toLowerCase();
        g in l.attributes || u.push(p(c[m], g))
    }
    if (i.indices !== void 0 && !l.index) {
        const m = o.getDependency("accessor", i.indices).then(function(g) {
            l.setIndex(g)
        });
        u.push(m)
    }
    return ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in c && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`), assignExtrasToUserData(l, i), computeBounds(l, i, o), Promise.all(u).then(function() {
        return i.targets !== void 0 ? addMorphTargets(l, i.targets, o) : l
    })
}
class TopPageMissionVisionScene extends BaseScene {
    _grid;
    _commonUniforms;
    _oCamera;
    constructor(i) {
        super(), this._commonUniforms = UniformsLib.mergeUniforms(i), this._camera.position.set(0, 0, 8), this._camera.fov = 60, this._camera.updateProjectionMatrix(), this.background = new Color("#D7DBDC"), this._grid = new Grid("dark", "flat", this._commonUniforms), this.add(this._grid), this._oCamera = new OrthographicCamera(-5, 5, 5, -5, .1, 1e3)
    }
    get oCamera() {
        return this._oCamera
    }
    update(i) {
        super.update(i);
        const o = lenis.scroll / window.innerHeight;
        this._grid.setScrollAmount(lerper.set("missionVisionScroll", o, .5))
    }
    resize(i) {
        super.resize(i), this._grid.resize(this.oCamera);
        let o = 4,
            c = o;
        i.aspectRatio < 1 ? c = o / i.aspectRatio : o = c * i.aspectRatio, this._oCamera.left = -o, this._oCamera.right = o, this._oCamera.top = c, this._oCamera.bottom = -c, this._oCamera.updateProjectionMatrix()
    }
}
const lerpMatrix = (l, i, o) => {
    const c = l.elements,
        u = i.elements,
        p = new Matrix4,
        m = p.elements;
    for (let g = 0; g < 16; g++) m[g] = c[g] * (1 - o) + u[g] * o;
    return p
};
class ShaderPrecompiler {
    _renderer;
    _dummyRenderTarget;
    _dummyCamera;
    _compiledMaterials;
    constructor(i) {
        this._renderer = i, this._compiledMaterials = new Set, this._dummyRenderTarget = new WebGLRenderTarget(1, 1, {
            format: RGBAFormat,
            type: UnsignedByteType,
            minFilter: NearestFilter,
            magFilter: NearestFilter,
            generateMipmaps: !1
        }), this._dummyCamera = new PerspectiveCamera(75, 1, .1, 1e3)
    }
    async precompileAllScenes(i, o = {}) {
        const {
            includeScenes: c,
            excludeScenes: u = [],
            includeInvisible: p = !1,
            verbose: m = !1,
            onProgress: g,
            onComplete: _
        } = o;
        let v = Array.from(i.keys());
        c && (v = v.filter(y => c.includes(y))), v = v.filter(y => !u.includes(y));
        const x = v.length;
        for (let y = 0; y < v.length; y++) {
            const b = v[y],
                S = i.get(b);
            if (g) {
                const C = {
                    current: y + 1,
                    total: x,
                    percentage: Math.round((y + 1) / x * 100),
                    sceneName: b
                };
                g(C)
            }
            try {
                await this._precompileScene(b, S, {
                    includeInvisible: p,
                    verbose: m
                })
            } catch {}
            await new Promise(C => requestAnimationFrame(C))
        }
        _ && _({
            totalMaterials: this._compiledMaterials.size,
            processedScenes: v
        })
    }
    async _precompileScene(i, o, c = {}) {
        const {
            includeInvisible: u = !1,
            verbose: p = !1
        } = c;
        if (!o || !o.traverse) return;
        const m = o.camera || this._dummyCamera,
            g = [];
        o.traverse(_ => {
            !u && !_.visible || (_ instanceof Mesh && _.material && g.push(_), _.isInstancedMesh && _.material && g.push(_))
        });
        for (const _ of g) this._precompileMeshMaterials(_, m, i, p);
        await this._performDummyRender(o, m, p)
    }
    _precompileMeshMaterials(i, o, c, u = !1) {
        (Array.isArray(i.material) ? i.material : [i.material]).forEach(m => {
            if (m instanceof ShaderMaterial) {
                if (this._compiledMaterials.has(m)) return;
                try {
                    this._renderer.compile(i, o), this._compiledMaterials.add(m)
                } catch {}
            }
        })
    }
    async _performDummyRender(i, o, c = !1) {
        const u = this._renderer.getRenderTarget();
        try {
            this._renderer.setRenderTarget(this._dummyRenderTarget);
            const p = i.background;
            i.background = null, this._renderer.render(i, o), i.background = p
        } catch {} finally {
            this._renderer.setRenderTarget(u)
        }
    }
    getCompiledMaterialsCount() {
        return this._compiledMaterials.size
    }
    isCompiledMaterial(i) {
        return this._compiledMaterials.has(i)
    }
    getStats() {
        return {
            totalCompiledMaterials: this._compiledMaterials.size,
            compiledMaterialIds: Array.from(this._compiledMaterials).map(i => i.id)
        }
    }
    dispose() {
        this._dummyRenderTarget && this._dummyRenderTarget.dispose(), this._compiledMaterials.clear()
    }
}
const renderer = new WebGLRenderer;
renderer.setPixelRatio(window.devicePixelRatio);
const rtMainScene = new WebGLRenderTarget(1, 1, {
        type: HalfFloatType
    }),
    rtMissionVisionScene = new WebGLRenderTarget(1, 1, {}),
    rtServiceScene = new WebGLRenderTarget(1, 1, {
        type: HalfFloatType
    }),
    rtThumbnailScene = new WebGLRenderTarget(1, 1, {}),
    rtSubpageScene = new WebGLRenderTarget(1, 1, {}),
    rtNotFoundScene = new WebGLRenderTarget(1, 1, {}),
    transparentRenderer1 = new TransparentBufferRenderer,
    transparentRenderer2 = new TransparentBufferRenderer,
    loadingManager = new LoadingManager,
    textureLoader = new TextureLoader(loadingManager),
    gltfLoader = new GLTFLoader(loadingManager),
    resources = new Resources,
    gltfPrm = new Promise(l => {
        gltfLoader.load("/common/scene.glb", i => {
            l(i)
        })
    });
class GL {
    _scene;
    _camera;
    _prevTime;
    _containerElm;
    _resolution;
    _renderPipeline;
    _commonUniforms;
    _isMobile;
    _animator;
    _fluids;
    _scenes;
    _topPageMainScene;
    _topPageMissionVisionScene;
    _topPageServiceScene;
    _thumbnailScene;
    _subPageScene;
    _notFoundScene;
    _worksOutroTrigger;
    _missionTrigger;
    _visionTrigger;
    _serviceTrigger;
    _pointerPos;
    _lastPointerEvent;
    _currentSceneSelector;
    _shaderPrecompiler;
    constructor() {
        const i = navigator.userAgent;
        this._isMobile = i.indexOf("iPhone") >= 0 || i.indexOf("iPad") >= 0 || i.indexOf("Android") >= 0 || navigator.platform == "iPad" || navigator.platform == "MacIntel" && navigator.userAgent.indexOf("Safari") != -1 && navigator.userAgent.indexOf("Chrome") == -1 && navigator.standalone !== void 0, this._containerElm = null, this._prevTime = new Date().getTime(), this._worksOutroTrigger = null, this._missionTrigger = null, this._serviceTrigger = null, this._visionTrigger = null, this._pointerPos = new Vector2, this._lastPointerEvent = null, this._currentSceneSelector = 0, this._animator = new Animator, this._animator.add({
            name: "subpageSceneSelector",
            initValue: 0
        }), this._animator.add({
            name: "notfoundVisibility",
            initValue: 0
        }), this._animator.add({
            name: "transition",
            initValue: 0
        }), this._animator.add({
            name: "loaded",
            initValue: 0,
            easing: Easings.easeOutCubic
        }), this._commonUniforms = {
            uScreenResolution: {
                value: new Vector2(1, 1)
            },
            uScreenResolutionInverse: {
                value: new Vector2(1, 1)
            },
            uScreenAspectRatio: {
                value: 1
            },
            uTime: {
                value: 0
            },
            uFluidsTex: {
                value: null
            },
            uTransition: this._animator.getVariableObject("transition"),
            uLoaded: this._animator.getVariableObject("loaded"),
            uSPWeight: {
                value: 0
            }
        }, initResources(renderer, this._commonUniforms), this._resolution = new Vector2(1, 1), this._renderPipeline = new RenderPipeline(renderer, this._commonUniforms), this._scene = new Scene, this._scene.background = new Color("#000"), this._camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1e3), this._fluids = new StableFluids(renderer, this._commonUniforms), this._commonUniforms.uFluidsTex.value = this._fluids.getTexture(), this._topPageMainScene = new TopPageMainScene(this._commonUniforms), this._topPageMissionVisionScene = new TopPageMissionVisionScene(this._commonUniforms), this._topPageServiceScene = new TopPageServiceScene(this._commonUniforms), this._thumbnailScene = new ThumbnailScene(this._commonUniforms), this._subPageScene = new SubPageScene(this._commonUniforms), this._notFoundScene = new NotFoundScene(this._commonUniforms), this._scenes = new Map, this._scenes.set("topPageMain", this._topPageMainScene), this._scenes.set("topPageMissionVision", this._topPageMissionVisionScene), this._scenes.set("topPageService", this._topPageServiceScene), this._scenes.set("thumbnail", this._thumbnailScene), this._scenes.set("subPage", this._subPageScene), this._scenes.set("notFound", this._notFoundScene), this._thumbnailScene.setRenderCamera(this._topPageMainScene.camera), this._topPageMissionVisionScene.add(this._topPageMainScene.mainLogo.logoMeshOutline);
        const o = c => {
            this._pointerPos.x = c.clientX / window.innerWidth * 2 - 1, this._pointerPos.y = -(c.clientY / window.innerHeight * 2 - 1), this._lastPointerEvent = c
        };
        window.addEventListener("pointermove", o), window.addEventListener("pointerdown", c => {
            const u = new Vector2(c.clientX / window.innerWidth * 2 - 1, -(c.clientY / window.innerHeight * 2 - 1));
            easyRaycaster.touchStart(u, this._topPageMainScene.camera)
        }), window.addEventListener("pointerup", c => {
            const u = new Vector2(c.clientX / window.innerWidth * 2 - 1, -(c.clientY / window.innerHeight * 2 - 1));
            easyRaycaster.touchEnd(u, this._topPageMainScene.camera)
        }), this._shaderPrecompiler = new ShaderPrecompiler(renderer), this.resize(), document.body.setAttribute("data-gl_loading_end", "false")
    }
    get canvas() {
        return renderer.domElement
    }
    get sceneThumbnail() {
        return this._thumbnailScene
    }
    get sceneSubPage() {
        return this._subPageScene
    }
    get sceneMain() {
        return this._topPageMainScene
    }
    get sceneService() {
        return this._topPageServiceScene
    }
    get sceneNotFound() {
        return this._notFoundScene
    }
    update() {
        const i = new Date().getTime(),
            o = Math.min((i - this._prevTime) / 1e3, 1 / 30);
        this._prevTime = i, this._commonUniforms.uTime.value += o, this._commonUniforms.uTime.value, this._camera, this.spWeight, this._animator.update(o);
        const c = lerper.set("pointerPosX", this._pointerPos.x, 1),
            u = lerper.set("pointerPosY", this._pointerPos.y, 1),
            p = lerper.set("pointerVelocityX", lerper.get("pointerPosX") ? .velocity || 0, 2),
            m = lerper.set("pointerVelocityY", -(lerper.get("pointerPosY") ? .velocity || 0), 2);
        this._isMobile || this._fluids.setPointer(new Vector2(c, u), new Vector2(p, m)), easyRaycaster.update(new Vector2(c, u), this._topPageMainScene.camera), this._lastPointerEvent && this._scenes.forEach(v => {
            v.hover(this._lastPointerEvent)
        }), this._isMobile || this._fluids.update(o);
        const g = resources.getTexture("noise");
        g && g.render();
        const _ = this._animator.get("notfoundVisibility") || 0;
        return this._notFoundScene.uniforms.uVisibility.value = _, this._scenes.forEach(v => {
            const x = {
                deltaTime: o,
                time: this._commonUniforms.uTime.value,
                camera: v.camera,
                spWeight: this.spWeight
            };
            v.update(x)
        }), this._topPageMainScene.camera.updateProjectionMatrix(), this._topPageMainScene.camera.projectionMatrix.copy(lerpMatrix(this._topPageMainScene.camera.projectionMatrix.clone(), this._topPageMissionVisionScene.oCamera.projectionMatrix.clone(), lerper.set("worksOutro_progress", this._worksOutroTrigger ? this._worksOutroTrigger.progress : 0, 1))), this._renderPipeline.render({
            top: {
                mainScene: this._topPageMainScene,
                missionVisionScene: this._topPageMissionVisionScene,
                serviceScene: this._topPageServiceScene,
                visibleMission: this._missionTrigger ? lerper.set("mission_progress", this._missionTrigger.progress, 1.5) : 0,
                visibleVision: this._visionTrigger ? lerper.set("vision_renderer", this._visionTrigger.progress) : 0,
                visibleService: this._serviceTrigger ? lerper.set("service_renderer", this._serviceTrigger.progress, .5) : 0
            },
            subpage: {
                subpageScene: this._subPageScene,
                subpageSceneCamera: this._subPageScene.camera,
                subpageSceneSelector: this._animator.get("subpageSceneSelector") || 0
            },
            thumbnail: {
                thumbnailScene: this._thumbnailScene,
                thumbnailSceneCamera: this._thumbnailScene.camera
            },
            notfound: {
                notfoundScene: this._notFoundScene,
                notfoundSceneCamera: this._notFoundScene.camera,
                notfoundVisibility: this._animator.get("notfoundVisibility") || 0
            },
            camera: this._camera
        }), o
    }
    spWeight = 0;
    resize() {
        this._containerElm && this._resolution.set(this._containerElm.clientWidth, this._containerElm.clientHeight);
        const i = this._resolution.x / this._resolution.y,
            o = 16 / 9,
            c = 9 / 16,
            u = Math.max(0, Math.min(1, (o - i) / (o - c)));
        this.spWeight = u;
        const p = {
            canvasSize: this._resolution,
            sceneResolution: this._resolution.clone().multiplyScalar(Math.min(1.5, renderer.getPixelRatio())),
            thumbnailResolution: this._resolution.clone().multiplyScalar(renderer.getPixelRatio() || 1),
            aspectRatio: i,
            camera: this._camera,
            spWeight: u
        };
        if (this._commonUniforms.uScreenAspectRatio.value = p.aspectRatio, this._commonUniforms.uScreenResolution.value.copy(p.sceneResolution), this._commonUniforms.uSPWeight.value = p.spWeight, renderer.setSize(p.sceneResolution.x, p.sceneResolution.y), this._renderPipeline.resize(p), transparentRenderer1.resize(p.sceneResolution), transparentRenderer2.resize(p.sceneResolution), !this._isMobile) {
            const m = new Vector2(256, 256);
            p.aspectRatio < 1 ? m.x = Math.floor(m.y * p.aspectRatio) : m.y = Math.floor(m.x / p.aspectRatio), this._fluids.resize(m)
        }
        this._scenes.forEach(m => {
            const g = {
                canvasSize: p.canvasSize,
                sceneResolution: p.sceneResolution,
                thumbnailResolution: p.thumbnailResolution,
                aspectRatio: p.aspectRatio,
                camera: this._topPageMainScene.camera,
                spWeight: p.spWeight
            };
            m.resize(g)
        }), this.update()
    }
    inStart() {
        this._animator.animate("transition", 0, .5), this._worksOutroTrigger = topScrollManager.getTrigger("works_outro"), this._missionTrigger = topScrollManager.getTrigger("mission_in"), this._serviceTrigger = topScrollManager.getTrigger("service_in"), this._visionTrigger = topScrollManager.getTrigger("vision"), this.sceneThumbnail.topWorksThumbnail.in(), this.sceneMain.cameraController.in(), this.sceneMain.mainLogo.in(), this.sceneMain.worksTitle.in(), this.sceneService.serviceList.in()
    }
    outStart() {
        this._animator.animate("transition", 1, .5)
    }
    outEnd() {
        this._topPageMainScene.mainLogo.out(), this._thumbnailScene.out(), this.sceneThumbnail.topWorksThumbnail.out(), this.sceneMain.mainLogo.out(), this.sceneMain.worksTitle.out()
    }
    switchToTopPage() {
        this._currentSceneSelector !== 0 && (this._currentSceneSelector = 0, this._animator.animate("subpageSceneSelector", 0, .5))
    }
    switchToSubPage() {
        this._currentSceneSelector !== 1 && (this._currentSceneSelector = 1, this._animator.animate("subpageSceneSelector", 1, .5))
    }
    changeTopSection(i) {
        this._topPageMainScene.changeSection(i)
    }
    switchToNotFoundPage() {
        this._animator.animate("notfoundVisibility", 1, .5)
    }
    hideNotFoundPage() {
        this._animator.animate("notfoundVisibility", 0, .5)
    }
    registerElm(i) {
        this._containerElm = i, this.resize()
    }
    onLoadingComplete(i = !1) {
        this._animator.animate("loaded", 1, i ? 0 : 3), setTimeout(() => {
            document.body.setAttribute("data-gl_loading_end", "true")
        }, 800)
    }
    async precompileShaders(i) {
        return this._shaderPrecompiler.precompileAllScenes(this._scenes, i)
    }
    getPrecompileStats() {
        return {
            totalMaterials: this._shaderPrecompiler.getCompiledMaterialsCount(),
            scenes: Array.from(this._scenes.keys()),
            stats: this._shaderPrecompiler.getStats()
        }
    }
    isShaderCompiled(i) {
        return this._shaderPrecompiler.isCompiledMaterial(i)
    }
}
const getElmRelativeTop = (l, i) => {
    const o = (c, u) => i.isEqualNode(c) || (u += c.offsetTop, c.offsetParent === null) ? u : o(c.offsetParent, u);
    return o(l, 0)
};
class ObjectScroller extends EventEmitter$1 {
    _elements;
    _cache;
    _tmpVectorZero;
    _tmpVectorCalc;
    _scrollYLerp;
    constructor() {
        super(), this._elements = new Map, this._cache = new Map, this._tmpVectorZero = new Vector3$1, this._tmpVectorCalc = new Vector3$1, this._scrollYLerp = typeof window < "u" && window.scrollY || 0
    }
    setElement(i, o) {
        this._deleteElement(i);
        const c = new Vector4,
            u = () => {
                queueMicrotask(() => {
                    const g = o.getBoundingClientRect();
                    c.set(getElmRelativeTop(o, document.body), o.offsetLeft, g.width, g.height)
                })
            },
            p = new ResizeObserver(u);
        p.observe(o);
        const m = {
            name: i,
            elm: o,
            calcPos: new Vector3$1,
            elmTransform: c,
            observer: p
        };
        return u(), this._elements.set(i, m), {
            dispose: () => {
                this._deleteElement(i)
            }
        }
    }
    deleteElement(i) {
        this._deleteElement(i)
    }
    _deleteElement(i) {
        const o = this._elements.get(i);
        o && (o.observer.disconnect(), this._elements.delete(i))
    }
    update(i) {
        this._scrollYLerp = i.scrollYLerp, this._cache.clear()
    }
    getScreenPos(i, o = 1) {
        const c = this._elements.get(i);
        return c ? (c.elmTransform.x + c.elmTransform.w / 2 - this._scrollYLerp - window.innerHeight / 2) / window.innerHeight * -2 * o : 0
    }
    calc(i, o, c, u = 1, p = 1) {
        const m = i + u + p,
            g = this._cache.get(m);
        if (g) return c && c.copy(g.pos), g;
        if (!this._elements.get(i)) return {
            pos: this._tmpVectorZero,
            screenY: 0,
            percentageToTop: 0,
            percentageToCenter: 0
        };
        const v = this.getScreenPos(i, p);
        this._tmpVectorCalc.set(0, 0, -u).applyMatrix4(o.projectionMatrix), this._tmpVectorCalc.set(0, v, this._tmpVectorCalc.z).applyMatrix4(o.projectionMatrixInverse), this._tmpVectorCalc.applyMatrix4(o.matrixWorld);
        const x = {
            pos: this._tmpVectorCalc.clone(),
            screenY: v,
            percentageToCenter: Math.max(0, Math.min(1, 1 + v)),
            percentageToTop: Math.max(0, Math.min(1, v * .5 + .5))
        };
        return c && c.copy(this._tmpVectorCalc), this._cache.set(m, x), x
    }
}
const duration = 1e3,
    partialStartDuration = 700,
    partialEndDuration = 500;
class Transition extends EventEmitter$1 {
    fromPage = "";
    toPage = "";
    activePromises = new Set;
    constructor() {
        super(), document.body.setAttribute("data-phase", "ready")
    }
    addActivePromise(i) {
        this.activePromises.add(i)
    }
    removeActivePromise(i) {
        this.activePromises.delete(i)
    }
    rejectAllActivePromises() {
        this.activePromises.forEach(i => {
            i()
        }), this.activePromises.clear()
    }
    setPageInfo(i, o) {
        this.fromPage = i, this.toPage = o
    }
    isWorksRelatedTransition() {
        const i = ["works", "works-detail"];
        return i.includes(this.fromPage) && i.includes(this.toPage)
    }
    isWorksCategoryTransition() {
        return this.fromPage === "works" && this.toPage === "works"
    }
    async start() {
        this.isWorksRelatedTransition() ? document.body.setAttribute("data-transition-type", "works") : document.body.removeAttribute("data-transition-type"), document.body.setAttribute("data-phase", "in"), await new Promise((i, o) => {
            this.addActivePromise(o);
            const c = setTimeout(() => {
                    this.removeActivePromise(o), i(!0)
                }, duration),
                u = o,
                p = m => {
                    clearTimeout(c), this.removeActivePromise(u), u(m)
                };
            this.activePromises.delete(u), this.addActivePromise(p)
        })
    }
    async end() {
        document.body.setAttribute("data-phase", "out"), await new Promise((i, o) => {
            this.addActivePromise(o);
            const c = setTimeout(() => {
                    this.removeActivePromise(o), i(!0)
                }, duration),
                u = o,
                p = m => {
                    clearTimeout(c), this.removeActivePromise(u), u(m)
                };
            this.activePromises.delete(u), this.addActivePromise(p)
        }), document.body.setAttribute("data-phase", "ready"), document.body.removeAttribute("data-transition-type")
    }
    async startPartial() {
        document.body.setAttribute("data-phase", "partial-in"), await new Promise((i, o) => {
            this.addActivePromise(o);
            const c = setTimeout(() => {
                    this.removeActivePromise(o), i(!0)
                }, partialStartDuration),
                u = o,
                p = m => {
                    clearTimeout(c), this.removeActivePromise(u), u(m)
                };
            this.activePromises.delete(u), this.addActivePromise(p)
        })
    }
    async endPartial() {
        document.body.setAttribute("data-phase", "partial-out"), await new Promise((i, o) => {
            this.addActivePromise(o);
            const c = setTimeout(() => {
                    this.removeActivePromise(o), i(!0)
                }, partialEndDuration),
                u = o,
                p = m => {
                    clearTimeout(c), this.removeActivePromise(u), u(m)
                };
            this.activePromises.delete(u), this.addActivePromise(p)
        }), document.body.setAttribute("data-phase", "ready")
    }
}
class PageBase extends EventEmitter$1 {
    constructor() {
        super()
    }
    inStart(i) {}
    inEnd(i) {}
    contentReplace(i) {}
    outStart(i) {}
    outEnd(i) {}
}

function _assertThisInitialized(l) {
    if (l === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return l
}

function _inheritsLoose(l, i) {
    l.prototype = Object.create(i.prototype), l.prototype.constructor = l, l.__proto__ = i
}
/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */
var _config = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
            lineHeight: ""
        }
    },
    _defaults = {
        duration: .5,
        overwrite: !1,
        delay: 0
    },
    _suppressOverwrites, _reverting$1, _context$1, _bigNum$1 = 1e8,
    _tinyNum = 1 / _bigNum$1,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function(i) {
        return typeof i == "string"
    },
    _isFunction = function(i) {
        return typeof i == "function"
    },
    _isNumber = function(i) {
        return typeof i == "number"
    },
    _isUndefined = function(i) {
        return typeof i > "u"
    },
    _isObject = function(i) {
        return typeof i == "object"
    },
    _isNotFalse = function(i) {
        return i !== !1
    },
    _windowExists$1 = function() {
        return typeof window < "u"
    },
    _isFuncOrString = function(i) {
        return _isFunction(i) || _isString(i)
    },
    _isTypedArray = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {},
    _isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    _relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    _globalTimeline, _win$1, _coreInitted$1, _doc$1, _globals = {},
    _installScope = {},
    _coreReady, _install = function(i) {
        return (_installScope = _merge(i, _globals)) && gsap$1
    },
    _missingPlugin = function(i, o) {
        return console.warn("Invalid property", i, "set to", o, "Missing plugin? gsap.registerPlugin()")
    },
    _warn = function(i, o) {
        return !o && console.warn(i)
    },
    _addGlobal = function(i, o) {
        return i && (_globals[i] = o) && _installScope && (_installScope[i] = o) || _globals
    },
    _emptyFunc = function() {
        return 0
    },
    _startAtRevertConfig = {
        suppressEvents: !0,
        isStart: !0,
        kill: !1
    },
    _revertConfigNoKill = {
        suppressEvents: !0,
        kill: !1
    },
    _revertConfig = {
        suppressEvents: !0
    },
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame, _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function(i) {
        var o = i[0],
            c, u;
        if (_isObject(o) || _isFunction(o) || (i = [i]), !(c = (o._gsap || {}).harness)) {
            for (u = _harnessPlugins.length; u-- && !_harnessPlugins[u].targetTest(o););
            c = _harnessPlugins[u]
        }
        for (u = i.length; u--;) i[u] && (i[u]._gsap || (i[u]._gsap = new GSCache(i[u], c))) || i.splice(u, 1);
        return i
    },
    _getCache = function(i) {
        return i._gsap || _harness(toArray(i))[0]._gsap
    },
    _getProperty = function(i, o, c) {
        return (c = i[o]) && _isFunction(c) ? i[o]() : _isUndefined(c) && i.getAttribute && i.getAttribute(o) || c
    },
    _forEachName = function(i, o) {
        return (i = i.split(",")).forEach(o) || i
    },
    _round = function(i) {
        return Math.round(i * 1e5) / 1e5 || 0
    },
    _roundPrecise = function(i) {
        return Math.round(i * 1e7) / 1e7 || 0
    },
    _parseRelative = function(i, o) {
        var c = o.charAt(0),
            u = parseFloat(o.substr(2));
        return i = parseFloat(i), c === "+" ? i + u : c === "-" ? i - u : c === "*" ? i * u : i / u
    },
    _arrayContainsAny = function(i, o) {
        for (var c = o.length, u = 0; i.indexOf(o[u]) < 0 && ++u < c;);
        return u < c
    },
    _lazyRender = function() {
        var i = _lazyTweens.length,
            o = _lazyTweens.slice(0),
            c, u;
        for (_lazyLookup = {}, _lazyTweens.length = 0, c = 0; c < i; c++) u = o[c], u && u._lazy && (u.render(u._lazy[0], u._lazy[1], !0)._lazy = 0)
    },
    _isRevertWorthy = function(i) {
        return !!(i._initted || i._startAt || i.add)
    },
    _lazySafeRender = function(i, o, c, u) {
        _lazyTweens.length && !_reverting$1 && _lazyRender(), i.render(o, c, !!(_reverting$1 && o < 0 && _isRevertWorthy(i))), _lazyTweens.length && !_reverting$1 && _lazyRender()
    },
    _numericIfPossible = function(i) {
        var o = parseFloat(i);
        return (o || o === 0) && (i + "").match(_delimitedValueExp).length < 2 ? o : _isString(i) ? i.trim() : i
    },
    _passThrough = function(i) {
        return i
    },
    _setDefaults = function(i, o) {
        for (var c in o) c in i || (i[c] = o[c]);
        return i
    },
    _setKeyframeDefaults = function(i) {
        return function(o, c) {
            for (var u in c) u in o || u === "duration" && i || u === "ease" || (o[u] = c[u])
        }
    },
    _merge = function(i, o) {
        for (var c in o) i[c] = o[c];
        return i
    },
    _mergeDeep = function l(i, o) {
        for (var c in o) c !== "__proto__" && c !== "constructor" && c !== "prototype" && (i[c] = _isObject(o[c]) ? l(i[c] || (i[c] = {}), o[c]) : o[c]);
        return i
    },
    _copyExcluding = function(i, o) {
        var c = {},
            u;
        for (u in i) u in o || (c[u] = i[u]);
        return c
    },
    _inheritDefaults = function(i) {
        var o = i.parent || _globalTimeline,
            c = i.keyframes ? _setKeyframeDefaults(_isArray(i.keyframes)) : _setDefaults;
        if (_isNotFalse(i.inherit))
            for (; o;) c(i, o.vars.defaults), o = o.parent || o._dp;
        return i
    },
    _arraysMatch = function(i, o) {
        for (var c = i.length, u = c === o.length; u && c-- && i[c] === o[c];);
        return c < 0
    },
    _addLinkedListItem = function(i, o, c, u, p) {
        var m = i[u],
            g;
        if (p)
            for (g = o[p]; m && m[p] > g;) m = m._prev;
        return m ? (o._next = m._next, m._next = o) : (o._next = i[c], i[c] = o), o._next ? o._next._prev = o : i[u] = o, o._prev = m, o.parent = o._dp = i, o
    },
    _removeLinkedListItem = function(i, o, c, u) {
        c === void 0 && (c = "_first"), u === void 0 && (u = "_last");
        var p = o._prev,
            m = o._next;
        p ? p._next = m : i[c] === o && (i[c] = m), m ? m._prev = p : i[u] === o && (i[u] = p), o._next = o._prev = o.parent = null
    },
    _removeFromParent = function(i, o) {
        i.parent && (!o || i.parent.autoRemoveChildren) && i.parent.remove && i.parent.remove(i), i._act = 0
    },
    _uncache = function(i, o) {
        if (i && (!o || o._end > i._dur || o._start < 0))
            for (var c = i; c;) c._dirty = 1, c = c.parent;
        return i
    },
    _recacheAncestors = function(i) {
        for (var o = i.parent; o && o.parent;) o._dirty = 1, o.totalDuration(), o = o.parent;
        return i
    },
    _rewindStartAt = function(i, o, c, u) {
        return i._startAt && (_reverting$1 ? i._startAt.revert(_revertConfigNoKill) : i.vars.immediateRender && !i.vars.autoRevert || i._startAt.render(o, !0, u))
    },
    _hasNoPausedAncestors = function l(i) {
        return !i || i._ts && l(i.parent)
    },
    _elapsedCycleDuration = function(i) {
        return i._repeat ? _animationCycle(i._tTime, i = i.duration() + i._rDelay) * i : 0
    },
    _animationCycle = function(i, o) {
        var c = Math.floor(i = _roundPrecise(i / o));
        return i && c === i ? c - 1 : c
    },
    _parentToChildTotalTime = function(i, o) {
        return (i - o._start) * o._ts + (o._ts >= 0 ? 0 : o._dirty ? o.totalDuration() : o._tDur)
    },
    _setEnd = function(i) {
        return i._end = _roundPrecise(i._start + (i._tDur / Math.abs(i._ts || i._rts || _tinyNum) || 0))
    },
    _alignPlayhead = function(i, o) {
        var c = i._dp;
        return c && c.smoothChildTiming && i._ts && (i._start = _roundPrecise(c._time - (i._ts > 0 ? o / i._ts : ((i._dirty ? i.totalDuration() : i._tDur) - o) / -i._ts)), _setEnd(i), c._dirty || _uncache(c, i)), i
    },
    _postAddChecks = function(i, o) {
        var c;
        if ((o._time || !o._dur && o._initted || o._start < i._time && (o._dur || !o.add)) && (c = _parentToChildTotalTime(i.rawTime(), o), (!o._dur || _clamp(0, o.totalDuration(), c) - o._tTime > _tinyNum) && o.render(c, !0)), _uncache(i, o)._dp && i._initted && i._time >= i._dur && i._ts) {
            if (i._dur < i.duration())
                for (c = i; c._dp;) c.rawTime() >= 0 && c.totalTime(c._tTime), c = c._dp;
            i._zTime = -1e-8
        }
    },
    _addToTimeline = function(i, o, c, u) {
        return o.parent && _removeFromParent(o), o._start = _roundPrecise((_isNumber(c) ? c : c || i !== _globalTimeline ? _parsePosition(i, c, o) : i._time) + o._delay), o._end = _roundPrecise(o._start + (o.totalDuration() / Math.abs(o.timeScale()) || 0)), _addLinkedListItem(i, o, "_first", "_last", i._sort ? "_start" : 0), _isFromOrFromStart(o) || (i._recent = o), u || _postAddChecks(i, o), i._ts < 0 && _alignPlayhead(i, i._tTime), i
    },
    _scrollTrigger = function(i, o) {
        return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", o)) && _globals.ScrollTrigger.create(o, i)
    },
    _attemptInitTween = function(i, o, c, u, p) {
        if (_initTween(i, o, p), !i._initted) return 1;
        if (!c && i._pt && !_reverting$1 && (i._dur && i.vars.lazy !== !1 || !i._dur && i.vars.lazy) && _lastRenderedFrame !== _ticker.frame) return _lazyTweens.push(i), i._lazy = [p, u], 1
    },
    _parentPlayheadIsBeforeStart = function l(i) {
        var o = i.parent;
        return o && o._ts && o._initted && !o._lock && (o.rawTime() < 0 || l(o))
    },
    _isFromOrFromStart = function(i) {
        var o = i.data;
        return o === "isFromStart" || o === "isStart"
    },
    _renderZeroDurationTween = function(i, o, c, u) {
        var p = i.ratio,
            m = o < 0 || !o && (!i._start && _parentPlayheadIsBeforeStart(i) && !(!i._initted && _isFromOrFromStart(i)) || (i._ts < 0 || i._dp._ts < 0) && !_isFromOrFromStart(i)) ? 0 : 1,
            g = i._rDelay,
            _ = 0,
            v, x, y;
        if (g && i._repeat && (_ = _clamp(0, i._tDur, o), x = _animationCycle(_, g), i._yoyo && x & 1 && (m = 1 - m), x !== _animationCycle(i._tTime, g) && (p = 1 - m, i.vars.repeatRefresh && i._initted && i.invalidate())), m !== p || _reverting$1 || u || i._zTime === _tinyNum || !o && i._zTime) {
            if (!i._initted && _attemptInitTween(i, o, u, c, _)) return;
            for (y = i._zTime, i._zTime = o || (c ? _tinyNum : 0), c || (c = o && !y), i.ratio = m, i._from && (m = 1 - m), i._time = 0, i._tTime = _, v = i._pt; v;) v.r(m, v.d), v = v._next;
            o < 0 && _rewindStartAt(i, o, c, !0), i._onUpdate && !c && _callback(i, "onUpdate"), _ && i._repeat && !c && i.parent && _callback(i, "onRepeat"), (o >= i._tDur || o < 0) && i.ratio === m && (m && _removeFromParent(i, 1), !c && !_reverting$1 && (_callback(i, m ? "onComplete" : "onReverseComplete", !0), i._prom && i._prom()))
        } else i._zTime || (i._zTime = o)
    },
    _findNextPauseTween = function(i, o, c) {
        var u;
        if (c > o)
            for (u = i._first; u && u._start <= c;) {
                if (u.data === "isPause" && u._start > o) return u;
                u = u._next
            } else
                for (u = i._last; u && u._start >= c;) {
                    if (u.data === "isPause" && u._start < o) return u;
                    u = u._prev
                }
    },
    _setDuration = function(i, o, c, u) {
        var p = i._repeat,
            m = _roundPrecise(o) || 0,
            g = i._tTime / i._tDur;
        return g && !u && (i._time *= m / i._dur), i._dur = m, i._tDur = p ? p < 0 ? 1e10 : _roundPrecise(m * (p + 1) + i._rDelay * p) : m, g > 0 && !u && _alignPlayhead(i, i._tTime = i._tDur * g), i.parent && _setEnd(i), c || _uncache(i.parent, i), i
    },
    _onUpdateTotalDuration = function(i) {
        return i instanceof Timeline ? _uncache(i) : _setDuration(i, i._dur)
    },
    _zeroPosition = {
        _start: 0,
        endTime: _emptyFunc,
        totalDuration: _emptyFunc
    },
    _parsePosition = function l(i, o, c) {
        var u = i.labels,
            p = i._recent || _zeroPosition,
            m = i.duration() >= _bigNum$1 ? p.endTime(!1) : i._dur,
            g, _, v;
        return _isString(o) && (isNaN(o) || o in u) ? (_ = o.charAt(0), v = o.substr(-1) === "%", g = o.indexOf("="), _ === "<" || _ === ">" ? (g >= 0 && (o = o.replace(/=/, "")), (_ === "<" ? p._start : p.endTime(p._repeat >= 0)) + (parseFloat(o.substr(1)) || 0) * (v ? (g < 0 ? p : c).totalDuration() / 100 : 1)) : g < 0 ? (o in u || (u[o] = m), u[o]) : (_ = parseFloat(o.charAt(g - 1) + o.substr(g + 1)), v && c && (_ = _ / 100 * (_isArray(c) ? c[0] : c).totalDuration()), g > 1 ? l(i, o.substr(0, g - 1), c) + _ : m + _)) : o == null ? m : +o
    },
    _createTweenType = function(i, o, c) {
        var u = _isNumber(o[1]),
            p = (u ? 2 : 1) + (i < 2 ? 0 : 1),
            m = o[p],
            g, _;
        if (u && (m.duration = o[1]), m.parent = c, i) {
            for (g = m, _ = c; _ && !("immediateRender" in g);) g = _.vars.defaults || {}, _ = _isNotFalse(_.vars.inherit) && _.parent;
            m.immediateRender = _isNotFalse(g.immediateRender), i < 2 ? m.runBackwards = 1 : m.startAt = o[p - 1]
        }
        return new Tween(o[0], m, o[p + 1])
    },
    _conditionalReturn = function(i, o) {
        return i || i === 0 ? o(i) : o
    },
    _clamp = function(i, o, c) {
        return c < i ? i : c > o ? o : c
    },
    getUnit = function(i, o) {
        return !_isString(i) || !(o = _unitExp.exec(i)) ? "" : o[1]
    },
    clamp = function(i, o, c) {
        return _conditionalReturn(c, function(u) {
            return _clamp(i, o, u)
        })
    },
    _slice = [].slice,
    _isArrayLike = function(i, o) {
        return i && _isObject(i) && "length" in i && (!o && !i.length || i.length - 1 in i && _isObject(i[0])) && !i.nodeType && i !== _win$1
    },
    _flatten = function(i, o, c) {
        return c === void 0 && (c = []), i.forEach(function(u) {
            var p;
            return _isString(u) && !o || _isArrayLike(u, 1) ? (p = c).push.apply(p, toArray(u)) : c.push(u)
        }) || c
    },
    toArray = function(i, o, c) {
        return _context$1 && !o && _context$1.selector ? _context$1.selector(i) : _isString(i) && !c && (_coreInitted$1 || !_wake()) ? _slice.call((o || _doc$1).querySelectorAll(i), 0) : _isArray(i) ? _flatten(i, c) : _isArrayLike(i) ? _slice.call(i, 0) : i ? [i] : []
    },
    selector = function(i) {
        return i = toArray(i)[0] || _warn("Invalid scope") || {},
            function(o) {
                var c = i.current || i.nativeElement || i;
                return toArray(o, c.querySelectorAll ? c : c === i ? _warn("Invalid scope") || _doc$1.createElement("div") : i)
            }
    },
    shuffle = function(i) {
        return i.sort(function() {
            return .5 - Math.random()
        })
    },
    distribute = function(i) {
        if (_isFunction(i)) return i;
        var o = _isObject(i) ? i : {
                each: i
            },
            c = _parseEase(o.ease),
            u = o.from || 0,
            p = parseFloat(o.base) || 0,
            m = {},
            g = u > 0 && u < 1,
            _ = isNaN(u) || g,
            v = o.axis,
            x = u,
            y = u;
        return _isString(u) ? x = y = {
                center: .5,
                edges: .5,
                end: 1
            }[u] || 0 : !g && _ && (x = u[0], y = u[1]),
            function(b, S, C) {
                var E = (C || o).length,
                    P = m[E],
                    w, T, M, A, D, R, I, k, F;
                if (!P) {
                    if (F = o.grid === "auto" ? 0 : (o.grid || [1, _bigNum$1])[1], !F) {
                        for (I = -1e8; I < (I = C[F++].getBoundingClientRect().left) && F < E;);
                        F < E && F--
                    }
                    for (P = m[E] = [], w = _ ? Math.min(F, E) * x - .5 : u % F, T = F === _bigNum$1 ? 0 : _ ? E * y / F - .5 : u / F | 0, I = 0, k = _bigNum$1, R = 0; R < E; R++) M = R % F - w, A = T - (R / F | 0), P[R] = D = v ? Math.abs(v === "y" ? A : M) : _sqrt(M * M + A * A), D > I && (I = D), D < k && (k = D);
                    u === "random" && shuffle(P), P.max = I - k, P.min = k, P.v = E = (parseFloat(o.amount) || parseFloat(o.each) * (F > E ? E - 1 : v ? v === "y" ? E / F : F : Math.max(F, E / F)) || 0) * (u === "edges" ? -1 : 1), P.b = E < 0 ? p - E : p, P.u = getUnit(o.amount || o.each) || 0, c = c && E < 0 ? _invertEase(c) : c
                }
                return E = (P[b] - P.min) / P.max || 0, _roundPrecise(P.b + (c ? c(E) : E) * P.v) + P.u
            }
    },
    _roundModifier = function(i) {
        var o = Math.pow(10, ((i + "").split(".")[1] || "").length);
        return function(c) {
            var u = _roundPrecise(Math.round(parseFloat(c) / i) * i * o);
            return (u - u % 1) / o + (_isNumber(c) ? 0 : getUnit(c))
        }
    },
    snap = function(i, o) {
        var c = _isArray(i),
            u, p;
        return !c && _isObject(i) && (u = c = i.radius || _bigNum$1, i.values ? (i = toArray(i.values), (p = !_isNumber(i[0])) && (u *= u)) : i = _roundModifier(i.increment)), _conditionalReturn(o, c ? _isFunction(i) ? function(m) {
            return p = i(m), Math.abs(p - m) <= u ? p : m
        } : function(m) {
            for (var g = parseFloat(p ? m.x : m), _ = parseFloat(p ? m.y : 0), v = _bigNum$1, x = 0, y = i.length, b, S; y--;) p ? (b = i[y].x - g, S = i[y].y - _, b = b * b + S * S) : b = Math.abs(i[y] - g), b < v && (v = b, x = y);
            return x = !u || v <= u ? i[x] : m, p || x === m || _isNumber(m) ? x : x + getUnit(m)
        } : _roundModifier(i))
    },
    random = function(i, o, c, u) {
        return _conditionalReturn(_isArray(i) ? !o : c === !0 ? !!(c = 0) : !u, function() {
            return _isArray(i) ? i[~~(Math.random() * i.length)] : (c = c || 1e-5) && (u = c < 1 ? Math.pow(10, (c + "").length - 2) : 1) && Math.floor(Math.round((i - c / 2 + Math.random() * (o - i + c * .99)) / c) * c * u) / u
        })
    },
    pipe = function() {
        for (var i = arguments.length, o = new Array(i), c = 0; c < i; c++) o[c] = arguments[c];
        return function(u) {
            return o.reduce(function(p, m) {
                return m(p)
            }, u)
        }
    },
    unitize = function(i, o) {
        return function(c) {
            return i(parseFloat(c)) + (o || getUnit(c))
        }
    },
    normalize = function(i, o, c) {
        return mapRange(i, o, 0, 1, c)
    },
    _wrapArray = function(i, o, c) {
        return _conditionalReturn(c, function(u) {
            return i[~~o(u)]
        })
    },
    wrap = function l(i, o, c) {
        var u = o - i;
        return _isArray(i) ? _wrapArray(i, l(0, i.length), o) : _conditionalReturn(c, function(p) {
            return (u + (p - i) % u) % u + i
        })
    },
    wrapYoyo = function l(i, o, c) {
        var u = o - i,
            p = u * 2;
        return _isArray(i) ? _wrapArray(i, l(0, i.length - 1), o) : _conditionalReturn(c, function(m) {
            return m = (p + (m - i) % p) % p || 0, i + (m > u ? p - m : m)
        })
    },
    _replaceRandom = function(i) {
        for (var o = 0, c = "", u, p, m, g; ~(u = i.indexOf("random(", o));) m = i.indexOf(")", u), g = i.charAt(u + 7) === "[", p = i.substr(u + 7, m - u - 7).match(g ? _delimitedValueExp : _strictNumExp), c += i.substr(o, u - o) + random(g ? p : +p[0], g ? 0 : +p[1], +p[2] || 1e-5), o = m + 1;
        return c + i.substr(o, i.length - o)
    },
    mapRange = function(i, o, c, u, p) {
        var m = o - i,
            g = u - c;
        return _conditionalReturn(p, function(_) {
            return c + ((_ - i) / m * g || 0)
        })
    },
    interpolate = function l(i, o, c, u) {
        var p = isNaN(i + o) ? 0 : function(S) {
            return (1 - S) * i + S * o
        };
        if (!p) {
            var m = _isString(i),
                g = {},
                _, v, x, y, b;
            if (c === !0 && (u = 1) && (c = null), m) i = {
                p: i
            }, o = {
                p: o
            };
            else if (_isArray(i) && !_isArray(o)) {
                for (x = [], y = i.length, b = y - 2, v = 1; v < y; v++) x.push(l(i[v - 1], i[v]));
                y--, p = function(C) {
                    C *= y;
                    var E = Math.min(b, ~~C);
                    return x[E](C - E)
                }, c = o
            } else u || (i = _merge(_isArray(i) ? [] : {}, i));
            if (!x) {
                for (_ in o) _addPropTween.call(g, i, _, "get", o[_]);
                p = function(C) {
                    return _renderPropTweens(C, g) || (m ? i.p : i)
                }
            }
        }
        return _conditionalReturn(c, p)
    },
    _getLabelInDirection = function(i, o, c) {
        var u = i.labels,
            p = _bigNum$1,
            m, g, _;
        for (m in u) g = u[m] - o, g < 0 == !!c && g && p > (g = Math.abs(g)) && (_ = m, p = g);
        return _
    },
    _callback = function(i, o, c) {
        var u = i.vars,
            p = u[o],
            m = _context$1,
            g = i._ctx,
            _, v, x;
        if (p) return _ = u[o + "Params"], v = u.callbackScope || i, c && _lazyTweens.length && _lazyRender(), g && (_context$1 = g), x = _ ? p.apply(v, _) : p.call(v), _context$1 = m, x
    },
    _interrupt = function(i) {
        return _removeFromParent(i), i.scrollTrigger && i.scrollTrigger.kill(!!_reverting$1), i.progress() < 1 && _callback(i, "onInterrupt"), i
    },
    _quickTween, _registerPluginQueue = [],
    _createPlugin = function(i) {
        if (i)
            if (i = !i.name && i.default || i, _windowExists$1() || i.headless) {
                var o = i.name,
                    c = _isFunction(i),
                    u = o && !c && i.init ? function() {
                        this._props = []
                    } : i,
                    p = {
                        init: _emptyFunc,
                        render: _renderPropTweens,
                        add: _addPropTween,
                        kill: _killPropTweensOf,
                        modifier: _addPluginModifier,
                        rawVars: 0
                    },
                    m = {
                        targetTest: 0,
                        get: 0,
                        getSetter: _getSetter,
                        aliases: {},
                        register: 0
                    };
                if (_wake(), i !== u) {
                    if (_plugins[o]) return;
                    _setDefaults(u, _setDefaults(_copyExcluding(i, p), m)), _merge(u.prototype, _merge(p, _copyExcluding(i, m))), _plugins[u.prop = o] = u, i.targetTest && (_harnessPlugins.push(u), _reservedProps[o] = 1), o = (o === "css" ? "CSS" : o.charAt(0).toUpperCase() + o.substr(1)) + "Plugin"
                }
                _addGlobal(o, u), i.register && i.register(gsap$1, u, PropTween)
            } else _registerPluginQueue.push(i)
    },
    _255 = 255,
    _colorLookup = {
        aqua: [0, _255, _255],
        lime: [0, _255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, _255],
        navy: [0, 0, 128],
        white: [_255, _255, _255],
        olive: [128, 128, 0],
        yellow: [_255, _255, 0],
        orange: [_255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [_255, 0, 0],
        pink: [_255, 192, 203],
        cyan: [0, _255, _255],
        transparent: [_255, _255, _255, 0]
    },
    _hue = function(i, o, c) {
        return i += i < 0 ? 1 : i > 1 ? -1 : 0, (i * 6 < 1 ? o + (c - o) * i * 6 : i < .5 ? c : i * 3 < 2 ? o + (c - o) * (2 / 3 - i) * 6 : o) * _255 + .5 | 0
    },
    splitColor = function(i, o, c) {
        var u = i ? _isNumber(i) ? [i >> 16, i >> 8 & _255, i & _255] : 0 : _colorLookup.black,
            p, m, g, _, v, x, y, b, S, C;
        if (!u) {
            if (i.substr(-1) === "," && (i = i.substr(0, i.length - 1)), _colorLookup[i]) u = _colorLookup[i];
            else if (i.charAt(0) === "#") {
                if (i.length < 6 && (p = i.charAt(1), m = i.charAt(2), g = i.charAt(3), i = "#" + p + p + m + m + g + g + (i.length === 5 ? i.charAt(4) + i.charAt(4) : "")), i.length === 9) return u = parseInt(i.substr(1, 6), 16), [u >> 16, u >> 8 & _255, u & _255, parseInt(i.substr(7), 16) / 255];
                i = parseInt(i.substr(1), 16), u = [i >> 16, i >> 8 & _255, i & _255]
            } else if (i.substr(0, 3) === "hsl") {
                if (u = C = i.match(_strictNumExp), !o) _ = +u[0] % 360 / 360, v = +u[1] / 100, x = +u[2] / 100, m = x <= .5 ? x * (v + 1) : x + v - x * v, p = x * 2 - m, u.length > 3 && (u[3] *= 1), u[0] = _hue(_ + 1 / 3, p, m), u[1] = _hue(_, p, m), u[2] = _hue(_ - 1 / 3, p, m);
                else if (~i.indexOf("=")) return u = i.match(_numExp), c && u.length < 4 && (u[3] = 1), u
            } else u = i.match(_strictNumExp) || _colorLookup.transparent;
            u = u.map(Number)
        }
        return o && !C && (p = u[0] / _255, m = u[1] / _255, g = u[2] / _255, y = Math.max(p, m, g), b = Math.min(p, m, g), x = (y + b) / 2, y === b ? _ = v = 0 : (S = y - b, v = x > .5 ? S / (2 - y - b) : S / (y + b), _ = y === p ? (m - g) / S + (m < g ? 6 : 0) : y === m ? (g - p) / S + 2 : (p - m) / S + 4, _ *= 60), u[0] = ~~(_ + .5), u[1] = ~~(v * 100 + .5), u[2] = ~~(x * 100 + .5)), c && u.length < 4 && (u[3] = 1), u
    },
    _colorOrderData = function(i) {
        var o = [],
            c = [],
            u = -1;
        return i.split(_colorExp).forEach(function(p) {
            var m = p.match(_numWithUnitExp) || [];
            o.push.apply(o, m), c.push(u += m.length + 1)
        }), o.c = c, o
    },
    _formatColors = function(i, o, c) {
        var u = "",
            p = (i + u).match(_colorExp),
            m = o ? "hsla(" : "rgba(",
            g = 0,
            _, v, x, y;
        if (!p) return i;
        if (p = p.map(function(b) {
                return (b = splitColor(b, o, 1)) && m + (o ? b[0] + "," + b[1] + "%," + b[2] + "%," + b[3] : b.join(",")) + ")"
            }), c && (x = _colorOrderData(i), _ = c.c, _.join(u) !== x.c.join(u)))
            for (v = i.replace(_colorExp, "1").split(_numWithUnitExp), y = v.length - 1; g < y; g++) u += v[g] + (~_.indexOf(g) ? p.shift() || m + "0,0,0,0)" : (x.length ? x : p.length ? p : c).shift());
        if (!v)
            for (v = i.split(_colorExp), y = v.length - 1; g < y; g++) u += v[g] + p[g];
        return u + v[y]
    },
    _colorExp = function() {
        var l = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
            i;
        for (i in _colorLookup) l += "|" + i + "\\b";
        return new RegExp(l + ")", "gi")
    }(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function(i) {
        var o = i.join(" "),
            c;
        if (_colorExp.lastIndex = 0, _colorExp.test(o)) return c = _hslExp.test(o), i[1] = _formatColors(i[1], c), i[0] = _formatColors(i[0], c, _colorOrderData(i[1])), !0
    },
    _tickerActive, _ticker = function() {
        var l = Date.now,
            i = 500,
            o = 33,
            c = l(),
            u = c,
            p = 1e3 / 240,
            m = p,
            g = [],
            _, v, x, y, b, S, C = function E(P) {
                var w = l() - u,
                    T = P === !0,
                    M, A, D, R;
                if ((w > i || w < 0) && (c += w - o), u += w, D = u - c, M = D - m, (M > 0 || T) && (R = ++y.frame, b = D - y.time * 1e3, y.time = D = D / 1e3, m += M + (M >= p ? 4 : p - M), A = 1), T || (_ = v(E)), A)
                    for (S = 0; S < g.length; S++) g[S](D, b, R, P)
            };
        return y = {
            time: 0,
            frame: 0,
            tick: function() {
                C(!0)
            },
            deltaRatio: function(P) {
                return b / (1e3 / (P || 60))
            },
            wake: function() {
                _coreReady && (!_coreInitted$1 && _windowExists$1() && (_win$1 = _coreInitted$1 = window, _doc$1 = _win$1.document || {}, _globals.gsap = gsap$1, (_win$1.gsapVersions || (_win$1.gsapVersions = [])).push(gsap$1.version), _install(_installScope || _win$1.GreenSockGlobals || !_win$1.gsap && _win$1 || {}), _registerPluginQueue.forEach(_createPlugin)), x = typeof requestAnimationFrame < "u" && requestAnimationFrame, _ && y.sleep(), v = x || function(P) {
                    return setTimeout(P, m - y.time * 1e3 + 1 | 0)
                }, _tickerActive = 1, C(2))
            },
            sleep: function() {
                (x ? cancelAnimationFrame : clearTimeout)(_), _tickerActive = 0, v = _emptyFunc
            },
            lagSmoothing: function(P, w) {
                i = P || 1 / 0, o = Math.min(w || 33, i)
            },
            fps: function(P) {
                p = 1e3 / (P || 240), m = y.time * 1e3 + p
            },
            add: function(P, w, T) {
                var M = w ? function(A, D, R, I) {
                    P(A, D, R, I), y.remove(M)
                } : P;
                return y.remove(P), g[T ? "unshift" : "push"](M), _wake(), M
            },
            remove: function(P, w) {
                ~(w = g.indexOf(P)) && g.splice(w, 1) && S >= w && S--
            },
            _listeners: g
        }, y
    }(),
    _wake = function() {
        return !_tickerActive && _ticker.wake()
    },
    _easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function(i) {
        for (var o = {}, c = i.substr(1, i.length - 3).split(":"), u = c[0], p = 1, m = c.length, g, _, v; p < m; p++) _ = c[p], g = p !== m - 1 ? _.lastIndexOf(",") : _.length, v = _.substr(0, g), o[u] = isNaN(v) ? v.replace(_quotesExp, "").trim() : +v, u = _.substr(g + 1).trim();
        return o
    },
    _valueInParentheses = function(i) {
        var o = i.indexOf("(") + 1,
            c = i.indexOf(")"),
            u = i.indexOf("(", o);
        return i.substring(o, ~u && u < c ? i.indexOf(")", c + 1) : c)
    },
    _configEaseFromString = function(i) {
        var o = (i + "").split("("),
            c = _easeMap[o[0]];
        return c && o.length > 1 && c.config ? c.config.apply(null, ~i.indexOf("{") ? [_parseObjectInString(o[1])] : _valueInParentheses(i).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(i) ? _easeMap._CE("", i) : c
    },
    _invertEase = function(i) {
        return function(o) {
            return 1 - i(1 - o)
        }
    },
    _propagateYoyoEase = function l(i, o) {
        for (var c = i._first, u; c;) c instanceof Timeline ? l(c, o) : c.vars.yoyoEase && (!c._yoyo || !c._repeat) && c._yoyo !== o && (c.timeline ? l(c.timeline, o) : (u = c._ease, c._ease = c._yEase, c._yEase = u, c._yoyo = o)), c = c._next
    },
    _parseEase = function(i, o) {
        return i && (_isFunction(i) ? i : _easeMap[i] || _configEaseFromString(i)) || o
    },
    _insertEase = function(i, o, c, u) {
        c === void 0 && (c = function(_) {
            return 1 - o(1 - _)
        }), u === void 0 && (u = function(_) {
            return _ < .5 ? o(_ * 2) / 2 : 1 - o((1 - _) * 2) / 2
        });
        var p = {
                easeIn: o,
                easeOut: c,
                easeInOut: u
            },
            m;
        return _forEachName(i, function(g) {
            _easeMap[g] = _globals[g] = p, _easeMap[m = g.toLowerCase()] = c;
            for (var _ in p) _easeMap[m + (_ === "easeIn" ? ".in" : _ === "easeOut" ? ".out" : ".inOut")] = _easeMap[g + "." + _] = p[_]
        }), p
    },
    _easeInOutFromOut = function(i) {
        return function(o) {
            return o < .5 ? (1 - i(1 - o * 2)) / 2 : .5 + i((o - .5) * 2) / 2
        }
    },
    _configElastic = function l(i, o, c) {
        var u = o >= 1 ? o : 1,
            p = (c || (i ? .3 : .45)) / (o < 1 ? o : 1),
            m = p / _2PI * (Math.asin(1 / u) || 0),
            g = function(x) {
                return x === 1 ? 1 : u * Math.pow(2, -10 * x) * _sin((x - m) * p) + 1
            },
            _ = i === "out" ? g : i === "in" ? function(v) {
                return 1 - g(1 - v)
            } : _easeInOutFromOut(g);
        return p = _2PI / p, _.config = function(v, x) {
            return l(i, v, x)
        }, _
    },
    _configBack = function l(i, o) {
        o === void 0 && (o = 1.70158);
        var c = function(m) {
                return m ? --m * m * ((o + 1) * m + o) + 1 : 0
            },
            u = i === "out" ? c : i === "in" ? function(p) {
                return 1 - c(1 - p)
            } : _easeInOutFromOut(c);
        return u.config = function(p) {
            return l(i, p)
        }, u
    };
_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(l, i) {
    var o = i < 5 ? i + 1 : i;
    _insertEase(l + ",Power" + (o - 1), i ? function(c) {
        return Math.pow(c, o)
    } : function(c) {
        return c
    }, function(c) {
        return 1 - Math.pow(1 - c, o)
    }, function(c) {
        return c < .5 ? Math.pow(c * 2, o) / 2 : 1 - Math.pow((1 - c) * 2, o) / 2
    })
});
_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
(function(l, i) {
    var o = 1 / i,
        c = 2 * o,
        u = 2.5 * o,
        p = function(g) {
            return g < o ? l * g * g : g < c ? l * Math.pow(g - 1.5 / i, 2) + .75 : g < u ? l * (g -= 2.25 / i) * g + .9375 : l * Math.pow(g - 2.625 / i, 2) + .984375
        };
    _insertEase("Bounce", function(m) {
        return 1 - p(1 - m)
    }, p)
})(7.5625, 2.75);
_insertEase("Expo", function(l) {
    return Math.pow(2, 10 * (l - 1)) * l + l * l * l * l * l * l * (1 - l)
});
_insertEase("Circ", function(l) {
    return -(_sqrt(1 - l * l) - 1)
});
_insertEase("Sine", function(l) {
    return l === 1 ? 1 : -_cos(l * _HALF_PI) + 1
});
_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function(i, o) {
        i === void 0 && (i = 1);
        var c = 1 / i,
            u = i + (o ? 0 : 1),
            p = o ? 1 : 0,
            m = 1 - _tinyNum;
        return function(g) {
            return ((u * _clamp(0, m, g) | 0) + p) * c
        }
    }
};
_defaults.ease = _easeMap["quad.out"];
_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(l) {
    return _callbackNames += l + "," + l + "Params,"
});
var GSCache = function(i, o) {
        this.id = _gsID++, i._gsap = this, this.target = i, this.harness = o, this.get = o ? o.get : _getProperty, this.set = o ? o.getSetter : _getSetter
    },
    Animation = function() {
        function l(o) {
            this.vars = o, this._delay = +o.delay || 0, (this._repeat = o.repeat === 1 / 0 ? -2 : o.repeat || 0) && (this._rDelay = o.repeatDelay || 0, this._yoyo = !!o.yoyo || !!o.yoyoEase), this._ts = 1, _setDuration(this, +o.duration, 1, 1), this.data = o.data, _context$1 && (this._ctx = _context$1, _context$1.data.push(this)), _tickerActive || _ticker.wake()
        }
        var i = l.prototype;
        return i.delay = function(c) {
            return c || c === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + c - this._delay), this._delay = c, this) : this._delay
        }, i.duration = function(c) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? c + (c + this._rDelay) * this._repeat : c) : this.totalDuration() && this._dur
        }, i.totalDuration = function(c) {
            return arguments.length ? (this._dirty = 0, _setDuration(this, this._repeat < 0 ? c : (c - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }, i.totalTime = function(c, u) {
            if (_wake(), !arguments.length) return this._tTime;
            var p = this._dp;
            if (p && p.smoothChildTiming && this._ts) {
                for (_alignPlayhead(this, c), !p._dp || p.parent || _postAddChecks(p, this); p && p.parent;) p.parent._time !== p._start + (p._ts >= 0 ? p._tTime / p._ts : (p.totalDuration() - p._tTime) / -p._ts) && p.totalTime(p._tTime, !0), p = p.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && c < this._tDur || this._ts < 0 && c > 0 || !this._tDur && !c) && _addToTimeline(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== c || !this._dur && !u || this._initted && Math.abs(this._zTime) === _tinyNum || !c && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = c), _lazySafeRender(this, c, u)), this
        }, i.time = function(c, u) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), c + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (c ? this._dur : 0), u) : this._time
        }, i.totalProgress = function(c, u) {
            return arguments.length ? this.totalTime(this.totalDuration() * c, u) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0
        }, i.progress = function(c, u) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - c : c) + _elapsedCycleDuration(this), u) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
        }, i.iteration = function(c, u) {
            var p = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (c - 1) * p, u) : this._repeat ? _animationCycle(this._tTime, p) + 1 : 1
        }, i.timeScale = function(c, u) {
            if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
            if (this._rts === c) return this;
            var p = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
            return this._rts = +c || 0, this._ts = this._ps || c === -1e-8 ? 0 : this._rts, this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), p), u !== !1), _setEnd(this), _recacheAncestors(this)
        }, i.paused = function(c) {
            return arguments.length ? (this._ps !== c && (this._ps = c, c ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (_wake(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)))), this) : this._ps
        }, i.startTime = function(c) {
            if (arguments.length) {
                this._start = c;
                var u = this.parent || this._dp;
                return u && (u._sort || !this.parent) && _addToTimeline(u, this, c - this._delay), this
            }
            return this._start
        }, i.endTime = function(c) {
            return this._start + (_isNotFalse(c) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }, i.rawTime = function(c) {
            var u = this.parent || this._dp;
            return u ? c && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? _parentToChildTotalTime(u.rawTime(c), this) : this._tTime : this._tTime
        }, i.revert = function(c) {
            c === void 0 && (c = _revertConfig);
            var u = _reverting$1;
            return _reverting$1 = c, _isRevertWorthy(this) && (this.timeline && this.timeline.revert(c), this.totalTime(-.01, c.suppressEvents)), this.data !== "nested" && c.kill !== !1 && this.kill(), _reverting$1 = u, this
        }, i.globalTime = function(c) {
            for (var u = this, p = arguments.length ? c : u.rawTime(); u;) p = u._start + p / (Math.abs(u._ts) || 1), u = u._dp;
            return !this.parent && this._sat ? this._sat.globalTime(c) : p
        }, i.repeat = function(c) {
            return arguments.length ? (this._repeat = c === 1 / 0 ? -2 : c, _onUpdateTotalDuration(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
        }, i.repeatDelay = function(c) {
            if (arguments.length) {
                var u = this._time;
                return this._rDelay = c, _onUpdateTotalDuration(this), u ? this.time(u) : this
            }
            return this._rDelay
        }, i.yoyo = function(c) {
            return arguments.length ? (this._yoyo = c, this) : this._yoyo
        }, i.seek = function(c, u) {
            return this.totalTime(_parsePosition(this, c), _isNotFalse(u))
        }, i.restart = function(c, u) {
            return this.play().totalTime(c ? -this._delay : 0, _isNotFalse(u)), this._dur || (this._zTime = -1e-8), this
        }, i.play = function(c, u) {
            return c != null && this.seek(c, u), this.reversed(!1).paused(!1)
        }, i.reverse = function(c, u) {
            return c != null && this.seek(c || this.totalDuration(), u), this.reversed(!0).paused(!1)
        }, i.pause = function(c, u) {
            return c != null && this.seek(c, u), this.paused(!0)
        }, i.resume = function() {
            return this.paused(!1)
        }, i.reversed = function(c) {
            return arguments.length ? (!!c !== this.reversed() && this.timeScale(-this._rts || (c ? -1e-8 : 0)), this) : this._rts < 0
        }, i.invalidate = function() {
            return this._initted = this._act = 0, this._zTime = -1e-8, this
        }, i.isActive = function() {
            var c = this.parent || this._dp,
                u = this._start,
                p;
            return !!(!c || this._ts && this._initted && c.isActive() && (p = c.rawTime(!0)) >= u && p < this.endTime(!0) - _tinyNum)
        }, i.eventCallback = function(c, u, p) {
            var m = this.vars;
            return arguments.length > 1 ? (u ? (m[c] = u, p && (m[c + "Params"] = p), c === "onUpdate" && (this._onUpdate = u)) : delete m[c], this) : m[c]
        }, i.then = function(c) {
            var u = this;
            return new Promise(function(p) {
                var m = _isFunction(c) ? c : _passThrough,
                    g = function() {
                        var v = u.then;
                        u.then = null, _isFunction(m) && (m = m(u)) && (m.then || m === u) && (u.then = v), p(m), u.then = v
                    };
                u._initted && u.totalProgress() === 1 && u._ts >= 0 || !u._tTime && u._ts < 0 ? g() : u._prom = g
            })
        }, i.kill = function() {
            _interrupt(this)
        }, l
    }();
_setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Timeline = function(l) {
    _inheritsLoose(i, l);

    function i(c, u) {
        var p;
        return c === void 0 && (c = {}), p = l.call(this, c) || this, p.labels = {}, p.smoothChildTiming = !!c.smoothChildTiming, p.autoRemoveChildren = !!c.autoRemoveChildren, p._sort = _isNotFalse(c.sortChildren), _globalTimeline && _addToTimeline(c.parent || _globalTimeline, _assertThisInitialized(p), u), c.reversed && p.reverse(), c.paused && p.paused(!0), c.scrollTrigger && _scrollTrigger(_assertThisInitialized(p), c.scrollTrigger), p
    }
    var o = i.prototype;
    return o.to = function(u, p, m) {
        return _createTweenType(0, arguments, this), this
    }, o.from = function(u, p, m) {
        return _createTweenType(1, arguments, this), this
    }, o.fromTo = function(u, p, m, g) {
        return _createTweenType(2, arguments, this), this
    }, o.set = function(u, p, m) {
        return p.duration = 0, p.parent = this, _inheritDefaults(p).repeatDelay || (p.repeat = 0), p.immediateRender = !!p.immediateRender, new Tween(u, p, _parsePosition(this, m), 1), this
    }, o.call = function(u, p, m) {
        return _addToTimeline(this, Tween.delayedCall(0, u, p), m)
    }, o.staggerTo = function(u, p, m, g, _, v, x) {
        return m.duration = p, m.stagger = m.stagger || g, m.onComplete = v, m.onCompleteParams = x, m.parent = this, new Tween(u, m, _parsePosition(this, _)), this
    }, o.staggerFrom = function(u, p, m, g, _, v, x) {
        return m.runBackwards = 1, _inheritDefaults(m).immediateRender = _isNotFalse(m.immediateRender), this.staggerTo(u, p, m, g, _, v, x)
    }, o.staggerFromTo = function(u, p, m, g, _, v, x, y) {
        return g.startAt = m, _inheritDefaults(g).immediateRender = _isNotFalse(g.immediateRender), this.staggerTo(u, p, g, _, v, x, y)
    }, o.render = function(u, p, m) {
        var g = this._time,
            _ = this._dirty ? this.totalDuration() : this._tDur,
            v = this._dur,
            x = u <= 0 ? 0 : _roundPrecise(u),
            y = this._zTime < 0 != u < 0 && (this._initted || !v),
            b, S, C, E, P, w, T, M, A, D, R, I;
        if (this !== _globalTimeline && x > _ && u >= 0 && (x = _), x !== this._tTime || m || y) {
            if (g !== this._time && v && (x += this._time - g, u += this._time - g), b = x, A = this._start, M = this._ts, w = !M, y && (v || (g = this._zTime), (u || !p) && (this._zTime = u)), this._repeat) {
                if (R = this._yoyo, P = v + this._rDelay, this._repeat < -1 && u < 0) return this.totalTime(P * 100 + u, p, m);
                if (b = _roundPrecise(x % P), x === _ ? (E = this._repeat, b = v) : (D = _roundPrecise(x / P), E = ~~D, E && E === D && (b = v, E--), b > v && (b = v)), D = _animationCycle(this._tTime, P), !g && this._tTime && D !== E && this._tTime - D * P - this._dur <= 0 && (D = E), R && E & 1 && (b = v - b, I = 1), E !== D && !this._lock) {
                    var k = R && D & 1,
                        F = k === (R && E & 1);
                    if (E < D && (k = !k), g = k ? 0 : x % v ? v : x, this._lock = 1, this.render(g || (I ? 0 : _roundPrecise(E * P)), p, !v)._lock = 0, this._tTime = x, !p && this.parent && _callback(this, "onRepeat"), this.vars.repeatRefresh && !I && (this.invalidate()._lock = 1), g && g !== this._time || w !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                    if (v = this._dur, _ = this._tDur, F && (this._lock = 2, g = k ? v : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !I && this.invalidate()), this._lock = 0, !this._ts && !w) return this;
                    _propagateYoyoEase(this, I)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (T = _findNextPauseTween(this, _roundPrecise(g), _roundPrecise(b)), T && (x -= b - (b = T._start))), this._tTime = x, this._time = b, this._act = !M, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = u, g = 0), !g && x && !p && !D && (_callback(this, "onStart"), this._tTime !== x)) return this;
            if (b >= g && u >= 0)
                for (S = this._first; S;) {
                    if (C = S._next, (S._act || b >= S._start) && S._ts && T !== S) {
                        if (S.parent !== this) return this.render(u, p, m);
                        if (S.render(S._ts > 0 ? (b - S._start) * S._ts : (S._dirty ? S.totalDuration() : S._tDur) + (b - S._start) * S._ts, p, m), b !== this._time || !this._ts && !w) {
                            T = 0, C && (x += this._zTime = -1e-8);
                            break
                        }
                    }
                    S = C
                } else {
                    S = this._last;
                    for (var V = u < 0 ? u : b; S;) {
                        if (C = S._prev, (S._act || V <= S._end) && S._ts && T !== S) {
                            if (S.parent !== this) return this.render(u, p, m);
                            if (S.render(S._ts > 0 ? (V - S._start) * S._ts : (S._dirty ? S.totalDuration() : S._tDur) + (V - S._start) * S._ts, p, m || _reverting$1 && _isRevertWorthy(S)), b !== this._time || !this._ts && !w) {
                                T = 0, C && (x += this._zTime = V ? -1e-8 : _tinyNum);
                                break
                            }
                        }
                        S = C
                    }
                }
            if (T && !p && (this.pause(), T.render(b >= g ? 0 : -1e-8)._zTime = b >= g ? 1 : -1, this._ts)) return this._start = A, _setEnd(this), this.render(u, p, m);
            this._onUpdate && !p && _callback(this, "onUpdate", !0), (x === _ && this._tTime >= this.totalDuration() || !x && g) && (A === this._start || Math.abs(M) !== Math.abs(this._ts)) && (this._lock || ((u || !v) && (x === _ && this._ts > 0 || !x && this._ts < 0) && _removeFromParent(this, 1), !p && !(u < 0 && !g) && (x || g || !_) && (_callback(this, x === _ && u >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(x < _ && this.timeScale() > 0) && this._prom())))
        }
        return this
    }, o.add = function(u, p) {
        var m = this;
        if (_isNumber(p) || (p = _parsePosition(this, p, u)), !(u instanceof Animation)) {
            if (_isArray(u)) return u.forEach(function(g) {
                return m.add(g, p)
            }), this;
            if (_isString(u)) return this.addLabel(u, p);
            if (_isFunction(u)) u = Tween.delayedCall(0, u);
            else return this
        }
        return this !== u ? _addToTimeline(this, u, p) : this
    }, o.getChildren = function(u, p, m, g) {
        u === void 0 && (u = !0), p === void 0 && (p = !0), m === void 0 && (m = !0), g === void 0 && (g = -1e8);
        for (var _ = [], v = this._first; v;) v._start >= g && (v instanceof Tween ? p && _.push(v) : (m && _.push(v), u && _.push.apply(_, v.getChildren(!0, p, m)))), v = v._next;
        return _
    }, o.getById = function(u) {
        for (var p = this.getChildren(1, 1, 1), m = p.length; m--;)
            if (p[m].vars.id === u) return p[m]
    }, o.remove = function(u) {
        return _isString(u) ? this.removeLabel(u) : _isFunction(u) ? this.killTweensOf(u) : (u.parent === this && _removeLinkedListItem(this, u), u === this._recent && (this._recent = this._last), _uncache(this))
    }, o.totalTime = function(u, p) {
        return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? u / this._ts : (this.totalDuration() - u) / -this._ts))), l.prototype.totalTime.call(this, u, p), this._forcing = 0, this) : this._tTime
    }, o.addLabel = function(u, p) {
        return this.labels[u] = _parsePosition(this, p), this
    }, o.removeLabel = function(u) {
        return delete this.labels[u], this
    }, o.addPause = function(u, p, m) {
        var g = Tween.delayedCall(0, p || _emptyFunc, m);
        return g.data = "isPause", this._hasPause = 1, _addToTimeline(this, g, _parsePosition(this, u))
    }, o.removePause = function(u) {
        var p = this._first;
        for (u = _parsePosition(this, u); p;) p._start === u && p.data === "isPause" && _removeFromParent(p), p = p._next
    }, o.killTweensOf = function(u, p, m) {
        for (var g = this.getTweensOf(u, m), _ = g.length; _--;) _overwritingTween !== g[_] && g[_].kill(u, p);
        return this
    }, o.getTweensOf = function(u, p) {
        for (var m = [], g = toArray(u), _ = this._first, v = _isNumber(p), x; _;) _ instanceof Tween ? _arrayContainsAny(_._targets, g) && (v ? (!_overwritingTween || _._initted && _._ts) && _.globalTime(0) <= p && _.globalTime(_.totalDuration()) > p : !p || _.isActive()) && m.push(_) : (x = _.getTweensOf(g, p)).length && m.push.apply(m, x), _ = _._next;
        return m
    }, o.tweenTo = function(u, p) {
        p = p || {};
        var m = this,
            g = _parsePosition(m, u),
            _ = p,
            v = _.startAt,
            x = _.onStart,
            y = _.onStartParams,
            b = _.immediateRender,
            S, C = Tween.to(m, _setDefaults({
                ease: p.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: g,
                overwrite: "auto",
                duration: p.duration || Math.abs((g - (v && "time" in v ? v.time : m._time)) / m.timeScale()) || _tinyNum,
                onStart: function() {
                    if (m.pause(), !S) {
                        var P = p.duration || Math.abs((g - (v && "time" in v ? v.time : m._time)) / m.timeScale());
                        C._dur !== P && _setDuration(C, P, 0, 1).render(C._time, !0, !0), S = 1
                    }
                    x && x.apply(C, y || [])
                }
            }, p));
        return b ? C.render(0) : C
    }, o.tweenFromTo = function(u, p, m) {
        return this.tweenTo(p, _setDefaults({
            startAt: {
                time: _parsePosition(this, u)
            }
        }, m))
    }, o.recent = function() {
        return this._recent
    }, o.nextLabel = function(u) {
        return u === void 0 && (u = this._time), _getLabelInDirection(this, _parsePosition(this, u))
    }, o.previousLabel = function(u) {
        return u === void 0 && (u = this._time), _getLabelInDirection(this, _parsePosition(this, u), 1)
    }, o.currentLabel = function(u) {
        return arguments.length ? this.seek(u, !0) : this.previousLabel(this._time + _tinyNum)
    }, o.shiftChildren = function(u, p, m) {
        m === void 0 && (m = 0);
        for (var g = this._first, _ = this.labels, v; g;) g._start >= m && (g._start += u, g._end += u), g = g._next;
        if (p)
            for (v in _) _[v] >= m && (_[v] += u);
        return _uncache(this)
    }, o.invalidate = function(u) {
        var p = this._first;
        for (this._lock = 0; p;) p.invalidate(u), p = p._next;
        return l.prototype.invalidate.call(this, u)
    }, o.clear = function(u) {
        u === void 0 && (u = !0);
        for (var p = this._first, m; p;) m = p._next, this.remove(p), p = m;
        return this._dp && (this._time = this._tTime = this._pTime = 0), u && (this.labels = {}), _uncache(this)
    }, o.totalDuration = function(u) {
        var p = 0,
            m = this,
            g = m._last,
            _ = _bigNum$1,
            v, x, y;
        if (arguments.length) return m.timeScale((m._repeat < 0 ? m.duration() : m.totalDuration()) / (m.reversed() ? -u : u));
        if (m._dirty) {
            for (y = m.parent; g;) v = g._prev, g._dirty && g.totalDuration(), x = g._start, x > _ && m._sort && g._ts && !m._lock ? (m._lock = 1, _addToTimeline(m, g, x - g._delay, 1)._lock = 0) : _ = x, x < 0 && g._ts && (p -= x, (!y && !m._dp || y && y.smoothChildTiming) && (m._start += x / m._ts, m._time -= x, m._tTime -= x), m.shiftChildren(-x, !1, -1 / 0), _ = 0), g._end > p && g._ts && (p = g._end), g = v;
            _setDuration(m, m === _globalTimeline && m._time > p ? m._time : p, 1, 1), m._dirty = 0
        }
        return m._tDur
    }, i.updateRoot = function(u) {
        if (_globalTimeline._ts && (_lazySafeRender(_globalTimeline, _parentToChildTotalTime(u, _globalTimeline)), _lastRenderedFrame = _ticker.frame), _ticker.frame >= _nextGCFrame) {
            _nextGCFrame += _config.autoSleep || 120;
            var p = _globalTimeline._first;
            if ((!p || !p._ts) && _config.autoSleep && _ticker._listeners.length < 2) {
                for (; p && !p._ts;) p = p._next;
                p || _ticker.sleep()
            }
        }
    }, i
}(Animation);
_setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var _addComplexStringPropTween = function(i, o, c, u, p, m, g) {
        var _ = new PropTween(this._pt, i, o, 0, 1, _renderComplexString, null, p),
            v = 0,
            x = 0,
            y, b, S, C, E, P, w, T;
        for (_.b = c, _.e = u, c += "", u += "", (w = ~u.indexOf("random(")) && (u = _replaceRandom(u)), m && (T = [c, u], m(T, i, o), c = T[0], u = T[1]), b = c.match(_complexStringNumExp) || []; y = _complexStringNumExp.exec(u);) C = y[0], E = u.substring(v, y.index), S ? S = (S + 1) % 5 : E.substr(-5) === "rgba(" && (S = 1), C !== b[x++] && (P = parseFloat(b[x - 1]) || 0, _._pt = {
            _next: _._pt,
            p: E || x === 1 ? E : ",",
            s: P,
            c: C.charAt(1) === "=" ? _parseRelative(P, C) - P : parseFloat(C) - P,
            m: S && S < 4 ? Math.round : 0
        }, v = _complexStringNumExp.lastIndex);
        return _.c = v < u.length ? u.substring(v, u.length) : "", _.fp = g, (_relExp.test(u) || w) && (_.e = 0), this._pt = _, _
    },
    _addPropTween = function(i, o, c, u, p, m, g, _, v, x) {
        _isFunction(u) && (u = u(p || 0, i, m));
        var y = i[o],
            b = c !== "get" ? c : _isFunction(y) ? v ? i[o.indexOf("set") || !_isFunction(i["get" + o.substr(3)]) ? o : "get" + o.substr(3)](v) : i[o]() : y,
            S = _isFunction(y) ? v ? _setterFuncWithParam : _setterFunc : _setterPlain,
            C;
        if (_isString(u) && (~u.indexOf("random(") && (u = _replaceRandom(u)), u.charAt(1) === "=" && (C = _parseRelative(b, u) + (getUnit(b) || 0), (C || C === 0) && (u = C))), !x || b !== u || _forceAllPropTweens) return !isNaN(b * u) && u !== "" ? (C = new PropTween(this._pt, i, o, +b || 0, u - (b || 0), typeof y == "boolean" ? _renderBoolean : _renderPlain, 0, S), v && (C.fp = v), g && C.modifier(g, this, i), this._pt = C) : (!y && !(o in i) && _missingPlugin(o, u), _addComplexStringPropTween.call(this, i, o, b, u, S, _ || _config.stringFilter, v))
    },
    _processVars = function(i, o, c, u, p) {
        if (_isFunction(i) && (i = _parseFuncOrString(i, p, o, c, u)), !_isObject(i) || i.style && i.nodeType || _isArray(i) || _isTypedArray(i)) return _isString(i) ? _parseFuncOrString(i, p, o, c, u) : i;
        var m = {},
            g;
        for (g in i) m[g] = _parseFuncOrString(i[g], p, o, c, u);
        return m
    },
    _checkPlugin = function(i, o, c, u, p, m) {
        var g, _, v, x;
        if (_plugins[i] && (g = new _plugins[i]).init(p, g.rawVars ? o[i] : _processVars(o[i], u, p, m, c), c, u, m) !== !1 && (c._pt = _ = new PropTween(c._pt, p, i, 0, 1, g.render, g, 0, g.priority), c !== _quickTween))
            for (v = c._ptLookup[c._targets.indexOf(p)], x = g._props.length; x--;) v[g._props[x]] = _;
        return g
    },
    _overwritingTween, _forceAllPropTweens, _initTween = function l(i, o, c) {
        var u = i.vars,
            p = u.ease,
            m = u.startAt,
            g = u.immediateRender,
            _ = u.lazy,
            v = u.onUpdate,
            x = u.runBackwards,
            y = u.yoyoEase,
            b = u.keyframes,
            S = u.autoRevert,
            C = i._dur,
            E = i._startAt,
            P = i._targets,
            w = i.parent,
            T = w && w.data === "nested" ? w.vars.targets : P,
            M = i._overwrite === "auto" && !_suppressOverwrites,
            A = i.timeline,
            D, R, I, k, F, V, B, U, H, Q, Y, O, G;
        if (A && (!b || !p) && (p = "none"), i._ease = _parseEase(p, _defaults.ease), i._yEase = y ? _invertEase(_parseEase(y === !0 ? p : y, _defaults.ease)) : 0, y && i._yoyo && !i._repeat && (y = i._yEase, i._yEase = i._ease, i._ease = y), i._from = !A && !!u.runBackwards, !A || b && !u.stagger) {
            if (U = P[0] ? _getCache(P[0]).harness : 0, O = U && u[U.prop], D = _copyExcluding(u, _reservedProps), E && (E._zTime < 0 && E.progress(1), o < 0 && x && g && !S ? E.render(-1, !0) : E.revert(x && C ? _revertConfigNoKill : _startAtRevertConfig), E._lazy = 0), m) {
                if (_removeFromParent(i._startAt = Tween.set(P, _setDefaults({
                        data: "isStart",
                        overwrite: !1,
                        parent: w,
                        immediateRender: !0,
                        lazy: !E && _isNotFalse(_),
                        startAt: null,
                        delay: 0,
                        onUpdate: v && function() {
                            return _callback(i, "onUpdate")
                        },
                        stagger: 0
                    }, m))), i._startAt._dp = 0, i._startAt._sat = i, o < 0 && (_reverting$1 || !g && !S) && i._startAt.revert(_revertConfigNoKill), g && C && o <= 0 && c <= 0) {
                    o && (i._zTime = o);
                    return
                }
            } else if (x && C && !E) {
                if (o && (g = !1), I = _setDefaults({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: g && !E && _isNotFalse(_),
                        immediateRender: g,
                        stagger: 0,
                        parent: w
                    }, D), O && (I[U.prop] = O), _removeFromParent(i._startAt = Tween.set(P, I)), i._startAt._dp = 0, i._startAt._sat = i, o < 0 && (_reverting$1 ? i._startAt.revert(_revertConfigNoKill) : i._startAt.render(-1, !0)), i._zTime = o, !g) l(i._startAt, _tinyNum, _tinyNum);
                else if (!o) return
            }
            for (i._pt = i._ptCache = 0, _ = C && _isNotFalse(_) || _ && !C, R = 0; R < P.length; R++) {
                if (F = P[R], B = F._gsap || _harness(P)[R]._gsap, i._ptLookup[R] = Q = {}, _lazyLookup[B.id] && _lazyTweens.length && _lazyRender(), Y = T === P ? R : T.indexOf(F), U && (H = new U).init(F, O || D, i, Y, T) !== !1 && (i._pt = k = new PropTween(i._pt, F, H.name, 0, 1, H.render, H, 0, H.priority), H._props.forEach(function(L) {
                        Q[L] = k
                    }), H.priority && (V = 1)), !U || O)
                    for (I in D) _plugins[I] && (H = _checkPlugin(I, D, i, Y, F, T)) ? H.priority && (V = 1) : Q[I] = k = _addPropTween.call(i, F, I, "get", D[I], Y, T, 0, u.stringFilter);
                i._op && i._op[R] && i.kill(F, i._op[R]), M && i._pt && (_overwritingTween = i, _globalTimeline.killTweensOf(F, Q, i.globalTime(o)), G = !i.parent, _overwritingTween = 0), i._pt && _ && (_lazyLookup[B.id] = 1)
            }
            V && _sortPropTweensByPriority(i), i._onInit && i._onInit(i)
        }
        i._onUpdate = v, i._initted = (!i._op || i._pt) && !G, b && o <= 0 && A.render(_bigNum$1, !0, !0)
    },
    _updatePropTweens = function(i, o, c, u, p, m, g, _) {
        var v = (i._pt && i._ptCache || (i._ptCache = {}))[o],
            x, y, b, S;
        if (!v)
            for (v = i._ptCache[o] = [], b = i._ptLookup, S = i._targets.length; S--;) {
                if (x = b[S][o], x && x.d && x.d._pt)
                    for (x = x.d._pt; x && x.p !== o && x.fp !== o;) x = x._next;
                if (!x) return _forceAllPropTweens = 1, i.vars[o] = "+=0", _initTween(i, g), _forceAllPropTweens = 0, _ ? _warn(o + " not eligible for reset") : 1;
                v.push(x)
            }
        for (S = v.length; S--;) y = v[S], x = y._pt || y, x.s = (u || u === 0) && !p ? u : x.s + (u || 0) + m * x.c, x.c = c - x.s, y.e && (y.e = _round(c) + getUnit(y.e)), y.b && (y.b = x.s + getUnit(y.b))
    },
    _addAliasesToVars = function(i, o) {
        var c = i[0] ? _getCache(i[0]).harness : 0,
            u = c && c.aliases,
            p, m, g, _;
        if (!u) return o;
        p = _merge({}, o);
        for (m in u)
            if (m in p)
                for (_ = u[m].split(","), g = _.length; g--;) p[_[g]] = p[m];
        return p
    },
    _parseKeyframe = function(i, o, c, u) {
        var p = o.ease || u || "power1.inOut",
            m, g;
        if (_isArray(o)) g = c[i] || (c[i] = []), o.forEach(function(_, v) {
            return g.push({
                t: v / (o.length - 1) * 100,
                v: _,
                e: p
            })
        });
        else
            for (m in o) g = c[m] || (c[m] = []), m === "ease" || g.push({
                t: parseFloat(i),
                v: o[m],
                e: p
            })
    },
    _parseFuncOrString = function(i, o, c, u, p) {
        return _isFunction(i) ? i.call(o, c, u, p) : _isString(i) && ~i.indexOf("random(") ? _replaceRandom(i) : i
    },
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    _staggerPropsToSkip = {};
_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(l) {
    return _staggerPropsToSkip[l] = 1
});
var Tween = function(l) {
    _inheritsLoose(i, l);

    function i(c, u, p, m) {
        var g;
        typeof u == "number" && (p.duration = u, u = p, p = null), g = l.call(this, m ? u : _inheritDefaults(u)) || this;
        var _ = g.vars,
            v = _.duration,
            x = _.delay,
            y = _.immediateRender,
            b = _.stagger,
            S = _.overwrite,
            C = _.keyframes,
            E = _.defaults,
            P = _.scrollTrigger,
            w = _.yoyoEase,
            T = u.parent || _globalTimeline,
            M = (_isArray(c) || _isTypedArray(c) ? _isNumber(c[0]) : "length" in u) ? [c] : toArray(c),
            A, D, R, I, k, F, V, B;
        if (g._targets = M.length ? _harness(M) : _warn("GSAP target " + c + " not found. https://gsap.com", !_config.nullTargetWarn) || [], g._ptLookup = [], g._overwrite = S, C || b || _isFuncOrString(v) || _isFuncOrString(x)) {
            if (u = g.vars, A = g.timeline = new Timeline({
                    data: "nested",
                    defaults: E || {},
                    targets: T && T.data === "nested" ? T.vars.targets : M
                }), A.kill(), A.parent = A._dp = _assertThisInitialized(g), A._start = 0, b || _isFuncOrString(v) || _isFuncOrString(x)) {
                if (I = M.length, V = b && distribute(b), _isObject(b))
                    for (k in b) ~_staggerTweenProps.indexOf(k) && (B || (B = {}), B[k] = b[k]);
                for (D = 0; D < I; D++) R = _copyExcluding(u, _staggerPropsToSkip), R.stagger = 0, w && (R.yoyoEase = w), B && _merge(R, B), F = M[D], R.duration = +_parseFuncOrString(v, _assertThisInitialized(g), D, F, M), R.delay = (+_parseFuncOrString(x, _assertThisInitialized(g), D, F, M) || 0) - g._delay, !b && I === 1 && R.delay && (g._delay = x = R.delay, g._start += x, R.delay = 0), A.to(F, R, V ? V(D, F, M) : 0), A._ease = _easeMap.none;
                A.duration() ? v = x = 0 : g.timeline = 0
            } else if (C) {
                _inheritDefaults(_setDefaults(A.vars.defaults, {
                    ease: "none"
                })), A._ease = _parseEase(C.ease || u.ease || "none");
                var U = 0,
                    H, Q, Y;
                if (_isArray(C)) C.forEach(function(O) {
                    return A.to(M, O, ">")
                }), A.duration();
                else {
                    R = {};
                    for (k in C) k === "ease" || k === "easeEach" || _parseKeyframe(k, C[k], R, C.easeEach);
                    for (k in R)
                        for (H = R[k].sort(function(O, G) {
                                return O.t - G.t
                            }), U = 0, D = 0; D < H.length; D++) Q = H[D], Y = {
                            ease: Q.e,
                            duration: (Q.t - (D ? H[D - 1].t : 0)) / 100 * v
                        }, Y[k] = Q.v, A.to(M, Y, U), U += Y.duration;
                    A.duration() < v && A.to({}, {
                        duration: v - A.duration()
                    })
                }
            }
            v || g.duration(v = A.duration())
        } else g.timeline = 0;
        return S === !0 && !_suppressOverwrites && (_overwritingTween = _assertThisInitialized(g), _globalTimeline.killTweensOf(M), _overwritingTween = 0), _addToTimeline(T, _assertThisInitialized(g), p), u.reversed && g.reverse(), u.paused && g.paused(!0), (y || !v && !C && g._start === _roundPrecise(T._time) && _isNotFalse(y) && _hasNoPausedAncestors(_assertThisInitialized(g)) && T.data !== "nested") && (g._tTime = -1e-8, g.render(Math.max(0, -x) || 0)), P && _scrollTrigger(_assertThisInitialized(g), P), g
    }
    var o = i.prototype;
    return o.render = function(u, p, m) {
        var g = this._time,
            _ = this._tDur,
            v = this._dur,
            x = u < 0,
            y = u > _ - _tinyNum && !x ? _ : u < _tinyNum ? 0 : u,
            b, S, C, E, P, w, T, M, A;
        if (!v) _renderZeroDurationTween(this, u, p, m);
        else if (y !== this._tTime || !u || m || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== x || this._lazy) {
            if (b = y, M = this.timeline, this._repeat) {
                if (E = v + this._rDelay, this._repeat < -1 && x) return this.totalTime(E * 100 + u, p, m);
                if (b = _roundPrecise(y % E), y === _ ? (C = this._repeat, b = v) : (P = _roundPrecise(y / E), C = ~~P, C && C === P ? (b = v, C--) : b > v && (b = v)), w = this._yoyo && C & 1, w && (A = this._yEase, b = v - b), P = _animationCycle(this._tTime, E), b === g && !m && this._initted && C === P) return this._tTime = y, this;
                C !== P && (M && this._yEase && _propagateYoyoEase(M, w), this.vars.repeatRefresh && !w && !this._lock && b !== E && this._initted && (this._lock = m = 1, this.render(_roundPrecise(E * C), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (_attemptInitTween(this, x ? u : b, m, p, y)) return this._tTime = 0, this;
                if (g !== this._time && !(m && this.vars.repeatRefresh && C !== P)) return this;
                if (v !== this._dur) return this.render(u, p, m)
            }
            if (this._tTime = y, this._time = b, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = T = (A || this._ease)(b / v), this._from && (this.ratio = T = 1 - T), !g && y && !p && !P && (_callback(this, "onStart"), this._tTime !== y)) return this;
            for (S = this._pt; S;) S.r(T, S.d), S = S._next;
            M && M.render(u < 0 ? u : M._dur * M._ease(b / this._dur), p, m) || this._startAt && (this._zTime = u), this._onUpdate && !p && (x && _rewindStartAt(this, u, p, m), _callback(this, "onUpdate")), this._repeat && C !== P && this.vars.onRepeat && !p && this.parent && _callback(this, "onRepeat"), (y === this._tDur || !y) && this._tTime === y && (x && !this._onUpdate && _rewindStartAt(this, u, !0, !0), (u || !v) && (y === this._tDur && this._ts > 0 || !y && this._ts < 0) && _removeFromParent(this, 1), !p && !(x && !g) && (y || g || w) && (_callback(this, y === _ ? "onComplete" : "onReverseComplete", !0), this._prom && !(y < _ && this.timeScale() > 0) && this._prom()))
        }
        return this
    }, o.targets = function() {
        return this._targets
    }, o.invalidate = function(u) {
        return (!u || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(u), l.prototype.invalidate.call(this, u)
    }, o.resetTo = function(u, p, m, g, _) {
        _tickerActive || _ticker.wake(), this._ts || this.play();
        var v = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
            x;
        return this._initted || _initTween(this, v), x = this._ease(v / this._dur), _updatePropTweens(this, u, p, m, g, x, v, _) ? this.resetTo(u, p, m, g, 1) : (_alignPlayhead(this, 0), this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
    }, o.kill = function(u, p) {
        if (p === void 0 && (p = "all"), !u && (!p || p === "all")) return this._lazy = this._pt = 0, this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting$1), this;
        if (this.timeline) {
            var m = this.timeline.totalDuration();
            return this.timeline.killTweensOf(u, p, _overwritingTween && _overwritingTween.vars.overwrite !== !0)._first || _interrupt(this), this.parent && m !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / m, 0, 1), this
        }
        var g = this._targets,
            _ = u ? toArray(u) : g,
            v = this._ptLookup,
            x = this._pt,
            y, b, S, C, E, P, w;
        if ((!p || p === "all") && _arraysMatch(g, _)) return p === "all" && (this._pt = 0), _interrupt(this);
        for (y = this._op = this._op || [], p !== "all" && (_isString(p) && (E = {}, _forEachName(p, function(T) {
                return E[T] = 1
            }), p = E), p = _addAliasesToVars(g, p)), w = g.length; w--;)
            if (~_.indexOf(g[w])) {
                b = v[w], p === "all" ? (y[w] = p, C = b, S = {}) : (S = y[w] = y[w] || {}, C = p);
                for (E in C) P = b && b[E], P && ((!("kill" in P.d) || P.d.kill(E) === !0) && _removeLinkedListItem(this, P, "_pt"), delete b[E]), S !== "all" && (S[E] = 1)
            }
        return this._initted && !this._pt && x && _interrupt(this), this
    }, i.to = function(u, p) {
        return new i(u, p, arguments[2])
    }, i.from = function(u, p) {
        return _createTweenType(1, arguments)
    }, i.delayedCall = function(u, p, m, g) {
        return new i(p, 0, {
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: u,
            onComplete: p,
            onReverseComplete: p,
            onCompleteParams: m,
            onReverseCompleteParams: m,
            callbackScope: g
        })
    }, i.fromTo = function(u, p, m) {
        return _createTweenType(2, arguments)
    }, i.set = function(u, p) {
        return p.duration = 0, p.repeatDelay || (p.repeat = 0), new i(u, p)
    }, i.killTweensOf = function(u, p, m) {
        return _globalTimeline.killTweensOf(u, p, m)
    }, i
}(Animation);
_setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
_forEachName("staggerTo,staggerFrom,staggerFromTo", function(l) {
    Tween[l] = function() {
        var i = new Timeline,
            o = _slice.call(arguments, 0);
        return o.splice(l === "staggerFromTo" ? 5 : 4, 0, 0), i[l].apply(i, o)
    }
});
var _setterPlain = function(i, o, c) {
        return i[o] = c
    },
    _setterFunc = function(i, o, c) {
        return i[o](c)
    },
    _setterFuncWithParam = function(i, o, c, u) {
        return i[o](u.fp, c)
    },
    _setterAttribute = function(i, o, c) {
        return i.setAttribute(o, c)
    },
    _getSetter = function(i, o) {
        return _isFunction(i[o]) ? _setterFunc : _isUndefined(i[o]) && i.setAttribute ? _setterAttribute : _setterPlain
    },
    _renderPlain = function(i, o) {
        return o.set(o.t, o.p, Math.round((o.s + o.c * i) * 1e6) / 1e6, o)
    },
    _renderBoolean = function(i, o) {
        return o.set(o.t, o.p, !!(o.s + o.c * i), o)
    },
    _renderComplexString = function(i, o) {
        var c = o._pt,
            u = "";
        if (!i && o.b) u = o.b;
        else if (i === 1 && o.e) u = o.e;
        else {
            for (; c;) u = c.p + (c.m ? c.m(c.s + c.c * i) : Math.round((c.s + c.c * i) * 1e4) / 1e4) + u, c = c._next;
            u += o.c
        }
        o.set(o.t, o.p, u, o)
    },
    _renderPropTweens = function(i, o) {
        for (var c = o._pt; c;) c.r(i, c.d), c = c._next
    },
    _addPluginModifier = function(i, o, c, u) {
        for (var p = this._pt, m; p;) m = p._next, p.p === u && p.modifier(i, o, c), p = m
    },
    _killPropTweensOf = function(i) {
        for (var o = this._pt, c, u; o;) u = o._next, o.p === i && !o.op || o.op === i ? _removeLinkedListItem(this, o, "_pt") : o.dep || (c = 1), o = u;
        return !c
    },
    _setterWithModifier = function(i, o, c, u) {
        u.mSet(i, o, u.m.call(u.tween, c, u.mt), u)
    },
    _sortPropTweensByPriority = function(i) {
        for (var o = i._pt, c, u, p, m; o;) {
            for (c = o._next, u = p; u && u.pr > o.pr;) u = u._next;
            (o._prev = u ? u._prev : m) ? o._prev._next = o: p = o, (o._next = u) ? u._prev = o : m = o, o = c
        }
        i._pt = p
    },
    PropTween = function() {
        function l(o, c, u, p, m, g, _, v, x) {
            this.t = c, this.s = p, this.c = m, this.p = u, this.r = g || _renderPlain, this.d = _ || this, this.set = v || _setterPlain, this.pr = x || 0, this._next = o, o && (o._prev = this)
        }
        var i = l.prototype;
        return i.modifier = function(c, u, p) {
            this.mSet = this.mSet || this.set, this.set = _setterWithModifier, this.m = c, this.mt = p, this.tween = u
        }, l
    }();
_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(l) {
    return _reservedProps[l] = 1
});
_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
    sortChildren: !1,
    defaults: _defaults,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
_config.stringFilter = _colorStringFilter;
var _media = [],
    _listeners = {},
    _emptyArray$1 = [],
    _lastMediaTime = 0,
    _contextID = 0,
    _dispatch = function(i) {
        return (_listeners[i] || _emptyArray$1).map(function(o) {
            return o()
        })
    },
    _onMediaChange = function() {
        var i = Date.now(),
            o = [];
        i - _lastMediaTime > 2 && (_dispatch("matchMediaInit"), _media.forEach(function(c) {
            var u = c.queries,
                p = c.conditions,
                m, g, _, v;
            for (g in u) m = _win$1.matchMedia(u[g]).matches, m && (_ = 1), m !== p[g] && (p[g] = m, v = 1);
            v && (c.revert(), _ && o.push(c))
        }), _dispatch("matchMediaRevert"), o.forEach(function(c) {
            return c.onMatch(c, function(u) {
                return c.add(null, u)
            })
        }), _lastMediaTime = i, _dispatch("matchMedia"))
    },
    Context = function() {
        function l(o, c) {
            this.selector = c && selector(c), this.data = [], this._r = [], this.isReverted = !1, this.id = _contextID++, o && this.add(o)
        }
        var i = l.prototype;
        return i.add = function(c, u, p) {
            _isFunction(c) && (p = u, u = c, c = _isFunction);
            var m = this,
                g = function() {
                    var v = _context$1,
                        x = m.selector,
                        y;
                    return v && v !== m && v.data.push(m), p && (m.selector = selector(p)), _context$1 = m, y = u.apply(m, arguments), _isFunction(y) && m._r.push(y), _context$1 = v, m.selector = x, m.isReverted = !1, y
                };
            return m.last = g, c === _isFunction ? g(m, function(_) {
                return m.add(null, _)
            }) : c ? m[c] = g : g
        }, i.ignore = function(c) {
            var u = _context$1;
            _context$1 = null, c(this), _context$1 = u
        }, i.getTweens = function() {
            var c = [];
            return this.data.forEach(function(u) {
                return u instanceof l ? c.push.apply(c, u.getTweens()) : u instanceof Tween && !(u.parent && u.parent.data === "nested") && c.push(u)
            }), c
        }, i.clear = function() {
            this._r.length = this.data.length = 0
        }, i.kill = function(c, u) {
            var p = this;
            if (c ? function() {
                    for (var g = p.getTweens(), _ = p.data.length, v; _--;) v = p.data[_], v.data === "isFlip" && (v.revert(), v.getChildren(!0, !0, !1).forEach(function(x) {
                        return g.splice(g.indexOf(x), 1)
                    }));
                    for (g.map(function(x) {
                            return {
                                g: x._dur || x._delay || x._sat && !x._sat.vars.immediateRender ? x.globalTime(0) : -1 / 0,
                                t: x
                            }
                        }).sort(function(x, y) {
                            return y.g - x.g || -1 / 0
                        }).forEach(function(x) {
                            return x.t.revert(c)
                        }), _ = p.data.length; _--;) v = p.data[_], v instanceof Timeline ? v.data !== "nested" && (v.scrollTrigger && v.scrollTrigger.revert(), v.kill()) : !(v instanceof Tween) && v.revert && v.revert(c);
                    p._r.forEach(function(x) {
                        return x(c, p)
                    }), p.isReverted = !0
                }() : this.data.forEach(function(g) {
                    return g.kill && g.kill()
                }), this.clear(), u)
                for (var m = _media.length; m--;) _media[m].id === this.id && _media.splice(m, 1)
        }, i.revert = function(c) {
            this.kill(c || {})
        }, l
    }(),
    MatchMedia = function() {
        function l(o) {
            this.contexts = [], this.scope = o, _context$1 && _context$1.data.push(this)
        }
        var i = l.prototype;
        return i.add = function(c, u, p) {
            _isObject(c) || (c = {
                matches: c
            });
            var m = new Context(0, p || this.scope),
                g = m.conditions = {},
                _, v, x;
            _context$1 && !m.selector && (m.selector = _context$1.selector), this.contexts.push(m), u = m.add("onMatch", u), m.queries = c;
            for (v in c) v === "all" ? x = 1 : (_ = _win$1.matchMedia(c[v]), _ && (_media.indexOf(m) < 0 && _media.push(m), (g[v] = _.matches) && (x = 1), _.addListener ? _.addListener(_onMediaChange) : _.addEventListener("change", _onMediaChange)));
            return x && u(m, function(y) {
                return m.add(null, y)
            }), this
        }, i.revert = function(c) {
            this.kill(c || {})
        }, i.kill = function(c) {
            this.contexts.forEach(function(u) {
                return u.kill(c, !0)
            })
        }, l
    }(),
    _gsap = {
        registerPlugin: function() {
            for (var i = arguments.length, o = new Array(i), c = 0; c < i; c++) o[c] = arguments[c];
            o.forEach(function(u) {
                return _createPlugin(u)
            })
        },
        timeline: function(i) {
            return new Timeline(i)
        },
        getTweensOf: function(i, o) {
            return _globalTimeline.getTweensOf(i, o)
        },
        getProperty: function(i, o, c, u) {
            _isString(i) && (i = toArray(i)[0]);
            var p = _getCache(i || {}).get,
                m = c ? _passThrough : _numericIfPossible;
            return c === "native" && (c = ""), i && (o ? m((_plugins[o] && _plugins[o].get || p)(i, o, c, u)) : function(g, _, v) {
                return m((_plugins[g] && _plugins[g].get || p)(i, g, _, v))
            })
        },
        quickSetter: function(i, o, c) {
            if (i = toArray(i), i.length > 1) {
                var u = i.map(function(x) {
                        return gsap$1.quickSetter(x, o, c)
                    }),
                    p = u.length;
                return function(x) {
                    for (var y = p; y--;) u[y](x)
                }
            }
            i = i[0] || {};
            var m = _plugins[o],
                g = _getCache(i),
                _ = g.harness && (g.harness.aliases || {})[o] || o,
                v = m ? function(x) {
                    var y = new m;
                    _quickTween._pt = 0, y.init(i, c ? x + c : x, _quickTween, 0, [i]), y.render(1, y), _quickTween._pt && _renderPropTweens(1, _quickTween)
                } : g.set(i, _);
            return m ? v : function(x) {
                return v(i, _, c ? x + c : x, g, 1)
            }
        },
        quickTo: function(i, o, c) {
            var u, p = gsap$1.to(i, _setDefaults((u = {}, u[o] = "+=0.1", u.paused = !0, u.stagger = 0, u), c || {})),
                m = function(_, v, x) {
                    return p.resetTo(o, _, v, x)
                };
            return m.tween = p, m
        },
        isTweening: function(i) {
            return _globalTimeline.getTweensOf(i, !0).length > 0
        },
        defaults: function(i) {
            return i && i.ease && (i.ease = _parseEase(i.ease, _defaults.ease)), _mergeDeep(_defaults, i || {})
        },
        config: function(i) {
            return _mergeDeep(_config, i || {})
        },
        registerEffect: function(i) {
            var o = i.name,
                c = i.effect,
                u = i.plugins,
                p = i.defaults,
                m = i.extendTimeline;
            (u || "").split(",").forEach(function(g) {
                return g && !_plugins[g] && !_globals[g] && _warn(o + " effect requires " + g + " plugin.")
            }), _effects[o] = function(g, _, v) {
                return c(toArray(g), _setDefaults(_ || {}, p), v)
            }, m && (Timeline.prototype[o] = function(g, _, v) {
                return this.add(_effects[o](g, _isObject(_) ? _ : (v = _) && {}, this), v)
            })
        },
        registerEase: function(i, o) {
            _easeMap[i] = _parseEase(o)
        },
        parseEase: function(i, o) {
            return arguments.length ? _parseEase(i, o) : _easeMap
        },
        getById: function(i) {
            return _globalTimeline.getById(i)
        },
        exportRoot: function(i, o) {
            i === void 0 && (i = {});
            var c = new Timeline(i),
                u, p;
            for (c.smoothChildTiming = _isNotFalse(i.smoothChildTiming), _globalTimeline.remove(c), c._dp = 0, c._time = c._tTime = _globalTimeline._time, u = _globalTimeline._first; u;) p = u._next, (o || !(!u._dur && u instanceof Tween && u.vars.onComplete === u._targets[0])) && _addToTimeline(c, u, u._start - u._delay), u = p;
            return _addToTimeline(_globalTimeline, c, 0), c
        },
        context: function(i, o) {
            return i ? new Context(i, o) : _context$1
        },
        matchMedia: function(i) {
            return new MatchMedia(i)
        },
        matchMediaRefresh: function() {
            return _media.forEach(function(i) {
                var o = i.conditions,
                    c, u;
                for (u in o) o[u] && (o[u] = !1, c = 1);
                c && i.revert()
            }) || _onMediaChange()
        },
        addEventListener: function(i, o) {
            var c = _listeners[i] || (_listeners[i] = []);
            ~c.indexOf(o) || c.push(o)
        },
        removeEventListener: function(i, o) {
            var c = _listeners[i],
                u = c && c.indexOf(o);
            u >= 0 && c.splice(u, 1)
        },
        utils: {
            wrap,
            wrapYoyo,
            distribute,
            random,
            snap,
            normalize,
            getUnit,
            clamp,
            splitColor,
            toArray,
            selector,
            mapRange,
            pipe,
            unitize,
            interpolate,
            shuffle
        },
        install: _install,
        effects: _effects,
        ticker: _ticker,
        updateRoot: Timeline.updateRoot,
        plugins: _plugins,
        globalTimeline: _globalTimeline,
        core: {
            PropTween,
            globals: _addGlobal,
            Tween,
            Timeline,
            Animation,
            getCache: _getCache,
            _removeLinkedListItem,
            reverting: function() {
                return _reverting$1
            },
            context: function(i) {
                return i && _context$1 && (_context$1.data.push(i), i._ctx = _context$1), _context$1
            },
            suppressOverwrites: function(i) {
                return _suppressOverwrites = i
            }
        }
    };
_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(l) {
    return _gsap[l] = Tween[l]
});
_ticker.add(Timeline.updateRoot);
_quickTween = _gsap.to({}, {
    duration: 0
});
var _getPluginPropTween = function(i, o) {
        for (var c = i._pt; c && c.p !== o && c.op !== o && c.fp !== o;) c = c._next;
        return c
    },
    _addModifiers = function(i, o) {
        var c = i._targets,
            u, p, m;
        for (u in o)
            for (p = c.length; p--;) m = i._ptLookup[p][u], m && (m = m.d) && (m._pt && (m = _getPluginPropTween(m, u)), m && m.modifier && m.modifier(o[u], i, c[p], u))
    },
    _buildModifierPlugin = function(i, o) {
        return {
            name: i,
            headless: 1,
            rawVars: 1,
            init: function(u, p, m) {
                m._onInit = function(g) {
                    var _, v;
                    if (_isString(p) && (_ = {}, _forEachName(p, function(x) {
                            return _[x] = 1
                        }), p = _), o) {
                        _ = {};
                        for (v in p) _[v] = o(p[v]);
                        p = _
                    }
                    _addModifiers(g, p)
                }
            }
        }
    },
    gsap$1 = _gsap.registerPlugin({
        name: "attr",
        init: function(i, o, c, u, p) {
            var m, g, _;
            this.tween = c;
            for (m in o) _ = i.getAttribute(m) || "", g = this.add(i, "setAttribute", (_ || 0) + "", o[m], u, p, 0, 0, m), g.op = m, g.b = _, this._props.push(m)
        },
        render: function(i, o) {
            for (var c = o._pt; c;) _reverting$1 ? c.set(c.t, c.p, c.b, c) : c.r(i, c.d), c = c._next
        }
    }, {
        name: "endArray",
        headless: 1,
        init: function(i, o) {
            for (var c = o.length; c--;) this.add(i, c, i[c] || 0, o[c], 0, 0, 0, 0, 0, 1)
        }
    }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
Tween.version = Timeline.version = gsap$1.version = "3.13.0";
_coreReady = 1;
_windowExists$1() && _wake();
_easeMap.Power0;
_easeMap.Power1;
_easeMap.Power2;
_easeMap.Power3;
_easeMap.Power4;
_easeMap.Linear;
_easeMap.Quad;
_easeMap.Cubic;
_easeMap.Quart;
_easeMap.Quint;
_easeMap.Strong;
_easeMap.Elastic;
_easeMap.Back;
_easeMap.SteppedEase;
_easeMap.Bounce;
_easeMap.Sine;
_easeMap.Expo;
_easeMap.Circ;
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */
var _win, _doc, _docElement, _pluginInitted, _tempDiv, _recentSetterPlugin, _reverting, _windowExists = function() {
        return typeof window < "u"
    },
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
    },
    _renderCSSProp = function(i, o) {
        return o.set(o.t, o.p, Math.round((o.s + o.c * i) * 1e4) / 1e4 + o.u, o)
    },
    _renderPropWithEnd = function(i, o) {
        return o.set(o.t, o.p, i === 1 ? o.e : Math.round((o.s + o.c * i) * 1e4) / 1e4 + o.u, o)
    },
    _renderCSSPropWithBeginning = function(i, o) {
        return o.set(o.t, o.p, i ? Math.round((o.s + o.c * i) * 1e4) / 1e4 + o.u : o.b, o)
    },
    _renderRoundedCSSProp = function(i, o) {
        var c = o.s + o.c * i;
        o.set(o.t, o.p, ~~(c + (c < 0 ? -.5 : .5)) + o.u, o)
    },
    _renderNonTweeningValue = function(i, o) {
        return o.set(o.t, o.p, i ? o.e : o.b, o)
    },
    _renderNonTweeningValueOnlyAtEnd = function(i, o) {
        return o.set(o.t, o.p, i !== 1 ? o.b : o.e, o)
    },
    _setterCSSStyle = function(i, o, c) {
        return i.style[o] = c
    },
    _setterCSSProp = function(i, o, c) {
        return i.style.setProperty(o, c)
    },
    _setterTransform = function(i, o, c) {
        return i._gsap[o] = c
    },
    _setterScale = function(i, o, c) {
        return i._gsap.scaleX = i._gsap.scaleY = c
    },
    _setterScaleWithRender = function(i, o, c, u, p) {
        var m = i._gsap;
        m.scaleX = m.scaleY = c, m.renderTransform(p, m)
    },
    _setterTransformWithRender = function(i, o, c, u, p) {
        var m = i._gsap;
        m[o] = c, m.renderTransform(p, m)
    },
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _saveStyle = function l(i, o) {
        var c = this,
            u = this.target,
            p = u.style,
            m = u._gsap;
        if (i in _transformProps && p) {
            if (this.tfm = this.tfm || {}, i !== "transform") i = _propertyAliases[i] || i, ~i.indexOf(",") ? i.split(",").forEach(function(g) {
                return c.tfm[g] = _get(u, g)
            }) : this.tfm[i] = m.x ? m[i] : _get(u, i), i === _transformOriginProp && (this.tfm.zOrigin = m.zOrigin);
            else return _propertyAliases.transform.split(",").forEach(function(g) {
                return l.call(c, g, o)
            });
            if (this.props.indexOf(_transformProp) >= 0) return;
            m.svg && (this.svgo = u.getAttribute("data-svg-origin"), this.props.push(_transformOriginProp, o, "")), i = _transformProp
        }(p || o) && this.props.push(i, o, p[i])
    },
    _removeIndependentTransforms = function(i) {
        i.translate && (i.removeProperty("translate"), i.removeProperty("scale"), i.removeProperty("rotate"))
    },
    _revertStyle = function() {
        var i = this.props,
            o = this.target,
            c = o.style,
            u = o._gsap,
            p, m;
        for (p = 0; p < i.length; p += 3) i[p + 1] ? i[p + 1] === 2 ? o[i[p]](i[p + 2]) : o[i[p]] = i[p + 2] : i[p + 2] ? c[i[p]] = i[p + 2] : c.removeProperty(i[p].substr(0, 2) === "--" ? i[p] : i[p].replace(_capsExp, "-$1").toLowerCase());
        if (this.tfm) {
            for (m in this.tfm) u[m] = this.tfm[m];
            u.svg && (u.renderTransform(), o.setAttribute("data-svg-origin", this.svgo || "")), p = _reverting(), (!p || !p.isStart) && !c[_transformProp] && (_removeIndependentTransforms(c), u.zOrigin && c[_transformOriginProp] && (c[_transformOriginProp] += " " + u.zOrigin + "px", u.zOrigin = 0, u.renderTransform()), u.uncache = 1)
        }
    },
    _getStyleSaver = function(i, o) {
        var c = {
            target: i,
            props: [],
            revert: _revertStyle,
            save: _saveStyle
        };
        return i._gsap || gsap$1.core.getCache(i), o && i.style && i.nodeType && o.split(",").forEach(function(u) {
            return c.save(u)
        }), c
    },
    _supports3D, _createElement = function(i, o) {
        var c = _doc.createElementNS ? _doc.createElementNS((o || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), i) : _doc.createElement(i);
        return c && c.style ? c : _doc.createElement(i)
    },
    _getComputedProperty = function l(i, o, c) {
        var u = getComputedStyle(i);
        return u[o] || u.getPropertyValue(o.replace(_capsExp, "-$1").toLowerCase()) || u.getPropertyValue(o) || !c && l(i, _checkPropPrefix(o) || o, 1) || ""
    },
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function(i, o, c) {
        var u = o || _tempDiv,
            p = u.style,
            m = 5;
        if (i in p && !c) return i;
        for (i = i.charAt(0).toUpperCase() + i.substr(1); m-- && !(_prefixes[m] + i in p););
        return m < 0 ? null : (m === 3 ? "ms" : m >= 0 ? _prefixes[m] : "") + i
    },
    _initCore = function() {
        _windowExists() && window.document && (_win = window, _doc = _win.document, _docElement = _doc.documentElement, _tempDiv = _createElement("div") || {
            style: {}
        }, _createElement("div"), _transformProp = _checkPropPrefix(_transformProp), _transformOriginProp = _transformProp + "Origin", _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", _supports3D = !!_checkPropPrefix("perspective"), _reverting = gsap$1.core.reverting, _pluginInitted = 1)
    },
    _getReparentedCloneBBox = function(i) {
        var o = i.ownerSVGElement,
            c = _createElement("svg", o && o.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
            u = i.cloneNode(!0),
            p;
        u.style.display = "block", c.appendChild(u), _docElement.appendChild(c);
        try {
            p = u.getBBox()
        } catch {}
        return c.removeChild(u), _docElement.removeChild(c), p
    },
    _getAttributeFallbacks = function(i, o) {
        for (var c = o.length; c--;)
            if (i.hasAttribute(o[c])) return i.getAttribute(o[c])
    },
    _getBBox = function(i) {
        var o, c;
        try {
            o = i.getBBox()
        } catch {
            o = _getReparentedCloneBBox(i), c = 1
        }
        return o && (o.width || o.height) || c || (o = _getReparentedCloneBBox(i)), o && !o.width && !o.x && !o.y ? {
            x: +_getAttributeFallbacks(i, ["x", "cx", "x1"]) || 0,
            y: +_getAttributeFallbacks(i, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        } : o
    },
    _isSVG = function(i) {
        return !!(i.getCTM && (!i.parentNode || i.ownerSVGElement) && _getBBox(i))
    },
    _removeProperty = function(i, o) {
        if (o) {
            var c = i.style,
                u;
            o in _transformProps && o !== _transformOriginProp && (o = _transformProp), c.removeProperty ? (u = o.substr(0, 2), (u === "ms" || o.substr(0, 6) === "webkit") && (o = "-" + o), c.removeProperty(u === "--" ? o : o.replace(_capsExp, "-$1").toLowerCase())) : c.removeAttribute(o)
        }
    },
    _addNonTweeningPT = function(i, o, c, u, p, m) {
        var g = new PropTween(i._pt, o, c, 0, 1, m ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
        return i._pt = g, g.b = u, g.e = p, i._props.push(c), g
    },
    _nonConvertibleUnits = {
        deg: 1,
        rad: 1,
        turn: 1
    },
    _nonStandardLayouts = {
        grid: 1,
        flex: 1
    },
    _convertToUnit = function l(i, o, c, u) {
        var p = parseFloat(c) || 0,
            m = (c + "").trim().substr((p + "").length) || "px",
            g = _tempDiv.style,
            _ = _horizontalExp.test(o),
            v = i.tagName.toLowerCase() === "svg",
            x = (v ? "client" : "offset") + (_ ? "Width" : "Height"),
            y = 100,
            b = u === "px",
            S = u === "%",
            C, E, P, w;
        if (u === m || !p || _nonConvertibleUnits[u] || _nonConvertibleUnits[m]) return p;
        if (m !== "px" && !b && (p = l(i, o, c, "px")), w = i.getCTM && _isSVG(i), (S || m === "%") && (_transformProps[o] || ~o.indexOf("adius"))) return C = w ? i.getBBox()[_ ? "width" : "height"] : i[x], _round(S ? p / C * y : p / 100 * C);
        if (g[_ ? "width" : "height"] = y + (b ? m : u), E = u !== "rem" && ~o.indexOf("adius") || u === "em" && i.appendChild && !v ? i : i.parentNode, w && (E = (i.ownerSVGElement || {}).parentNode), (!E || E === _doc || !E.appendChild) && (E = _doc.body), P = E._gsap, P && S && P.width && _ && P.time === _ticker.time && !P.uncache) return _round(p / P.width * y);
        if (S && (o === "height" || o === "width")) {
            var T = i.style[o];
            i.style[o] = y + u, C = i[x], T ? i.style[o] = T : _removeProperty(i, o)
        } else(S || m === "%") && !_nonStandardLayouts[_getComputedProperty(E, "display")] && (g.position = _getComputedProperty(i, "position")), E === i && (g.position = "static"), E.appendChild(_tempDiv), C = _tempDiv[x], E.removeChild(_tempDiv), g.position = "absolute";
        return _ && S && (P = _getCache(E), P.time = _ticker.time, P.width = E[x]), _round(b ? C * p / y : C && p ? y / C * p : 0)
    },
    _get = function(i, o, c, u) {
        var p;
        return _pluginInitted || _initCore(), o in _propertyAliases && o !== "transform" && (o = _propertyAliases[o], ~o.indexOf(",") && (o = o.split(",")[0])), _transformProps[o] && o !== "transform" ? (p = _parseTransform(i, u), p = o !== "transformOrigin" ? p[o] : p.svg ? p.origin : _firstTwoOnly(_getComputedProperty(i, _transformOriginProp)) + " " + p.zOrigin + "px") : (p = i.style[o], (!p || p === "auto" || u || ~(p + "").indexOf("calc(")) && (p = _specialProps[o] && _specialProps[o](i, o, c) || _getComputedProperty(i, o) || _getProperty(i, o) || (o === "opacity" ? 1 : 0))), c && !~(p + "").trim().indexOf(" ") ? _convertToUnit(i, o, p, c) + c : p
    },
    _tweenComplexCSSString = function(i, o, c, u) {
        if (!c || c === "none") {
            var p = _checkPropPrefix(o, i, 1),
                m = p && _getComputedProperty(i, p, 1);
            m && m !== c ? (o = p, c = m) : o === "borderColor" && (c = _getComputedProperty(i, "borderTopColor"))
        }
        var g = new PropTween(this._pt, i.style, o, 0, 1, _renderComplexString),
            _ = 0,
            v = 0,
            x, y, b, S, C, E, P, w, T, M, A, D;
        if (g.b = c, g.e = u, c += "", u += "", u.substring(0, 6) === "var(--" && (u = _getComputedProperty(i, u.substring(4, u.indexOf(")")))), u === "auto" && (E = i.style[o], i.style[o] = u, u = _getComputedProperty(i, o) || u, E ? i.style[o] = E : _removeProperty(i, o)), x = [c, u], _colorStringFilter(x), c = x[0], u = x[1], b = c.match(_numWithUnitExp) || [], D = u.match(_numWithUnitExp) || [], D.length) {
            for (; y = _numWithUnitExp.exec(u);) P = y[0], T = u.substring(_, y.index), C ? C = (C + 1) % 5 : (T.substr(-5) === "rgba(" || T.substr(-5) === "hsla(") && (C = 1), P !== (E = b[v++] || "") && (S = parseFloat(E) || 0, A = E.substr((S + "").length), P.charAt(1) === "=" && (P = _parseRelative(S, P) + A), w = parseFloat(P), M = P.substr((w + "").length), _ = _numWithUnitExp.lastIndex - M.length, M || (M = M || _config.units[o] || A, _ === u.length && (u += M, g.e += M)), A !== M && (S = _convertToUnit(i, o, E, M) || 0), g._pt = {
                _next: g._pt,
                p: T || v === 1 ? T : ",",
                s: S,
                c: w - S,
                m: C && C < 4 || o === "zIndex" ? Math.round : 0
            });
            g.c = _ < u.length ? u.substring(_, u.length) : ""
        } else g.r = o === "display" && u === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
        return _relExp.test(u) && (g.e = 0), this._pt = g, g
    },
    _keywordToPercent = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
    },
    _convertKeywordsToPercentages = function(i) {
        var o = i.split(" "),
            c = o[0],
            u = o[1] || "50%";
        return (c === "top" || c === "bottom" || u === "left" || u === "right") && (i = c, c = u, u = i), o[0] = _keywordToPercent[c] || c, o[1] = _keywordToPercent[u] || u, o.join(" ")
    },
    _renderClearProps = function(i, o) {
        if (o.tween && o.tween._time === o.tween._dur) {
            var c = o.t,
                u = c.style,
                p = o.u,
                m = c._gsap,
                g, _, v;
            if (p === "all" || p === !0) u.cssText = "", _ = 1;
            else
                for (p = p.split(","), v = p.length; --v > -1;) g = p[v], _transformProps[g] && (_ = 1, g = g === "transformOrigin" ? _transformOriginProp : _transformProp), _removeProperty(c, g);
            _ && (_removeProperty(c, _transformProp), m && (m.svg && c.removeAttribute("transform"), u.scale = u.rotate = u.translate = "none", _parseTransform(c, 1), m.uncache = 1, _removeIndependentTransforms(u)))
        }
    },
    _specialProps = {
        clearProps: function(i, o, c, u, p) {
            if (p.data !== "isFromStart") {
                var m = i._pt = new PropTween(i._pt, o, c, 0, 0, _renderClearProps);
                return m.u = u, m.pr = -10, m.tween = p, i._props.push(c), 1
            }
        }
    },
    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function(i) {
        return i === "matrix(1, 0, 0, 1, 0, 0)" || i === "none" || !i
    },
    _getComputedTransformMatrixAsArray = function(i) {
        var o = _getComputedProperty(i, _transformProp);
        return _isNullTransform(o) ? _identity2DMatrix : o.substr(7).match(_numExp).map(_round)
    },
    _getMatrix = function(i, o) {
        var c = i._gsap || _getCache(i),
            u = i.style,
            p = _getComputedTransformMatrixAsArray(i),
            m, g, _, v;
        return c.svg && i.getAttribute("transform") ? (_ = i.transform.baseVal.consolidate().matrix, p = [_.a, _.b, _.c, _.d, _.e, _.f], p.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : p) : (p === _identity2DMatrix && !i.offsetParent && i !== _docElement && !c.svg && (_ = u.display, u.display = "block", m = i.parentNode, (!m || !i.offsetParent && !i.getBoundingClientRect().width) && (v = 1, g = i.nextElementSibling, _docElement.appendChild(i)), p = _getComputedTransformMatrixAsArray(i), _ ? u.display = _ : _removeProperty(i, "display"), v && (g ? m.insertBefore(i, g) : m ? m.appendChild(i) : _docElement.removeChild(i))), o && p.length > 6 ? [p[0], p[1], p[4], p[5], p[12], p[13]] : p)
    },
    _applySVGOrigin = function(i, o, c, u, p, m) {
        var g = i._gsap,
            _ = p || _getMatrix(i, !0),
            v = g.xOrigin || 0,
            x = g.yOrigin || 0,
            y = g.xOffset || 0,
            b = g.yOffset || 0,
            S = _[0],
            C = _[1],
            E = _[2],
            P = _[3],
            w = _[4],
            T = _[5],
            M = o.split(" "),
            A = parseFloat(M[0]) || 0,
            D = parseFloat(M[1]) || 0,
            R, I, k, F;
        c ? _ !== _identity2DMatrix && (I = S * P - C * E) && (k = A * (P / I) + D * (-E / I) + (E * T - P * w) / I, F = A * (-C / I) + D * (S / I) - (S * T - C * w) / I, A = k, D = F) : (R = _getBBox(i), A = R.x + (~M[0].indexOf("%") ? A / 100 * R.width : A), D = R.y + (~(M[1] || M[0]).indexOf("%") ? D / 100 * R.height : D)), u || u !== !1 && g.smooth ? (w = A - v, T = D - x, g.xOffset = y + (w * S + T * E) - w, g.yOffset = b + (w * C + T * P) - T) : g.xOffset = g.yOffset = 0, g.xOrigin = A, g.yOrigin = D, g.smooth = !!u, g.origin = o, g.originIsAbsolute = !!c, i.style[_transformOriginProp] = "0px 0px", m && (_addNonTweeningPT(m, g, "xOrigin", v, A), _addNonTweeningPT(m, g, "yOrigin", x, D), _addNonTweeningPT(m, g, "xOffset", y, g.xOffset), _addNonTweeningPT(m, g, "yOffset", b, g.yOffset)), i.setAttribute("data-svg-origin", A + " " + D)
    },
    _parseTransform = function(i, o) {
        var c = i._gsap || new GSCache(i);
        if ("x" in c && !o && !c.uncache) return c;
        var u = i.style,
            p = c.scaleX < 0,
            m = "px",
            g = "deg",
            _ = getComputedStyle(i),
            v = _getComputedProperty(i, _transformOriginProp) || "0",
            x, y, b, S, C, E, P, w, T, M, A, D, R, I, k, F, V, B, U, H, Q, Y, O, G, L, N, K, Z, he, we, ie, _e;
        return x = y = b = E = P = w = T = M = A = 0, S = C = 1, c.svg = !!(i.getCTM && _isSVG(i)), _.translate && ((_.translate !== "none" || _.scale !== "none" || _.rotate !== "none") && (u[_transformProp] = (_.translate !== "none" ? "translate3d(" + (_.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (_.rotate !== "none" ? "rotate(" + _.rotate + ") " : "") + (_.scale !== "none" ? "scale(" + _.scale.split(" ").join(",") + ") " : "") + (_[_transformProp] !== "none" ? _[_transformProp] : "")), u.scale = u.rotate = u.translate = "none"), I = _getMatrix(i, c.svg), c.svg && (c.uncache ? (L = i.getBBox(), v = c.xOrigin - L.x + "px " + (c.yOrigin - L.y) + "px", G = "") : G = !o && i.getAttribute("data-svg-origin"), _applySVGOrigin(i, G || v, !!G || c.originIsAbsolute, c.smooth !== !1, I)), D = c.xOrigin || 0, R = c.yOrigin || 0, I !== _identity2DMatrix && (B = I[0], U = I[1], H = I[2], Q = I[3], x = Y = I[4], y = O = I[5], I.length === 6 ? (S = Math.sqrt(B * B + U * U), C = Math.sqrt(Q * Q + H * H), E = B || U ? _atan2(U, B) * _RAD2DEG : 0, T = H || Q ? _atan2(H, Q) * _RAD2DEG + E : 0, T && (C *= Math.abs(Math.cos(T * _DEG2RAD))), c.svg && (x -= D - (D * B + R * H), y -= R - (D * U + R * Q))) : (_e = I[6], we = I[7], K = I[8], Z = I[9], he = I[10], ie = I[11], x = I[12], y = I[13], b = I[14], k = _atan2(_e, he), P = k * _RAD2DEG, k && (F = Math.cos(-k), V = Math.sin(-k), G = Y * F + K * V, L = O * F + Z * V, N = _e * F + he * V, K = Y * -V + K * F, Z = O * -V + Z * F, he = _e * -V + he * F, ie = we * -V + ie * F, Y = G, O = L, _e = N), k = _atan2(-H, he), w = k * _RAD2DEG, k && (F = Math.cos(-k), V = Math.sin(-k), G = B * F - K * V, L = U * F - Z * V, N = H * F - he * V, ie = Q * V + ie * F, B = G, U = L, H = N), k = _atan2(U, B), E = k * _RAD2DEG, k && (F = Math.cos(k), V = Math.sin(k), G = B * F + U * V, L = Y * F + O * V, U = U * F - B * V, O = O * F - Y * V, B = G, Y = L), P && Math.abs(P) + Math.abs(E) > 359.9 && (P = E = 0, w = 180 - w), S = _round(Math.sqrt(B * B + U * U + H * H)), C = _round(Math.sqrt(O * O + _e * _e)), k = _atan2(Y, O), T = Math.abs(k) > 2e-4 ? k * _RAD2DEG : 0, A = ie ? 1 / (ie < 0 ? -ie : ie) : 0), c.svg && (G = i.getAttribute("transform"), c.forceCSS = i.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(i, _transformProp)), G && i.setAttribute("transform", G))), Math.abs(T) > 90 && Math.abs(T) < 270 && (p ? (S *= -1, T += E <= 0 ? 180 : -180, E += E <= 0 ? 180 : -180) : (C *= -1, T += T <= 0 ? 180 : -180)), o = o || c.uncache, c.x = x - ((c.xPercent = x && (!o && c.xPercent || (Math.round(i.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? i.offsetWidth * c.xPercent / 100 : 0) + m, c.y = y - ((c.yPercent = y && (!o && c.yPercent || (Math.round(i.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? i.offsetHeight * c.yPercent / 100 : 0) + m, c.z = b + m, c.scaleX = _round(S), c.scaleY = _round(C), c.rotation = _round(E) + g, c.rotationX = _round(P) + g, c.rotationY = _round(w) + g, c.skewX = T + g, c.skewY = M + g, c.transformPerspective = A + m, (c.zOrigin = parseFloat(v.split(" ")[2]) || !o && c.zOrigin || 0) && (u[_transformOriginProp] = _firstTwoOnly(v)), c.xOffset = c.yOffset = 0, c.force3D = _config.force3D, c.renderTransform = c.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms, c.uncache = 0, c
    },
    _firstTwoOnly = function(i) {
        return (i = i.split(" "))[0] + " " + i[1]
    },
    _addPxTranslate = function(i, o, c) {
        var u = getUnit(o);
        return _round(parseFloat(o) + parseFloat(_convertToUnit(i, "x", c + "px", u))) + u
    },
    _renderNon3DTransforms = function(i, o) {
        o.z = "0px", o.rotationY = o.rotationX = "0deg", o.force3D = 0, _renderCSSTransforms(i, o)
    },
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function(i, o) {
        var c = o || this,
            u = c.xPercent,
            p = c.yPercent,
            m = c.x,
            g = c.y,
            _ = c.z,
            v = c.rotation,
            x = c.rotationY,
            y = c.rotationX,
            b = c.skewX,
            S = c.skewY,
            C = c.scaleX,
            E = c.scaleY,
            P = c.transformPerspective,
            w = c.force3D,
            T = c.target,
            M = c.zOrigin,
            A = "",
            D = w === "auto" && i && i !== 1 || w === !0;
        if (M && (y !== _zeroDeg || x !== _zeroDeg)) {
            var R = parseFloat(x) * _DEG2RAD,
                I = Math.sin(R),
                k = Math.cos(R),
                F;
            R = parseFloat(y) * _DEG2RAD, F = Math.cos(R), m = _addPxTranslate(T, m, I * F * -M), g = _addPxTranslate(T, g, -Math.sin(R) * -M), _ = _addPxTranslate(T, _, k * F * -M + M)
        }
        P !== _zeroPx && (A += "perspective(" + P + _endParenthesis), (u || p) && (A += "translate(" + u + "%, " + p + "%) "), (D || m !== _zeroPx || g !== _zeroPx || _ !== _zeroPx) && (A += _ !== _zeroPx || D ? "translate3d(" + m + ", " + g + ", " + _ + ") " : "translate(" + m + ", " + g + _endParenthesis), v !== _zeroDeg && (A += "rotate(" + v + _endParenthesis), x !== _zeroDeg && (A += "rotateY(" + x + _endParenthesis), y !== _zeroDeg && (A += "rotateX(" + y + _endParenthesis), (b !== _zeroDeg || S !== _zeroDeg) && (A += "skew(" + b + ", " + S + _endParenthesis), (C !== 1 || E !== 1) && (A += "scale(" + C + ", " + E + _endParenthesis), T.style[_transformProp] = A || "translate(0, 0)"
    },
    _renderSVGTransforms = function(i, o) {
        var c = o || this,
            u = c.xPercent,
            p = c.yPercent,
            m = c.x,
            g = c.y,
            _ = c.rotation,
            v = c.skewX,
            x = c.skewY,
            y = c.scaleX,
            b = c.scaleY,
            S = c.target,
            C = c.xOrigin,
            E = c.yOrigin,
            P = c.xOffset,
            w = c.yOffset,
            T = c.forceCSS,
            M = parseFloat(m),
            A = parseFloat(g),
            D, R, I, k, F;
        _ = parseFloat(_), v = parseFloat(v), x = parseFloat(x), x && (x = parseFloat(x), v += x, _ += x), _ || v ? (_ *= _DEG2RAD, v *= _DEG2RAD, D = Math.cos(_) * y, R = Math.sin(_) * y, I = Math.sin(_ - v) * -b, k = Math.cos(_ - v) * b, v && (x *= _DEG2RAD, F = Math.tan(v - x), F = Math.sqrt(1 + F * F), I *= F, k *= F, x && (F = Math.tan(x), F = Math.sqrt(1 + F * F), D *= F, R *= F)), D = _round(D), R = _round(R), I = _round(I), k = _round(k)) : (D = y, k = b, R = I = 0), (M && !~(m + "").indexOf("px") || A && !~(g + "").indexOf("px")) && (M = _convertToUnit(S, "x", m, "px"), A = _convertToUnit(S, "y", g, "px")), (C || E || P || w) && (M = _round(M + C - (C * D + E * I) + P), A = _round(A + E - (C * R + E * k) + w)), (u || p) && (F = S.getBBox(), M = _round(M + u / 100 * F.width), A = _round(A + p / 100 * F.height)), F = "matrix(" + D + "," + R + "," + I + "," + k + "," + M + "," + A + ")", S.setAttribute("transform", F), T && (S.style[_transformProp] = F)
    },
    _addRotationalPropTween = function(i, o, c, u, p) {
        var m = 360,
            g = _isString(p),
            _ = parseFloat(p) * (g && ~p.indexOf("rad") ? _RAD2DEG : 1),
            v = _ - u,
            x = u + v + "deg",
            y, b;
        return g && (y = p.split("_")[1], y === "short" && (v %= m, v !== v % (m / 2) && (v += v < 0 ? m : -360)), y === "cw" && v < 0 ? v = (v + m * _bigNum) % m - ~~(v / m) * m : y === "ccw" && v > 0 && (v = (v - m * _bigNum) % m - ~~(v / m) * m)), i._pt = b = new PropTween(i._pt, o, c, u, v, _renderPropWithEnd), b.e = x, b.u = "deg", i._props.push(c), b
    },
    _assign = function(i, o) {
        for (var c in o) i[c] = o[c];
        return i
    },
    _addRawTransformPTs = function(i, o, c) {
        var u = _assign({}, c._gsap),
            p = "perspective,force3D,transformOrigin,svgOrigin",
            m = c.style,
            g, _, v, x, y, b, S, C;
        u.svg ? (v = c.getAttribute("transform"), c.setAttribute("transform", ""), m[_transformProp] = o, g = _parseTransform(c, 1), _removeProperty(c, _transformProp), c.setAttribute("transform", v)) : (v = getComputedStyle(c)[_transformProp], m[_transformProp] = o, g = _parseTransform(c, 1), m[_transformProp] = v);
        for (_ in _transformProps) v = u[_], x = g[_], v !== x && p.indexOf(_) < 0 && (S = getUnit(v), C = getUnit(x), y = S !== C ? _convertToUnit(c, _, v, C) : parseFloat(v), b = parseFloat(x), i._pt = new PropTween(i._pt, g, _, y, b - y, _renderCSSProp), i._pt.u = C || 0, i._props.push(_));
        _assign(g, u)
    };
_forEachName("padding,margin,Width,Radius", function(l, i) {
    var o = "Top",
        c = "Right",
        u = "Bottom",
        p = "Left",
        m = (i < 3 ? [o, c, u, p] : [o + p, o + c, u + c, u + p]).map(function(g) {
            return i < 2 ? l + g : "border" + g + l
        });
    _specialProps[i > 1 ? "border" + l : l] = function(g, _, v, x, y) {
        var b, S;
        if (arguments.length < 4) return b = m.map(function(C) {
            return _get(g, C, v)
        }), S = b.join(" "), S.split(b[0]).length === 5 ? b[0] : S;
        b = (x + "").split(" "), S = {}, m.forEach(function(C, E) {
            return S[C] = b[E] = b[E] || b[(E - 1) / 2 | 0]
        }), g.init(_, S, y)
    }
});
var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function(i) {
        return i.style && i.nodeType
    },
    init: function(i, o, c, u, p) {
        var m = this._props,
            g = i.style,
            _ = c.vars.startAt,
            v, x, y, b, S, C, E, P, w, T, M, A, D, R, I, k;
        _pluginInitted || _initCore(), this.styles = this.styles || _getStyleSaver(i), k = this.styles.props, this.tween = c;
        for (E in o)
            if (E !== "autoRound" && (x = o[E], !(_plugins[E] && _checkPlugin(E, o, c, u, i, p)))) {
                if (S = typeof x, C = _specialProps[E], S === "function" && (x = x.call(c, u, i, p), S = typeof x), S === "string" && ~x.indexOf("random(") && (x = _replaceRandom(x)), C) C(this, i, E, x, c) && (I = 1);
                else if (E.substr(0, 2) === "--") v = (getComputedStyle(i).getPropertyValue(E) + "").trim(), x += "", _colorExp.lastIndex = 0, _colorExp.test(v) || (P = getUnit(v), w = getUnit(x)), w ? P !== w && (v = _convertToUnit(i, E, v, w) + w) : P && (x += P), this.add(g, "setProperty", v, x, u, p, 0, 0, E), m.push(E), k.push(E, 0, g[E]);
                else if (S !== "undefined") {
                    if (_ && E in _ ? (v = typeof _[E] == "function" ? _[E].call(c, u, i, p) : _[E], _isString(v) && ~v.indexOf("random(") && (v = _replaceRandom(v)), getUnit(v + "") || v === "auto" || (v += _config.units[E] || getUnit(_get(i, E)) || ""), (v + "").charAt(1) === "=" && (v = _get(i, E))) : v = _get(i, E), b = parseFloat(v), T = S === "string" && x.charAt(1) === "=" && x.substr(0, 2), T && (x = x.substr(2)), y = parseFloat(x), E in _propertyAliases && (E === "autoAlpha" && (b === 1 && _get(i, "visibility") === "hidden" && y && (b = 0), k.push("visibility", 0, g.visibility), _addNonTweeningPT(this, g, "visibility", b ? "inherit" : "hidden", y ? "inherit" : "hidden", !y)), E !== "scale" && E !== "transform" && (E = _propertyAliases[E], ~E.indexOf(",") && (E = E.split(",")[0]))), M = E in _transformProps, M) {
                        if (this.styles.save(E), S === "string" && x.substring(0, 6) === "var(--" && (x = _getComputedProperty(i, x.substring(4, x.indexOf(")"))), y = parseFloat(x)), A || (D = i._gsap, D.renderTransform && !o.parseTransform || _parseTransform(i, o.parseTransform), R = o.smoothOrigin !== !1 && D.smooth, A = this._pt = new PropTween(this._pt, g, _transformProp, 0, 1, D.renderTransform, D, 0, -1), A.dep = 1), E === "scale") this._pt = new PropTween(this._pt, D, "scaleY", D.scaleY, (T ? _parseRelative(D.scaleY, T + y) : y) - D.scaleY || 0, _renderCSSProp), this._pt.u = 0, m.push("scaleY", E), E += "X";
                        else if (E === "transformOrigin") {
                            k.push(_transformOriginProp, 0, g[_transformOriginProp]), x = _convertKeywordsToPercentages(x), D.svg ? _applySVGOrigin(i, x, 0, R, 0, this) : (w = parseFloat(x.split(" ")[2]) || 0, w !== D.zOrigin && _addNonTweeningPT(this, D, "zOrigin", D.zOrigin, w), _addNonTweeningPT(this, g, E, _firstTwoOnly(v), _firstTwoOnly(x)));
                            continue
                        } else if (E === "svgOrigin") {
                            _applySVGOrigin(i, x, 1, R, 0, this);
                            continue
                        } else if (E in _rotationalProperties) {
                            _addRotationalPropTween(this, D, E, b, T ? _parseRelative(b, T + x) : x);
                            continue
                        } else if (E === "smoothOrigin") {
                            _addNonTweeningPT(this, D, "smooth", D.smooth, x);
                            continue
                        } else if (E === "force3D") {
                            D[E] = x;
                            continue
                        } else if (E === "transform") {
                            _addRawTransformPTs(this, x, i);
                            continue
                        }
                    } else E in g || (E = _checkPropPrefix(E) || E);
                    if (M || (y || y === 0) && (b || b === 0) && !_complexExp.test(x) && E in g) P = (v + "").substr((b + "").length), y || (y = 0), w = getUnit(x) || (E in _config.units ? _config.units[E] : P), P !== w && (b = _convertToUnit(i, E, v, w)), this._pt = new PropTween(this._pt, M ? D : g, E, b, (T ? _parseRelative(b, T + y) : y) - b, !M && (w === "px" || E === "zIndex") && o.autoRound !== !1 ? _renderRoundedCSSProp : _renderCSSProp), this._pt.u = w || 0, P !== w && w !== "%" && (this._pt.b = v, this._pt.r = _renderCSSPropWithBeginning);
                    else if (E in g) _tweenComplexCSSString.call(this, i, E, v, T ? T + x : x);
                    else if (E in i) this.add(i, E, v || i[E], T ? T + x : x, u, p);
                    else if (E !== "parseTransform") {
                        _missingPlugin(E, x);
                        continue
                    }
                    M || (E in g ? k.push(E, 0, g[E]) : typeof i[E] == "function" ? k.push(E, 2, i[E]()) : k.push(E, 1, v || i[E])), m.push(E)
                }
            }
        I && _sortPropTweensByPriority(this)
    },
    render: function(i, o) {
        if (o.tween._time || !_reverting())
            for (var c = o._pt; c;) c.r(i, c.d), c = c._next;
        else o.styles.revert()
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function(i, o, c) {
        var u = _propertyAliases[o];
        return u && u.indexOf(",") < 0 && (o = u), o in _transformProps && o !== _transformOriginProp && (i._gsap.x || _get(i, "x")) ? c && _recentSetterPlugin === c ? o === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = c || {}) && (o === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : i.style && !_isUndefined(i.style[o]) ? _setterCSSStyle : ~o.indexOf("-") ? _setterCSSProp : _getSetter(i, o)
    },
    core: {
        _removeProperty,
        _getMatrix
    }
};
gsap$1.utils.checkPrefix = _checkPropPrefix;
gsap$1.core.getStyleSaver = _getStyleSaver;
(function(l, i, o, c) {
    var u = _forEachName(l + "," + i + "," + o, function(p) {
        _transformProps[p] = 1
    });
    _forEachName(i, function(p) {
        _config.units[p] = "deg", _rotationalProperties[p] = 1
    }), _propertyAliases[u[13]] = l + "," + i, _forEachName(c, function(p) {
        var m = p.split(":");
        _propertyAliases[m[1]] = u[m[0]]
    })
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
_forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(l) {
    _config.units[l] = "px"
});
gsap$1.registerPlugin(CSSPlugin);
var gsapWithCSS = gsap$1.registerPlugin(CSSPlugin) || gsap$1;
gsapWithCSS.core.Tween;
/*!
 * SplitText 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.
 * @author: Jack Doyle
 */
let gsap, _fonts, _coreInitted, _initIfNecessary = () => _coreInitted || SplitText.register(window.gsap),
    _charSegmenter = typeof Intl < "u" ? new Intl.Segmenter : 0,
    _toArray = l => typeof l == "string" ? _toArray(document.querySelectorAll(l)) : "length" in l ? Array.from(l) : [l],
    _elements = l => _toArray(l).filter(i => i instanceof HTMLElement),
    _emptyArray = [],
    _context = function() {},
    _spacesRegEx = /\s+/g,
    _emojiSafeRegEx = new RegExp("\\p{RI}\\p{RI}|\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?(\\u{200D}\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?)*|.", "gu"),
    _emptyBounds = {
        left: 0,
        top: 0,
        width: 0,
        height: 0
    },
    _stretchToFitSpecialChars = (l, i) => {
        if (i) {
            let o = new Set(l.join("").match(i) || _emptyArray),
                c = l.length,
                u, p, m, g;
            if (o.size)
                for (; --c > -1;) {
                    p = l[c];
                    for (m of o)
                        if (m.startsWith(p) && m.length > p.length) {
                            for (u = 0, g = p; m.startsWith(g += l[c + ++u]) && g.length < m.length;);
                            if (u && g.length === m.length) {
                                l[c] = m, l.splice(c + 1, u);
                                break
                            }
                        }
                }
        }
        return l
    },
    _disallowInline = l => window.getComputedStyle(l).display === "inline" && (l.style.display = "inline-block"),
    _insertNodeBefore = (l, i, o) => i.insertBefore(typeof l == "string" ? document.createTextNode(l) : l, o),
    _getWrapper = (l, i, o) => {
        let c = i[l + "sClass"] || "",
            {
                tag: u = "div",
                aria: p = "auto",
                propIndex: m = !1
            } = i,
            g = l === "line" ? "block" : "inline-block",
            _ = c.indexOf("++") > -1,
            v = x => {
                let y = document.createElement(u),
                    b = o.length + 1;
                return c && (y.className = c + (_ ? " " + c + b : "")), m && y.style.setProperty("--" + l, b + ""), p !== "none" && y.setAttribute("aria-hidden", "true"), u !== "span" && (y.style.position = "relative", y.style.display = g), y.textContent = x, o.push(y), y
            };
        return _ && (c = c.replace("++", "")), v.collection = o, v
    },
    _getLineWrapper = (l, i, o, c) => {
        let u = _getWrapper("line", o, c),
            p = window.getComputedStyle(l).textAlign || "left";
        return (m, g) => {
            let _ = u("");
            for (_.style.textAlign = p, l.insertBefore(_, i[m]); m < g; m++) _.appendChild(i[m]);
            _.normalize()
        }
    },
    _splitWordsAndCharsRecursively = (l, i, o, c, u, p, m, g, _, v) => {
        var x;
        let y = Array.from(l.childNodes),
            b = 0,
            {
                wordDelimiter: S,
                reduceWhiteSpace: C = !0,
                prepareText: E
            } = i,
            P = l.getBoundingClientRect(),
            w = P,
            T = !C && window.getComputedStyle(l).whiteSpace.substring(0, 3) === "pre",
            M = 0,
            A = o.collection,
            D, R, I, k, F, V, B, U, H, Q, Y, O, G, L, N, K, Z, he;
        for (typeof S == "object" ? (I = S.delimiter || S, R = S.replaceWith || "") : R = S === "" ? "" : S || " ", D = R !== " "; b < y.length; b++)
            if (k = y[b], k.nodeType === 3) {
                for (N = k.textContent || "", C ? N = N.replace(_spacesRegEx, " ") : T && (N = N.replace(/\n/g, R + `
`)), E && (N = E(N, l)), k.textContent = N, F = R || I ? N.split(I || R) : N.match(g) || _emptyArray, Z = F[F.length - 1], U = D ? Z.slice(-1) === " " : !Z, Z || F.pop(), w = P, B = D ? F[0].charAt(0) === " " : !F[0], B && _insertNodeBefore(" ", l, k), F[0] || F.shift(), _stretchToFitSpecialChars(F, _), p && v || (k.textContent = ""), H = 1; H <= F.length; H++)
                    if (K = F[H - 1], !C && T && K.charAt(0) === `
` && ((x = k.previousSibling) == null || x.remove(), _insertNodeBefore(document.createElement("br"), l, k), K = K.slice(1)), !C && K === "") _insertNodeBefore(R, l, k);
                    else if (K === " ") l.insertBefore(document.createTextNode(" "), k);
                else {
                    if (D && K.charAt(0) === " " && _insertNodeBefore(" ", l, k), M && H === 1 && !B && A.indexOf(M.parentNode) > -1 ? (V = A[A.length - 1], V.appendChild(document.createTextNode(c ? "" : K))) : (V = o(c ? "" : K), _insertNodeBefore(V, l, k), M && H === 1 && !B && V.insertBefore(M, V.firstChild)), c)
                        for (Y = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(K)].map(we => we.segment), _) : K.match(g) || _emptyArray, he = 0; he < Y.length; he++) V.appendChild(Y[he] === " " ? document.createTextNode(" ") : c(Y[he]));
                    if (p && v) {
                        if (N = k.textContent = N.substring(K.length + 1, N.length), Q = V.getBoundingClientRect(), Q.top > w.top && Q.left <= w.left) {
                            for (O = l.cloneNode(), G = l.childNodes[0]; G && G !== V;) L = G, G = G.nextSibling, O.appendChild(L);
                            l.parentNode.insertBefore(O, l), u && _disallowInline(O)
                        }
                        w = Q
                    }(H < F.length || U) && _insertNodeBefore(H >= F.length ? " " : D && K.slice(-1) === " " ? " " + R : R, l, k)
                }
                l.removeChild(k), M = 0
            } else k.nodeType === 1 && (m && m.indexOf(k) > -1 ? (A.indexOf(k.previousSibling) > -1 && A[A.length - 1].appendChild(k), M = k) : (_splitWordsAndCharsRecursively(k, i, o, c, u, p, m, g, _, !0), M = 0), u && _disallowInline(k))
    };
const _SplitText = class Kr {
    constructor(i, o) {
        this.isSplit = !1, _initIfNecessary(), this.elements = _elements(i), this.chars = [], this.words = [], this.lines = [], this.masks = [], this.vars = o, this._split = () => this.isSplit && this.split(this.vars);
        let c = [],
            u, p = () => {
                let m = c.length,
                    g;
                for (; m--;) {
                    g = c[m];
                    let _ = g.element.offsetWidth;
                    if (_ !== g.width) {
                        g.width = _, this._split();
                        return
                    }
                }
            };
        this._data = {
            orig: c,
            obs: typeof ResizeObserver < "u" && new ResizeObserver(() => {
                clearTimeout(u), u = setTimeout(p, 200)
            })
        }, _context(this), this.split(o)
    }
    split(i) {
        this.isSplit && this.revert(), this.vars = i = i || this.vars || {};
        let {
            type: o = "chars,words,lines",
            aria: c = "auto",
            deepSlice: u = !0,
            smartWrap: p,
            onSplit: m,
            autoSplit: g = !1,
            specialChars: _,
            mask: v
        } = this.vars, x = o.indexOf("lines") > -1, y = o.indexOf("chars") > -1, b = o.indexOf("words") > -1, S = y && !b && !x, C = _ && ("push" in _ ? new RegExp("(?:" + _.join("|") + ")", "gu") : _), E = C ? new RegExp(C.source + "|" + _emojiSafeRegEx.source, "gu") : _emojiSafeRegEx, P = !!i.ignore && _elements(i.ignore), {
            orig: w,
            animTime: T,
            obs: M
        } = this._data, A;
        return (y || b || x) && (this.elements.forEach((D, R) => {
            w[R] = {
                element: D,
                html: D.innerHTML,
                ariaL: D.getAttribute("aria-label"),
                ariaH: D.getAttribute("aria-hidden")
            }, c === "auto" ? D.setAttribute("aria-label", (D.textContent || "").trim()) : c === "hidden" && D.setAttribute("aria-hidden", "true");
            let I = [],
                k = [],
                F = [],
                V = y ? _getWrapper("char", i, I) : null,
                B = _getWrapper("word", i, k),
                U, H, Q, Y;
            if (_splitWordsAndCharsRecursively(D, i, B, V, S, u && (x || S), P, E, C, !1), x) {
                let O = _toArray(D.childNodes),
                    G = _getLineWrapper(D, O, i, F),
                    L, N = [],
                    K = 0,
                    Z = O.map(we => we.nodeType === 1 ? we.getBoundingClientRect() : _emptyBounds),
                    he = _emptyBounds;
                for (U = 0; U < O.length; U++) L = O[U], L.nodeType === 1 && (L.nodeName === "BR" ? (N.push(L), G(K, U + 1), K = U + 1, he = Z[K]) : (U && Z[U].top > he.top && Z[U].left <= he.left && (G(K, U), K = U), he = Z[U]));
                K < U && G(K, U), N.forEach(we => {
                    var ie;
                    return (ie = we.parentNode) == null ? void 0 : ie.removeChild(we)
                })
            }
            if (!b) {
                for (U = 0; U < k.length; U++)
                    if (H = k[U], y || !H.nextSibling || H.nextSibling.nodeType !== 3)
                        if (p && !x) {
                            for (Q = document.createElement("span"), Q.style.whiteSpace = "nowrap"; H.firstChild;) Q.appendChild(H.firstChild);
                            H.replaceWith(Q)
                        } else H.replaceWith(...H.childNodes);
                else Y = H.nextSibling, Y && Y.nodeType === 3 && (Y.textContent = (H.textContent || "") + (Y.textContent || ""), H.remove());
                k.length = 0, D.normalize()
            }
            this.lines.push(...F), this.words.push(...k), this.chars.push(...I)
        }), v && this[v] && this.masks.push(...this[v].map(D => {
            let R = D.cloneNode();
            return D.replaceWith(R), R.appendChild(D), D.className && (R.className = D.className.replace(/(\b\w+\b)/g, "$1-mask")), R.style.overflow = "clip", R
        }))), this.isSplit = !0, _fonts && (g ? _fonts.addEventListener("loadingdone", this._split) : _fonts.status === "loading" && console.warn("SplitText called before fonts loaded")), (A = m && m(this)) && A.totalTime && (this._data.anim = T ? A.totalTime(T) : A), x && g && this.elements.forEach((D, R) => {
            w[R].width = D.offsetWidth, M && M.observe(D)
        }), this
    }
    revert() {
        var i, o;
        let {
            orig: c,
            anim: u,
            obs: p
        } = this._data;
        return p && p.disconnect(), c.forEach(({
            element: m,
            html: g,
            ariaL: _,
            ariaH: v
        }) => {
            m.innerHTML = g, _ ? m.setAttribute("aria-label", _) : m.removeAttribute("aria-label"), v ? m.setAttribute("aria-hidden", v) : m.removeAttribute("aria-hidden")
        }), this.chars.length = this.words.length = this.lines.length = c.length = this.masks.length = 0, this.isSplit = !1, _fonts ? .removeEventListener("loadingdone", this._split), u && (this._data.animTime = u.totalTime(), u.revert()), (o = (i = this.vars).onRevert) == null || o.call(i, this), this
    }
    static create(i, o) {
        return new Kr(i, o)
    }
    static register(i) {
        gsap = gsap || i || window.gsap, gsap && (_toArray = gsap.utils.toArray, _context = gsap.core.context || _context), !_coreInitted && window.innerWidth > 0 && (_fonts = document.fonts, _coreInitted = !0)
    }
};
_SplitText.version = "3.13.0";
let SplitText = _SplitText;
class TransitionUtils {
    static isWorksTransition(i) {
        return i && (i.from.url.includes("/works") && i.to.url.includes("/works/detail") || i.from.url.includes("/works/detail") && i.to.url.includes("/works"))
    }
    static isWorksDetailToDetail(i) {
        return i.from.url.includes("/works/detail") && i.to.url.includes("/works/detail")
    }
    static isWorksCategoryToDetail(i) {
        return i.from.url.includes("/works") && !i.from.url.includes("/works/detail") && i.to.url.includes("/works/detail")
    }
    static isWorksCategoryToCategory(i) {
        return i.from.url.includes("/works") && i.to.url.includes("/works") && !i.from.url.includes("/works/detail") && !i.to.url.includes("/works/detail")
    }
    static isWorksDetailToCategory(i) {
        return i.from.url.includes("/works/detail") && i.to.url.includes("/works") && !i.to.url.includes("/works/detail")
    }
    static shouldSkipTransition(i) {
        return !1
    }
    static shouldUsePartialTransition(i) {
        return this.isWorksCategoryToCategory(i) || this.isWorksDetailToDetail(i)
    }
    static isSameUrlTransition(i) {
        return i && i.from.url === i.to.url
    }
    static isWorksRelatedPage(i, o) {
        const c = o.getPageNameFromUrl(i);
        return c === "works" || c === "works-detail"
    }
}
gsapWithCSS.registerPlugin(SplitText);
class SubPageTitleAnimation {
    _titleElement = null;
    _splitText = null;
    _timeline = null;
    constructor() {} in (i) {
        i && TransitionUtils.isWorksDetailToDetail(i) || (this._titleElement = document.querySelector("#animated-title"), this._titleElement && (this._createSplitText(), this._animateChars()))
    }
    _createSplitText() {
        this._titleElement && (this._splitText = new SplitText(this._titleElement, {
            type: "chars"
        }), gsapWithCSS.set(this._splitText.chars, {
            opacity: 0,
            y: 30
        }))
    }
    _animateChars() {
        !this._splitText || !this._splitText.chars || (this._timeline = gsapWithCSS.timeline(), this._splitText.chars.forEach((i, o) => {
            this._timeline.to(i, {
                opacity: 1,
                y: 0,
                duration: .6,
                ease: "power2.out"
            }, o * .05)
        }))
    }
    out() {
        this._timeline && (this._timeline.kill(), this._timeline = null), this._splitText && (this._splitText.revert(), this._splitText = null), this._titleElement = null
    }
}
class PageSub extends PageBase {
    _titleAnimation;
    constructor() {
        super(), this._titleAnimation = new SubPageTitleAnimation
    }
    inStart(i) {
        super.inStart(i), this._titleAnimation.in(i)
    }
    outStart(i) {
        super.outStart(i), this._titleAnimation.out()
    }
}
class BGQuadTreeWorksManager {
    setup() {
        const i = document.querySelector("[data-works-container]");
        if (!i) {
            console.warn("Works container not found");
            return
        }
        const o = document.querySelectorAll("[data-top_works_item]");
        if (o.length === 0) {
            console.warn("No works elements found");
            return
        }
        const c = this.extractWorksDataFromElements(o);
        gl.sceneMain.bgQuadTree.works.setElement(i, c)
    }
    extractWorksDataFromElements(i) {
        return Array.from(i).map(o => ({
            title: "",
            img: o.getAttribute("data-top_works_item") || "",
            links: [],
            date: ""
        }))
    }
}
class ServiceIndicatorController {
    container = null;
    dots = null;
    constructor() {
        this.init()
    }
    init() {
        if (this.container = document.querySelector("[data-service-indicator]"), this.dots = document.querySelectorAll("[data-service-indicator-dot]"), !this.container || !this.dots.length) {
            console.warn("ServiceIndicatorController: Elements not found");
            return
        }
        this.updateIndicators(0)
    }
    updateIndicators(i) {
        if (!this.dots) return;
        const o = Math.max(0, Math.min(2, i));
        this.dots.forEach((c, u) => {
            c.removeAttribute("data-active"), c.removeAttribute("data-partially-active"), u === o && c.setAttribute("data-active", "true")
        })
    }
    show() {
        this.container && (this.container.style.opacity = "1", this.container.style.visibility = "visible")
    }
    hide() {
        this.container && (this.container.style.opacity = "0", this.container.style.visibility = "hidden")
    }
    dispose() {
        this.container = null, this.dots = null
    }
}
gsapWithCSS.registerPlugin(SplitText);
class ServiceItemController {
    _container = null;
    _items = null;
    _currentItemIndex = -1;
    _currentAnimation = null;
    _splits = new Map;
    _serviceInTimeline = null;
    _serviceInTrigger = null;
    _tickerCallback = null;
    _serviceIndicatorController = null;
    constructor() {
        topScrollManager.on("service/item_enter", i => {
            this._onItemEnter(i)
        }), topScrollManager.on("service/item_leave", i => {
            this._onItemLeave(i)
        })
    } in () {
        if (this._container = document.querySelector("[data-service-container]"), !this._container) {
            console.warn("ServiceItemController: Service container not found");
            return
        }
        if (this._items = this._container.querySelectorAll("[data-service_item]"), !this._items || this._items.length === 0) {
            console.warn("ServiceItemController: Service items not found");
            return
        }
        this._setupItems(), this._setupServiceInTrigger(), this._initializeServiceIndicator()
    }
    out() {
        this._tickerCallback && (gsapWithCSS.ticker.remove(this._tickerCallback), this._tickerCallback = null), this._disposeServiceIndicator(), this._currentAnimation && this._currentAnimation.kill(), this._serviceInTimeline && this._serviceInTimeline.kill(), this._splits.forEach(i => {
            i.revert()
        }), this._splits.clear(), this._currentAnimation = null, this._serviceInTimeline = null, this._serviceInTrigger = null, this._container = null, this._items = null, this._currentItemIndex = -1
    }
    _setupServiceInTrigger() {
        if (this._serviceInTrigger = topScrollManager.getTrigger("service_in"), !this._serviceInTrigger || !this._container) {
            console.warn("ServiceItemController: service_in trigger or container not found");
            return
        }
        this._serviceInTimeline = gsapWithCSS.timeline({
            paused: !0
        }), gsapWithCSS.set(this._container, {
            opacity: 0
        }), this._serviceInTimeline.to(this._container, {
            opacity: 1,
            duration: .6,
            ease: "power2.out"
        }), this._tickerCallback = () => {
            if (this._serviceInTrigger && this._serviceInTimeline && this._container) {
                const i = Math.min(this._serviceInTrigger.progress, 1);
                this._serviceInTimeline.progress(i)
            }
        }, gsapWithCSS.ticker.add(this._tickerCallback)
    }
    _setupItems() {
        this._items && (this._items.forEach(i => {
            i.style.visibility = "hidden", i.style.opacity = "0";
            const o = i.querySelector("[data-service_title]");
            if (o) {
                const c = SplitText.create(o, {
                    type: "chars"
                });
                this._splits.set(o, c)
            }
        }), this._currentItemIndex = -1)
    }
    _onItemEnter(i) {
        !this._items || this._currentItemIndex === i || (this._currentAnimation && this._currentAnimation.revert(), this._items.forEach((o, c) => {
            c === i ? this._showItem(i) : this._hideItem(c)
        }), this._currentItemIndex = i, this._updateIndicator())
    }
    _onItemLeave(i) {
        this._items && (this._hideItem(i), this._currentItemIndex === i && (this._currentItemIndex = -1))
    }
    _hideItem(i) {
        if (!this._items) return;
        const o = this._items[i],
            c = o.querySelector("[data-service_title]"),
            u = o.querySelectorAll("[data-service_description]");
        if (c && this._splits.has(c)) {
            const p = this._splits.get(c);
            gsapWithCSS.to(p.chars, {
                y: -10,
                opacity: 0,
                duration: .4,
                ease: "power2.in",
                stagger: .02
            })
        }
        u.forEach(p => {
            gsapWithCSS.to(p, {
                opacity: 0,
                duration: .3,
                ease: "power2.in"
            })
        }), gsapWithCSS.to(o, {
            opacity: 0,
            duration: .5,
            ease: "power2.inOut",
            onComplete: () => {
                o.style.visibility = "hidden"
            }
        })
    }
    _showItem(i) {
        if (!this._items) return;
        const o = this._items[i],
            c = o.querySelector("[data-service_title]"),
            u = o.querySelectorAll("[data-service_description]");
        if (o.style.visibility = "visible", gsapWithCSS.to(o, {
                opacity: 1,
                duration: .3,
                ease: "power2.out"
            }), c && this._splits.has(c)) {
            const p = this._splits.get(c);
            gsapWithCSS.set(p.chars, {
                y: 10,
                opacity: 0
            }), this._currentAnimation = gsapWithCSS.to(p.chars, {
                y: 0,
                opacity: 1,
                duration: .7,
                ease: "power4",
                stagger: .04
            })
        }
        u.forEach(p => {
            gsapWithCSS.set(p, {
                opacity: 0
            }), gsapWithCSS.to(p, {
                opacity: 1,
                duration: .5,
                ease: "power2.out",
                delay: .3
            })
        })
    }
    _initializeServiceIndicator() {
        setTimeout(() => {
            this._serviceIndicatorController = new ServiceIndicatorController, this._serviceIndicatorController.show(), this._updateIndicator()
        }, 100)
    }
    _disposeServiceIndicator() {
        this._serviceIndicatorController && (this._serviceIndicatorController.dispose(), this._serviceIndicatorController = null)
    }
    _updateIndicator() {
        this._serviceIndicatorController && this._currentItemIndex >= 0 && this._serviceIndicatorController.updateIndicators(this._currentItemIndex)
    }
}
class ServiceTitleController {
    _titleElement = null;
    _items = null;
    _currentAnimation = null;
    constructor() {
        topScrollManager.on("service/item_enter", i => {
            this._onItemEnter(i)
        })
    } in () {
        if (this._titleElement = document.querySelector("[data-service-title]"), !this._titleElement) {
            console.warn("ServiceTitleController: Service title element not found - this may be expected on some pages");
            return
        }
        const i = document.querySelector("[data-service-container]");
        if (this._items = i ? .querySelectorAll("[data-service_item]") || null, !this._items || this._items.length === 0) {
            console.warn("ServiceTitleController: Service items not found - this may be expected on some pages");
            return
        }
        this._titleElement.style.visibility = "visible", this._titleElement.style.opacity = "1"
    }
    out() {
        this._currentAnimation && this._currentAnimation.kill(), this._currentAnimation = null, this._titleElement = null, this._items = null
    }
    _onItemEnter(i) {
        if (!this._items || !this._titleElement) return;
        const o = this._items[i];
        if (!o) return;
        o.getAttribute("data-service_item") === "stellla" ? this._hideTitle() : this._showTitle()
    }
    _hideTitle() {
        this._titleElement && (this._currentAnimation && this._currentAnimation.kill(), this._currentAnimation = gsapWithCSS.to(this._titleElement, {
            opacity: 0,
            y: -0,
            duration: .4,
            ease: "power2.inOut"
        }))
    }
    _showTitle() {
        this._titleElement && (this._currentAnimation && this._currentAnimation.kill(), this._currentAnimation = gsapWithCSS.to(this._titleElement, {
            opacity: 1,
            y: 0,
            duration: .4,
            ease: "power2.inOut"
        }))
    }
}
gsapWithCSS.registerPlugin(SplitText);
class WorksItemController {
    _container = null;
    _items = null;
    _currentItemIndex = -1;
    _currentAnimation = null;
    _splits = new Map;
    constructor() {
        topScrollManager.on("works/item_enter", i => {
            this._onItemEnter(i)
        }), topScrollManager.on("works/item_leave", i => {
            this._onItemLeave(i)
        })
    } in () {
        if (this._container = document.querySelector("[data-works-container]"), !this._container) {
            console.warn("WorksItemController: Works container not found");
            return
        }
        if (this._items = this._container.querySelectorAll("[data-works_item]"), !this._items || this._items.length === 0) {
            console.warn("WorksItemController: Works items not found");
            return
        }
        this._setupItems()
    }
    out() {
        this._currentAnimation && this._currentAnimation.kill(), this._splits.forEach(i => {
            i.revert()
        }), this._splits.clear(), this._currentAnimation = null, this._container = null, this._items = null, this._currentItemIndex = -1
    }
    _setupItems() {
        this._items && (this._items.forEach(i => {
            i.style.visibility = "hidden", i.style.opacity = "0";
            const o = i.querySelector("[data-works_title]");
            if (o) {
                const c = SplitText.create(o, {
                    type: "chars"
                });
                this._splits.set(o, c)
            }
        }), this._currentItemIndex = -1)
    }
    _onItemEnter(i) {
        !this._items || this._currentItemIndex === i || (this._currentAnimation && this._currentAnimation.revert(), this._showItem(i), this._currentItemIndex = i)
    }
    _onItemLeave(i) {
        this._items && (this._hideItem(i), this._currentItemIndex === i && (this._currentItemIndex = -1))
    }
    _hideItem(i) {
        if (!this._items) return;
        const o = this._items[i],
            c = o.querySelector("[data-works_title]"),
            u = o.querySelector("[data-works_description]");
        if (c && this._splits.has(c)) {
            const p = this._splits.get(c);
            gsapWithCSS.to(p.chars, {
                y: -10,
                opacity: 0,
                duration: .4,
                ease: "power2.in",
                stagger: .001
            })
        }
        u && gsapWithCSS.to(u, {
            opacity: 0,
            duration: .3,
            ease: "power2.in"
        }), gsapWithCSS.to(o, {
            opacity: 0,
            duration: .5,
            ease: "power2.inOut"
        })
    }
    _showItem(i) {
        if (!this._items) return;
        const o = this._items[i],
            c = o.querySelector("[data-works_title]"),
            u = o.querySelector("[data-works_description]");
        if (o.style.visibility = "visible", gsapWithCSS.to(o, {
                opacity: 1,
                duration: .3,
                ease: "power2.out"
            }), c && this._splits.has(c)) {
            const p = this._splits.get(c);
            gsapWithCSS.set(p.chars, {
                y: 10,
                opacity: 0
            }), this._currentAnimation = gsapWithCSS.to(p.chars, {
                y: 0,
                opacity: 1,
                duration: .7,
                ease: "power4",
                stagger: .01
            })
        }
        u && (gsapWithCSS.set(u, {
            opacity: 0
        }), gsapWithCSS.to(u, {
            opacity: 1,
            duration: .5,
            ease: "power2.out",
            delay: .3
        }))
    }
}
class _BaseMissionVisionController {
    static PATH_LENGTH = 500;
    static ANIMATION_CONFIG = {
        PATH_LERP_SPEED: .4,
        PATH_SMOOTH_SPEED: .4,
        LINE_DURATION: .1,
        MARKER_DURATION: .5
    };
    _elements = {
        container: null,
        title: null,
        path: null,
        textEn: null,
        texts: [],
        lines: [],
        markers: []
    };
    _timeline = null;
    constructor() {}
    setupElements() {
        const i = document.querySelector(this.containerSelector);
        i && (this._elements = {
            container: i,
            title: i.querySelector(this.titleSelector),
            path: i.querySelector("path"),
            textEn: i.querySelector(this.textEnSelector),
            texts: Array.from(i.querySelectorAll(this.textSelector)),
            lines: Array.from(i.querySelectorAll("[data-line-index]")),
            markers: []
        }, this._elements.lines.forEach((o, c) => {
            gsapWithCSS.set(o, {
                opacity: 0,
                y: 20
            });
            const u = o.querySelector(`[data-marker-${c}]`);
            u && (this._elements.markers.push(u), u.style.backgroundSize = "0% 100%")
        }), this._elements.path && this.setupPathAnimation())
    }
    setupPathAnimation() {
        this._elements.path && (this._elements.path.style.strokeDasharray = `0 ${_BaseMissionVisionController.PATH_LENGTH}`, this._elements.path.style.strokeDashoffset = "0", this._timeline = gsapWithCSS.timeline({
            paused: !0
        }), this._timeline.to(this._elements.path.style, {
            strokeDasharray: `${_BaseMissionVisionController.PATH_LENGTH} 0`,
            duration: 1,
            ease: "none"
        }))
    }
    updatePathAnimation(i) {
        if (!this._timeline) return 0;
        const o = lerper.set(`${this.lerperPrefix}_path_raw`, i.progress, _BaseMissionVisionController.ANIMATION_CONFIG.PATH_LERP_SPEED),
            c = Math.round(o),
            u = lerper.set(`${this.lerperPrefix}_path`, c - (c - o) * .7, _BaseMissionVisionController.ANIMATION_CONFIG.PATH_SMOOTH_SPEED);
        return this._timeline.progress(u), u
    }
    updateLinesAndMarkers(i) {
        this._elements.lines.forEach((o, c) => {
            const u = c / this._elements.lines.length * .8,
                p = gsapWithCSS.utils.clamp(0, 1, (i - u) / _BaseMissionVisionController.ANIMATION_CONFIG.LINE_DURATION),
                m = gsapWithCSS.utils.interpolate(0, 1, gsapWithCSS.parseEase("power3.out")(p));
            o.style.opacity = m.toString(), o.style.transform = `translateY(${(1-m)*8}px)`;
            const g = u + _BaseMissionVisionController.ANIMATION_CONFIG.LINE_DURATION * .3,
                _ = gsapWithCSS.utils.clamp(0, 1, (i - g) / _BaseMissionVisionController.ANIMATION_CONFIG.MARKER_DURATION),
                v = gsapWithCSS.utils.interpolate(0, 1, gsapWithCSS.parseEase("power2.out")(_)),
                x = this._elements.markers[c];
            x && (x.style.backgroundSize = `${v*100}% 100%`)
        })
    }
    updateOpacityAndBlur(i, o) {
        const {
            title: c,
            path: u,
            texts: p,
            textEn: m
        } = this._elements;
        if (!c || !u || !m || deviceManager.isSPLayout) return;
        const g = Math.max(0, 1 - i.progress * 2),
            _ = g * o,
            v = (1 - g) * 10;
        u.style.opacity = g.toString();
        const x = `blur(${v}px)`;
        c.style.filter = x, m.style.opacity = _.toString(), m.style.filter = x, p.forEach(y => {
            y.style.opacity = g.toString(), y.style.filter = x
        })
    }
    resetElements() {
        this._elements.markers.forEach(i => {
            i.style.backgroundSize = "0% 100%"
        }), this._elements = {
            container: null,
            title: null,
            path: null,
            textEn: null,
            texts: [],
            lines: [],
            markers: []
        }
    }
    update() {
        if (!this._elements.container || !this._timeline || !this._elements.path || !this._elements.title || !this._elements.textEn) return;
        const i = topScrollManager.getTrigger(this.triggerName),
            o = topScrollManager.getTrigger(this.outTriggerName);
        if (!i || !o) return;
        this.updateSpecificEffects(i);
        const c = this.updatePathAnimation(i);
        this.updateLinesAndMarkers(c), this.updateOpacityAndBlur(o, c)
    } in () {
        this.setupElements()
    }
    out() {
        this._timeline && (this._timeline.kill(), this._timeline = null), this.resetElements()
    }
    resize() {}
}
class MissionController extends _BaseMissionVisionController {
    static MASK_CONFIG = {
        MASK_LERP_SPEED: 1,
        MASK_FADE: "3%"
    };
    get containerSelector() {
        return "[data-mission-container]"
    }
    get titleSelector() {
        return "[data-mission-title]"
    }
    get textEnSelector() {
        return "[data-mission-text_en]"
    }
    get textSelector() {
        return "[data-mission-text]"
    }
    get triggerName() {
        return "mission_in"
    }
    get outTriggerName() {
        return "vision"
    }
    get lerperPrefix() {
        return "mission"
    }
    constructor() {
        super()
    }
    updateMaskEffect(i) {
        if (!this._elements.container || deviceManager.isMobile) return;
        const c = lerper.set("mission_mask_progress", i.progress, MissionController.MASK_CONFIG.MASK_LERP_SPEED) * 100 - 1.5;
        this._elements.container.style.setProperty("--mask-height", `${c}%`), this._elements.container.style.setProperty("--mask-fade", MissionController.MASK_CONFIG.MASK_FADE)
    }
    updateSpecificEffects(i) {
        this.updateMaskEffect(i)
    }
}
class VisionController extends _BaseMissionVisionController {
    get containerSelector() {
        return "[data-vision-container]"
    }
    get titleSelector() {
        return "[data-vision-title]"
    }
    get textEnSelector() {
        return "[data-vision-text_en]"
    }
    get textSelector() {
        return "[data-vision-text]"
    }
    get triggerName() {
        return "vision"
    }
    get outTriggerName() {
        return "vision_out"
    }
    get lerperPrefix() {
        return "vision"
    }
    constructor() {
        super()
    }
    updateSpecificEffects(i) {
        const o = i.progress;
        this._elements.container && (this._elements.container.style.opacity = o.toString())
    }
}
class VisionMissionController {
    _missionController;
    _visionController;
    _tickerCallback = null;
    constructor() {
        this._missionController = new MissionController, this._visionController = new VisionController
    } in () {
        this._missionController.in(), this._visionController.in(), this._tickerCallback = () => {
            this._missionController.update(), this._visionController.update()
        }, gsapWithCSS.ticker.add(this._tickerCallback)
    }
    out() {
        this._tickerCallback && (gsapWithCSS.ticker.remove(this._tickerCallback), this._tickerCallback = null), this._missionController.out(), this._visionController.out()
    }
    resize() {
        this._missionController.resize(), this._visionController.resize()
    }
}
gsapWithCSS.registerPlugin(SplitText);
class StelllaSectionController {
    _element = null;
    _frameElement = null;
    _stelllaTrigger = null;
    _tickerCallback = null;
    constructor() {} in () {
        this._element = document.querySelector("[data-top-stellla-content]"), this._element && (this._frameElement = this._element.querySelector("[data-top-stellla-frame]"), gsapWithCSS.set(this._element, {
            opacity: 0
        }), this._stelllaTrigger = topScrollManager.getTrigger("stellla"), this._stelllaTrigger && (this._tickerCallback = () => {
            if (this._element && this._frameElement && this._stelllaTrigger) {
                const i = Math.min(this._stelllaTrigger.progress * 1.5, 1);
                gsapWithCSS.set(this._element, {
                    opacity: i
                }), this._frameElement.style.setProperty("--progress", i.toString())
            }
        }, gsapWithCSS.ticker.add(this._tickerCallback)))
    }
    out() {
        this._tickerCallback && (gsapWithCSS.ticker.remove(this._tickerCallback), this._tickerCallback = null), this._stelllaTrigger = null, this._element = null, this._frameElement = null
    }
    resize() {}
}
var ScrambleTextPlugin$1 = {
        exports: {}
    },
    ScrambleTextPlugin = ScrambleTextPlugin$1.exports,
    hasRequiredScrambleTextPlugin;

function requireScrambleTextPlugin() {
    return hasRequiredScrambleTextPlugin || (hasRequiredScrambleTextPlugin = 1, function(l, i) {
        (function(o, c) {
            c(i)
        })(ScrambleTextPlugin, function(o) {
            var c = /(?:^\s+|\s+$)/g,
                u = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2642\u2640]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDD27\uDCBC\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCC\uDFCB]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

            function p(M) {
                var A = M.nodeType,
                    D = "";
                if (A === 1 || A === 9 || A === 11) {
                    if (typeof M.textContent == "string") return M.textContent;
                    for (M = M.firstChild; M; M = M.nextSibling) D += p(M)
                } else if (A === 3 || A === 4) return M.nodeValue;
                return D
            }

            function m(M, A, D, R, I) {
                if (M += "", D && (M = M.trim ? M.trim() : M.replace(c, "")), A && A !== "") return M.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(A);
                for (var k = [], F = M.length, V = 0, B, U; V < F; V++) U = M.charAt(V), (U.charCodeAt(0) >= 55296 && U.charCodeAt(0) <= 56319 || M.charCodeAt(V + 1) >= 65024 && M.charCodeAt(V + 1) <= 65039) && (B = ((M.substr(V, 12).split(u) || [])[1] || "").length || 2, U = M.substr(V, B), k.emoji = 1, V += B - 1), k.push(I ? U : U === ">" ? "&gt;" : U === "<" ? "&lt;" : R && U === " " && (M.charAt(V - 1) === " " || M.charAt(V + 1) === " ") ? "&nbsp;" : U);
                return k
            }
            /*!
             * ScrambleTextPlugin 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var g = function() {
                    function M(D) {
                        this.chars = m(D), this.sets = [], this.length = 50;
                        for (var R = 0; R < 20; R++) this.sets[R] = S(80, this.chars)
                    }
                    var A = M.prototype;
                    return A.grow = function(R) {
                        for (var I = 0; I < 20; I++) this.sets[I] += S(R - this.length, this.chars);
                        this.length = R
                    }, M
                }(),
                _, v, x = function() {
                    return _ || typeof window < "u" && (_ = window.gsap) && _.registerPlugin && _
                },
                y = 1,
                b = /\s+/g,
                S = function(A, D) {
                    for (var R = D.length, I = ""; --A > -1;) I += D[~~(Math.random() * R)];
                    return I
                },
                C = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                E = C.toLowerCase(),
                P = {
                    upperCase: new g(C),
                    lowerCase: new g(E),
                    upperAndLowerCase: new g(C + E)
                },
                w = function() {
                    v = _ = x()
                },
                T = {
                    version: "3.13.0",
                    name: "scrambleText",
                    register: function(A, D, R) {
                        _ = A, w()
                    },
                    init: function(A, D, R, I, k) {
                        if (v || w(), this.prop = "innerHTML" in A ? "innerHTML" : "textContent" in A ? "textContent" : 0, !!this.prop) {
                            this.target = A, typeof D != "object" && (D = {
                                text: D
                            });
                            var F = D.text || D.value || "",
                                V = D.trim !== !1,
                                B = this,
                                U, H, Q, Y;
                            return B.delimiter = U = D.delimiter || "", B.original = m(p(A).replace(b, " ").split("&nbsp;").join(""), U, V), (F === "{original}" || F === !0 || F == null) && (F = B.original.join(U)), B.text = m((F || "").replace(b, " "), U, V), B.hasClass = !!(D.newClass || D.oldClass), B.newClass = D.newClass, B.oldClass = D.oldClass, Y = U === "", B.textHasEmoji = Y && !!B.text.emoji, B.charsHaveEmoji = !!D.chars && !!m(D.chars).emoji, B.length = Y ? B.original.length : B.original.join(U).length, B.lengthDif = (Y ? B.text.length : B.text.join(U).length) - B.length, B.fillChar = D.fillChar || D.chars && ~D.chars.indexOf(" ") ? "&nbsp;" : "", B.charSet = Q = P[D.chars || "upperCase"] || new g(D.chars), B.speed = .05 / (D.speed || 1), B.prevScrambleTime = 0, B.setIndex = Math.random() * 20 | 0, H = B.length + Math.max(B.lengthDif, 0), H > Q.length && Q.grow(H), B.chars = Q.sets[B.setIndex], B.revealDelay = D.revealDelay || 0, B.tweenLength = D.tweenLength !== !1, B.tween = R, B.rightToLeft = !!D.rightToLeft, B._props.push("scrambleText", "text"), y
                        }
                    },
                    render: function(A, D) {
                        var R = D.target,
                            I = D.prop,
                            k = D.text,
                            F = D.delimiter,
                            V = D.tween,
                            B = D.prevScrambleTime,
                            U = D.revealDelay,
                            H = D.setIndex,
                            Q = D.chars,
                            Y = D.charSet,
                            O = D.length,
                            G = D.textHasEmoji,
                            L = D.charsHaveEmoji,
                            N = D.lengthDif,
                            K = D.tweenLength,
                            Z = D.oldClass,
                            he = D.newClass,
                            we = D.rightToLeft,
                            ie = D.fillChar,
                            _e = D.speed,
                            Te = D.original,
                            Me = D.hasClass,
                            Pe = k.length,
                            be = V._time,
                            Be = be - B,
                            De, We, Re, q, At, dt, tt, ke, ot, ze, Ie;
                        U && (V._from && (be = V._dur - be), A = be === 0 ? 0 : be < U ? 1e-6 : be === V._dur ? 1 : V._ease((be - U) / (V._dur - U))), A < 0 ? A = 0 : A > 1 && (A = 1), we && (A = 1 - A), De = ~~(A * Pe + .5), A ? ((Be > _e || Be < -_e) && (D.setIndex = H = (H + (Math.random() * 19 | 0)) % 20, D.chars = Y.sets[H], D.prevScrambleTime += Be), q = Q) : q = Te.join(F), Ie = V._from ? A : 1 - A, ze = O + (K ? V._from ? Ie * Ie * Ie : 1 - Ie * Ie * Ie : 1) * N, we ? A === 1 && (V._from || V.data === "isFromStart") ? (Re = "", q = Te.join(F)) : (tt = k.slice(De).join(F), L ? Re = m(q).slice(0, ze - (G ? m(tt) : tt).length + .5 | 0).join("") : Re = q.substr(0, ze - (G ? m(tt) : tt).length + .5 | 0), q = tt) : (Re = k.slice(0, De).join(F), We = (G ? m(Re) : Re).length, L ? q = m(q).slice(We, ze + .5 | 0).join("") : q = q.substr(We, ze - We + .5 | 0)), Me ? (ke = we ? Z : he, ot = we ? he : Z, At = ke && De !== 0, dt = ot && De !== Pe, tt = (At ? "<span class='" + ke + "'>" : "") + Re + (At ? "</span>" : "") + (dt ? "<span class='" + ot + "'>" : "") + F + q + (dt ? "</span>" : "")) : tt = Re + F + q, R[I] = ie === "&nbsp;" && ~tt.indexOf("  ") ? tt.split("  ").join("&nbsp;&nbsp;") : tt
                    }
                };
            T.emojiSafeSplit = m, T.getText = p, x() && _.registerPlugin(T), o.ScrambleTextPlugin = T, o.default = T, Object.defineProperty(o, "__esModule", {
                value: !0
            })
        })
    }(ScrambleTextPlugin$1, ScrambleTextPlugin$1.exports)), ScrambleTextPlugin$1.exports
}
var ScrambleTextPluginExports = requireScrambleTextPlugin();
gsapWithCSS.registerPlugin(ScrambleTextPluginExports.ScrambleTextPlugin);
class MoreWorksController {
    static _instance = null;
    _moreWorksButton = null;
    constructor() {
        this.initialize()
    }
    static getInstance() {
        return MoreWorksController._instance || (MoreWorksController._instance = new MoreWorksController), MoreWorksController._instance
    }
    initialize() {
        document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => {
            this.setupElements()
        }) : this.setupElements()
    }
    setupElements() {
        if (this._moreWorksButton = document.querySelector("[data-scramble-text]"), !this._moreWorksButton) return;
        const i = this._moreWorksButton.textContent || "";
        this._moreWorksButton.dataset.originalText = i, this._moreWorksButton.addEventListener("mouseenter", () => this.onMouseEnter(this._moreWorksButton)), this._moreWorksButton.addEventListener("mouseleave", () => this.onMouseLeave(this._moreWorksButton))
    }
    onMouseEnter(i) {
        const o = i.dataset.originalText;
        o && this.scrambleText(i, o, .4)
    }
    onMouseLeave(i) {}
    scrambleText(i, o, c) {
        gsapWithCSS.to(i, {
            duration: c,
            scrambleText: {
                text: o,
                chars: "ALCHEALCHEALCHE",
                revealDelay: .2,
                speed: 1.5
            },
            ease: "power2.out"
        })
    }
    init() {
        this.setupElements()
    }
    dispose() {
        this._moreWorksButton && (this._moreWorksButton.removeEventListener("mouseenter", () => this.onMouseEnter(this._moreWorksButton)), this._moreWorksButton.removeEventListener("mouseleave", () => this.onMouseLeave(this._moreWorksButton))), this._moreWorksButton = null
    }
}
MoreWorksController.getInstance();
var ScrollTrigger$1 = {
        exports: {}
    },
    ScrollTrigger = ScrollTrigger$1.exports,
    hasRequiredScrollTrigger;

function requireScrollTrigger() {
    return hasRequiredScrollTrigger || (hasRequiredScrollTrigger = 1, function(l, i) {
        (function(o, c) {
            c(i)
        })(ScrollTrigger, function(o) {
            function c(oe, z) {
                for (var ee = 0; ee < z.length; ee++) {
                    var j = z[ee];
                    j.enumerable = j.enumerable || !1, j.configurable = !0, "value" in j && (j.writable = !0), Object.defineProperty(oe, j.key, j)
                }
            }

            function u(oe, z, ee) {
                return z && c(oe.prototype, z), oe
            }
            /*!
             * Observer 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var p, m, g, _, v, x, y, b, S, C, E, P, w, T = function() {
                    return p || typeof window < "u" && (p = window.gsap) && p.registerPlugin && p
                },
                M = 1,
                A = [],
                D = [],
                R = [],
                I = Date.now,
                k = function(z, ee) {
                    return ee
                },
                F = function() {
                    var z = S.core,
                        ee = z.bridge || {},
                        j = z._scrollers,
                        X = z._proxies;
                    j.push.apply(j, D), X.push.apply(X, R), D = j, R = X, k = function(me, ue) {
                        return ee[me](ue)
                    }
                },
                V = function(z, ee) {
                    return ~R.indexOf(z) && R[R.indexOf(z) + 1][ee]
                },
                B = function(z) {
                    return !!~C.indexOf(z)
                },
                U = function(z, ee, j, X, ne) {
                    return z.addEventListener(ee, j, {
                        passive: X !== !1,
                        capture: !!ne
                    })
                },
                H = function(z, ee, j, X) {
                    return z.removeEventListener(ee, j, !!X)
                },
                Q = "scrollLeft",
                Y = "scrollTop",
                O = function() {
                    return E && E.isPressed || D.cache++
                },
                G = function(z, ee) {
                    var j = function X(ne) {
                        if (ne || ne === 0) {
                            M && (g.history.scrollRestoration = "manual");
                            var me = E && E.isPressed;
                            ne = X.v = Math.round(ne) || (E && E.iOS ? 1 : 0), z(ne), X.cacheID = D.cache, me && k("ss", ne)
                        } else(ee || D.cache !== X.cacheID || k("ref")) && (X.cacheID = D.cache, X.v = z());
                        return X.v + X.offset
                    };
                    return j.offset = 0, z && j
                },
                L = {
                    s: Q,
                    p: "left",
                    p2: "Left",
                    os: "right",
                    os2: "Right",
                    d: "width",
                    d2: "Width",
                    a: "x",
                    sc: G(function(oe) {
                        return arguments.length ? g.scrollTo(oe, N.sc()) : g.pageXOffset || _[Q] || v[Q] || x[Q] || 0
                    })
                },
                N = {
                    s: Y,
                    p: "top",
                    p2: "Top",
                    os: "bottom",
                    os2: "Bottom",
                    d: "height",
                    d2: "Height",
                    a: "y",
                    op: L,
                    sc: G(function(oe) {
                        return arguments.length ? g.scrollTo(L.sc(), oe) : g.pageYOffset || _[Y] || v[Y] || x[Y] || 0
                    })
                },
                K = function(z, ee) {
                    return (ee && ee._ctx && ee._ctx.selector || p.utils.toArray)(z)[0] || (typeof z == "string" && p.config().nullTargetWarn !== !1 ? console.warn("Element not found:", z) : null)
                },
                Z = function(z, ee) {
                    for (var j = ee.length; j--;)
                        if (ee[j] === z || ee[j].contains(z)) return !0;
                    return !1
                },
                he = function(z, ee) {
                    var j = ee.s,
                        X = ee.sc;
                    B(z) && (z = _.scrollingElement || v);
                    var ne = D.indexOf(z),
                        me = X === N.sc ? 1 : 2;
                    !~ne && (ne = D.push(z) - 1), D[ne + me] || U(z, "scroll", O);
                    var ue = D[ne + me],
                        He = ue || (D[ne + me] = G(V(z, j), !0) || (B(z) ? X : G(function(ft) {
                            return arguments.length ? z[j] = ft : z[j]
                        })));
                    return He.target = z, ue || (He.smooth = p.getProperty(z, "scrollBehavior") === "smooth"), He
                },
                we = function(z, ee, j) {
                    var X = z,
                        ne = z,
                        me = I(),
                        ue = me,
                        He = ee || 50,
                        ft = Math.max(500, He * 3),
                        Vt = function(ut, Kt) {
                            var Gt = I();
                            Kt || Gt - me > He ? (ne = X, X = ut, ue = me, me = Gt) : j ? X += ut : X = ne + (ut - ne) / (Gt - ue) * (me - ue)
                        },
                        Ct = function() {
                            ne = X = j ? 0 : X, ue = me = 0
                        },
                        st = function(ut) {
                            var Kt = ue,
                                Gt = ne,
                                oi = I();
                            return (ut || ut === 0) && ut !== X && Vt(ut), me === ue || oi - ue > ft ? 0 : (X + (j ? Gt : -Gt)) / ((j ? oi : me) - Kt) * 1e3
                        };
                    return {
                        update: Vt,
                        reset: Ct,
                        getVelocity: st
                    }
                },
                ie = function(z, ee) {
                    return ee && !z._gsapAllow && z.preventDefault(), z.changedTouches ? z.changedTouches[0] : z
                },
                _e = function(z) {
                    var ee = Math.max.apply(Math, z),
                        j = Math.min.apply(Math, z);
                    return Math.abs(ee) >= Math.abs(j) ? ee : j
                },
                Te = function() {
                    S = p.core.globals().ScrollTrigger, S && S.core && F()
                },
                Me = function(z) {
                    return p = z || T(), !m && p && typeof document < "u" && document.body && (g = window, _ = document, v = _.documentElement, x = _.body, C = [g, _, v, x], p.utils.clamp, w = p.core.context || function() {}, b = "onpointerenter" in x ? "pointer" : "mouse", y = Pe.isTouch = g.matchMedia && g.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in g || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, P = Pe.eventTypes = ("ontouchstart" in v ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in v ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
                        return M = 0
                    }, 500), Te(), m = 1), m
                };
            L.op = N, D.cache = 0;
            var Pe = function() {
                function oe(ee) {
                    this.init(ee)
                }
                var z = oe.prototype;
                return z.init = function(j) {
                    m || Me(p) || console.warn("Please gsap.registerPlugin(Observer)"), S || Te();
                    var X = j.tolerance,
                        ne = j.dragMinimum,
                        me = j.type,
                        ue = j.target,
                        He = j.lineHeight,
                        ft = j.debounce,
                        Vt = j.preventDefault,
                        Ct = j.onStop,
                        st = j.onStopDelay,
                        xe = j.ignore,
                        ut = j.wheelSpeed,
                        Kt = j.event,
                        Gt = j.onDragStart,
                        oi = j.onDragEnd,
                        jt = j.onDrag,
                        gi = j.onPress,
                        xt = j.onRelease,
                        ji = j.onRight,
                        Ht = j.onLeft,
                        gt = j.onUp,
                        Pi = j.onDown,
                        Vi = j.onChangeX,
                        nt = j.onChangeY,
                        pi = j.onChange,
                        mt = j.onToggleX,
                        ln = j.onToggleY,
                        ai = j.onHover,
                        Ai = j.onHoverEnd,
                        Di = j.onMove,
                        $t = j.ignoreCheck,
                        ii = j.isNormalizer,
                        ni = j.onGestureStart,
                        le = j.onGestureEnd,
                        li = j.onWheel,
                        Dn = j.onEnable,
                        _n = j.onDisable,
                        qi = j.onClick,
                        un = j.scrollSpeed,
                        xi = j.capture,
                        ri = j.allowClicks,
                        Ri = j.lockAxis,
                        Si = j.onLockAxis;
                    this.target = ue = K(ue) || v, this.vars = j, xe && (xe = p.utils.toArray(xe)), X = X || 1e-9, ne = ne || 0, ut = ut || 1, un = un || 1, me = me || "wheel,touch,pointer", ft = ft !== !1, He || (He = parseFloat(g.getComputedStyle(x).lineHeight) || 22);
                    var vn, Li, Ni, Lt, Qt, Oi, $i, pe = this,
                        Ui = 0,
                        hn = 0,
                        yn = j.passive || !Vt && j.passive !== !1,
                        Yt = he(ue, L),
                        dn = he(ue, N),
                        bn = Yt(),
                        Rn = dn(),
                        fi = ~me.indexOf("touch") && !~me.indexOf("pointer") && P[0] === "pointerdown",
                        xn = B(ue),
                        Jt = ue.ownerDocument || _,
                        Yi = [0, 0, 0],
                        Xi = [0, 0, 0],
                        pn = 0,
                        Zn = function() {
                            return pn = I()
                        },
                        si = function(pt, Nt) {
                            return (pe.event = pt) && xe && Z(pt.target, xe) || Nt && fi && pt.pointerType !== "touch" || $t && $t(pt, Nt)
                        },
                        fr = function() {
                            pe._vx.reset(), pe._vy.reset(), Li.pause(), Ct && Ct(pe)
                        },
                        fn = function() {
                            var pt = pe.deltaX = _e(Yi),
                                Nt = pe.deltaY = _e(Xi),
                                Ue = Math.abs(pt) >= X,
                                _t = Math.abs(Nt) >= X;
                            pi && (Ue || _t) && pi(pe, pt, Nt, Yi, Xi), Ue && (ji && pe.deltaX > 0 && ji(pe), Ht && pe.deltaX < 0 && Ht(pe), Vi && Vi(pe), mt && pe.deltaX < 0 != Ui < 0 && mt(pe), Ui = pe.deltaX, Yi[0] = Yi[1] = Yi[2] = 0), _t && (Pi && pe.deltaY > 0 && Pi(pe), gt && pe.deltaY < 0 && gt(pe), nt && nt(pe), ln && pe.deltaY < 0 != hn < 0 && ln(pe), hn = pe.deltaY, Xi[0] = Xi[1] = Xi[2] = 0), (Lt || Ni) && (Di && Di(pe), Ni && (Gt && Ni === 1 && Gt(pe), jt && jt(pe), Ni = 0), Lt = !1), Oi && !(Oi = !1) && Si && Si(pe), Qt && (li(pe), Qt = !1), vn = 0
                        },
                        Bn = function(pt, Nt, Ue) {
                            Yi[Ue] += pt, Xi[Ue] += Nt, pe._vx.update(pt), pe._vy.update(Nt), ft ? vn || (vn = requestAnimationFrame(fn)) : fn()
                        },
                        $n = function(pt, Nt) {
                            Ri && !$i && (pe.axis = $i = Math.abs(pt) > Math.abs(Nt) ? "x" : "y", Oi = !0), $i !== "y" && (Yi[2] += pt, pe._vx.update(pt, !0)), $i !== "x" && (Xi[2] += Nt, pe._vy.update(Nt, !0)), ft ? vn || (vn = requestAnimationFrame(fn)) : fn()
                        },
                        Sn = function(pt) {
                            if (!si(pt, 1)) {
                                pt = ie(pt, Vt);
                                var Nt = pt.clientX,
                                    Ue = pt.clientY,
                                    _t = Nt - pe.x,
                                    lt = Ue - pe.y,
                                    vt = pe.isDragging;
                                pe.x = Nt, pe.y = Ue, (vt || (_t || lt) && (Math.abs(pe.startX - Nt) >= ne || Math.abs(pe.startY - Ue) >= ne)) && (Ni = vt ? 2 : 1, vt || (pe.isDragging = !0), $n(_t, lt))
                            }
                        },
                        Ln = pe.onPress = function(yt) {
                            si(yt, 1) || yt && yt.button || (pe.axis = $i = null, Li.pause(), pe.isPressed = !0, yt = ie(yt), Ui = hn = 0, pe.startX = pe.x = yt.clientX, pe.startY = pe.y = yt.clientY, pe._vx.reset(), pe._vy.reset(), U(ii ? ue : Jt, P[1], Sn, yn, !0), pe.deltaX = pe.deltaY = 0, gi && gi(pe))
                        },
                        Et = pe.onRelease = function(yt) {
                            if (!si(yt, 1)) {
                                H(ii ? ue : Jt, P[1], Sn, !0);
                                var pt = !isNaN(pe.y - pe.startY),
                                    Nt = pe.isDragging,
                                    Ue = Nt && (Math.abs(pe.x - pe.startX) > 3 || Math.abs(pe.y - pe.startY) > 3),
                                    _t = ie(yt);
                                !Ue && pt && (pe._vx.reset(), pe._vy.reset(), Vt && ri && p.delayedCall(.08, function() {
                                    if (I() - pn > 300 && !yt.defaultPrevented) {
                                        if (yt.target.click) yt.target.click();
                                        else if (Jt.createEvent) {
                                            var lt = Jt.createEvent("MouseEvents");
                                            lt.initMouseEvent("click", !0, !0, g, 1, _t.screenX, _t.screenY, _t.clientX, _t.clientY, !1, !1, !1, !1, 0, null), yt.target.dispatchEvent(lt)
                                        }
                                    }
                                })), pe.isDragging = pe.isGesturing = pe.isPressed = !1, Ct && Nt && !ii && Li.restart(!0), Ni && fn(), oi && Nt && oi(pe), xt && xt(pe, Ue)
                            }
                        },
                        In = function(pt) {
                            return pt.touches && pt.touches.length > 1 && (pe.isGesturing = !0) && ni(pt, pe.isDragging)
                        },
                        Zi = function() {
                            return (pe.isGesturing = !1) || le(pe)
                        },
                        Qi = function(pt) {
                            if (!si(pt)) {
                                var Nt = Yt(),
                                    Ue = dn();
                                Bn((Nt - bn) * un, (Ue - Rn) * un, 1), bn = Nt, Rn = Ue, Ct && Li.restart(!0)
                            }
                        },
                        Ji = function(pt) {
                            if (!si(pt)) {
                                pt = ie(pt, Vt), li && (Qt = !0);
                                var Nt = (pt.deltaMode === 1 ? He : pt.deltaMode === 2 ? g.innerHeight : 1) * ut;
                                Bn(pt.deltaX * Nt, pt.deltaY * Nt, 0), Ct && !ii && Li.restart(!0)
                            }
                        },
                        Fn = function(pt) {
                            if (!si(pt)) {
                                var Nt = pt.clientX,
                                    Ue = pt.clientY,
                                    _t = Nt - pe.x,
                                    lt = Ue - pe.y;
                                pe.x = Nt, pe.y = Ue, Lt = !0, Ct && Li.restart(!0), (_t || lt) && $n(_t, lt)
                            }
                        },
                        Un = function(pt) {
                            pe.event = pt, ai(pe)
                        },
                        mn = function(pt) {
                            pe.event = pt, Ai(pe)
                        },
                        Qn = function(pt) {
                            return si(pt) || ie(pt, Vt) && qi(pe)
                        };
                    Li = pe._dc = p.delayedCall(st || .25, fr).pause(), pe.deltaX = pe.deltaY = 0, pe._vx = we(0, 50, !0), pe._vy = we(0, 50, !0), pe.scrollX = Yt, pe.scrollY = dn, pe.isDragging = pe.isGesturing = pe.isPressed = !1, w(this), pe.enable = function(yt) {
                        return pe.isEnabled || (U(xn ? Jt : ue, "scroll", O), me.indexOf("scroll") >= 0 && U(xn ? Jt : ue, "scroll", Qi, yn, xi), me.indexOf("wheel") >= 0 && U(ue, "wheel", Ji, yn, xi), (me.indexOf("touch") >= 0 && y || me.indexOf("pointer") >= 0) && (U(ue, P[0], Ln, yn, xi), U(Jt, P[2], Et), U(Jt, P[3], Et), ri && U(ue, "click", Zn, !0, !0), qi && U(ue, "click", Qn), ni && U(Jt, "gesturestart", In), le && U(Jt, "gestureend", Zi), ai && U(ue, b + "enter", Un), Ai && U(ue, b + "leave", mn), Di && U(ue, b + "move", Fn)), pe.isEnabled = !0, pe.isDragging = pe.isGesturing = pe.isPressed = Lt = Ni = !1, pe._vx.reset(), pe._vy.reset(), bn = Yt(), Rn = dn(), yt && yt.type && Ln(yt), Dn && Dn(pe)), pe
                    }, pe.disable = function() {
                        pe.isEnabled && (A.filter(function(yt) {
                            return yt !== pe && B(yt.target)
                        }).length || H(xn ? Jt : ue, "scroll", O), pe.isPressed && (pe._vx.reset(), pe._vy.reset(), H(ii ? ue : Jt, P[1], Sn, !0)), H(xn ? Jt : ue, "scroll", Qi, xi), H(ue, "wheel", Ji, xi), H(ue, P[0], Ln, xi), H(Jt, P[2], Et), H(Jt, P[3], Et), H(ue, "click", Zn, !0), H(ue, "click", Qn), H(Jt, "gesturestart", In), H(Jt, "gestureend", Zi), H(ue, b + "enter", Un), H(ue, b + "leave", mn), H(ue, b + "move", Fn), pe.isEnabled = pe.isPressed = pe.isDragging = !1, _n && _n(pe))
                    }, pe.kill = pe.revert = function() {
                        pe.disable();
                        var yt = A.indexOf(pe);
                        yt >= 0 && A.splice(yt, 1), E === pe && (E = 0)
                    }, A.push(pe), ii && B(ue) && (E = pe), pe.enable(Kt)
                }, u(oe, [{
                    key: "velocityX",
                    get: function() {
                        return this._vx.getVelocity()
                    }
                }, {
                    key: "velocityY",
                    get: function() {
                        return this._vy.getVelocity()
                    }
                }]), oe
            }();
            Pe.version = "3.13.0", Pe.create = function(oe) {
                return new Pe(oe)
            }, Pe.register = Me, Pe.getAll = function() {
                return A.slice()
            }, Pe.getById = function(oe) {
                return A.filter(function(z) {
                    return z.vars.id === oe
                })[0]
            }, T() && p.registerPlugin(Pe);
            /*!
             * ScrollTrigger 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var be, Be, De, We, Re, q, At, dt, tt, ke, ot, ze, Ie, Dt, J, $, ae, ge, ye, fe, Ke, Le, Oe, Ze, Se, qe, Je, it, Fe, ct, te, Ve, Ce, Xe, Ee = 1,
                ve = Date.now,
                Ye = ve(),
                et = 0,
                kt = 0,
                It = function(z, ee, j) {
                    var X = Ti(z) && (z.substr(0, 6) === "clamp(" || z.indexOf("max") > -1);
                    return j["_" + ee + "Clamp"] = X, X ? z.substr(6, z.length - 7) : z
                },
                Ii = function(z, ee) {
                    return ee && (!Ti(z) || z.substr(0, 6) !== "clamp(") ? "clamp(" + z + ")" : z
                },
                Ki = function oe() {
                    return kt && requestAnimationFrame(oe)
                },
                Gn = function() {
                    return Dt = 1
                },
                Hn = function() {
                    return Dt = 0
                },
                ui = function(z) {
                    return z
                },
                sn = function(z) {
                    return Math.round(z * 1e5) / 1e5 || 0
                },
                Wn = function() {
                    return typeof window < "u"
                },
                jn = function() {
                    return be || Wn() && (be = window.gsap) && be.registerPlugin && be
                },
                Gi = function(z) {
                    return !!~At.indexOf(z)
                },
                qn = function(z) {
                    return (z === "Height" ? te : De["inner" + z]) || Re["client" + z] || q["client" + z]
                },
                Cn = function(z) {
                    return V(z, "getBoundingClientRect") || (Gi(z) ? function() {
                        return hr.width = De.innerWidth, hr.height = te, hr
                    } : function() {
                        return yi(z)
                    })
                },
                tr = function(z, ee, j) {
                    var X = j.d,
                        ne = j.d2,
                        me = j.a;
                    return (me = V(z, "getBoundingClientRect")) ? function() {
                        return me()[X]
                    } : function() {
                        return (ee ? qn(ne) : z["client" + ne]) || 0
                    }
                },
                ir = function(z, ee) {
                    return !ee || ~R.indexOf(z) ? Cn(z) : function() {
                        return hr
                    }
                },
                Hi = function(z, ee) {
                    var j = ee.s,
                        X = ee.d2,
                        ne = ee.d,
                        me = ee.a;
                    return Math.max(0, (j = "scroll" + X) && (me = V(z, j)) ? me() - Cn(z)()[ne] : Gi(z) ? (Re[j] || q[j]) - qn(X) : z[j] - z["offset" + X])
                },
                Vn = function(z, ee) {
                    for (var j = 0; j < ye.length; j += 3)(!ee || ~ee.indexOf(ye[j + 1])) && z(ye[j], ye[j + 1], ye[j + 2])
                },
                Ti = function(z) {
                    return typeof z == "string"
                },
                hi = function(z) {
                    return typeof z == "function"
                },
                En = function(z) {
                    return typeof z == "number"
                },
                on = function(z) {
                    return typeof z == "object"
                },
                W = function(z, ee, j) {
                    return z && z.progress(ee ? 0 : 1) && j && z.pause()
                },
                re = function(z, ee) {
                    if (z.enabled) {
                        var j = z._ctx ? z._ctx.add(function() {
                            return ee(z)
                        }) : ee(z);
                        j && j.totalTime && (z.callbackAnimation = j)
                    }
                },
                ce = Math.abs,
                de = "left",
                se = "top",
                Ae = "right",
                Ne = "bottom",
                je = "width",
                $e = "height",
                rt = "Right",
                at = "Left",
                Qe = "Top",
                bt = "Bottom",
                ht = "padding",
                Tt = "margin",
                Bt = "Width",
                Mt = "Height",
                Ge = "px",
                Ot = function(z) {
                    return De.getComputedStyle(z)
                },
                Ft = function(z) {
                    var ee = Ot(z).position;
                    z.style.position = ee === "absolute" || ee === "fixed" ? ee : "relative"
                },
                Fi = function(z, ee) {
                    for (var j in ee) j in z || (z[j] = ee[j]);
                    return z
                },
                yi = function(z, ee) {
                    var j = ee && Ot(z)[J] !== "matrix(1, 0, 0, 1, 0, 0)" && be.to(z, {
                            x: 0,
                            y: 0,
                            xPercent: 0,
                            yPercent: 0,
                            rotation: 0,
                            rotationX: 0,
                            rotationY: 0,
                            scale: 1,
                            skewX: 0,
                            skewY: 0
                        }).progress(1),
                        X = z.getBoundingClientRect();
                    return j && j.progress(0).kill(), X
                },
                di = function(z, ee) {
                    var j = ee.d2;
                    return z["offset" + j] || z["client" + j] || 0
                },
                gn = function(z) {
                    var ee = [],
                        j = z.labels,
                        X = z.duration(),
                        ne;
                    for (ne in j) ee.push(j[ne] / X);
                    return ee
                },
                zt = function(z) {
                    return function(ee) {
                        return be.utils.snap(gn(z), ee)
                    }
                },
                bi = function(z) {
                    var ee = be.utils.snap(z),
                        j = Array.isArray(z) && z.slice(0).sort(function(X, ne) {
                            return X - ne
                        });
                    return j ? function(X, ne, me) {
                        me === void 0 && (me = .001);
                        var ue;
                        if (!ne) return ee(X);
                        if (ne > 0) {
                            for (X -= me, ue = 0; ue < j.length; ue++)
                                if (j[ue] >= X) return j[ue];
                            return j[ue - 1]
                        } else
                            for (ue = j.length, X += me; ue--;)
                                if (j[ue] <= X) return j[ue];
                        return j[0]
                    } : function(X, ne, me) {
                        me === void 0 && (me = .001);
                        var ue = ee(X);
                        return !ne || Math.abs(ue - X) < me || ue - X < 0 == ne < 0 ? ue : ee(ne < 0 ? X - z : X + z)
                    }
                },
                ki = function(z) {
                    return function(ee, j) {
                        return bi(gn(z))(ee, j.direction)
                    }
                },
                ti = function(z, ee, j, X) {
                    return j.split(",").forEach(function(ne) {
                        return z(ee, ne, X)
                    })
                },
                Rt = function(z, ee, j, X, ne) {
                    return z.addEventListener(ee, j, {
                        passive: !X,
                        capture: !!ne
                    })
                },
                Xt = function(z, ee, j, X) {
                    return z.removeEventListener(ee, j, !!X)
                },
                Wi = function(z, ee, j) {
                    j = j && j.wheelHandler, j && (z(ee, "wheel", j), z(ee, "touchmove", j))
                },
                Er = {
                    startColor: "green",
                    endColor: "red",
                    indent: 0,
                    fontSize: "16px",
                    fontWeight: "normal"
                },
                nr = {
                    toggleActions: "play",
                    anticipatePin: 0
                },
                rr = {
                    top: 0,
                    left: 0,
                    center: .5,
                    bottom: 1,
                    right: 1
                },
                sr = function(z, ee) {
                    if (Ti(z)) {
                        var j = z.indexOf("="),
                            X = ~j ? +(z.charAt(j - 1) + 1) * parseFloat(z.substr(j + 1)) : 0;
                        ~j && (z.indexOf("%") > j && (X *= ee / 100), z = z.substr(0, j - 1)), z = X + (z in rr ? rr[z] * ee : ~z.indexOf("%") ? parseFloat(z) * ee / 100 : parseFloat(z) || 0)
                    }
                    return z
                },
                or = function(z, ee, j, X, ne, me, ue, He) {
                    var ft = ne.startColor,
                        Vt = ne.endColor,
                        Ct = ne.fontSize,
                        st = ne.indent,
                        xe = ne.fontWeight,
                        ut = We.createElement("div"),
                        Kt = Gi(j) || V(j, "pinType") === "fixed",
                        Gt = z.indexOf("scroller") !== -1,
                        oi = Kt ? q : j,
                        jt = z.indexOf("start") !== -1,
                        gi = jt ? ft : Vt,
                        xt = "border-color:" + gi + ";font-size:" + Ct + ";color:" + gi + ";font-weight:" + xe + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                    return xt += "position:" + ((Gt || He) && Kt ? "fixed;" : "absolute;"), (Gt || He || !Kt) && (xt += (X === N ? Ae : Ne) + ":" + (me + parseFloat(st)) + "px;"), ue && (xt += "box-sizing:border-box;text-align:left;width:" + ue.offsetWidth + "px;"), ut._isStart = jt, ut.setAttribute("class", "gsap-marker-" + z + (ee ? " marker-" + ee : "")), ut.style.cssText = xt, ut.innerText = ee || ee === 0 ? z + "-" + ee : z, oi.children[0] ? oi.insertBefore(ut, oi.children[0]) : oi.appendChild(ut), ut._offset = ut["offset" + X.op.d2], ar(ut, 0, X, jt), ut
                },
                ar = function(z, ee, j, X) {
                    var ne = {
                            display: "block"
                        },
                        me = j[X ? "os2" : "p2"],
                        ue = j[X ? "p2" : "os2"];
                    z._isFlipped = X, ne[j.a + "Percent"] = X ? -100 : 0, ne[j.a] = X ? "1px" : 0, ne["border" + me + Bt] = 1, ne["border" + ue + Bt] = 0, ne[j.p] = ee + "px", be.set(z, ne)
                },
                St = [],
                _r = {},
                Xn, Tr = function() {
                    return ve() - et > 34 && (Xn || (Xn = requestAnimationFrame(an)))
                },
                Nn = function() {
                    (!Oe || !Oe.isPressed || Oe.startX > q.clientWidth) && (D.cache++, Oe ? Xn || (Xn = requestAnimationFrame(an)) : an(), et || Mn("scrollStart"), et = ve())
                },
                vr = function() {
                    qe = De.innerWidth, Se = De.innerHeight
                },
                Kn = function(z) {
                    D.cache++, (z === !0 || !Ie && !Le && !We.fullscreenElement && !We.webkitFullscreenElement && (!Ze || qe !== De.innerWidth || Math.abs(De.innerHeight - Se) > De.innerHeight * .25)) && dt.restart(!0)
                },
                Tn = {},
                Yr = [],
                Mr = function oe() {
                    return Xt(wt, "scrollEnd", oe) || An(!0)
                },
                Mn = function(z) {
                    return Tn[z] && Tn[z].map(function(ee) {
                        return ee()
                    }) || Yr
                },
                Bi = [],
                Pr = function(z) {
                    for (var ee = 0; ee < Bi.length; ee += 5)(!z || Bi[ee + 4] && Bi[ee + 4].query === z) && (Bi[ee].style.cssText = Bi[ee + 1], Bi[ee].getBBox && Bi[ee].setAttribute("transform", Bi[ee + 2] || ""), Bi[ee + 3].uncache = 1)
                },
                yr = function(z, ee) {
                    var j;
                    for ($ = 0; $ < St.length; $++) j = St[$], j && (!ee || j._ctx === ee) && (z ? j.kill(1) : j.revert(!0, !0));
                    Ve = !0, ee && Pr(ee), ee || Mn("revert")
                },
                Ar = function(z, ee) {
                    D.cache++, (ee || !Mi) && D.forEach(function(j) {
                        return hi(j) && j.cacheID++ && (j.rec = 0)
                    }), Ti(z) && (De.history.scrollRestoration = Fe = z)
                },
                Mi, Pn = 0,
                Dr, Zr = function() {
                    if (Dr !== Pn) {
                        var z = Dr = Pn;
                        requestAnimationFrame(function() {
                            return z === Pn && An(!0)
                        })
                    }
                },
                Rr = function() {
                    q.appendChild(ct), te = !Oe && ct.offsetHeight || De.innerHeight, q.removeChild(ct)
                },
                Lr = function(z) {
                    return tt(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(ee) {
                        return ee.style.display = z ? "none" : "block"
                    })
                },
                An = function(z, ee) {
                    if (Re = We.documentElement, q = We.body, At = [De, We, Re, q], et && !z && !Ve) {
                        Rt(wt, "scrollEnd", Mr);
                        return
                    }
                    Rr(), Mi = wt.isRefreshing = !0, D.forEach(function(X) {
                        return hi(X) && ++X.cacheID && (X.rec = X())
                    });
                    var j = Mn("refreshInit");
                    fe && wt.sort(), ee || yr(), D.forEach(function(X) {
                        hi(X) && (X.smooth && (X.target.style.scrollBehavior = "auto"), X(0))
                    }), St.slice(0).forEach(function(X) {
                        return X.refresh()
                    }), Ve = !1, St.forEach(function(X) {
                        if (X._subPinOffset && X.pin) {
                            var ne = X.vars.horizontal ? "offsetWidth" : "offsetHeight",
                                me = X.pin[ne];
                            X.revert(!0, 1), X.adjustPinSpacing(X.pin[ne] - me), X.refresh()
                        }
                    }), Ce = 1, Lr(!0), St.forEach(function(X) {
                        var ne = Hi(X.scroller, X._dir),
                            me = X.vars.end === "max" || X._endClamp && X.end > ne,
                            ue = X._startClamp && X.start >= ne;
                        (me || ue) && X.setPositions(ue ? ne - 1 : X.start, me ? Math.max(ue ? ne : X.start + 1, ne) : X.end, !0)
                    }), Lr(!1), Ce = 0, j.forEach(function(X) {
                        return X && X.render && X.render(-1)
                    }), D.forEach(function(X) {
                        hi(X) && (X.smooth && requestAnimationFrame(function() {
                            return X.target.style.scrollBehavior = "smooth"
                        }), X.rec && X(X.rec))
                    }), Ar(Fe, 1), dt.pause(), Pn++, Mi = 2, an(2), St.forEach(function(X) {
                        return hi(X.vars.onRefresh) && X.vars.onRefresh(X)
                    }), Mi = wt.isRefreshing = !1, Mn("refresh")
                },
                br = 0,
                lr = 1,
                Yn, an = function(z) {
                    if (z === 2 || !Mi && !Ve) {
                        wt.isUpdating = !0, Yn && Yn.update(0);
                        var ee = St.length,
                            j = ve(),
                            X = j - Ye >= 50,
                            ne = ee && St[0].scroll();
                        if (lr = br > ne ? -1 : 1, Mi || (br = ne), X && (et && !Dt && j - et > 200 && (et = 0, Mn("scrollEnd")), ot = Ye, Ye = j), lr < 0) {
                            for ($ = ee; $-- > 0;) St[$] && St[$].update(0, X);
                            lr = 1
                        } else
                            for ($ = 0; $ < ee; $++) St[$] && St[$].update(0, X);
                        wt.isUpdating = !1
                    }
                    Xn = 0
                },
                xr = [de, se, Ne, Ae, Tt + bt, Tt + rt, Tt + Qe, Tt + at, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
                cr = xr.concat([je, $e, "boxSizing", "max" + Bt, "max" + Mt, "position", Tt, ht, ht + Qe, ht + rt, ht + bt, ht + at]),
                Qr = function(z, ee, j) {
                    On(j);
                    var X = z._gsap;
                    if (X.spacerIsNative) On(X.spacerState);
                    else if (z._gsap.swappedIn) {
                        var ne = ee.parentNode;
                        ne && (ne.insertBefore(z, ee), ne.removeChild(ee))
                    }
                    z._gsap.swappedIn = !1
                },
                Sr = function(z, ee, j, X) {
                    if (!z._gsap.swappedIn) {
                        for (var ne = xr.length, me = ee.style, ue = z.style, He; ne--;) He = xr[ne], me[He] = j[He];
                        me.position = j.position === "absolute" ? "absolute" : "relative", j.display === "inline" && (me.display = "inline-block"), ue[Ne] = ue[Ae] = "auto", me.flexBasis = j.flexBasis || "auto", me.overflow = "visible", me.boxSizing = "border-box", me[je] = di(z, L) + Ge, me[$e] = di(z, N) + Ge, me[ht] = ue[Tt] = ue[se] = ue[de] = "0", On(X), ue[je] = ue["max" + Bt] = j[je], ue[$e] = ue["max" + Mt] = j[$e], ue[ht] = j[ht], z.parentNode !== ee && (z.parentNode.insertBefore(ee, z), ee.appendChild(z)), z._gsap.swappedIn = !0
                    }
                },
                Jr = /([A-Z])/g,
                On = function(z) {
                    if (z) {
                        var ee = z.t.style,
                            j = z.length,
                            X = 0,
                            ne, me;
                        for ((z.t._gsap || be.core.getCache(z.t)).uncache = 1; X < j; X += 2) me = z[X + 1], ne = z[X], me ? ee[ne] = me : ee[ne] && ee.removeProperty(ne.replace(Jr, "-$1").toLowerCase())
                    }
                },
                ur = function(z) {
                    for (var ee = cr.length, j = z.style, X = [], ne = 0; ne < ee; ne++) X.push(cr[ne], j[cr[ne]]);
                    return X.t = z, X
                },
                es = function(z, ee, j) {
                    for (var X = [], ne = z.length, me = j ? 8 : 0, ue; me < ne; me += 2) ue = z[me], X.push(ue, ue in ee ? ee[ue] : z[me + 1]);
                    return X.t = z.t, X
                },
                hr = {
                    left: 0,
                    top: 0
                },
                Ir = function(z, ee, j, X, ne, me, ue, He, ft, Vt, Ct, st, xe, ut) {
                    hi(z) && (z = z(He)), Ti(z) && z.substr(0, 3) === "max" && (z = st + (z.charAt(4) === "=" ? sr("0" + z.substr(3), j) : 0));
                    var Kt = xe ? xe.time() : 0,
                        Gt, oi, jt;
                    if (xe && xe.seek(0), isNaN(z) || (z = +z), En(z)) xe && (z = be.utils.mapRange(xe.scrollTrigger.start, xe.scrollTrigger.end, 0, st, z)), ue && ar(ue, j, X, !0);
                    else {
                        hi(ee) && (ee = ee(He));
                        var gi = (z || "0").split(" "),
                            xt, ji, Ht, gt;
                        jt = K(ee, He) || q, xt = yi(jt) || {}, (!xt || !xt.left && !xt.top) && Ot(jt).display === "none" && (gt = jt.style.display, jt.style.display = "block", xt = yi(jt), gt ? jt.style.display = gt : jt.style.removeProperty("display")), ji = sr(gi[0], xt[X.d]), Ht = sr(gi[1] || "0", j), z = xt[X.p] - ft[X.p] - Vt + ji + ne - Ht, ue && ar(ue, Ht, X, j - Ht < 20 || ue._isStart && Ht > 20), j -= j - Ht
                    }
                    if (ut && (He[ut] = z || -.001, z < 0 && (z = 0)), me) {
                        var Pi = z + j,
                            Vi = me._isStart;
                        Gt = "scroll" + X.d2, ar(me, Pi, X, Vi && Pi > 20 || !Vi && (Ct ? Math.max(q[Gt], Re[Gt]) : me.parentNode[Gt]) <= Pi + 1), Ct && (ft = yi(ue), Ct && (me.style[X.op.p] = ft[X.op.p] - X.op.m - me._offset + Ge))
                    }
                    return xe && jt && (Gt = yi(jt), xe.seek(st), oi = yi(jt), xe._caScrollDist = Gt[X.p] - oi[X.p], z = z / xe._caScrollDist * st), xe && xe.seek(Kt), xe ? z : Math.round(z)
                },
                ts = /(webkit|moz|length|cssText|inset)/i,
                Fr = function(z, ee, j, X) {
                    if (z.parentNode !== ee) {
                        var ne = z.style,
                            me, ue;
                        if (ee === q) {
                            z._stOrig = ne.cssText, ue = Ot(z);
                            for (me in ue) !+me && !ts.test(me) && ue[me] && typeof ne[me] == "string" && me !== "0" && (ne[me] = ue[me]);
                            ne.top = j, ne.left = X
                        } else ne.cssText = z._stOrig;
                        be.core.getCache(z).uncache = 1, ee.appendChild(z)
                    }
                },
                kr = function(z, ee, j) {
                    var X = ee,
                        ne = X;
                    return function(me) {
                        var ue = Math.round(z());
                        return ue !== X && ue !== ne && Math.abs(ue - X) > 3 && Math.abs(ue - ne) > 3 && (me = ue, j && j()), ne = X, X = Math.round(me), X
                    }
                },
                dr = function(z, ee, j) {
                    var X = {};
                    X[ee.p] = "+=" + j, be.set(z, X)
                },
                Vr = function(z, ee) {
                    var j = he(z, ee),
                        X = "_scroll" + ee.p2,
                        ne = function me(ue, He, ft, Vt, Ct) {
                            var st = me.tween,
                                xe = He.onComplete,
                                ut = {};
                            ft = ft || j();
                            var Kt = kr(j, ft, function() {
                                st.kill(), me.tween = 0
                            });
                            return Ct = Vt && Ct || 0, Vt = Vt || ue - ft, st && st.kill(), He[X] = ue, He.inherit = !1, He.modifiers = ut, ut[X] = function() {
                                return Kt(ft + Vt * st.ratio + Ct * st.ratio * st.ratio)
                            }, He.onUpdate = function() {
                                D.cache++, me.tween && an()
                            }, He.onComplete = function() {
                                me.tween = 0, xe && xe.call(st)
                            }, st = me.tween = be.to(z, He), st
                        };
                    return z[X] = j, j.wheelHandler = function() {
                        return ne.tween && ne.tween.kill() && (ne.tween = 0)
                    }, Rt(z, "wheel", j.wheelHandler), wt.isTouch && Rt(z, "touchmove", j.wheelHandler), ne
                },
                wt = function() {
                    function oe(ee, j) {
                        Be || oe.register(be) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), it(this), this.init(ee, j)
                    }
                    var z = oe.prototype;
                    return z.init = function(j, X) {
                        if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !kt) {
                            this.update = this.refresh = this.kill = ui;
                            return
                        }
                        j = Fi(Ti(j) || En(j) || j.nodeType ? {
                            trigger: j
                        } : j, nr);
                        var ne = j,
                            me = ne.onUpdate,
                            ue = ne.toggleClass,
                            He = ne.id,
                            ft = ne.onToggle,
                            Vt = ne.onRefresh,
                            Ct = ne.scrub,
                            st = ne.trigger,
                            xe = ne.pin,
                            ut = ne.pinSpacing,
                            Kt = ne.invalidateOnRefresh,
                            Gt = ne.anticipatePin,
                            oi = ne.onScrubComplete,
                            jt = ne.onSnapComplete,
                            gi = ne.once,
                            xt = ne.snap,
                            ji = ne.pinReparent,
                            Ht = ne.pinSpacer,
                            gt = ne.containerAnimation,
                            Pi = ne.fastScrollEnd,
                            Vi = ne.preventOverlaps,
                            nt = j.horizontal || j.containerAnimation && j.horizontal !== !1 ? L : N,
                            pi = !Ct && Ct !== 0,
                            mt = K(j.scroller || De),
                            ln = be.core.getCache(mt),
                            ai = Gi(mt),
                            Ai = ("pinType" in j ? j.pinType : V(mt, "pinType") || ai && "fixed") === "fixed",
                            Di = [j.onEnter, j.onLeave, j.onEnterBack, j.onLeaveBack],
                            $t = pi && j.toggleActions.split(" "),
                            ii = "markers" in j ? j.markers : nr.markers,
                            ni = ai ? 0 : parseFloat(Ot(mt)["border" + nt.p2 + Bt]) || 0,
                            le = this,
                            li = j.onRefreshInit && function() {
                                return j.onRefreshInit(le)
                            },
                            Dn = tr(mt, ai, nt),
                            _n = ir(mt, ai),
                            qi = 0,
                            un = 0,
                            xi = 0,
                            ri = he(mt, nt),
                            Ri, Si, vn, Li, Ni, Lt, Qt, Oi, $i, pe, Ui, hn, yn, Yt, dn, bn, Rn, fi, xn, Jt, Yi, Xi, pn, Zn, si, fr, fn, Bn, $n, Sn, Ln, Et, In, Zi, Qi, Ji, Fn, Un, mn;
                        if (le._startClamp = le._endClamp = !1, le._dir = nt, Gt *= 45, le.scroller = mt, le.scroll = gt ? gt.time.bind(gt) : ri, Li = ri(), le.vars = j, X = X || j.animation, "refreshPriority" in j && (fe = 1, j.refreshPriority === -9999 && (Yn = le)), ln.tweenScroll = ln.tweenScroll || {
                                top: Vr(mt, N),
                                left: Vr(mt, L)
                            }, le.tweenTo = Ri = ln.tweenScroll[nt.p], le.scrubDuration = function(Ue) {
                                In = En(Ue) && Ue, In ? Et ? Et.duration(Ue) : Et = be.to(X, {
                                    ease: "expo",
                                    totalProgress: "+=0",
                                    inherit: !1,
                                    duration: In,
                                    paused: !0,
                                    onComplete: function() {
                                        return oi && oi(le)
                                    }
                                }) : (Et && Et.progress(1).kill(), Et = 0)
                            }, X && (X.vars.lazy = !1, X._initted && !le.isReverted || X.vars.immediateRender !== !1 && j.immediateRender !== !1 && X.duration() && X.render(0, !0, !0), le.animation = X.pause(), X.scrollTrigger = le, le.scrubDuration(Ct), Sn = 0, He || (He = X.vars.id)), xt && ((!on(xt) || xt.push) && (xt = {
                                snapTo: xt
                            }), "scrollBehavior" in q.style && be.set(ai ? [q, Re] : mt, {
                                scrollBehavior: "auto"
                            }), D.forEach(function(Ue) {
                                return hi(Ue) && Ue.target === (ai ? We.scrollingElement || Re : mt) && (Ue.smooth = !1)
                            }), vn = hi(xt.snapTo) ? xt.snapTo : xt.snapTo === "labels" ? zt(X) : xt.snapTo === "labelsDirectional" ? ki(X) : xt.directional !== !1 ? function(Ue, _t) {
                                return bi(xt.snapTo)(Ue, ve() - un < 500 ? 0 : _t.direction)
                            } : be.utils.snap(xt.snapTo), Zi = xt.duration || {
                                min: .1,
                                max: 2
                            }, Zi = on(Zi) ? ke(Zi.min, Zi.max) : ke(Zi, Zi), Qi = be.delayedCall(xt.delay || In / 2 || .1, function() {
                                var Ue = ri(),
                                    _t = ve() - un < 500,
                                    lt = Ri.tween;
                                if ((_t || Math.abs(le.getVelocity()) < 10) && !lt && !Dt && qi !== Ue) {
                                    var vt = (Ue - Lt) / Yt,
                                        mi = X && !pi ? X.totalProgress() : vt,
                                        Pt = _t ? 0 : (mi - Ln) / (ve() - ot) * 1e3 || 0,
                                        ei = be.utils.clamp(-vt, 1 - vt, ce(Pt / 2) * Pt / .185),
                                        wi = vt + (xt.inertia === !1 ? 0 : ei),
                                        Zt, Wt, Ut = xt,
                                        en = Ut.onStart,
                                        qt = Ut.onInterrupt,
                                        zi = Ut.onComplete;
                                    if (Zt = vn(wi, le), En(Zt) || (Zt = wi), Wt = Math.max(0, Math.round(Lt + Zt * Yt)), Ue <= Qt && Ue >= Lt && Wt !== Ue) {
                                        if (lt && !lt._initted && lt.data <= ce(Wt - Ue)) return;
                                        xt.inertia === !1 && (ei = Zt - vt), Ri(Wt, {
                                            duration: Zi(ce(Math.max(ce(wi - mi), ce(Zt - mi)) * .185 / Pt / .05 || 0)),
                                            ease: xt.ease || "power3",
                                            data: ce(Wt - Ue),
                                            onInterrupt: function() {
                                                return Qi.restart(!0) && qt && qt(le)
                                            },
                                            onComplete: function() {
                                                le.update(), qi = ri(), X && !pi && (Et ? Et.resetTo("totalProgress", Zt, X._tTime / X._tDur) : X.progress(Zt)), Sn = Ln = X && !pi ? X.totalProgress() : le.progress, jt && jt(le), zi && zi(le)
                                            }
                                        }, Ue, ei * Yt, Wt - Ue - ei * Yt), en && en(le, Ri.tween)
                                    }
                                } else le.isActive && qi !== Ue && Qi.restart(!0)
                            }).pause()), He && (_r[He] = le), st = le.trigger = K(st || xe !== !0 && xe), mn = st && st._gsap && st._gsap.stRevert, mn && (mn = mn(le)), xe = xe === !0 ? st : K(xe), Ti(ue) && (ue = {
                                targets: st,
                                className: ue
                            }), xe && (ut === !1 || ut === Tt || (ut = !ut && xe.parentNode && xe.parentNode.style && Ot(xe.parentNode).display === "flex" ? !1 : ht), le.pin = xe, Si = be.core.getCache(xe), Si.spacer ? dn = Si.pinState : (Ht && (Ht = K(Ht), Ht && !Ht.nodeType && (Ht = Ht.current || Ht.nativeElement), Si.spacerIsNative = !!Ht, Ht && (Si.spacerState = ur(Ht))), Si.spacer = fi = Ht || We.createElement("div"), fi.classList.add("pin-spacer"), He && fi.classList.add("pin-spacer-" + He), Si.pinState = dn = ur(xe)), j.force3D !== !1 && be.set(xe, {
                                force3D: !0
                            }), le.spacer = fi = Si.spacer, $n = Ot(xe), Zn = $n[ut + nt.os2], Jt = be.getProperty(xe), Yi = be.quickSetter(xe, nt.a, Ge), Sr(xe, fi, $n), Rn = ur(xe)), ii) {
                            hn = on(ii) ? Fi(ii, Er) : Er, pe = or("scroller-start", He, mt, nt, hn, 0), Ui = or("scroller-end", He, mt, nt, hn, 0, pe), xn = pe["offset" + nt.op.d2];
                            var Qn = K(V(mt, "content") || mt);
                            Oi = this.markerStart = or("start", He, Qn, nt, hn, xn, 0, gt), $i = this.markerEnd = or("end", He, Qn, nt, hn, xn, 0, gt), gt && (Un = be.quickSetter([Oi, $i], nt.a, Ge)), !Ai && !(R.length && V(mt, "fixedMarkers") === !0) && (Ft(ai ? q : mt), be.set([pe, Ui], {
                                force3D: !0
                            }), fr = be.quickSetter(pe, nt.a, Ge), Bn = be.quickSetter(Ui, nt.a, Ge))
                        }
                        if (gt) {
                            var yt = gt.vars.onUpdate,
                                pt = gt.vars.onUpdateParams;
                            gt.eventCallback("onUpdate", function() {
                                le.update(0, 0, 1), yt && yt.apply(gt, pt || [])
                            })
                        }
                        if (le.previous = function() {
                                return St[St.indexOf(le) - 1]
                            }, le.next = function() {
                                return St[St.indexOf(le) + 1]
                            }, le.revert = function(Ue, _t) {
                                if (!_t) return le.kill(!0);
                                var lt = Ue !== !1 || !le.enabled,
                                    vt = Ie;
                                lt !== le.isReverted && (lt && (Ji = Math.max(ri(), le.scroll.rec || 0), xi = le.progress, Fn = X && X.progress()), Oi && [Oi, $i, pe, Ui].forEach(function(mi) {
                                    return mi.style.display = lt ? "none" : "block"
                                }), lt && (Ie = le, le.update(lt)), xe && (!ji || !le.isActive) && (lt ? Qr(xe, fi, dn) : Sr(xe, fi, Ot(xe), si)), lt || le.update(lt), Ie = vt, le.isReverted = lt)
                            }, le.refresh = function(Ue, _t, lt, vt) {
                                if (!((Ie || !le.enabled) && !_t)) {
                                    if (xe && Ue && et) {
                                        Rt(oe, "scrollEnd", Mr);
                                        return
                                    }!Mi && li && li(le), Ie = le, Ri.tween && !lt && (Ri.tween.kill(), Ri.tween = 0), Et && Et.pause(), Kt && X && (X.revert({
                                        kill: !1
                                    }).invalidate(), X.getChildren && X.getChildren(!0, !0, !1).forEach(function(wn) {
                                        return wn.vars.immediateRender && wn.render(0, !0, !0)
                                    })), le.isReverted || le.revert(!0, !0), le._subPinOffset = !1;
                                    var mi = Dn(),
                                        Pt = _n(),
                                        ei = gt ? gt.duration() : Hi(mt, nt),
                                        wi = Yt <= .01 || !Yt,
                                        Zt = 0,
                                        Wt = vt || 0,
                                        Ut = on(lt) ? lt.end : j.end,
                                        en = j.endTrigger || st,
                                        qt = on(lt) ? lt.start : j.start || (j.start === 0 || !st ? 0 : xe ? "0 0" : "0 100%"),
                                        zi = le.pinnedContainer = j.pinnedContainer && K(j.pinnedContainer, le),
                                        tn = st && Math.max(0, St.indexOf(le)) || 0,
                                        _i = tn,
                                        vi, Ci, kn, mr, Ei, ci, nn, Cr, Ur, Jn, rn, er, gr;
                                    for (ii && on(lt) && (er = be.getProperty(pe, nt.p), gr = be.getProperty(Ui, nt.p)); _i-- > 0;) ci = St[_i], ci.end || ci.refresh(0, 1) || (Ie = le), nn = ci.pin, nn && (nn === st || nn === xe || nn === zi) && !ci.isReverted && (Jn || (Jn = []), Jn.unshift(ci), ci.revert(!0, !0)), ci !== St[_i] && (tn--, _i--);
                                    for (hi(qt) && (qt = qt(le)), qt = It(qt, "start", le), Lt = Ir(qt, st, mi, nt, ri(), Oi, pe, le, Pt, ni, Ai, ei, gt, le._startClamp && "_startClamp") || (xe ? -.001 : 0), hi(Ut) && (Ut = Ut(le)), Ti(Ut) && !Ut.indexOf("+=") && (~Ut.indexOf(" ") ? Ut = (Ti(qt) ? qt.split(" ")[0] : "") + Ut : (Zt = sr(Ut.substr(2), mi), Ut = Ti(qt) ? qt : (gt ? be.utils.mapRange(0, gt.duration(), gt.scrollTrigger.start, gt.scrollTrigger.end, Lt) : Lt) + Zt, en = st)), Ut = It(Ut, "end", le), Qt = Math.max(Lt, Ir(Ut || (en ? "100% 0" : ei), en, mi, nt, ri() + Zt, $i, Ui, le, Pt, ni, Ai, ei, gt, le._endClamp && "_endClamp")) || -.001, Zt = 0, _i = tn; _i--;) ci = St[_i], nn = ci.pin, nn && ci.start - ci._pinPush <= Lt && !gt && ci.end > 0 && (vi = ci.end - (le._startClamp ? Math.max(0, ci.start) : ci.start), (nn === st && ci.start - ci._pinPush < Lt || nn === zi) && isNaN(qt) && (Zt += vi * (1 - ci.progress)), nn === xe && (Wt += vi));
                                    if (Lt += Zt, Qt += Zt, le._startClamp && (le._startClamp += Zt), le._endClamp && !Mi && (le._endClamp = Qt || -.001, Qt = Math.min(Qt, Hi(mt, nt))), Yt = Qt - Lt || (Lt -= .01) && .001, wi && (xi = be.utils.clamp(0, 1, be.utils.normalize(Lt, Qt, Ji))), le._pinPush = Wt, Oi && Zt && (vi = {}, vi[nt.a] = "+=" + Zt, zi && (vi[nt.p] = "-=" + ri()), be.set([Oi, $i], vi)), xe && !(Ce && le.end >= Hi(mt, nt))) vi = Ot(xe), mr = nt === N, kn = ri(), Xi = parseFloat(Jt(nt.a)) + Wt, !ei && Qt > 1 && (rn = (ai ? We.scrollingElement || Re : mt).style, rn = {
                                        style: rn,
                                        value: rn["overflow" + nt.a.toUpperCase()]
                                    }, ai && Ot(q)["overflow" + nt.a.toUpperCase()] !== "scroll" && (rn.style["overflow" + nt.a.toUpperCase()] = "scroll")), Sr(xe, fi, vi), Rn = ur(xe), Ci = yi(xe, !0), Cr = Ai && he(mt, mr ? L : N)(), ut ? (si = [ut + nt.os2, Yt + Wt + Ge], si.t = fi, _i = ut === ht ? di(xe, nt) + Yt + Wt : 0, _i && (si.push(nt.d, _i + Ge), fi.style.flexBasis !== "auto" && (fi.style.flexBasis = _i + Ge)), On(si), zi && St.forEach(function(wn) {
                                        wn.pin === zi && wn.vars.pinSpacing !== !1 && (wn._subPinOffset = !0)
                                    }), Ai && ri(Ji)) : (_i = di(xe, nt), _i && fi.style.flexBasis !== "auto" && (fi.style.flexBasis = _i + Ge)), Ai && (Ei = {
                                        top: Ci.top + (mr ? kn - Lt : Cr) + Ge,
                                        left: Ci.left + (mr ? Cr : kn - Lt) + Ge,
                                        boxSizing: "border-box",
                                        position: "fixed"
                                    }, Ei[je] = Ei["max" + Bt] = Math.ceil(Ci.width) + Ge, Ei[$e] = Ei["max" + Mt] = Math.ceil(Ci.height) + Ge, Ei[Tt] = Ei[Tt + Qe] = Ei[Tt + rt] = Ei[Tt + bt] = Ei[Tt + at] = "0", Ei[ht] = vi[ht], Ei[ht + Qe] = vi[ht + Qe], Ei[ht + rt] = vi[ht + rt], Ei[ht + bt] = vi[ht + bt], Ei[ht + at] = vi[ht + at], bn = es(dn, Ei, ji), Mi && ri(0)), X ? (Ur = X._initted, Ke(1), X.render(X.duration(), !0, !0), pn = Jt(nt.a) - Xi + Yt + Wt, fn = Math.abs(Yt - pn) > 1, Ai && fn && bn.splice(bn.length - 2, 2), X.render(0, !0, !0), Ur || X.invalidate(!0), X.parent || X.totalTime(X.totalTime()), Ke(0)) : pn = Yt, rn && (rn.value ? rn.style["overflow" + nt.a.toUpperCase()] = rn.value : rn.style.removeProperty("overflow-" + nt.a));
                                    else if (st && ri() && !gt)
                                        for (Ci = st.parentNode; Ci && Ci !== q;) Ci._pinOffset && (Lt -= Ci._pinOffset, Qt -= Ci._pinOffset), Ci = Ci.parentNode;
                                    Jn && Jn.forEach(function(wn) {
                                        return wn.revert(!1, !0)
                                    }), le.start = Lt, le.end = Qt, Li = Ni = Mi ? Ji : ri(), !gt && !Mi && (Li < Ji && ri(Ji), le.scroll.rec = 0), le.revert(!1, !0), un = ve(), Qi && (qi = -1, Qi.restart(!0)), Ie = 0, X && pi && (X._initted || Fn) && X.progress() !== Fn && X.progress(Fn || 0, !0).render(X.time(), !0, !0), (wi || xi !== le.progress || gt || Kt || X && !X._initted) && (X && !pi && (X._initted || xi || X.vars.immediateRender !== !1) && X.totalProgress(gt && Lt < -.001 && !xi ? be.utils.normalize(Lt, Qt, 0) : xi, !0), le.progress = wi || (Li - Lt) / Yt === xi ? 0 : xi), xe && ut && (fi._pinOffset = Math.round(le.progress * pn)), Et && Et.invalidate(), isNaN(er) || (er -= be.getProperty(pe, nt.p), gr -= be.getProperty(Ui, nt.p), dr(pe, nt, er), dr(Oi, nt, er - (vt || 0)), dr(Ui, nt, gr), dr($i, nt, gr - (vt || 0))), wi && !Mi && le.update(), Vt && !Mi && !yn && (yn = !0, Vt(le), yn = !1)
                                }
                            }, le.getVelocity = function() {
                                return (ri() - Ni) / (ve() - ot) * 1e3 || 0
                            }, le.endAnimation = function() {
                                W(le.callbackAnimation), X && (Et ? Et.progress(1) : X.paused() ? pi || W(X, le.direction < 0, 1) : W(X, X.reversed()))
                            }, le.labelToScroll = function(Ue) {
                                return X && X.labels && (Lt || le.refresh() || Lt) + X.labels[Ue] / X.duration() * Yt || 0
                            }, le.getTrailing = function(Ue) {
                                var _t = St.indexOf(le),
                                    lt = le.direction > 0 ? St.slice(0, _t).reverse() : St.slice(_t + 1);
                                return (Ti(Ue) ? lt.filter(function(vt) {
                                    return vt.vars.preventOverlaps === Ue
                                }) : lt).filter(function(vt) {
                                    return le.direction > 0 ? vt.end <= Lt : vt.start >= Qt
                                })
                            }, le.update = function(Ue, _t, lt) {
                                if (!(gt && !lt && !Ue)) {
                                    var vt = Mi === !0 ? Ji : le.scroll(),
                                        mi = Ue ? 0 : (vt - Lt) / Yt,
                                        Pt = mi < 0 ? 0 : mi > 1 ? 1 : mi || 0,
                                        ei = le.progress,
                                        wi, Zt, Wt, Ut, en, qt, zi, tn;
                                    if (_t && (Ni = Li, Li = gt ? ri() : vt, xt && (Ln = Sn, Sn = X && !pi ? X.totalProgress() : Pt)), Gt && xe && !Ie && !Ee && et && (!Pt && Lt < vt + (vt - Ni) / (ve() - ot) * Gt ? Pt = 1e-4 : Pt === 1 && Qt > vt + (vt - Ni) / (ve() - ot) * Gt && (Pt = .9999)), Pt !== ei && le.enabled) {
                                        if (wi = le.isActive = !!Pt && Pt < 1, Zt = !!ei && ei < 1, qt = wi !== Zt, en = qt || !!Pt != !!ei, le.direction = Pt > ei ? 1 : -1, le.progress = Pt, en && !Ie && (Wt = Pt && !ei ? 0 : Pt === 1 ? 1 : ei === 1 ? 2 : 3, pi && (Ut = !qt && $t[Wt + 1] !== "none" && $t[Wt + 1] || $t[Wt], tn = X && (Ut === "complete" || Ut === "reset" || Ut in X))), Vi && (qt || tn) && (tn || Ct || !X) && (hi(Vi) ? Vi(le) : le.getTrailing(Vi).forEach(function(kn) {
                                                return kn.endAnimation()
                                            })), pi || (Et && !Ie && !Ee ? (Et._dp._time - Et._start !== Et._time && Et.render(Et._dp._time - Et._start), Et.resetTo ? Et.resetTo("totalProgress", Pt, X._tTime / X._tDur) : (Et.vars.totalProgress = Pt, Et.invalidate().restart())) : X && X.totalProgress(Pt, !!(Ie && (un || Ue)))), xe) {
                                            if (Ue && ut && (fi.style[ut + nt.os2] = Zn), !Ai) Yi(sn(Xi + pn * Pt));
                                            else if (en) {
                                                if (zi = !Ue && Pt > ei && Qt + 1 > vt && vt + 1 >= Hi(mt, nt), ji)
                                                    if (!Ue && (wi || zi)) {
                                                        var _i = yi(xe, !0),
                                                            vi = vt - Lt;
                                                        Fr(xe, q, _i.top + (nt === N ? vi : 0) + Ge, _i.left + (nt === N ? 0 : vi) + Ge)
                                                    } else Fr(xe, fi);
                                                On(wi || zi ? bn : Rn), fn && Pt < 1 && wi || Yi(Xi + (Pt === 1 && !zi ? pn : 0))
                                            }
                                        }
                                        xt && !Ri.tween && !Ie && !Ee && Qi.restart(!0), ue && (qt || gi && Pt && (Pt < 1 || !Xe)) && tt(ue.targets).forEach(function(kn) {
                                            return kn.classList[wi || gi ? "add" : "remove"](ue.className)
                                        }), me && !pi && !Ue && me(le), en && !Ie ? (pi && (tn && (Ut === "complete" ? X.pause().totalProgress(1) : Ut === "reset" ? X.restart(!0).pause() : Ut === "restart" ? X.restart(!0) : X[Ut]()), me && me(le)), (qt || !Xe) && (ft && qt && re(le, ft), Di[Wt] && re(le, Di[Wt]), gi && (Pt === 1 ? le.kill(!1, 1) : Di[Wt] = 0), qt || (Wt = Pt === 1 ? 1 : 3, Di[Wt] && re(le, Di[Wt]))), Pi && !wi && Math.abs(le.getVelocity()) > (En(Pi) ? Pi : 2500) && (W(le.callbackAnimation), Et ? Et.progress(1) : W(X, Ut === "reverse" ? 1 : !Pt, 1))) : pi && me && !Ie && me(le)
                                    }
                                    if (Bn) {
                                        var Ci = gt ? vt / gt.duration() * (gt._caScrollDist || 0) : vt;
                                        fr(Ci + (pe._isFlipped ? 1 : 0)), Bn(Ci)
                                    }
                                    Un && Un(-vt / gt.duration() * (gt._caScrollDist || 0))
                                }
                            }, le.enable = function(Ue, _t) {
                                le.enabled || (le.enabled = !0, Rt(mt, "resize", Kn), ai || Rt(mt, "scroll", Nn), li && Rt(oe, "refreshInit", li), Ue !== !1 && (le.progress = xi = 0, Li = Ni = qi = ri()), _t !== !1 && le.refresh())
                            }, le.getTween = function(Ue) {
                                return Ue && Ri ? Ri.tween : Et
                            }, le.setPositions = function(Ue, _t, lt, vt) {
                                if (gt) {
                                    var mi = gt.scrollTrigger,
                                        Pt = gt.duration(),
                                        ei = mi.end - mi.start;
                                    Ue = mi.start + ei * Ue / Pt, _t = mi.start + ei * _t / Pt
                                }
                                le.refresh(!1, !1, {
                                    start: Ii(Ue, lt && !!le._startClamp),
                                    end: Ii(_t, lt && !!le._endClamp)
                                }, vt), le.update()
                            }, le.adjustPinSpacing = function(Ue) {
                                if (si && Ue) {
                                    var _t = si.indexOf(nt.d) + 1;
                                    si[_t] = parseFloat(si[_t]) + Ue + Ge, si[1] = parseFloat(si[1]) + Ue + Ge, On(si)
                                }
                            }, le.disable = function(Ue, _t) {
                                if (le.enabled && (Ue !== !1 && le.revert(!0, !0), le.enabled = le.isActive = !1, _t || Et && Et.pause(), Ji = 0, Si && (Si.uncache = 1), li && Xt(oe, "refreshInit", li), Qi && (Qi.pause(), Ri.tween && Ri.tween.kill() && (Ri.tween = 0)), !ai)) {
                                    for (var lt = St.length; lt--;)
                                        if (St[lt].scroller === mt && St[lt] !== le) return;
                                    Xt(mt, "resize", Kn), ai || Xt(mt, "scroll", Nn)
                                }
                            }, le.kill = function(Ue, _t) {
                                le.disable(Ue, _t), Et && !_t && Et.kill(), He && delete _r[He];
                                var lt = St.indexOf(le);
                                lt >= 0 && St.splice(lt, 1), lt === $ && lr > 0 && $--, lt = 0, St.forEach(function(vt) {
                                    return vt.scroller === le.scroller && (lt = 1)
                                }), lt || Mi || (le.scroll.rec = 0), X && (X.scrollTrigger = null, Ue && X.revert({
                                    kill: !1
                                }), _t || X.kill()), Oi && [Oi, $i, pe, Ui].forEach(function(vt) {
                                    return vt.parentNode && vt.parentNode.removeChild(vt)
                                }), Yn === le && (Yn = 0), xe && (Si && (Si.uncache = 1), lt = 0, St.forEach(function(vt) {
                                    return vt.pin === xe && lt++
                                }), lt || (Si.spacer = 0)), j.onKill && j.onKill(le)
                            }, St.push(le), le.enable(!1, !1), mn && mn(le), X && X.add && !Yt) {
                            var Nt = le.update;
                            le.update = function() {
                                le.update = Nt, D.cache++, Lt || Qt || le.refresh()
                            }, be.delayedCall(.01, le.update), Yt = .01, Lt = Qt = 0
                        } else le.refresh();
                        xe && Zr()
                    }, oe.register = function(j) {
                        return Be || (be = j || jn(), Wn() && window.document && oe.enable(), Be = kt), Be
                    }, oe.defaults = function(j) {
                        if (j)
                            for (var X in j) nr[X] = j[X];
                        return nr
                    }, oe.disable = function(j, X) {
                        kt = 0, St.forEach(function(me) {
                            return me[X ? "kill" : "disable"](j)
                        }), Xt(De, "wheel", Nn), Xt(We, "scroll", Nn), clearInterval(ze), Xt(We, "touchcancel", ui), Xt(q, "touchstart", ui), ti(Xt, We, "pointerdown,touchstart,mousedown", Gn), ti(Xt, We, "pointerup,touchend,mouseup", Hn), dt.kill(), Vn(Xt);
                        for (var ne = 0; ne < D.length; ne += 3) Wi(Xt, D[ne], D[ne + 1]), Wi(Xt, D[ne], D[ne + 2])
                    }, oe.enable = function() {
                        if (De = window, We = document, Re = We.documentElement, q = We.body, be && (tt = be.utils.toArray, ke = be.utils.clamp, it = be.core.context || ui, Ke = be.core.suppressOverwrites || ui, Fe = De.history.scrollRestoration || "auto", br = De.pageYOffset || 0, be.core.globals("ScrollTrigger", oe), q)) {
                            kt = 1, ct = document.createElement("div"), ct.style.height = "100vh", ct.style.position = "absolute", Rr(), Ki(), Pe.register(be), oe.isTouch = Pe.isTouch, Je = Pe.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Ze = Pe.isTouch === 1, Rt(De, "wheel", Nn), At = [De, We, Re, q], be.matchMedia ? (oe.matchMedia = function(ft) {
                                var Vt = be.matchMedia(),
                                    Ct;
                                for (Ct in ft) Vt.add(Ct, ft[Ct]);
                                return Vt
                            }, be.addEventListener("matchMediaInit", function() {
                                return yr()
                            }), be.addEventListener("matchMediaRevert", function() {
                                return Pr()
                            }), be.addEventListener("matchMedia", function() {
                                An(0, 1), Mn("matchMedia")
                            }), be.matchMedia().add("(orientation: portrait)", function() {
                                return vr(), vr
                            })) : console.warn("Requires GSAP 3.11.0 or later"), vr(), Rt(We, "scroll", Nn);
                            var j = q.hasAttribute("style"),
                                X = q.style,
                                ne = X.borderTopStyle,
                                me = be.core.Animation.prototype,
                                ue, He;
                            for (me.revert || Object.defineProperty(me, "revert", {
                                    value: function() {
                                        return this.time(-.01, !0)
                                    }
                                }), X.borderTopStyle = "solid", ue = yi(q), N.m = Math.round(ue.top + N.sc()) || 0, L.m = Math.round(ue.left + L.sc()) || 0, ne ? X.borderTopStyle = ne : X.removeProperty("border-top-style"), j || (q.setAttribute("style", ""), q.removeAttribute("style")), ze = setInterval(Tr, 250), be.delayedCall(.5, function() {
                                    return Ee = 0
                                }), Rt(We, "touchcancel", ui), Rt(q, "touchstart", ui), ti(Rt, We, "pointerdown,touchstart,mousedown", Gn), ti(Rt, We, "pointerup,touchend,mouseup", Hn), J = be.utils.checkPrefix("transform"), cr.push(J), Be = ve(), dt = be.delayedCall(.2, An).pause(), ye = [We, "visibilitychange", function() {
                                    var ft = De.innerWidth,
                                        Vt = De.innerHeight;
                                    We.hidden ? (ae = ft, ge = Vt) : (ae !== ft || ge !== Vt) && Kn()
                                }, We, "DOMContentLoaded", An, De, "load", An, De, "resize", Kn], Vn(Rt), St.forEach(function(ft) {
                                    return ft.enable(0, 1)
                                }), He = 0; He < D.length; He += 3) Wi(Xt, D[He], D[He + 1]), Wi(Xt, D[He], D[He + 2])
                        }
                    }, oe.config = function(j) {
                        "limitCallbacks" in j && (Xe = !!j.limitCallbacks);
                        var X = j.syncInterval;
                        X && clearInterval(ze) || (ze = X) && setInterval(Tr, X), "ignoreMobileResize" in j && (Ze = oe.isTouch === 1 && j.ignoreMobileResize), "autoRefreshEvents" in j && (Vn(Xt) || Vn(Rt, j.autoRefreshEvents || "none"), Le = (j.autoRefreshEvents + "").indexOf("resize") === -1)
                    }, oe.scrollerProxy = function(j, X) {
                        var ne = K(j),
                            me = D.indexOf(ne),
                            ue = Gi(ne);
                        ~me && D.splice(me, ue ? 6 : 2), X && (ue ? R.unshift(De, X, q, X, Re, X) : R.unshift(ne, X))
                    }, oe.clearMatchMedia = function(j) {
                        St.forEach(function(X) {
                            return X._ctx && X._ctx.query === j && X._ctx.kill(!0, !0)
                        })
                    }, oe.isInViewport = function(j, X, ne) {
                        var me = (Ti(j) ? K(j) : j).getBoundingClientRect(),
                            ue = me[ne ? je : $e] * X || 0;
                        return ne ? me.right - ue > 0 && me.left + ue < De.innerWidth : me.bottom - ue > 0 && me.top + ue < De.innerHeight
                    }, oe.positionInViewport = function(j, X, ne) {
                        Ti(j) && (j = K(j));
                        var me = j.getBoundingClientRect(),
                            ue = me[ne ? je : $e],
                            He = X == null ? ue / 2 : X in rr ? rr[X] * ue : ~X.indexOf("%") ? parseFloat(X) * ue / 100 : parseFloat(X) || 0;
                        return ne ? (me.left + He) / De.innerWidth : (me.top + He) / De.innerHeight
                    }, oe.killAll = function(j) {
                        if (St.slice(0).forEach(function(ne) {
                                return ne.vars.id !== "ScrollSmoother" && ne.kill()
                            }), j !== !0) {
                            var X = Tn.killAll || [];
                            Tn = {}, X.forEach(function(ne) {
                                return ne()
                            })
                        }
                    }, oe
                }();
            wt.version = "3.13.0", wt.saveStyles = function(oe) {
                return oe ? tt(oe).forEach(function(z) {
                    if (z && z.style) {
                        var ee = Bi.indexOf(z);
                        ee >= 0 && Bi.splice(ee, 5), Bi.push(z, z.style.cssText, z.getBBox && z.getAttribute("transform"), be.core.getCache(z), it())
                    }
                }) : Bi
            }, wt.revert = function(oe, z) {
                return yr(!oe, z)
            }, wt.create = function(oe, z) {
                return new wt(oe, z)
            }, wt.refresh = function(oe) {
                return oe ? Kn(!0) : (Be || wt.register()) && An(!0)
            }, wt.update = function(oe) {
                return ++D.cache && an(oe === !0 ? 2 : 0)
            }, wt.clearScrollMemory = Ar, wt.maxScroll = function(oe, z) {
                return Hi(oe, z ? L : N)
            }, wt.getScrollFunc = function(oe, z) {
                return he(K(oe), z ? L : N)
            }, wt.getById = function(oe) {
                return _r[oe]
            }, wt.getAll = function() {
                return St.filter(function(oe) {
                    return oe.vars.id !== "ScrollSmoother"
                })
            }, wt.isScrolling = function() {
                return !!et
            }, wt.snapDirectional = bi, wt.addEventListener = function(oe, z) {
                var ee = Tn[oe] || (Tn[oe] = []);
                ~ee.indexOf(z) || ee.push(z)
            }, wt.removeEventListener = function(oe, z) {
                var ee = Tn[oe],
                    j = ee && ee.indexOf(z);
                j >= 0 && ee.splice(j, 1)
            }, wt.batch = function(oe, z) {
                var ee = [],
                    j = {},
                    X = z.interval || .016,
                    ne = z.batchMax || 1e9,
                    me = function(ft, Vt) {
                        var Ct = [],
                            st = [],
                            xe = be.delayedCall(X, function() {
                                Vt(Ct, st), Ct = [], st = []
                            }).pause();
                        return function(ut) {
                            Ct.length || xe.restart(!0), Ct.push(ut.trigger), st.push(ut), ne <= Ct.length && xe.progress(1)
                        }
                    },
                    ue;
                for (ue in z) j[ue] = ue.substr(0, 2) === "on" && hi(z[ue]) && ue !== "onRefreshInit" ? me(ue, z[ue]) : z[ue];
                return hi(ne) && (ne = ne(), Rt(wt, "refresh", function() {
                    return ne = z.batchMax()
                })), tt(oe).forEach(function(He) {
                    var ft = {};
                    for (ue in j) ft[ue] = j[ue];
                    ft.trigger = He, ee.push(wt.create(ft))
                }), ee
            };
            var Nr = function(z, ee, j, X) {
                    return ee > X ? z(X) : ee < 0 && z(0), j > X ? (X - ee) / (j - ee) : j < 0 ? ee / (ee - j) : 1
                },
                wr = function oe(z, ee) {
                    ee === !0 ? z.style.removeProperty("touch-action") : z.style.touchAction = ee === !0 ? "auto" : ee ? "pan-" + ee + (Pe.isTouch ? " pinch-zoom" : "") : "none", z === Re && oe(q, ee)
                },
                pr = {
                    auto: 1,
                    scroll: 1
                },
                is = function(z) {
                    var ee = z.event,
                        j = z.target,
                        X = z.axis,
                        ne = (ee.changedTouches ? ee.changedTouches[0] : ee).target,
                        me = ne._gsap || be.core.getCache(ne),
                        ue = ve(),
                        He;
                    if (!me._isScrollT || ue - me._isScrollT > 2e3) {
                        for (; ne && ne !== q && (ne.scrollHeight <= ne.clientHeight && ne.scrollWidth <= ne.clientWidth || !(pr[(He = Ot(ne)).overflowY] || pr[He.overflowX]));) ne = ne.parentNode;
                        me._isScroll = ne && ne !== j && !Gi(ne) && (pr[(He = Ot(ne)).overflowY] || pr[He.overflowX]), me._isScrollT = ue
                    }(me._isScroll || X === "x") && (ee.stopPropagation(), ee._gsapAllow = !0)
                },
                Or = function(z, ee, j, X) {
                    return Pe.create({
                        target: z,
                        capture: !0,
                        debounce: !1,
                        lockAxis: !0,
                        type: ee,
                        onWheel: X = X && is,
                        onPress: X,
                        onDrag: X,
                        onScroll: X,
                        onEnable: function() {
                            return j && Rt(We, Pe.eventTypes[0], $r, !1, !0)
                        },
                        onDisable: function() {
                            return Xt(We, Pe.eventTypes[0], $r, !0)
                        }
                    })
                },
                ns = /(input|label|select|textarea)/i,
                Br, $r = function(z) {
                    var ee = ns.test(z.target.tagName);
                    (ee || Br) && (z._gsapAllow = !0, Br = ee)
                },
                rs = function(z) {
                    on(z) || (z = {}), z.preventDefault = z.isNormalizer = z.allowClicks = !0, z.type || (z.type = "wheel,touch"), z.debounce = !!z.debounce, z.id = z.id || "normalizer";
                    var ee = z,
                        j = ee.normalizeScrollX,
                        X = ee.momentum,
                        ne = ee.allowNestedScroll,
                        me = ee.onRelease,
                        ue, He, ft = K(z.target) || Re,
                        Vt = be.core.globals().ScrollSmoother,
                        Ct = Vt && Vt.get(),
                        st = Je && (z.content && K(z.content) || Ct && z.content !== !1 && !Ct.smooth() && Ct.content()),
                        xe = he(ft, N),
                        ut = he(ft, L),
                        Kt = 1,
                        Gt = (Pe.isTouch && De.visualViewport ? De.visualViewport.scale * De.visualViewport.width : De.outerWidth) / De.innerWidth,
                        oi = 0,
                        jt = hi(X) ? function() {
                            return X(ue)
                        } : function() {
                            return X || 2.8
                        },
                        gi, xt, ji = Or(ft, z.type, !0, ne),
                        Ht = function() {
                            return xt = !1
                        },
                        gt = ui,
                        Pi = ui,
                        Vi = function() {
                            He = Hi(ft, N), Pi = ke(Je ? 1 : 0, He), j && (gt = ke(0, Hi(ft, L))), gi = Pn
                        },
                        nt = function() {
                            st._gsap.y = sn(parseFloat(st._gsap.y) + xe.offset) + "px", st.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(st._gsap.y) + ", 0, 1)", xe.offset = xe.cacheID = 0
                        },
                        pi = function() {
                            if (xt) {
                                requestAnimationFrame(Ht);
                                var ii = sn(ue.deltaY / 2),
                                    ni = Pi(xe.v - ii);
                                if (st && ni !== xe.v + xe.offset) {
                                    xe.offset = ni - xe.v;
                                    var le = sn((parseFloat(st && st._gsap.y) || 0) - xe.offset);
                                    st.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + le + ", 0, 1)", st._gsap.y = le + "px", xe.cacheID = D.cache, an()
                                }
                                return !0
                            }
                            xe.offset && nt(), xt = !0
                        },
                        mt, ln, ai, Ai, Di = function() {
                            Vi(), mt.isActive() && mt.vars.scrollY > He && (xe() > He ? mt.progress(1) && xe(He) : mt.resetTo("scrollY", He))
                        };
                    return st && be.set(st, {
                        y: "+=0"
                    }), z.ignoreCheck = function($t) {
                        return Je && $t.type === "touchmove" && pi() || Kt > 1.05 && $t.type !== "touchstart" || ue.isGesturing || $t.touches && $t.touches.length > 1
                    }, z.onPress = function() {
                        xt = !1;
                        var $t = Kt;
                        Kt = sn((De.visualViewport && De.visualViewport.scale || 1) / Gt), mt.pause(), $t !== Kt && wr(ft, Kt > 1.01 ? !0 : j ? !1 : "x"), ln = ut(), ai = xe(), Vi(), gi = Pn
                    }, z.onRelease = z.onGestureStart = function($t, ii) {
                        if (xe.offset && nt(), !ii) Ai.restart(!0);
                        else {
                            D.cache++;
                            var ni = jt(),
                                le, li;
                            j && (le = ut(), li = le + ni * .05 * -$t.velocityX / .227, ni *= Nr(ut, le, li, Hi(ft, L)), mt.vars.scrollX = gt(li)), le = xe(), li = le + ni * .05 * -$t.velocityY / .227, ni *= Nr(xe, le, li, Hi(ft, N)), mt.vars.scrollY = Pi(li), mt.invalidate().duration(ni).play(.01), (Je && mt.vars.scrollY >= He || le >= He - 1) && be.to({}, {
                                onUpdate: Di,
                                duration: ni
                            })
                        }
                        me && me($t)
                    }, z.onWheel = function() {
                        mt._ts && mt.pause(), ve() - oi > 1e3 && (gi = 0, oi = ve())
                    }, z.onChange = function($t, ii, ni, le, li) {
                        if (Pn !== gi && Vi(), ii && j && ut(gt(le[2] === ii ? ln + ($t.startX - $t.x) : ut() + ii - le[1])), ni) {
                            xe.offset && nt();
                            var Dn = li[2] === ni,
                                _n = Dn ? ai + $t.startY - $t.y : xe() + ni - li[1],
                                qi = Pi(_n);
                            Dn && _n !== qi && (ai += qi - _n), xe(qi)
                        }(ni || ii) && an()
                    }, z.onEnable = function() {
                        wr(ft, j ? !1 : "x"), wt.addEventListener("refresh", Di), Rt(De, "resize", Di), xe.smooth && (xe.target.style.scrollBehavior = "auto", xe.smooth = ut.smooth = !1), ji.enable()
                    }, z.onDisable = function() {
                        wr(ft, !0), Xt(De, "resize", Di), wt.removeEventListener("refresh", Di), ji.kill()
                    }, z.lockAxis = z.lockAxis !== !1, ue = new Pe(z), ue.iOS = Je, Je && !xe() && xe(1), Je && be.ticker.add(ui), Ai = ue._dc, mt = be.to(ue, {
                        ease: "power4",
                        paused: !0,
                        inherit: !1,
                        scrollX: j ? "+=0.1" : "+=0",
                        scrollY: "+=0.1",
                        modifiers: {
                            scrollY: kr(xe, xe(), function() {
                                return mt.pause()
                            })
                        },
                        onUpdate: an,
                        onComplete: Ai.vars.onComplete
                    }), ue
                };
            wt.sort = function(oe) {
                if (hi(oe)) return St.sort(oe);
                var z = De.pageYOffset || 0;
                return wt.getAll().forEach(function(ee) {
                    return ee._sortY = ee.trigger ? z + ee.trigger.getBoundingClientRect().top : ee.start + De.innerHeight
                }), St.sort(oe || function(ee, j) {
                    return (ee.vars.refreshPriority || 0) * -1e6 + (ee.vars.containerAnimation ? 1e6 : ee._sortY) - ((j.vars.containerAnimation ? 1e6 : j._sortY) + (j.vars.refreshPriority || 0) * -1e6)
                })
            }, wt.observe = function(oe) {
                return new Pe(oe)
            }, wt.normalizeScroll = function(oe) {
                if (typeof oe > "u") return Oe;
                if (oe === !0 && Oe) return Oe.enable();
                if (oe === !1) {
                    Oe && Oe.kill(), Oe = oe;
                    return
                }
                var z = oe instanceof Pe ? oe : rs(oe);
                return Oe && Oe.target === z.target && Oe.kill(), Gi(z.target) && (Oe = z), z
            }, wt.core = {
                _getVelocityProp: we,
                _inputObserver: Or,
                _scrollers: D,
                _proxies: R,
                bridge: {
                    ss: function() {
                        et || Mn("scrollStart"), et = ve()
                    },
                    ref: function() {
                        return Ie
                    }
                }
            }, jn() && be.registerPlugin(wt), o.ScrollTrigger = wt, o.default = wt, typeof window > "u" || window !== o ? Object.defineProperty(o, "__esModule", {
                value: !0
            }) : delete window.default
        })
    }(ScrollTrigger$1, ScrollTrigger$1.exports)), ScrollTrigger$1.exports
}
var ScrollTriggerExports = requireScrollTrigger();
class ScrollTriggerFactory {
    static _activePagename = null;
    static _registeredTriggers = new Map;
    static setActivePage(i) {
        this._activePagename = i
    }
    static create(i) {
        const {
            triggerId: o,
            pathname: c,
            ...u
        } = i;
        pageLoadingManager.registerScrollTrigger(c, o);
        const p = new ScrollTriggerExports.ScrollTrigger(u);
        return this._registeredTriggers.set(o, p), this._activePagename === c && requestAnimationFrame(() => {
            pageLoadingManager.notifyScrollTriggerInitialized(o)
        }), p
    }
    static notifyAllInitialized(i) {
        this._registeredTriggers.forEach((o, c) => {
            pageLoadingManager.notifyScrollTriggerInitialized(c)
        })
    }
    static killAll() {
        this._registeredTriggers.forEach(i => {
            i.kill()
        }), this._registeredTriggers.clear()
    }
    static getTrigger(i) {
        return this._registeredTriggers.get(i) || null
    }
}
class WorksOutroController {
    _scrollTrigger = null;
    _worksOutroElement = null;
    _isAboveViewport = !1;
    constructor() {} in () {
        if (this._worksOutroElement = document.querySelector('[data-top_section="works_outro"]'), !this._worksOutroElement) {
            console.warn("WorksOutroController: works_outro element not found");
            return
        }
        this._createScrollTrigger(), this._updateBodyDataAttribute()
    }
    out() {
        this._scrollTrigger && (this._scrollTrigger.kill(), this._scrollTrigger = null), this._worksOutroElement = null, this._isAboveViewport = !1, document.body.removeAttribute("data-works-outro-above-viewport")
    }
    _createScrollTrigger() {
        this._worksOutroElement && (this._scrollTrigger = ScrollTriggerFactory.create({
            triggerId: "works_outro_controller",
            pathname: "/",
            trigger: this._worksOutroElement,
            start: "top top",
            end: "bottom bottom",
            onEnter: () => {
                this._isAboveViewport = !0, this._updateBodyDataAttribute()
            },
            onLeaveBack: () => {
                this._isAboveViewport = !1, this._updateBodyDataAttribute()
            }
        }))
    }
    _updateBodyDataAttribute() {
        this._isAboveViewport ? document.body.setAttribute("data-works-outro-above-viewport", "true") : document.body.setAttribute("data-works-outro-above-viewport", "false")
    }
    isAboveViewport() {
        return this._isAboveViewport
    }
}
class PageTop extends PageBase {
    _bgQuadTreeWorksManager;
    _serviceItemController;
    _serviceTitleController;
    _worksItemController;
    _visionMissionController;
    _stelllaSectionController;
    _moreWorksController;
    _worksOutroController;
    constructor() {
        super(), this._bgQuadTreeWorksManager = new BGQuadTreeWorksManager, this._serviceItemController = new ServiceItemController, this._serviceTitleController = new ServiceTitleController, this._worksItemController = new WorksItemController, this._visionMissionController = new VisionMissionController, this._stelllaSectionController = new StelllaSectionController, this._moreWorksController = MoreWorksController.getInstance(), this._worksOutroController = new WorksOutroController, topScrollManager.on("section/change", i => {
            if (gl.changeTopSection(i.sectionName), i.direction === "enter") switch (i.sectionName) {
                case "works":
                    soundManager.playSE("works_in");
                    break;
                case "mission_in":
                    soundManager.playSE("mission_in"), soundManager.playSE("typing");
                    break;
                case "service_in":
                    soundManager.playSE("works_in"), soundManager.stopSE("typing");
                    break
            }
        })
    }
    inStart(i) {
        super.inStart(i), topScrollManager.in(), this._bgQuadTreeWorksManager.setup(), this._serviceItemController.in(), this._serviceTitleController.in(), this._worksItemController.in(), this._worksOutroController.in(), this._visionMissionController.in(), this._stelllaSectionController.in(), topScrollIndicatorController.in(), this._moreWorksController.init(), setTimeout(() => {
            debugManager.init()
        }, 100)
    }
    outEnd(i) {
        super.outEnd(i), topScrollManager.out(), this._serviceItemController.out(), this._serviceTitleController.out(), this._worksItemController.out(), this._worksOutroController.out(), this._visionMissionController.out(), this._stelllaSectionController.out(), topScrollIndicatorController.out(), this._moreWorksController.dispose(), debugManager.dispose()
    }
    get worksOutroController() {
        return this._worksOutroController
    }
}
class StellaMaskAnimation {
    maskElement = null;
    contactElement = null;
    scrollTriggerInstance = null;
    maskScrollTriggerInstance = null;
    resizeObserver = null;
    progressPageOut = 0;
    progressPageIn = 0;
    tickFunction = () => this.updateMaskSize();
    cachedMinRect = 0;
    cachedMaxRect = 0;
    constructor() {} in () {
        this.contactElement = document.querySelector("[data-stellla-contact]"), this.maskElement = document.querySelector("[data-stellla-mask]");
        const i = document.getElementById("stellla-bg-video");
        i && i.play(), !(!this.maskElement || !this.contactElement) && (this.createScrollTrigger(), gsapWithCSS.ticker.add(this.tickFunction), this.resizeObserver = new ResizeObserver(() => {
            this.updateMaskSizeCache(), this.createScrollTrigger()
        }), this.resizeObserver.observe(this.contactElement), this.resizeObserver.observe(this.maskElement))
    }
    out() {
        gsapWithCSS.ticker.remove(this.tickFunction), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), this.cleanup(), this.maskElement = null, this.contactElement = null
    }
    cleanup() {
        this.scrollTriggerInstance && (this.scrollTriggerInstance.kill(), this.scrollTriggerInstance = null), this.maskScrollTriggerInstance && (this.maskScrollTriggerInstance.kill(), this.maskScrollTriggerInstance = null)
    }
    updateMaskSizeCache() {
        if (!this.maskElement) return;
        const i = this.maskElement.getBoundingClientRect();
        this.cachedMinRect = Math.min(i.width, i.height), this.cachedMaxRect = Math.max(i.width, i.height)
    }
    createScrollTrigger() {
        this.cleanup(), !(!this.maskElement || !this.contactElement) && (this.updateMaskSizeCache(), this.scrollTriggerInstance = ScrollTriggerFactory.create({
            triggerId: "stellla_mask_contact_progress",
            pathname: "/stellla",
            trigger: this.contactElement,
            start: "top top-=100px",
            end: "bottom bottom",
            onUpdate: i => {
                this.progressPageOut = i.progress
            }
        }), this.maskScrollTriggerInstance = ScrollTriggerFactory.create({
            triggerId: "stellla_mask_animation",
            pathname: "/stellla",
            trigger: this.contactElement,
            start: "top bottom",
            end: "top top",
            onUpdate: i => {
                this.progressPageIn = i.progress
            }
        }))
    }
    updateMaskSize() {
        if (!this.maskElement) return;
        const i = this.cachedMinRect,
            o = this.cachedMaxRect,
            c = lerper.set("stelllaContact_in", this.progressPageIn, .7),
            u = lerper.set("stelllaContact_out", this.progressPageOut, .7),
            p = (c * .5 + .5) * i * .7,
            m = u * (o * 15 - i * .7),
            g = p + m;
        this.maskElement.style.maskSize = `${Math.floor(g)}px`, this.maskElement.style.opacity = (c * .5 + u * .5).toString()
    }
}
class StellaHorizontalScroll {
    scrollTriggerInstance = null;
    timeline = null;
    wrapperElm = null;
    listElm = null;
    resizeObserver = null;
    MD_WIDTH = 768;
    constructor() {} in () {
        this.wrapperElm = document.querySelector("[data-stellla-horizontal]"), this.listElm = document.getElementById("case_study_list"), !(!this.wrapperElm || !this.listElm) && (this.createScrollTrigger(), this.resizeObserver = new ResizeObserver(() => {
            this.createScrollTrigger()
        }), this.resizeObserver.observe(this.listElm))
    }
    out() {
        this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), this.cleanup(), this.wrapperElm = null, this.listElm = null
    }
    cleanup() {
        this.scrollTriggerInstance && (this.scrollTriggerInstance.kill(), this.scrollTriggerInstance = null), this.timeline && (this.timeline.kill(), this.timeline = null)
    }
    createScrollTrigger() {
        if (this.cleanup(), !this.wrapperElm || !this.listElm) return;
        if (window.innerWidth <= this.MD_WIDTH) {
            gsapWithCSS.set(this.listElm, {
                translateX: 0,
                clearProps: "transform"
            });
            return
        }
        const i = document.querySelector("[data-casestudy-article"),
            o = i ? i.clientWidth : this.wrapperElm.clientWidth * .43,
            c = this.listElm.scrollWidth - this.wrapperElm.clientWidth,
            u = window.innerWidth / 2 - o / 2;
        this.timeline = gsapWithCSS.timeline(), this.timeline.fromTo(this.listElm, {
            translateX: u,
            ease: "none"
        }, {
            translateX: -(c + u),
            ease: "none"
        }), this.scrollTriggerInstance = ScrollTriggerFactory.create({
            triggerId: "stellla_horizontal_scroll",
            pathname: "/stellla",
            trigger: this.wrapperElm,
            start: "top top",
            end: "bottom bottom",
            scrub: .5,
            animation: this.timeline
        })
    }
}
class StellaBackgroundDimmer {
    videoWrapperElement = null;
    _scrollTrigger = null;
    constructor() {} in () {
        if (this.videoWrapperElement = document.getElementById("stellla-kv-video-wrapper"), !this.videoWrapperElement) return;
        const i = gsapWithCSS.timeline();
        i.fromTo(this.videoWrapperElement.querySelector("video"), {
            filter: "blur(0px) brightness(1.0)",
            ease: "none"
        }, {
            filter: "blur(10px) brightness(0.3)",
            ease: "none"
        }), this._scrollTrigger = ScrollTriggerFactory.create({
            triggerId: "stellla_background_dimmer",
            pathname: "/stellla",
            trigger: document.body,
            start: "top top",
            end: "10% bottom",
            scrub: 1,
            animation: i
        })
    }
    out() {
        this._scrollTrigger && (this._scrollTrigger.kill(), this._scrollTrigger = null), this.videoWrapperElement && gsapWithCSS.set(this.videoWrapperElement, {
            opacity: 0
        })
    }
}
gsapWithCSS.registerPlugin(ScrollTriggerExports.ScrollTrigger);
class StellaFadeInAnimation {
    _timeline = null;
    _observer = null;
    constructor() {} in () {
        this._initObserver(), this._observeElements()
    }
    _initObserver() {
        const i = {
            root: null,
            rootMargin: "-15% 0px -15% 0px",
            threshold: 0
        };
        this._observer = new IntersectionObserver(o => {
            o.forEach(c => {
                c.isIntersecting && (this._animateElement(c.target), this._observer ? .unobserve(c.target))
            })
        }, i)
    }
    _observeElements() {
        if (!this._observer) return;
        document.querySelectorAll('[data-animation="intro-text"]').forEach(x => {
            gsapWithCSS.set(x, {
                y: 30,
                opacity: 0
            }), this._observer ? .observe(x)
        }), document.querySelectorAll('[data-animation="point-item"]').forEach(x => {
            const y = x.querySelector('[data-element="point-image"]'),
                b = x.querySelector('[data-element="point-detail"]'),
                S = x.querySelector('[data-element="point-number"]');
            y && gsapWithCSS.set(y, {
                x: -40,
                opacity: 0
            }), b && gsapWithCSS.set(b, {
                x: 40,
                opacity: 0
            }), S && gsapWithCSS.set(S, {
                scale: 0,
                opacity: 0
            }), this._observer ? .observe(x)
        }), document.querySelectorAll('[data-animation="feature-item"]').forEach(x => {
            const y = x.querySelector('[data-element="feature-image"]'),
                b = x.querySelector('[data-element="feature-detail"]');
            y && gsapWithCSS.set(y, {
                scale: .8,
                opacity: 0
            }), b && gsapWithCSS.set(b, {
                y: 30,
                opacity: 0
            }), this._observer ? .observe(x)
        });
        const u = document.querySelector('[data-animation="slide-container"]');
        u && (gsapWithCSS.set(u, {
            y: 40,
            opacity: 0
        }), this._observer.observe(u)), document.querySelectorAll('[data-animation="company-logo"]').forEach(x => {
            gsapWithCSS.set(x, {
                scale: .8,
                opacity: 0
            }), this._observer ? .observe(x)
        }), document.querySelectorAll('[data-animation="case-title"]').forEach(x => {
            gsapWithCSS.set(x, {
                y: 30,
                opacity: 0
            }), this._observer ? .observe(x)
        }), document.querySelectorAll("[data-casestudy-article]").forEach(x => {
            const y = x.querySelector('[data-element="case-btn"]'),
                b = x.querySelector('[data-element="case-title"]'),
                S = x.querySelector('[data-element="case-text"]');
            y && gsapWithCSS.set(y, {
                scale: .9,
                opacity: 0
            }), b && gsapWithCSS.set(b, {
                y: 20,
                opacity: 0
            }), S && gsapWithCSS.set(S, {
                y: 20,
                opacity: 0
            }), this._observer ? .observe(x)
        });
        const _ = document.querySelector("[data-stellla-contact]");
        if (_) {
            const x = _.querySelector('[data-element="contact-lead"]'),
                y = _.querySelector('[data-element="contact-text"]'),
                b = _.querySelector('[data-element="contact-button"]');
            x && gsapWithCSS.set(x, {
                y: 30,
                opacity: 0
            }), y && gsapWithCSS.set(y, {
                y: 30,
                opacity: 0
            }), b && gsapWithCSS.set(b, {
                y: 30,
                opacity: 0
            }), this._observer.observe(_)
        }
        document.querySelectorAll('[data-animation="img-scale"]').forEach(x => {
            gsapWithCSS.set(x, {
                scale: 1.05,
                opacity: 0
            }), this._observer ? .observe(x)
        })
    }
    _animateElement(i) {
        const o = i.getAttribute("data-animation");
        if (o === "intro-text") {
            const c = document.querySelectorAll('[data-animation="intro-text"]'),
                u = Array.from(c).indexOf(i);
            gsapWithCSS.to(i, {
                y: 0,
                opacity: 1,
                duration: .8,
                ease: "power2.out",
                delay: u * .1
            })
        } else if (o === "point-item") {
            const c = i.querySelector('[data-element="point-image"]'),
                u = i.querySelector('[data-element="point-detail"]'),
                p = i.querySelector('[data-element="point-number"]'),
                m = gsapWithCSS.timeline();
            p && m.to(p, {
                scale: 1,
                opacity: 1,
                duration: .5,
                ease: "back.out(1.7)"
            }), c && m.to(c, {
                x: 0,
                opacity: 1,
                duration: .8,
                ease: "power2.out"
            }, "-=0.3"), u && m.to(u, {
                x: 0,
                opacity: 1,
                duration: .8,
                ease: "power2.out"
            }, "-=0.6")
        } else if (o === "feature-item") {
            const c = document.querySelectorAll('[data-animation="feature-item"]'),
                u = Array.from(c).indexOf(i),
                p = i.querySelector('[data-element="feature-image"]'),
                m = i.querySelector('[data-element="feature-detail"]'),
                g = gsapWithCSS.timeline({
                    delay: u * .1
                });
            p && g.to(p, {
                scale: 1,
                opacity: 1,
                duration: .8,
                ease: "power2.out"
            }), m && g.to(m, {
                y: 0,
                opacity: 1,
                duration: .8,
                ease: "power2.out"
            }, "-=0.4")
        } else if (o === "slide-container") gsapWithCSS.to(i, {
            y: 0,
            opacity: 1,
            duration: 1,
            ease: "power2.out"
        });
        else if (o === "company-logo") {
            const c = document.querySelectorAll('[data-animation="company-logo"]'),
                u = Array.from(c).indexOf(i);
            gsapWithCSS.to(i, {
                scale: 1,
                opacity: 1,
                duration: .6,
                ease: "back.out(1.7)",
                delay: u * .1
            })
        } else if (o === "case-title") gsapWithCSS.to(i, {
            y: 0,
            opacity: 1,
            duration: .8,
            ease: "power2.out"
        });
        else if (i.hasAttribute("data-casestudy-article")) {
            const c = i.querySelector('[data-element="case-btn"]'),
                u = i.querySelector('[data-element="case-title"]'),
                p = i.querySelector('[data-element="case-text"]'),
                m = gsapWithCSS.timeline();
            c && m.to(c, {
                scale: 1,
                opacity: 1,
                duration: .6,
                ease: "power2.out"
            }), u && m.to(u, {
                y: 0,
                opacity: 1,
                duration: .6,
                ease: "power2.out"
            }, "-=0.3"), p && m.to(p, {
                y: 0,
                opacity: 1,
                duration: .6,
                ease: "power2.out"
            }, "-=0.4")
        } else if (i.hasAttribute("data-stellla-contact")) {
            const c = i.querySelector('[data-element="contact-lead"]'),
                u = i.querySelector('[data-element="contact-text"]'),
                p = i.querySelector('[data-element="contact-button"]'),
                m = gsapWithCSS.timeline();
            c && m.to(c, {
                y: 0,
                opacity: 1,
                duration: .8,
                ease: "power2.out"
            }), u && m.to(u, {
                y: 0,
                opacity: 1,
                duration: .8,
                ease: "power2.out"
            }, "-=0.4"), p && m.to(p, {
                y: 0,
                opacity: 1,
                duration: .8,
                ease: "power2.out"
            }, "-=0.4")
        } else o === "img-scale" && gsapWithCSS.to(i, {
            scale: 1,
            opacity: 1,
            duration: 1.2,
            ease: "power2.out"
        })
    }
    out() {
        this._observer && (this._observer.disconnect(), this._observer = null), this._timeline && (this._timeline.kill(), this._timeline = null)
    }
}
gsapWithCSS.registerPlugin(ScrollTriggerExports.ScrollTrigger);
class PageStellla extends PageBase {
    maskAnimation;
    horizontalScroll;
    backgroundDimmer;
    fadeInAnimation;
    constructor() {
        super(), this.backgroundDimmer = new StellaBackgroundDimmer, this.horizontalScroll = new StellaHorizontalScroll, this.fadeInAnimation = new StellaFadeInAnimation, this.maskAnimation = new StellaMaskAnimation
    }
    inStart(i) {
        super.inStart(i), ScrollTriggerFactory.setActivePage("/stellla");
        const o = document.getElementById("stellla-kv-video");
        o && (o.currentTime = 0, o.play().catch(c => {
            console.warn(":", c)
        })), this.horizontalScroll.in(), this.backgroundDimmer.in(), this.fadeInAnimation.in(), setTimeout(() => {
            this.maskAnimation.in(), this._waitForScrollTriggerComplete()
        }, 10)
    }
    _waitForScrollTriggerComplete() {
        setTimeout(() => {
            this.emit("stellla_scroll_triggers_ready")
        }, 150)
    }
    outEnd(i) {
        super.outEnd(i), ScrollTriggerFactory.killAll(), this.horizontalScroll.out(), this.maskAnimation.out(), this.backgroundDimmer.out(), this.fadeInAnimation.out()
    }
}

function isObject$1(l) {
    return l !== null && typeof l == "object" && "constructor" in l && l.constructor === Object
}

function extend$1(l, i) {
    l === void 0 && (l = {}), i === void 0 && (i = {});
    const o = ["__proto__", "constructor", "prototype"];
    Object.keys(i).filter(c => o.indexOf(c) < 0).forEach(c => {
        typeof l[c] > "u" ? l[c] = i[c] : isObject$1(i[c]) && isObject$1(l[c]) && Object.keys(i[c]).length > 0 && extend$1(l[c], i[c])
    })
}
const ssrDocument = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};

function getDocument() {
    const l = typeof document < "u" ? document : {};
    return extend$1(l, ssrDocument), l
}
const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(l) {
        return typeof setTimeout > "u" ? (l(), null) : setTimeout(l, 0)
    },
    cancelAnimationFrame(l) {
        typeof setTimeout > "u" || clearTimeout(l)
    }
};

function getWindow() {
    const l = typeof window < "u" ? window : {};
    return extend$1(l, ssrWindow), l
}

function classesToTokens(l) {
    return l === void 0 && (l = ""), l.trim().split(" ").filter(i => !!i.trim())
}

function deleteProps(l) {
    const i = l;
    Object.keys(i).forEach(o => {
        try {
            i[o] = null
        } catch {}
        try {
            delete i[o]
        } catch {}
    })
}

function nextTick(l, i) {
    return i === void 0 && (i = 0), setTimeout(l, i)
}

function now() {
    return Date.now()
}

function getComputedStyle$1(l) {
    const i = getWindow();
    let o;
    return i.getComputedStyle && (o = i.getComputedStyle(l, null)), !o && l.currentStyle && (o = l.currentStyle), o || (o = l.style), o
}

function getTranslate(l, i) {
    i === void 0 && (i = "x");
    const o = getWindow();
    let c, u, p;
    const m = getComputedStyle$1(l);
    return o.WebKitCSSMatrix ? (u = m.transform || m.webkitTransform, u.split(",").length > 6 && (u = u.split(", ").map(g => g.replace(",", ".")).join(", ")), p = new o.WebKitCSSMatrix(u === "none" ? "" : u)) : (p = m.MozTransform || m.OTransform || m.MsTransform || m.msTransform || m.transform || m.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), c = p.toString().split(",")), i === "x" && (o.WebKitCSSMatrix ? u = p.m41 : c.length === 16 ? u = parseFloat(c[12]) : u = parseFloat(c[4])), i === "y" && (o.WebKitCSSMatrix ? u = p.m42 : c.length === 16 ? u = parseFloat(c[13]) : u = parseFloat(c[5])), u || 0
}

function isObject(l) {
    return typeof l == "object" && l !== null && l.constructor && Object.prototype.toString.call(l).slice(8, -1) === "Object"
}

function isNode(l) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? l instanceof HTMLElement : l && (l.nodeType === 1 || l.nodeType === 11)
}

function extend() {
    const l = Object(arguments.length <= 0 ? void 0 : arguments[0]),
        i = ["__proto__", "constructor", "prototype"];
    for (let o = 1; o < arguments.length; o += 1) {
        const c = o < 0 || arguments.length <= o ? void 0 : arguments[o];
        if (c != null && !isNode(c)) {
            const u = Object.keys(Object(c)).filter(p => i.indexOf(p) < 0);
            for (let p = 0, m = u.length; p < m; p += 1) {
                const g = u[p],
                    _ = Object.getOwnPropertyDescriptor(c, g);
                _ !== void 0 && _.enumerable && (isObject(l[g]) && isObject(c[g]) ? c[g].__swiper__ ? l[g] = c[g] : extend(l[g], c[g]) : !isObject(l[g]) && isObject(c[g]) ? (l[g] = {}, c[g].__swiper__ ? l[g] = c[g] : extend(l[g], c[g])) : l[g] = c[g])
            }
        }
    }
    return l
}

function setCSSProperty(l, i, o) {
    l.style.setProperty(i, o)
}

function animateCSSModeScroll(l) {
    let {
        swiper: i,
        targetPosition: o,
        side: c
    } = l;
    const u = getWindow(),
        p = -i.translate;
    let m = null,
        g;
    const _ = i.params.speed;
    i.wrapperEl.style.scrollSnapType = "none", u.cancelAnimationFrame(i.cssModeFrameID);
    const v = o > p ? "next" : "prev",
        x = (b, S) => v === "next" && b >= S || v === "prev" && b <= S,
        y = () => {
            g = new Date().getTime(), m === null && (m = g);
            const b = Math.max(Math.min((g - m) / _, 1), 0),
                S = .5 - Math.cos(b * Math.PI) / 2;
            let C = p + S * (o - p);
            if (x(C, o) && (C = o), i.wrapperEl.scrollTo({
                    [c]: C
                }), x(C, o)) {
                i.wrapperEl.style.overflow = "hidden", i.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                    i.wrapperEl.style.overflow = "", i.wrapperEl.scrollTo({
                        [c]: C
                    })
                }), u.cancelAnimationFrame(i.cssModeFrameID);
                return
            }
            i.cssModeFrameID = u.requestAnimationFrame(y)
        };
    y()
}

function elementChildren(l, i) {
    i === void 0 && (i = "");
    const o = getWindow(),
        c = [...l.children];
    return o.HTMLSlotElement && l instanceof HTMLSlotElement && c.push(...l.assignedElements()), i ? c.filter(u => u.matches(i)) : c
}

function elementIsChildOfSlot(l, i) {
    const o = [i];
    for (; o.length > 0;) {
        const c = o.shift();
        if (l === c) return !0;
        o.push(...c.children, ...c.shadowRoot ? c.shadowRoot.children : [], ...c.assignedElements ? c.assignedElements() : [])
    }
}

function elementIsChildOf(l, i) {
    const o = getWindow();
    let c = i.contains(l);
    return !c && o.HTMLSlotElement && i instanceof HTMLSlotElement && (c = [...i.assignedElements()].includes(l), c || (c = elementIsChildOfSlot(l, i))), c
}

function showWarning(l) {
    try {
        console.warn(l);
        return
    } catch {}
}

function createElement(l, i) {
    i === void 0 && (i = []);
    const o = document.createElement(l);
    return o.classList.add(...Array.isArray(i) ? i : classesToTokens(i)), o
}

function elementPrevAll(l, i) {
    const o = [];
    for (; l.previousElementSibling;) {
        const c = l.previousElementSibling;
        i ? c.matches(i) && o.push(c) : o.push(c), l = c
    }
    return o
}

function elementNextAll(l, i) {
    const o = [];
    for (; l.nextElementSibling;) {
        const c = l.nextElementSibling;
        i ? c.matches(i) && o.push(c) : o.push(c), l = c
    }
    return o
}

function elementStyle(l, i) {
    return getWindow().getComputedStyle(l, null).getPropertyValue(i)
}

function elementIndex(l) {
    let i = l,
        o;
    if (i) {
        for (o = 0;
            (i = i.previousSibling) !== null;) i.nodeType === 1 && (o += 1);
        return o
    }
}

function elementParents(l, i) {
    const o = [];
    let c = l.parentElement;
    for (; c;) i ? c.matches(i) && o.push(c) : o.push(c), c = c.parentElement;
    return o
}

function elementOuterSize(l, i, o) {
    const c = getWindow();
    return l[i === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(c.getComputedStyle(l, null).getPropertyValue(i === "width" ? "margin-right" : "margin-top")) + parseFloat(c.getComputedStyle(l, null).getPropertyValue(i === "width" ? "margin-left" : "margin-bottom"))
}

function makeElementsArray(l) {
    return (Array.isArray(l) ? l : [l]).filter(i => !!i)
}

function setInnerHTML(l, i) {
    i === void 0 && (i = ""), typeof trustedTypes < "u" ? l.innerHTML = trustedTypes.createPolicy("html", {
        createHTML: o => o
    }).createHTML(i) : l.innerHTML = i
}
let support;

function calcSupport() {
    const l = getWindow(),
        i = getDocument();
    return {
        smoothScroll: i.documentElement && i.documentElement.style && "scrollBehavior" in i.documentElement.style,
        touch: !!("ontouchstart" in l || l.DocumentTouch && i instanceof l.DocumentTouch)
    }
}

function getSupport() {
    return support || (support = calcSupport()), support
}
let deviceCached;

function calcDevice(l) {
    let {
        userAgent: i
    } = l === void 0 ? {} : l;
    const o = getSupport(),
        c = getWindow(),
        u = c.navigator.platform,
        p = i || c.navigator.userAgent,
        m = {
            ios: !1,
            android: !1
        },
        g = c.screen.width,
        _ = c.screen.height,
        v = p.match(/(Android);?[\s\/]+([\d.]+)?/);
    let x = p.match(/(iPad).*OS\s([\d_]+)/);
    const y = p.match(/(iPod)(.*OS\s([\d_]+))?/),
        b = !x && p.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
        S = u === "Win32";
    let C = u === "MacIntel";
    const E = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !x && C && o.touch && E.indexOf(`${g}x${_}`) >= 0 && (x = p.match(/(Version)\/([\d.]+)/), x || (x = [0, 1, "13_0_0"]), C = !1), v && !S && (m.os = "android", m.android = !0), (x || b || y) && (m.os = "ios", m.ios = !0), m
}

function getDevice(l) {
    return l === void 0 && (l = {}), deviceCached || (deviceCached = calcDevice(l)), deviceCached
}
let browser;

function calcBrowser() {
    const l = getWindow(),
        i = getDevice();
    let o = !1;

    function c() {
        const g = l.navigator.userAgent.toLowerCase();
        return g.indexOf("safari") >= 0 && g.indexOf("chrome") < 0 && g.indexOf("android") < 0
    }
    if (c()) {
        const g = String(l.navigator.userAgent);
        if (g.includes("Version/")) {
            const [_, v] = g.split("Version/")[1].split(" ")[0].split(".").map(x => Number(x));
            o = _ < 16 || _ === 16 && v < 2
        }
    }
    const u = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(l.navigator.userAgent),
        p = c(),
        m = p || u && i.ios;
    return {
        isSafari: o || p,
        needPerspectiveFix: o,
        need3dFix: m,
        isWebView: u
    }
}

function getBrowser() {
    return browser || (browser = calcBrowser()), browser
}

function Resize(l) {
    let {
        swiper: i,
        on: o,
        emit: c
    } = l;
    const u = getWindow();
    let p = null,
        m = null;
    const g = () => {
            !i || i.destroyed || !i.initialized || (c("beforeResize"), c("resize"))
        },
        _ = () => {
            !i || i.destroyed || !i.initialized || (p = new ResizeObserver(y => {
                m = u.requestAnimationFrame(() => {
                    const {
                        width: b,
                        height: S
                    } = i;
                    let C = b,
                        E = S;
                    y.forEach(P => {
                        let {
                            contentBoxSize: w,
                            contentRect: T,
                            target: M
                        } = P;
                        M && M !== i.el || (C = T ? T.width : (w[0] || w).inlineSize, E = T ? T.height : (w[0] || w).blockSize)
                    }), (C !== b || E !== S) && g()
                })
            }), p.observe(i.el))
        },
        v = () => {
            m && u.cancelAnimationFrame(m), p && p.unobserve && i.el && (p.unobserve(i.el), p = null)
        },
        x = () => {
            !i || i.destroyed || !i.initialized || c("orientationchange")
        };
    o("init", () => {
        if (i.params.resizeObserver && typeof u.ResizeObserver < "u") {
            _();
            return
        }
        u.addEventListener("resize", g), u.addEventListener("orientationchange", x)
    }), o("destroy", () => {
        v(), u.removeEventListener("resize", g), u.removeEventListener("orientationchange", x)
    })
}

function Observer(l) {
    let {
        swiper: i,
        extendParams: o,
        on: c,
        emit: u
    } = l;
    const p = [],
        m = getWindow(),
        g = function(x, y) {
            y === void 0 && (y = {});
            const b = m.MutationObserver || m.WebkitMutationObserver,
                S = new b(C => {
                    if (i.__preventObserver__) return;
                    if (C.length === 1) {
                        u("observerUpdate", C[0]);
                        return
                    }
                    const E = function() {
                        u("observerUpdate", C[0])
                    };
                    m.requestAnimationFrame ? m.requestAnimationFrame(E) : m.setTimeout(E, 0)
                });
            S.observe(x, {
                attributes: typeof y.attributes > "u" ? !0 : y.attributes,
                childList: i.isElement || (typeof y.childList > "u" ? !0 : y).childList,
                characterData: typeof y.characterData > "u" ? !0 : y.characterData
            }), p.push(S)
        },
        _ = () => {
            if (i.params.observer) {
                if (i.params.observeParents) {
                    const x = elementParents(i.hostEl);
                    for (let y = 0; y < x.length; y += 1) g(x[y])
                }
                g(i.hostEl, {
                    childList: i.params.observeSlideChildren
                }), g(i.wrapperEl, {
                    attributes: !1
                })
            }
        },
        v = () => {
            p.forEach(x => {
                x.disconnect()
            }), p.splice(0, p.length)
        };
    o({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }), c("init", _), c("destroy", v)
}
var eventsEmitter = {
    on(l, i, o) {
        const c = this;
        if (!c.eventsListeners || c.destroyed || typeof i != "function") return c;
        const u = o ? "unshift" : "push";
        return l.split(" ").forEach(p => {
            c.eventsListeners[p] || (c.eventsListeners[p] = []), c.eventsListeners[p][u](i)
        }), c
    },
    once(l, i, o) {
        const c = this;
        if (!c.eventsListeners || c.destroyed || typeof i != "function") return c;

        function u() {
            c.off(l, u), u.__emitterProxy && delete u.__emitterProxy;
            for (var p = arguments.length, m = new Array(p), g = 0; g < p; g++) m[g] = arguments[g];
            i.apply(c, m)
        }
        return u.__emitterProxy = i, c.on(l, u, o)
    },
    onAny(l, i) {
        const o = this;
        if (!o.eventsListeners || o.destroyed || typeof l != "function") return o;
        const c = i ? "unshift" : "push";
        return o.eventsAnyListeners.indexOf(l) < 0 && o.eventsAnyListeners[c](l), o
    },
    offAny(l) {
        const i = this;
        if (!i.eventsListeners || i.destroyed || !i.eventsAnyListeners) return i;
        const o = i.eventsAnyListeners.indexOf(l);
        return o >= 0 && i.eventsAnyListeners.splice(o, 1), i
    },
    off(l, i) {
        const o = this;
        return !o.eventsListeners || o.destroyed || !o.eventsListeners || l.split(" ").forEach(c => {
            typeof i > "u" ? o.eventsListeners[c] = [] : o.eventsListeners[c] && o.eventsListeners[c].forEach((u, p) => {
                (u === i || u.__emitterProxy && u.__emitterProxy === i) && o.eventsListeners[c].splice(p, 1)
            })
        }), o
    },
    emit() {
        const l = this;
        if (!l.eventsListeners || l.destroyed || !l.eventsListeners) return l;
        let i, o, c;
        for (var u = arguments.length, p = new Array(u), m = 0; m < u; m++) p[m] = arguments[m];
        return typeof p[0] == "string" || Array.isArray(p[0]) ? (i = p[0], o = p.slice(1, p.length), c = l) : (i = p[0].events, o = p[0].data, c = p[0].context || l), o.unshift(c), (Array.isArray(i) ? i : i.split(" ")).forEach(_ => {
            l.eventsAnyListeners && l.eventsAnyListeners.length && l.eventsAnyListeners.forEach(v => {
                v.apply(c, [_, ...o])
            }), l.eventsListeners && l.eventsListeners[_] && l.eventsListeners[_].forEach(v => {
                v.apply(c, o)
            })
        }), l
    }
};

function updateSize() {
    const l = this;
    let i, o;
    const c = l.el;
    typeof l.params.width < "u" && l.params.width !== null ? i = l.params.width : i = c.clientWidth, typeof l.params.height < "u" && l.params.height !== null ? o = l.params.height : o = c.clientHeight, !(i === 0 && l.isHorizontal() || o === 0 && l.isVertical()) && (i = i - parseInt(elementStyle(c, "padding-left") || 0, 10) - parseInt(elementStyle(c, "padding-right") || 0, 10), o = o - parseInt(elementStyle(c, "padding-top") || 0, 10) - parseInt(elementStyle(c, "padding-bottom") || 0, 10), Number.isNaN(i) && (i = 0), Number.isNaN(o) && (o = 0), Object.assign(l, {
        width: i,
        height: o,
        size: l.isHorizontal() ? i : o
    }))
}

function updateSlides() {
    const l = this;

    function i(V, B) {
        return parseFloat(V.getPropertyValue(l.getDirectionLabel(B)) || 0)
    }
    const o = l.params,
        {
            wrapperEl: c,
            slidesEl: u,
            size: p,
            rtlTranslate: m,
            wrongRTL: g
        } = l,
        _ = l.virtual && o.virtual.enabled,
        v = _ ? l.virtual.slides.length : l.slides.length,
        x = elementChildren(u, `.${l.params.slideClass}, swiper-slide`),
        y = _ ? l.virtual.slides.length : x.length;
    let b = [];
    const S = [],
        C = [];
    let E = o.slidesOffsetBefore;
    typeof E == "function" && (E = o.slidesOffsetBefore.call(l));
    let P = o.slidesOffsetAfter;
    typeof P == "function" && (P = o.slidesOffsetAfter.call(l));
    const w = l.snapGrid.length,
        T = l.slidesGrid.length;
    let M = o.spaceBetween,
        A = -E,
        D = 0,
        R = 0;
    if (typeof p > "u") return;
    typeof M == "string" && M.indexOf("%") >= 0 ? M = parseFloat(M.replace("%", "")) / 100 * p : typeof M == "string" && (M = parseFloat(M)), l.virtualSize = -M, x.forEach(V => {
        m ? V.style.marginLeft = "" : V.style.marginRight = "", V.style.marginBottom = "", V.style.marginTop = ""
    }), o.centeredSlides && o.cssMode && (setCSSProperty(c, "--swiper-centered-offset-before", ""), setCSSProperty(c, "--swiper-centered-offset-after", ""));
    const I = o.grid && o.grid.rows > 1 && l.grid;
    I ? l.grid.initSlides(x) : l.grid && l.grid.unsetSlides();
    let k;
    const F = o.slidesPerView === "auto" && o.breakpoints && Object.keys(o.breakpoints).filter(V => typeof o.breakpoints[V].slidesPerView < "u").length > 0;
    for (let V = 0; V < y; V += 1) {
        k = 0;
        let B;
        if (x[V] && (B = x[V]), I && l.grid.updateSlide(V, B, x), !(x[V] && elementStyle(B, "display") === "none")) {
            if (o.slidesPerView === "auto") {
                F && (x[V].style[l.getDirectionLabel("width")] = "");
                const U = getComputedStyle(B),
                    H = B.style.transform,
                    Q = B.style.webkitTransform;
                if (H && (B.style.transform = "none"), Q && (B.style.webkitTransform = "none"), o.roundLengths) k = l.isHorizontal() ? elementOuterSize(B, "width") : elementOuterSize(B, "height");
                else {
                    const Y = i(U, "width"),
                        O = i(U, "padding-left"),
                        G = i(U, "padding-right"),
                        L = i(U, "margin-left"),
                        N = i(U, "margin-right"),
                        K = U.getPropertyValue("box-sizing");
                    if (K && K === "border-box") k = Y + L + N;
                    else {
                        const {
                            clientWidth: Z,
                            offsetWidth: he
                        } = B;
                        k = Y + O + G + L + N + (he - Z)
                    }
                }
                H && (B.style.transform = H), Q && (B.style.webkitTransform = Q), o.roundLengths && (k = Math.floor(k))
            } else k = (p - (o.slidesPerView - 1) * M) / o.slidesPerView, o.roundLengths && (k = Math.floor(k)), x[V] && (x[V].style[l.getDirectionLabel("width")] = `${k}px`);
            x[V] && (x[V].swiperSlideSize = k), C.push(k), o.centeredSlides ? (A = A + k / 2 + D / 2 + M, D === 0 && V !== 0 && (A = A - p / 2 - M), V === 0 && (A = A - p / 2 - M), Math.abs(A) < 1 / 1e3 && (A = 0), o.roundLengths && (A = Math.floor(A)), R % o.slidesPerGroup === 0 && b.push(A), S.push(A)) : (o.roundLengths && (A = Math.floor(A)), (R - Math.min(l.params.slidesPerGroupSkip, R)) % l.params.slidesPerGroup === 0 && b.push(A), S.push(A), A = A + k + M), l.virtualSize += k + M, D = k, R += 1
        }
    }
    if (l.virtualSize = Math.max(l.virtualSize, p) + P, m && g && (o.effect === "slide" || o.effect === "coverflow") && (c.style.width = `${l.virtualSize+M}px`), o.setWrapperSize && (c.style[l.getDirectionLabel("width")] = `${l.virtualSize+M}px`), I && l.grid.updateWrapperSize(k, b), !o.centeredSlides) {
        const V = [];
        for (let B = 0; B < b.length; B += 1) {
            let U = b[B];
            o.roundLengths && (U = Math.floor(U)), b[B] <= l.virtualSize - p && V.push(U)
        }
        b = V, Math.floor(l.virtualSize - p) - Math.floor(b[b.length - 1]) > 1 && b.push(l.virtualSize - p)
    }
    if (_ && o.loop) {
        const V = C[0] + M;
        if (o.slidesPerGroup > 1) {
            const B = Math.ceil((l.virtual.slidesBefore + l.virtual.slidesAfter) / o.slidesPerGroup),
                U = V * o.slidesPerGroup;
            for (let H = 0; H < B; H += 1) b.push(b[b.length - 1] + U)
        }
        for (let B = 0; B < l.virtual.slidesBefore + l.virtual.slidesAfter; B += 1) o.slidesPerGroup === 1 && b.push(b[b.length - 1] + V), S.push(S[S.length - 1] + V), l.virtualSize += V
    }
    if (b.length === 0 && (b = [0]), M !== 0) {
        const V = l.isHorizontal() && m ? "marginLeft" : l.getDirectionLabel("marginRight");
        x.filter((B, U) => !o.cssMode || o.loop ? !0 : U !== x.length - 1).forEach(B => {
            B.style[V] = `${M}px`
        })
    }
    if (o.centeredSlides && o.centeredSlidesBounds) {
        let V = 0;
        C.forEach(U => {
            V += U + (M || 0)
        }), V -= M;
        const B = V > p ? V - p : 0;
        b = b.map(U => U <= 0 ? -E : U > B ? B + P : U)
    }
    if (o.centerInsufficientSlides) {
        let V = 0;
        C.forEach(U => {
            V += U + (M || 0)
        }), V -= M;
        const B = (o.slidesOffsetBefore || 0) + (o.slidesOffsetAfter || 0);
        if (V + B < p) {
            const U = (p - V - B) / 2;
            b.forEach((H, Q) => {
                b[Q] = H - U
            }), S.forEach((H, Q) => {
                S[Q] = H + U
            })
        }
    }
    if (Object.assign(l, {
            slides: x,
            snapGrid: b,
            slidesGrid: S,
            slidesSizesGrid: C
        }), o.centeredSlides && o.cssMode && !o.centeredSlidesBounds) {
        setCSSProperty(c, "--swiper-centered-offset-before", `${-b[0]}px`), setCSSProperty(c, "--swiper-centered-offset-after", `${l.size/2-C[C.length-1]/2}px`);
        const V = -l.snapGrid[0],
            B = -l.slidesGrid[0];
        l.snapGrid = l.snapGrid.map(U => U + V), l.slidesGrid = l.slidesGrid.map(U => U + B)
    }
    if (y !== v && l.emit("slidesLengthChange"), b.length !== w && (l.params.watchOverflow && l.checkOverflow(), l.emit("snapGridLengthChange")), S.length !== T && l.emit("slidesGridLengthChange"), o.watchSlidesProgress && l.updateSlidesOffset(), l.emit("slidesUpdated"), !_ && !o.cssMode && (o.effect === "slide" || o.effect === "fade")) {
        const V = `${o.containerModifierClass}backface-hidden`,
            B = l.el.classList.contains(V);
        y <= o.maxBackfaceHiddenSlides ? B || l.el.classList.add(V) : B && l.el.classList.remove(V)
    }
}

function updateAutoHeight(l) {
    const i = this,
        o = [],
        c = i.virtual && i.params.virtual.enabled;
    let u = 0,
        p;
    typeof l == "number" ? i.setTransition(l) : l === !0 && i.setTransition(i.params.speed);
    const m = g => c ? i.slides[i.getSlideIndexByData(g)] : i.slides[g];
    if (i.params.slidesPerView !== "auto" && i.params.slidesPerView > 1)
        if (i.params.centeredSlides)(i.visibleSlides || []).forEach(g => {
            o.push(g)
        });
        else
            for (p = 0; p < Math.ceil(i.params.slidesPerView); p += 1) {
                const g = i.activeIndex + p;
                if (g > i.slides.length && !c) break;
                o.push(m(g))
            } else o.push(m(i.activeIndex));
    for (p = 0; p < o.length; p += 1)
        if (typeof o[p] < "u") {
            const g = o[p].offsetHeight;
            u = g > u ? g : u
        }(u || u === 0) && (i.wrapperEl.style.height = `${u}px`)
}

function updateSlidesOffset() {
    const l = this,
        i = l.slides,
        o = l.isElement ? l.isHorizontal() ? l.wrapperEl.offsetLeft : l.wrapperEl.offsetTop : 0;
    for (let c = 0; c < i.length; c += 1) i[c].swiperSlideOffset = (l.isHorizontal() ? i[c].offsetLeft : i[c].offsetTop) - o - l.cssOverflowAdjustment()
}
const toggleSlideClasses$1 = (l, i, o) => {
    i && !l.classList.contains(o) ? l.classList.add(o) : !i && l.classList.contains(o) && l.classList.remove(o)
};

function updateSlidesProgress(l) {
    l === void 0 && (l = this && this.translate || 0);
    const i = this,
        o = i.params,
        {
            slides: c,
            rtlTranslate: u,
            snapGrid: p
        } = i;
    if (c.length === 0) return;
    typeof c[0].swiperSlideOffset > "u" && i.updateSlidesOffset();
    let m = -l;
    u && (m = l), i.visibleSlidesIndexes = [], i.visibleSlides = [];
    let g = o.spaceBetween;
    typeof g == "string" && g.indexOf("%") >= 0 ? g = parseFloat(g.replace("%", "")) / 100 * i.size : typeof g == "string" && (g = parseFloat(g));
    for (let _ = 0; _ < c.length; _ += 1) {
        const v = c[_];
        let x = v.swiperSlideOffset;
        o.cssMode && o.centeredSlides && (x -= c[0].swiperSlideOffset);
        const y = (m + (o.centeredSlides ? i.minTranslate() : 0) - x) / (v.swiperSlideSize + g),
            b = (m - p[0] + (o.centeredSlides ? i.minTranslate() : 0) - x) / (v.swiperSlideSize + g),
            S = -(m - x),
            C = S + i.slidesSizesGrid[_],
            E = S >= 0 && S <= i.size - i.slidesSizesGrid[_],
            P = S >= 0 && S < i.size - 1 || C > 1 && C <= i.size || S <= 0 && C >= i.size;
        P && (i.visibleSlides.push(v), i.visibleSlidesIndexes.push(_)), toggleSlideClasses$1(v, P, o.slideVisibleClass), toggleSlideClasses$1(v, E, o.slideFullyVisibleClass), v.progress = u ? -y : y, v.originalProgress = u ? -b : b
    }
}

function updateProgress(l) {
    const i = this;
    if (typeof l > "u") {
        const x = i.rtlTranslate ? -1 : 1;
        l = i && i.translate && i.translate * x || 0
    }
    const o = i.params,
        c = i.maxTranslate() - i.minTranslate();
    let {
        progress: u,
        isBeginning: p,
        isEnd: m,
        progressLoop: g
    } = i;
    const _ = p,
        v = m;
    if (c === 0) u = 0, p = !0, m = !0;
    else {
        u = (l - i.minTranslate()) / c;
        const x = Math.abs(l - i.minTranslate()) < 1,
            y = Math.abs(l - i.maxTranslate()) < 1;
        p = x || u <= 0, m = y || u >= 1, x && (u = 0), y && (u = 1)
    }
    if (o.loop) {
        const x = i.getSlideIndexByData(0),
            y = i.getSlideIndexByData(i.slides.length - 1),
            b = i.slidesGrid[x],
            S = i.slidesGrid[y],
            C = i.slidesGrid[i.slidesGrid.length - 1],
            E = Math.abs(l);
        E >= b ? g = (E - b) / C : g = (E + C - S) / C, g > 1 && (g -= 1)
    }
    Object.assign(i, {
        progress: u,
        progressLoop: g,
        isBeginning: p,
        isEnd: m
    }), (o.watchSlidesProgress || o.centeredSlides && o.autoHeight) && i.updateSlidesProgress(l), p && !_ && i.emit("reachBeginning toEdge"), m && !v && i.emit("reachEnd toEdge"), (_ && !p || v && !m) && i.emit("fromEdge"), i.emit("progress", u)
}
const toggleSlideClasses = (l, i, o) => {
    i && !l.classList.contains(o) ? l.classList.add(o) : !i && l.classList.contains(o) && l.classList.remove(o)
};

function updateSlidesClasses() {
    const l = this,
        {
            slides: i,
            params: o,
            slidesEl: c,
            activeIndex: u
        } = l,
        p = l.virtual && o.virtual.enabled,
        m = l.grid && o.grid && o.grid.rows > 1,
        g = y => elementChildren(c, `.${o.slideClass}${y}, swiper-slide${y}`)[0];
    let _, v, x;
    if (p)
        if (o.loop) {
            let y = u - l.virtual.slidesBefore;
            y < 0 && (y = l.virtual.slides.length + y), y >= l.virtual.slides.length && (y -= l.virtual.slides.length), _ = g(`[data-swiper-slide-index="${y}"]`)
        } else _ = g(`[data-swiper-slide-index="${u}"]`);
    else m ? (_ = i.find(y => y.column === u), x = i.find(y => y.column === u + 1), v = i.find(y => y.column === u - 1)) : _ = i[u];
    _ && (m || (x = elementNextAll(_, `.${o.slideClass}, swiper-slide`)[0], o.loop && !x && (x = i[0]), v = elementPrevAll(_, `.${o.slideClass}, swiper-slide`)[0], o.loop && !v === 0 && (v = i[i.length - 1]))), i.forEach(y => {
        toggleSlideClasses(y, y === _, o.slideActiveClass), toggleSlideClasses(y, y === x, o.slideNextClass), toggleSlideClasses(y, y === v, o.slidePrevClass)
    }), l.emitSlidesClasses()
}
const processLazyPreloader = (l, i) => {
        if (!l || l.destroyed || !l.params) return;
        const o = () => l.isElement ? "swiper-slide" : `.${l.params.slideClass}`,
            c = i.closest(o());
        if (c) {
            let u = c.querySelector(`.${l.params.lazyPreloaderClass}`);
            !u && l.isElement && (c.shadowRoot ? u = c.shadowRoot.querySelector(`.${l.params.lazyPreloaderClass}`) : requestAnimationFrame(() => {
                c.shadowRoot && (u = c.shadowRoot.querySelector(`.${l.params.lazyPreloaderClass}`), u && u.remove())
            })), u && u.remove()
        }
    },
    unlazy = (l, i) => {
        if (!l.slides[i]) return;
        const o = l.slides[i].querySelector('[loading="lazy"]');
        o && o.removeAttribute("loading")
    },
    preload = l => {
        if (!l || l.destroyed || !l.params) return;
        let i = l.params.lazyPreloadPrevNext;
        const o = l.slides.length;
        if (!o || !i || i < 0) return;
        i = Math.min(i, o);
        const c = l.params.slidesPerView === "auto" ? l.slidesPerViewDynamic() : Math.ceil(l.params.slidesPerView),
            u = l.activeIndex;
        if (l.params.grid && l.params.grid.rows > 1) {
            const m = u,
                g = [m - i];
            g.push(...Array.from({
                length: i
            }).map((_, v) => m + c + v)), l.slides.forEach((_, v) => {
                g.includes(_.column) && unlazy(l, v)
            });
            return
        }
        const p = u + c - 1;
        if (l.params.rewind || l.params.loop)
            for (let m = u - i; m <= p + i; m += 1) {
                const g = (m % o + o) % o;
                (g < u || g > p) && unlazy(l, g)
            } else
                for (let m = Math.max(u - i, 0); m <= Math.min(p + i, o - 1); m += 1) m !== u && (m > p || m < u) && unlazy(l, m)
    };

function getActiveIndexByTranslate(l) {
    const {
        slidesGrid: i,
        params: o
    } = l, c = l.rtlTranslate ? l.translate : -l.translate;
    let u;
    for (let p = 0; p < i.length; p += 1) typeof i[p + 1] < "u" ? c >= i[p] && c < i[p + 1] - (i[p + 1] - i[p]) / 2 ? u = p : c >= i[p] && c < i[p + 1] && (u = p + 1) : c >= i[p] && (u = p);
    return o.normalizeSlideIndex && (u < 0 || typeof u > "u") && (u = 0), u
}

function updateActiveIndex(l) {
    const i = this,
        o = i.rtlTranslate ? i.translate : -i.translate,
        {
            snapGrid: c,
            params: u,
            activeIndex: p,
            realIndex: m,
            snapIndex: g
        } = i;
    let _ = l,
        v;
    const x = S => {
        let C = S - i.virtual.slidesBefore;
        return C < 0 && (C = i.virtual.slides.length + C), C >= i.virtual.slides.length && (C -= i.virtual.slides.length), C
    };
    if (typeof _ > "u" && (_ = getActiveIndexByTranslate(i)), c.indexOf(o) >= 0) v = c.indexOf(o);
    else {
        const S = Math.min(u.slidesPerGroupSkip, _);
        v = S + Math.floor((_ - S) / u.slidesPerGroup)
    }
    if (v >= c.length && (v = c.length - 1), _ === p && !i.params.loop) {
        v !== g && (i.snapIndex = v, i.emit("snapIndexChange"));
        return
    }
    if (_ === p && i.params.loop && i.virtual && i.params.virtual.enabled) {
        i.realIndex = x(_);
        return
    }
    const y = i.grid && u.grid && u.grid.rows > 1;
    let b;
    if (i.virtual && u.virtual.enabled && u.loop) b = x(_);
    else if (y) {
        const S = i.slides.find(E => E.column === _);
        let C = parseInt(S.getAttribute("data-swiper-slide-index"), 10);
        Number.isNaN(C) && (C = Math.max(i.slides.indexOf(S), 0)), b = Math.floor(C / u.grid.rows)
    } else if (i.slides[_]) {
        const S = i.slides[_].getAttribute("data-swiper-slide-index");
        S ? b = parseInt(S, 10) : b = _
    } else b = _;
    Object.assign(i, {
        previousSnapIndex: g,
        snapIndex: v,
        previousRealIndex: m,
        realIndex: b,
        previousIndex: p,
        activeIndex: _
    }), i.initialized && preload(i), i.emit("activeIndexChange"), i.emit("snapIndexChange"), (i.initialized || i.params.runCallbacksOnInit) && (m !== b && i.emit("realIndexChange"), i.emit("slideChange"))
}

function updateClickedSlide(l, i) {
    const o = this,
        c = o.params;
    let u = l.closest(`.${c.slideClass}, swiper-slide`);
    !u && o.isElement && i && i.length > 1 && i.includes(l) && [...i.slice(i.indexOf(l) + 1, i.length)].forEach(g => {
        !u && g.matches && g.matches(`.${c.slideClass}, swiper-slide`) && (u = g)
    });
    let p = !1,
        m;
    if (u) {
        for (let g = 0; g < o.slides.length; g += 1)
            if (o.slides[g] === u) {
                p = !0, m = g;
                break
            }
    }
    if (u && p) o.clickedSlide = u, o.virtual && o.params.virtual.enabled ? o.clickedIndex = parseInt(u.getAttribute("data-swiper-slide-index"), 10) : o.clickedIndex = m;
    else {
        o.clickedSlide = void 0, o.clickedIndex = void 0;
        return
    }
    c.slideToClickedSlide && o.clickedIndex !== void 0 && o.clickedIndex !== o.activeIndex && o.slideToClickedSlide()
}
var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
};

function getSwiperTranslate(l) {
    l === void 0 && (l = this.isHorizontal() ? "x" : "y");
    const i = this,
        {
            params: o,
            rtlTranslate: c,
            translate: u,
            wrapperEl: p
        } = i;
    if (o.virtualTranslate) return c ? -u : u;
    if (o.cssMode) return u;
    let m = getTranslate(p, l);
    return m += i.cssOverflowAdjustment(), c && (m = -m), m || 0
}

function setTranslate(l, i) {
    const o = this,
        {
            rtlTranslate: c,
            params: u,
            wrapperEl: p,
            progress: m
        } = o;
    let g = 0,
        _ = 0;
    const v = 0;
    o.isHorizontal() ? g = c ? -l : l : _ = l, u.roundLengths && (g = Math.floor(g), _ = Math.floor(_)), o.previousTranslate = o.translate, o.translate = o.isHorizontal() ? g : _, u.cssMode ? p[o.isHorizontal() ? "scrollLeft" : "scrollTop"] = o.isHorizontal() ? -g : -_ : u.virtualTranslate || (o.isHorizontal() ? g -= o.cssOverflowAdjustment() : _ -= o.cssOverflowAdjustment(), p.style.transform = `translate3d(${g}px, ${_}px, ${v}px)`);
    let x;
    const y = o.maxTranslate() - o.minTranslate();
    y === 0 ? x = 0 : x = (l - o.minTranslate()) / y, x !== m && o.updateProgress(l), o.emit("setTranslate", o.translate, i)
}

function minTranslate() {
    return -this.snapGrid[0]
}

function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1]
}

function translateTo(l, i, o, c, u) {
    l === void 0 && (l = 0), i === void 0 && (i = this.params.speed), o === void 0 && (o = !0), c === void 0 && (c = !0);
    const p = this,
        {
            params: m,
            wrapperEl: g
        } = p;
    if (p.animating && m.preventInteractionOnTransition) return !1;
    const _ = p.minTranslate(),
        v = p.maxTranslate();
    let x;
    if (c && l > _ ? x = _ : c && l < v ? x = v : x = l, p.updateProgress(x), m.cssMode) {
        const y = p.isHorizontal();
        if (i === 0) g[y ? "scrollLeft" : "scrollTop"] = -x;
        else {
            if (!p.support.smoothScroll) return animateCSSModeScroll({
                swiper: p,
                targetPosition: -x,
                side: y ? "left" : "top"
            }), !0;
            g.scrollTo({
                [y ? "left" : "top"]: -x,
                behavior: "smooth"
            })
        }
        return !0
    }
    return i === 0 ? (p.setTransition(0), p.setTranslate(x), o && (p.emit("beforeTransitionStart", i, u), p.emit("transitionEnd"))) : (p.setTransition(i), p.setTranslate(x), o && (p.emit("beforeTransitionStart", i, u), p.emit("transitionStart")), p.animating || (p.animating = !0, p.onTranslateToWrapperTransitionEnd || (p.onTranslateToWrapperTransitionEnd = function(b) {
        !p || p.destroyed || b.target === this && (p.wrapperEl.removeEventListener("transitionend", p.onTranslateToWrapperTransitionEnd), p.onTranslateToWrapperTransitionEnd = null, delete p.onTranslateToWrapperTransitionEnd, p.animating = !1, o && p.emit("transitionEnd"))
    }), p.wrapperEl.addEventListener("transitionend", p.onTranslateToWrapperTransitionEnd))), !0
}
var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
};

function setTransition(l, i) {
    const o = this;
    o.params.cssMode || (o.wrapperEl.style.transitionDuration = `${l}ms`, o.wrapperEl.style.transitionDelay = l === 0 ? "0ms" : ""), o.emit("setTransition", l, i)
}

function transitionEmit(l) {
    let {
        swiper: i,
        runCallbacks: o,
        direction: c,
        step: u
    } = l;
    const {
        activeIndex: p,
        previousIndex: m
    } = i;
    let g = c;
    g || (p > m ? g = "next" : p < m ? g = "prev" : g = "reset"), i.emit(`transition${u}`), o && g === "reset" ? i.emit(`slideResetTransition${u}`) : o && p !== m && (i.emit(`slideChangeTransition${u}`), g === "next" ? i.emit(`slideNextTransition${u}`) : i.emit(`slidePrevTransition${u}`))
}

function transitionStart(l, i) {
    l === void 0 && (l = !0);
    const o = this,
        {
            params: c
        } = o;
    c.cssMode || (c.autoHeight && o.updateAutoHeight(), transitionEmit({
        swiper: o,
        runCallbacks: l,
        direction: i,
        step: "Start"
    }))
}

function transitionEnd(l, i) {
    l === void 0 && (l = !0);
    const o = this,
        {
            params: c
        } = o;
    o.animating = !1, !c.cssMode && (o.setTransition(0), transitionEmit({
        swiper: o,
        runCallbacks: l,
        direction: i,
        step: "End"
    }))
}
var transition$1 = {
    setTransition,
    transitionStart,
    transitionEnd
};

function slideTo(l, i, o, c, u) {
    l === void 0 && (l = 0), o === void 0 && (o = !0), typeof l == "string" && (l = parseInt(l, 10));
    const p = this;
    let m = l;
    m < 0 && (m = 0);
    const {
        params: g,
        snapGrid: _,
        slidesGrid: v,
        previousIndex: x,
        activeIndex: y,
        rtlTranslate: b,
        wrapperEl: S,
        enabled: C
    } = p;
    if (!C && !c && !u || p.destroyed || p.animating && g.preventInteractionOnTransition) return !1;
    typeof i > "u" && (i = p.params.speed);
    const E = Math.min(p.params.slidesPerGroupSkip, m);
    let P = E + Math.floor((m - E) / p.params.slidesPerGroup);
    P >= _.length && (P = _.length - 1);
    const w = -_[P];
    if (g.normalizeSlideIndex)
        for (let I = 0; I < v.length; I += 1) {
            const k = -Math.floor(w * 100),
                F = Math.floor(v[I] * 100),
                V = Math.floor(v[I + 1] * 100);
            typeof v[I + 1] < "u" ? k >= F && k < V - (V - F) / 2 ? m = I : k >= F && k < V && (m = I + 1) : k >= F && (m = I)
        }
    if (p.initialized && m !== y && (!p.allowSlideNext && (b ? w > p.translate && w > p.minTranslate() : w < p.translate && w < p.minTranslate()) || !p.allowSlidePrev && w > p.translate && w > p.maxTranslate() && (y || 0) !== m)) return !1;
    m !== (x || 0) && o && p.emit("beforeSlideChangeStart"), p.updateProgress(w);
    let T;
    m > y ? T = "next" : m < y ? T = "prev" : T = "reset";
    const M = p.virtual && p.params.virtual.enabled;
    if (!(M && u) && (b && -w === p.translate || !b && w === p.translate)) return p.updateActiveIndex(m), g.autoHeight && p.updateAutoHeight(), p.updateSlidesClasses(), g.effect !== "slide" && p.setTranslate(w), T !== "reset" && (p.transitionStart(o, T), p.transitionEnd(o, T)), !1;
    if (g.cssMode) {
        const I = p.isHorizontal(),
            k = b ? w : -w;
        if (i === 0) M && (p.wrapperEl.style.scrollSnapType = "none", p._immediateVirtual = !0), M && !p._cssModeVirtualInitialSet && p.params.initialSlide > 0 ? (p._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
            S[I ? "scrollLeft" : "scrollTop"] = k
        })) : S[I ? "scrollLeft" : "scrollTop"] = k, M && requestAnimationFrame(() => {
            p.wrapperEl.style.scrollSnapType = "", p._immediateVirtual = !1
        });
        else {
            if (!p.support.smoothScroll) return animateCSSModeScroll({
                swiper: p,
                targetPosition: k,
                side: I ? "left" : "top"
            }), !0;
            S.scrollTo({
                [I ? "left" : "top"]: k,
                behavior: "smooth"
            })
        }
        return !0
    }
    const R = getBrowser().isSafari;
    return M && !u && R && p.isElement && p.virtual.update(!1, !1, m), p.setTransition(i), p.setTranslate(w), p.updateActiveIndex(m), p.updateSlidesClasses(), p.emit("beforeTransitionStart", i, c), p.transitionStart(o, T), i === 0 ? p.transitionEnd(o, T) : p.animating || (p.animating = !0, p.onSlideToWrapperTransitionEnd || (p.onSlideToWrapperTransitionEnd = function(k) {
        !p || p.destroyed || k.target === this && (p.wrapperEl.removeEventListener("transitionend", p.onSlideToWrapperTransitionEnd), p.onSlideToWrapperTransitionEnd = null, delete p.onSlideToWrapperTransitionEnd, p.transitionEnd(o, T))
    }), p.wrapperEl.addEventListener("transitionend", p.onSlideToWrapperTransitionEnd)), !0
}

function slideToLoop(l, i, o, c) {
    l === void 0 && (l = 0), o === void 0 && (o = !0), typeof l == "string" && (l = parseInt(l, 10));
    const u = this;
    if (u.destroyed) return;
    typeof i > "u" && (i = u.params.speed);
    const p = u.grid && u.params.grid && u.params.grid.rows > 1;
    let m = l;
    if (u.params.loop)
        if (u.virtual && u.params.virtual.enabled) m = m + u.virtual.slidesBefore;
        else {
            let g;
            if (p) {
                const b = m * u.params.grid.rows;
                g = u.slides.find(S => S.getAttribute("data-swiper-slide-index") * 1 === b).column
            } else g = u.getSlideIndexByData(m);
            const _ = p ? Math.ceil(u.slides.length / u.params.grid.rows) : u.slides.length,
                {
                    centeredSlides: v
                } = u.params;
            let x = u.params.slidesPerView;
            x === "auto" ? x = u.slidesPerViewDynamic() : (x = Math.ceil(parseFloat(u.params.slidesPerView, 10)), v && x % 2 === 0 && (x = x + 1));
            let y = _ - g < x;
            if (v && (y = y || g < Math.ceil(x / 2)), c && v && u.params.slidesPerView !== "auto" && !p && (y = !1), y) {
                const b = v ? g < u.activeIndex ? "prev" : "next" : g - u.activeIndex - 1 < u.params.slidesPerView ? "next" : "prev";
                u.loopFix({
                    direction: b,
                    slideTo: !0,
                    activeSlideIndex: b === "next" ? g + 1 : g - _ + 1,
                    slideRealIndex: b === "next" ? u.realIndex : void 0
                })
            }
            if (p) {
                const b = m * u.params.grid.rows;
                m = u.slides.find(S => S.getAttribute("data-swiper-slide-index") * 1 === b).column
            } else m = u.getSlideIndexByData(m)
        }
    return requestAnimationFrame(() => {
        u.slideTo(m, i, o, c)
    }), u
}

function slideNext(l, i, o) {
    i === void 0 && (i = !0);
    const c = this,
        {
            enabled: u,
            params: p,
            animating: m
        } = c;
    if (!u || c.destroyed) return c;
    typeof l > "u" && (l = c.params.speed);
    let g = p.slidesPerGroup;
    p.slidesPerView === "auto" && p.slidesPerGroup === 1 && p.slidesPerGroupAuto && (g = Math.max(c.slidesPerViewDynamic("current", !0), 1));
    const _ = c.activeIndex < p.slidesPerGroupSkip ? 1 : g,
        v = c.virtual && p.virtual.enabled;
    if (p.loop) {
        if (m && !v && p.loopPreventsSliding) return !1;
        if (c.loopFix({
                direction: "next"
            }), c._clientLeft = c.wrapperEl.clientLeft, c.activeIndex === c.slides.length - 1 && p.cssMode) return requestAnimationFrame(() => {
            c.slideTo(c.activeIndex + _, l, i, o)
        }), !0
    }
    return p.rewind && c.isEnd ? c.slideTo(0, l, i, o) : c.slideTo(c.activeIndex + _, l, i, o)
}

function slidePrev(l, i, o) {
    i === void 0 && (i = !0);
    const c = this,
        {
            params: u,
            snapGrid: p,
            slidesGrid: m,
            rtlTranslate: g,
            enabled: _,
            animating: v
        } = c;
    if (!_ || c.destroyed) return c;
    typeof l > "u" && (l = c.params.speed);
    const x = c.virtual && u.virtual.enabled;
    if (u.loop) {
        if (v && !x && u.loopPreventsSliding) return !1;
        c.loopFix({
            direction: "prev"
        }), c._clientLeft = c.wrapperEl.clientLeft
    }
    const y = g ? c.translate : -c.translate;

    function b(T) {
        return T < 0 ? -Math.floor(Math.abs(T)) : Math.floor(T)
    }
    const S = b(y),
        C = p.map(T => b(T)),
        E = u.freeMode && u.freeMode.enabled;
    let P = p[C.indexOf(S) - 1];
    if (typeof P > "u" && (u.cssMode || E)) {
        let T;
        p.forEach((M, A) => {
            S >= M && (T = A)
        }), typeof T < "u" && (P = E ? p[T] : p[T > 0 ? T - 1 : T])
    }
    let w = 0;
    if (typeof P < "u" && (w = m.indexOf(P), w < 0 && (w = c.activeIndex - 1), u.slidesPerView === "auto" && u.slidesPerGroup === 1 && u.slidesPerGroupAuto && (w = w - c.slidesPerViewDynamic("previous", !0) + 1, w = Math.max(w, 0))), u.rewind && c.isBeginning) {
        const T = c.params.virtual && c.params.virtual.enabled && c.virtual ? c.virtual.slides.length - 1 : c.slides.length - 1;
        return c.slideTo(T, l, i, o)
    } else if (u.loop && c.activeIndex === 0 && u.cssMode) return requestAnimationFrame(() => {
        c.slideTo(w, l, i, o)
    }), !0;
    return c.slideTo(w, l, i, o)
}

function slideReset(l, i, o) {
    i === void 0 && (i = !0);
    const c = this;
    if (!c.destroyed) return typeof l > "u" && (l = c.params.speed), c.slideTo(c.activeIndex, l, i, o)
}

function slideToClosest(l, i, o, c) {
    i === void 0 && (i = !0), c === void 0 && (c = .5);
    const u = this;
    if (u.destroyed) return;
    typeof l > "u" && (l = u.params.speed);
    let p = u.activeIndex;
    const m = Math.min(u.params.slidesPerGroupSkip, p),
        g = m + Math.floor((p - m) / u.params.slidesPerGroup),
        _ = u.rtlTranslate ? u.translate : -u.translate;
    if (_ >= u.snapGrid[g]) {
        const v = u.snapGrid[g],
            x = u.snapGrid[g + 1];
        _ - v > (x - v) * c && (p += u.params.slidesPerGroup)
    } else {
        const v = u.snapGrid[g - 1],
            x = u.snapGrid[g];
        _ - v <= (x - v) * c && (p -= u.params.slidesPerGroup)
    }
    return p = Math.max(p, 0), p = Math.min(p, u.slidesGrid.length - 1), u.slideTo(p, l, i, o)
}

function slideToClickedSlide() {
    const l = this;
    if (l.destroyed) return;
    const {
        params: i,
        slidesEl: o
    } = l, c = i.slidesPerView === "auto" ? l.slidesPerViewDynamic() : i.slidesPerView;
    let u = l.clickedIndex,
        p;
    const m = l.isElement ? "swiper-slide" : `.${i.slideClass}`;
    if (i.loop) {
        if (l.animating) return;
        p = parseInt(l.clickedSlide.getAttribute("data-swiper-slide-index"), 10), i.centeredSlides ? u < l.loopedSlides - c / 2 || u > l.slides.length - l.loopedSlides + c / 2 ? (l.loopFix(), u = l.getSlideIndex(elementChildren(o, `${m}[data-swiper-slide-index="${p}"]`)[0]), nextTick(() => {
            l.slideTo(u)
        })) : l.slideTo(u) : u > l.slides.length - c ? (l.loopFix(), u = l.getSlideIndex(elementChildren(o, `${m}[data-swiper-slide-index="${p}"]`)[0]), nextTick(() => {
            l.slideTo(u)
        })) : l.slideTo(u)
    } else l.slideTo(u)
}
var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
};

function loopCreate(l, i) {
    const o = this,
        {
            params: c,
            slidesEl: u
        } = o;
    if (!c.loop || o.virtual && o.params.virtual.enabled) return;
    const p = () => {
            elementChildren(u, `.${c.slideClass}, swiper-slide`).forEach((b, S) => {
                b.setAttribute("data-swiper-slide-index", S)
            })
        },
        m = o.grid && c.grid && c.grid.rows > 1,
        g = c.slidesPerGroup * (m ? c.grid.rows : 1),
        _ = o.slides.length % g !== 0,
        v = m && o.slides.length % c.grid.rows !== 0,
        x = y => {
            for (let b = 0; b < y; b += 1) {
                const S = o.isElement ? createElement("swiper-slide", [c.slideBlankClass]) : createElement("div", [c.slideClass, c.slideBlankClass]);
                o.slidesEl.append(S)
            }
        };
    if (_) {
        if (c.loopAddBlankSlides) {
            const y = g - o.slides.length % g;
            x(y), o.recalcSlides(), o.updateSlides()
        } else showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        p()
    } else if (v) {
        if (c.loopAddBlankSlides) {
            const y = c.grid.rows - o.slides.length % c.grid.rows;
            x(y), o.recalcSlides(), o.updateSlides()
        } else showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        p()
    } else p();
    o.loopFix({
        slideRealIndex: l,
        direction: c.centeredSlides ? void 0 : "next",
        initial: i
    })
}

function loopFix(l) {
    let {
        slideRealIndex: i,
        slideTo: o = !0,
        direction: c,
        setTranslate: u,
        activeSlideIndex: p,
        initial: m,
        byController: g,
        byMousewheel: _
    } = l === void 0 ? {} : l;
    const v = this;
    if (!v.params.loop) return;
    v.emit("beforeLoopFix");
    const {
        slides: x,
        allowSlidePrev: y,
        allowSlideNext: b,
        slidesEl: S,
        params: C
    } = v, {
        centeredSlides: E,
        initialSlide: P
    } = C;
    if (v.allowSlidePrev = !0, v.allowSlideNext = !0, v.virtual && C.virtual.enabled) {
        o && (!C.centeredSlides && v.snapIndex === 0 ? v.slideTo(v.virtual.slides.length, 0, !1, !0) : C.centeredSlides && v.snapIndex < C.slidesPerView ? v.slideTo(v.virtual.slides.length + v.snapIndex, 0, !1, !0) : v.snapIndex === v.snapGrid.length - 1 && v.slideTo(v.virtual.slidesBefore, 0, !1, !0)), v.allowSlidePrev = y, v.allowSlideNext = b, v.emit("loopFix");
        return
    }
    let w = C.slidesPerView;
    w === "auto" ? w = v.slidesPerViewDynamic() : (w = Math.ceil(parseFloat(C.slidesPerView, 10)), E && w % 2 === 0 && (w = w + 1));
    const T = C.slidesPerGroupAuto ? w : C.slidesPerGroup;
    let M = T;
    M % T !== 0 && (M += T - M % T), M += C.loopAdditionalSlides, v.loopedSlides = M;
    const A = v.grid && C.grid && C.grid.rows > 1;
    x.length < w + M || v.params.effect === "cards" && x.length < w + M * 2 ? showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : A && C.grid.fill === "row" && showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    const D = [],
        R = [],
        I = A ? Math.ceil(x.length / C.grid.rows) : x.length,
        k = m && I - P < w && !E;
    let F = k ? P : v.activeIndex;
    typeof p > "u" ? p = v.getSlideIndex(x.find(O => O.classList.contains(C.slideActiveClass))) : F = p;
    const V = c === "next" || !c,
        B = c === "prev" || !c;
    let U = 0,
        H = 0;
    const Y = (A ? x[p].column : p) + (E && typeof u > "u" ? -w / 2 + .5 : 0);
    if (Y < M) {
        U = Math.max(M - Y, T);
        for (let O = 0; O < M - Y; O += 1) {
            const G = O - Math.floor(O / I) * I;
            if (A) {
                const L = I - G - 1;
                for (let N = x.length - 1; N >= 0; N -= 1) x[N].column === L && D.push(N)
            } else D.push(I - G - 1)
        }
    } else if (Y + w > I - M) {
        H = Math.max(Y - (I - M * 2), T), k && (H = Math.max(H, w - I + P + 1));
        for (let O = 0; O < H; O += 1) {
            const G = O - Math.floor(O / I) * I;
            A ? x.forEach((L, N) => {
                L.column === G && R.push(N)
            }) : R.push(G)
        }
    }
    if (v.__preventObserver__ = !0, requestAnimationFrame(() => {
            v.__preventObserver__ = !1
        }), v.params.effect === "cards" && x.length < w + M * 2 && (R.includes(p) && R.splice(R.indexOf(p), 1), D.includes(p) && D.splice(D.indexOf(p), 1)), B && D.forEach(O => {
            x[O].swiperLoopMoveDOM = !0, S.prepend(x[O]), x[O].swiperLoopMoveDOM = !1
        }), V && R.forEach(O => {
            x[O].swiperLoopMoveDOM = !0, S.append(x[O]), x[O].swiperLoopMoveDOM = !1
        }), v.recalcSlides(), C.slidesPerView === "auto" ? v.updateSlides() : A && (D.length > 0 && B || R.length > 0 && V) && v.slides.forEach((O, G) => {
            v.grid.updateSlide(G, O, v.slides)
        }), C.watchSlidesProgress && v.updateSlidesOffset(), o) {
        if (D.length > 0 && B) {
            if (typeof i > "u") {
                const O = v.slidesGrid[F],
                    L = v.slidesGrid[F + U] - O;
                _ ? v.setTranslate(v.translate - L) : (v.slideTo(F + Math.ceil(U), 0, !1, !0), u && (v.touchEventsData.startTranslate = v.touchEventsData.startTranslate - L, v.touchEventsData.currentTranslate = v.touchEventsData.currentTranslate - L))
            } else if (u) {
                const O = A ? D.length / C.grid.rows : D.length;
                v.slideTo(v.activeIndex + O, 0, !1, !0), v.touchEventsData.currentTranslate = v.translate
            }
        } else if (R.length > 0 && V)
            if (typeof i > "u") {
                const O = v.slidesGrid[F],
                    L = v.slidesGrid[F - H] - O;
                _ ? v.setTranslate(v.translate - L) : (v.slideTo(F - H, 0, !1, !0), u && (v.touchEventsData.startTranslate = v.touchEventsData.startTranslate - L, v.touchEventsData.currentTranslate = v.touchEventsData.currentTranslate - L))
            } else {
                const O = A ? R.length / C.grid.rows : R.length;
                v.slideTo(v.activeIndex - O, 0, !1, !0)
            }
    }
    if (v.allowSlidePrev = y, v.allowSlideNext = b, v.controller && v.controller.control && !g) {
        const O = {
            slideRealIndex: i,
            direction: c,
            setTranslate: u,
            activeSlideIndex: p,
            byController: !0
        };
        Array.isArray(v.controller.control) ? v.controller.control.forEach(G => {
            !G.destroyed && G.params.loop && G.loopFix({ ...O,
                slideTo: G.params.slidesPerView === C.slidesPerView ? o : !1
            })
        }) : v.controller.control instanceof v.constructor && v.controller.control.params.loop && v.controller.control.loopFix({ ...O,
            slideTo: v.controller.control.params.slidesPerView === C.slidesPerView ? o : !1
        })
    }
    v.emit("loopFix")
}

function loopDestroy() {
    const l = this,
        {
            params: i,
            slidesEl: o
        } = l;
    if (!i.loop || !o || l.virtual && l.params.virtual.enabled) return;
    l.recalcSlides();
    const c = [];
    l.slides.forEach(u => {
        const p = typeof u.swiperSlideIndex > "u" ? u.getAttribute("data-swiper-slide-index") * 1 : u.swiperSlideIndex;
        c[p] = u
    }), l.slides.forEach(u => {
        u.removeAttribute("data-swiper-slide-index")
    }), c.forEach(u => {
        o.append(u)
    }), l.recalcSlides(), l.slideTo(l.realIndex, 0)
}
var loop = {
    loopCreate,
    loopFix,
    loopDestroy
};

function setGrabCursor(l) {
    const i = this;
    if (!i.params.simulateTouch || i.params.watchOverflow && i.isLocked || i.params.cssMode) return;
    const o = i.params.touchEventsTarget === "container" ? i.el : i.wrapperEl;
    i.isElement && (i.__preventObserver__ = !0), o.style.cursor = "move", o.style.cursor = l ? "grabbing" : "grab", i.isElement && requestAnimationFrame(() => {
        i.__preventObserver__ = !1
    })
}

function unsetGrabCursor() {
    const l = this;
    l.params.watchOverflow && l.isLocked || l.params.cssMode || (l.isElement && (l.__preventObserver__ = !0), l[l.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", l.isElement && requestAnimationFrame(() => {
        l.__preventObserver__ = !1
    }))
}
var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
};

function closestElement(l, i) {
    i === void 0 && (i = this);

    function o(c) {
        if (!c || c === getDocument() || c === getWindow()) return null;
        c.assignedSlot && (c = c.assignedSlot);
        const u = c.closest(l);
        return !u && !c.getRootNode ? null : u || o(c.getRootNode().host)
    }
    return o(i)
}

function preventEdgeSwipe(l, i, o) {
    const c = getWindow(),
        {
            params: u
        } = l,
        p = u.edgeSwipeDetection,
        m = u.edgeSwipeThreshold;
    return p && (o <= m || o >= c.innerWidth - m) ? p === "prevent" ? (i.preventDefault(), !0) : !1 : !0
}

function onTouchStart(l) {
    const i = this,
        o = getDocument();
    let c = l;
    c.originalEvent && (c = c.originalEvent);
    const u = i.touchEventsData;
    if (c.type === "pointerdown") {
        if (u.pointerId !== null && u.pointerId !== c.pointerId) return;
        u.pointerId = c.pointerId
    } else c.type === "touchstart" && c.targetTouches.length === 1 && (u.touchId = c.targetTouches[0].identifier);
    if (c.type === "touchstart") {
        preventEdgeSwipe(i, c, c.targetTouches[0].pageX);
        return
    }
    const {
        params: p,
        touches: m,
        enabled: g
    } = i;
    if (!g || !p.simulateTouch && c.pointerType === "mouse" || i.animating && p.preventInteractionOnTransition) return;
    !i.animating && p.cssMode && p.loop && i.loopFix();
    let _ = c.target;
    if (p.touchEventsTarget === "wrapper" && !elementIsChildOf(_, i.wrapperEl) || "which" in c && c.which === 3 || "button" in c && c.button > 0 || u.isTouched && u.isMoved) return;
    const v = !!p.noSwipingClass && p.noSwipingClass !== "",
        x = c.composedPath ? c.composedPath() : c.path;
    v && c.target && c.target.shadowRoot && x && (_ = x[0]);
    const y = p.noSwipingSelector ? p.noSwipingSelector : `.${p.noSwipingClass}`,
        b = !!(c.target && c.target.shadowRoot);
    if (p.noSwiping && (b ? closestElement(y, _) : _.closest(y))) {
        i.allowClick = !0;
        return
    }
    if (p.swipeHandler && !_.closest(p.swipeHandler)) return;
    m.currentX = c.pageX, m.currentY = c.pageY;
    const S = m.currentX,
        C = m.currentY;
    if (!preventEdgeSwipe(i, c, S)) return;
    Object.assign(u, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }), m.startX = S, m.startY = C, u.touchStartTime = now(), i.allowClick = !0, i.updateSize(), i.swipeDirection = void 0, p.threshold > 0 && (u.allowThresholdMove = !1);
    let E = !0;
    _.matches(u.focusableElements) && (E = !1, _.nodeName === "SELECT" && (u.isTouched = !1)), o.activeElement && o.activeElement.matches(u.focusableElements) && o.activeElement !== _ && (c.pointerType === "mouse" || c.pointerType !== "mouse" && !_.matches(u.focusableElements)) && o.activeElement.blur();
    const P = E && i.allowTouchMove && p.touchStartPreventDefault;
    (p.touchStartForcePreventDefault || P) && !_.isContentEditable && c.preventDefault(), p.freeMode && p.freeMode.enabled && i.freeMode && i.animating && !p.cssMode && i.freeMode.onTouchStart(), i.emit("touchStart", c)
}

function onTouchMove(l) {
    const i = getDocument(),
        o = this,
        c = o.touchEventsData,
        {
            params: u,
            touches: p,
            rtlTranslate: m,
            enabled: g
        } = o;
    if (!g || !u.simulateTouch && l.pointerType === "mouse") return;
    let _ = l;
    if (_.originalEvent && (_ = _.originalEvent), _.type === "pointermove" && (c.touchId !== null || _.pointerId !== c.pointerId)) return;
    let v;
    if (_.type === "touchmove") {
        if (v = [..._.changedTouches].find(D => D.identifier === c.touchId), !v || v.identifier !== c.touchId) return
    } else v = _;
    if (!c.isTouched) {
        c.startMoving && c.isScrolling && o.emit("touchMoveOpposite", _);
        return
    }
    const x = v.pageX,
        y = v.pageY;
    if (_.preventedByNestedSwiper) {
        p.startX = x, p.startY = y;
        return
    }
    if (!o.allowTouchMove) {
        _.target.matches(c.focusableElements) || (o.allowClick = !1), c.isTouched && (Object.assign(p, {
            startX: x,
            startY: y,
            currentX: x,
            currentY: y
        }), c.touchStartTime = now());
        return
    }
    if (u.touchReleaseOnEdges && !u.loop)
        if (o.isVertical()) {
            if (y < p.startY && o.translate <= o.maxTranslate() || y > p.startY && o.translate >= o.minTranslate()) {
                c.isTouched = !1, c.isMoved = !1;
                return
            }
        } else {
            if (m && (x > p.startX && -o.translate <= o.maxTranslate() || x < p.startX && -o.translate >= o.minTranslate())) return;
            if (!m && (x < p.startX && o.translate <= o.maxTranslate() || x > p.startX && o.translate >= o.minTranslate())) return
        }
    if (i.activeElement && i.activeElement.matches(c.focusableElements) && i.activeElement !== _.target && _.pointerType !== "mouse" && i.activeElement.blur(), i.activeElement && _.target === i.activeElement && _.target.matches(c.focusableElements)) {
        c.isMoved = !0, o.allowClick = !1;
        return
    }
    c.allowTouchCallbacks && o.emit("touchMove", _), p.previousX = p.currentX, p.previousY = p.currentY, p.currentX = x, p.currentY = y;
    const b = p.currentX - p.startX,
        S = p.currentY - p.startY;
    if (o.params.threshold && Math.sqrt(b ** 2 + S ** 2) < o.params.threshold) return;
    if (typeof c.isScrolling > "u") {
        let D;
        o.isHorizontal() && p.currentY === p.startY || o.isVertical() && p.currentX === p.startX ? c.isScrolling = !1 : b * b + S * S >= 25 && (D = Math.atan2(Math.abs(S), Math.abs(b)) * 180 / Math.PI, c.isScrolling = o.isHorizontal() ? D > u.touchAngle : 90 - D > u.touchAngle)
    }
    if (c.isScrolling && o.emit("touchMoveOpposite", _), typeof c.startMoving > "u" && (p.currentX !== p.startX || p.currentY !== p.startY) && (c.startMoving = !0), c.isScrolling || _.type === "touchmove" && c.preventTouchMoveFromPointerMove) {
        c.isTouched = !1;
        return
    }
    if (!c.startMoving) return;
    o.allowClick = !1, !u.cssMode && _.cancelable && _.preventDefault(), u.touchMoveStopPropagation && !u.nested && _.stopPropagation();
    let C = o.isHorizontal() ? b : S,
        E = o.isHorizontal() ? p.currentX - p.previousX : p.currentY - p.previousY;
    u.oneWayMovement && (C = Math.abs(C) * (m ? 1 : -1), E = Math.abs(E) * (m ? 1 : -1)), p.diff = C, C *= u.touchRatio, m && (C = -C, E = -E);
    const P = o.touchesDirection;
    o.swipeDirection = C > 0 ? "prev" : "next", o.touchesDirection = E > 0 ? "prev" : "next";
    const w = o.params.loop && !u.cssMode,
        T = o.touchesDirection === "next" && o.allowSlideNext || o.touchesDirection === "prev" && o.allowSlidePrev;
    if (!c.isMoved) {
        if (w && T && o.loopFix({
                direction: o.swipeDirection
            }), c.startTranslate = o.getTranslate(), o.setTransition(0), o.animating) {
            const D = new window.CustomEvent("transitionend", {
                bubbles: !0,
                cancelable: !0,
                detail: {
                    bySwiperTouchMove: !0
                }
            });
            o.wrapperEl.dispatchEvent(D)
        }
        c.allowMomentumBounce = !1, u.grabCursor && (o.allowSlideNext === !0 || o.allowSlidePrev === !0) && o.setGrabCursor(!0), o.emit("sliderFirstMove", _)
    }
    if (new Date().getTime(), u._loopSwapReset !== !1 && c.isMoved && c.allowThresholdMove && P !== o.touchesDirection && w && T && Math.abs(C) >= 1) {
        Object.assign(p, {
            startX: x,
            startY: y,
            currentX: x,
            currentY: y,
            startTranslate: c.currentTranslate
        }), c.loopSwapReset = !0, c.startTranslate = c.currentTranslate;
        return
    }
    o.emit("sliderMove", _), c.isMoved = !0, c.currentTranslate = C + c.startTranslate;
    let M = !0,
        A = u.resistanceRatio;
    if (u.touchReleaseOnEdges && (A = 0), C > 0 ? (w && T && c.allowThresholdMove && c.currentTranslate > (u.centeredSlides ? o.minTranslate() - o.slidesSizesGrid[o.activeIndex + 1] - (u.slidesPerView !== "auto" && o.slides.length - u.slidesPerView >= 2 ? o.slidesSizesGrid[o.activeIndex + 1] + o.params.spaceBetween : 0) - o.params.spaceBetween : o.minTranslate()) && o.loopFix({
            direction: "prev",
            setTranslate: !0,
            activeSlideIndex: 0
        }), c.currentTranslate > o.minTranslate() && (M = !1, u.resistance && (c.currentTranslate = o.minTranslate() - 1 + (-o.minTranslate() + c.startTranslate + C) ** A))) : C < 0 && (w && T && c.allowThresholdMove && c.currentTranslate < (u.centeredSlides ? o.maxTranslate() + o.slidesSizesGrid[o.slidesSizesGrid.length - 1] + o.params.spaceBetween + (u.slidesPerView !== "auto" && o.slides.length - u.slidesPerView >= 2 ? o.slidesSizesGrid[o.slidesSizesGrid.length - 1] + o.params.spaceBetween : 0) : o.maxTranslate()) && o.loopFix({
            direction: "next",
            setTranslate: !0,
            activeSlideIndex: o.slides.length - (u.slidesPerView === "auto" ? o.slidesPerViewDynamic() : Math.ceil(parseFloat(u.slidesPerView, 10)))
        }), c.currentTranslate < o.maxTranslate() && (M = !1, u.resistance && (c.currentTranslate = o.maxTranslate() + 1 - (o.maxTranslate() - c.startTranslate - C) ** A))), M && (_.preventedByNestedSwiper = !0), !o.allowSlideNext && o.swipeDirection === "next" && c.currentTranslate < c.startTranslate && (c.currentTranslate = c.startTranslate), !o.allowSlidePrev && o.swipeDirection === "prev" && c.currentTranslate > c.startTranslate && (c.currentTranslate = c.startTranslate), !o.allowSlidePrev && !o.allowSlideNext && (c.currentTranslate = c.startTranslate), u.threshold > 0)
        if (Math.abs(C) > u.threshold || c.allowThresholdMove) {
            if (!c.allowThresholdMove) {
                c.allowThresholdMove = !0, p.startX = p.currentX, p.startY = p.currentY, c.currentTranslate = c.startTranslate, p.diff = o.isHorizontal() ? p.currentX - p.startX : p.currentY - p.startY;
                return
            }
        } else {
            c.currentTranslate = c.startTranslate;
            return
        }!u.followFinger || u.cssMode || ((u.freeMode && u.freeMode.enabled && o.freeMode || u.watchSlidesProgress) && (o.updateActiveIndex(), o.updateSlidesClasses()), u.freeMode && u.freeMode.enabled && o.freeMode && o.freeMode.onTouchMove(), o.updateProgress(c.currentTranslate), o.setTranslate(c.currentTranslate))
}

function onTouchEnd(l) {
    const i = this,
        o = i.touchEventsData;
    let c = l;
    c.originalEvent && (c = c.originalEvent);
    let u;
    if (c.type === "touchend" || c.type === "touchcancel") {
        if (u = [...c.changedTouches].find(D => D.identifier === o.touchId), !u || u.identifier !== o.touchId) return
    } else {
        if (o.touchId !== null || c.pointerId !== o.pointerId) return;
        u = c
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(c.type) && !(["pointercancel", "contextmenu"].includes(c.type) && (i.browser.isSafari || i.browser.isWebView))) return;
    o.pointerId = null, o.touchId = null;
    const {
        params: m,
        touches: g,
        rtlTranslate: _,
        slidesGrid: v,
        enabled: x
    } = i;
    if (!x || !m.simulateTouch && c.pointerType === "mouse") return;
    if (o.allowTouchCallbacks && i.emit("touchEnd", c), o.allowTouchCallbacks = !1, !o.isTouched) {
        o.isMoved && m.grabCursor && i.setGrabCursor(!1), o.isMoved = !1, o.startMoving = !1;
        return
    }
    m.grabCursor && o.isMoved && o.isTouched && (i.allowSlideNext === !0 || i.allowSlidePrev === !0) && i.setGrabCursor(!1);
    const y = now(),
        b = y - o.touchStartTime;
    if (i.allowClick) {
        const D = c.path || c.composedPath && c.composedPath();
        i.updateClickedSlide(D && D[0] || c.target, D), i.emit("tap click", c), b < 300 && y - o.lastClickTime < 300 && i.emit("doubleTap doubleClick", c)
    }
    if (o.lastClickTime = now(), nextTick(() => {
            i.destroyed || (i.allowClick = !0)
        }), !o.isTouched || !o.isMoved || !i.swipeDirection || g.diff === 0 && !o.loopSwapReset || o.currentTranslate === o.startTranslate && !o.loopSwapReset) {
        o.isTouched = !1, o.isMoved = !1, o.startMoving = !1;
        return
    }
    o.isTouched = !1, o.isMoved = !1, o.startMoving = !1;
    let S;
    if (m.followFinger ? S = _ ? i.translate : -i.translate : S = -o.currentTranslate, m.cssMode) return;
    if (m.freeMode && m.freeMode.enabled) {
        i.freeMode.onTouchEnd({
            currentPos: S
        });
        return
    }
    const C = S >= -i.maxTranslate() && !i.params.loop;
    let E = 0,
        P = i.slidesSizesGrid[0];
    for (let D = 0; D < v.length; D += D < m.slidesPerGroupSkip ? 1 : m.slidesPerGroup) {
        const R = D < m.slidesPerGroupSkip - 1 ? 1 : m.slidesPerGroup;
        typeof v[D + R] < "u" ? (C || S >= v[D] && S < v[D + R]) && (E = D, P = v[D + R] - v[D]) : (C || S >= v[D]) && (E = D, P = v[v.length - 1] - v[v.length - 2])
    }
    let w = null,
        T = null;
    m.rewind && (i.isBeginning ? T = m.virtual && m.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1 : i.isEnd && (w = 0));
    const M = (S - v[E]) / P,
        A = E < m.slidesPerGroupSkip - 1 ? 1 : m.slidesPerGroup;
    if (b > m.longSwipesMs) {
        if (!m.longSwipes) {
            i.slideTo(i.activeIndex);
            return
        }
        i.swipeDirection === "next" && (M >= m.longSwipesRatio ? i.slideTo(m.rewind && i.isEnd ? w : E + A) : i.slideTo(E)), i.swipeDirection === "prev" && (M > 1 - m.longSwipesRatio ? i.slideTo(E + A) : T !== null && M < 0 && Math.abs(M) > m.longSwipesRatio ? i.slideTo(T) : i.slideTo(E))
    } else {
        if (!m.shortSwipes) {
            i.slideTo(i.activeIndex);
            return
        }
        i.navigation && (c.target === i.navigation.nextEl || c.target === i.navigation.prevEl) ? c.target === i.navigation.nextEl ? i.slideTo(E + A) : i.slideTo(E) : (i.swipeDirection === "next" && i.slideTo(w !== null ? w : E + A), i.swipeDirection === "prev" && i.slideTo(T !== null ? T : E))
    }
}

function onResize() {
    const l = this,
        {
            params: i,
            el: o
        } = l;
    if (o && o.offsetWidth === 0) return;
    i.breakpoints && l.setBreakpoint();
    const {
        allowSlideNext: c,
        allowSlidePrev: u,
        snapGrid: p
    } = l, m = l.virtual && l.params.virtual.enabled;
    l.allowSlideNext = !0, l.allowSlidePrev = !0, l.updateSize(), l.updateSlides(), l.updateSlidesClasses();
    const g = m && i.loop;
    (i.slidesPerView === "auto" || i.slidesPerView > 1) && l.isEnd && !l.isBeginning && !l.params.centeredSlides && !g ? l.slideTo(l.slides.length - 1, 0, !1, !0) : l.params.loop && !m ? l.slideToLoop(l.realIndex, 0, !1, !0) : l.slideTo(l.activeIndex, 0, !1, !0), l.autoplay && l.autoplay.running && l.autoplay.paused && (clearTimeout(l.autoplay.resizeTimeout), l.autoplay.resizeTimeout = setTimeout(() => {
        l.autoplay && l.autoplay.running && l.autoplay.paused && l.autoplay.resume()
    }, 500)), l.allowSlidePrev = u, l.allowSlideNext = c, l.params.watchOverflow && p !== l.snapGrid && l.checkOverflow()
}

function onClick(l) {
    const i = this;
    i.enabled && (i.allowClick || (i.params.preventClicks && l.preventDefault(), i.params.preventClicksPropagation && i.animating && (l.stopPropagation(), l.stopImmediatePropagation())))
}

function onScroll() {
    const l = this,
        {
            wrapperEl: i,
            rtlTranslate: o,
            enabled: c
        } = l;
    if (!c) return;
    l.previousTranslate = l.translate, l.isHorizontal() ? l.translate = -i.scrollLeft : l.translate = -i.scrollTop, l.translate === 0 && (l.translate = 0), l.updateActiveIndex(), l.updateSlidesClasses();
    let u;
    const p = l.maxTranslate() - l.minTranslate();
    p === 0 ? u = 0 : u = (l.translate - l.minTranslate()) / p, u !== l.progress && l.updateProgress(o ? -l.translate : l.translate), l.emit("setTranslate", l.translate, !1)
}

function onLoad(l) {
    const i = this;
    processLazyPreloader(i, l.target), !(i.params.cssMode || i.params.slidesPerView !== "auto" && !i.params.autoHeight) && i.update()
}

function onDocumentTouchStart() {
    const l = this;
    l.documentTouchHandlerProceeded || (l.documentTouchHandlerProceeded = !0, l.params.touchReleaseOnEdges && (l.el.style.touchAction = "auto"))
}
const events$1 = (l, i) => {
    const o = getDocument(),
        {
            params: c,
            el: u,
            wrapperEl: p,
            device: m
        } = l,
        g = !!c.nested,
        _ = i === "on" ? "addEventListener" : "removeEventListener",
        v = i;
    !u || typeof u == "string" || (o[_]("touchstart", l.onDocumentTouchStart, {
        passive: !1,
        capture: g
    }), u[_]("touchstart", l.onTouchStart, {
        passive: !1
    }), u[_]("pointerdown", l.onTouchStart, {
        passive: !1
    }), o[_]("touchmove", l.onTouchMove, {
        passive: !1,
        capture: g
    }), o[_]("pointermove", l.onTouchMove, {
        passive: !1,
        capture: g
    }), o[_]("touchend", l.onTouchEnd, {
        passive: !0
    }), o[_]("pointerup", l.onTouchEnd, {
        passive: !0
    }), o[_]("pointercancel", l.onTouchEnd, {
        passive: !0
    }), o[_]("touchcancel", l.onTouchEnd, {
        passive: !0
    }), o[_]("pointerout", l.onTouchEnd, {
        passive: !0
    }), o[_]("pointerleave", l.onTouchEnd, {
        passive: !0
    }), o[_]("contextmenu", l.onTouchEnd, {
        passive: !0
    }), (c.preventClicks || c.preventClicksPropagation) && u[_]("click", l.onClick, !0), c.cssMode && p[_]("scroll", l.onScroll), c.updateOnWindowResize ? l[v](m.ios || m.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : l[v]("observerUpdate", onResize, !0), u[_]("load", l.onLoad, {
        capture: !0
    }))
};

function attachEvents() {
    const l = this,
        {
            params: i
        } = l;
    l.onTouchStart = onTouchStart.bind(l), l.onTouchMove = onTouchMove.bind(l), l.onTouchEnd = onTouchEnd.bind(l), l.onDocumentTouchStart = onDocumentTouchStart.bind(l), i.cssMode && (l.onScroll = onScroll.bind(l)), l.onClick = onClick.bind(l), l.onLoad = onLoad.bind(l), events$1(l, "on")
}

function detachEvents() {
    events$1(this, "off")
}
var events$1$1 = {
    attachEvents,
    detachEvents
};
const isGridEnabled = (l, i) => l.grid && i.grid && i.grid.rows > 1;

function setBreakpoint() {
    const l = this,
        {
            realIndex: i,
            initialized: o,
            params: c,
            el: u
        } = l,
        p = c.breakpoints;
    if (!p || p && Object.keys(p).length === 0) return;
    const m = getDocument(),
        g = c.breakpointsBase === "window" || !c.breakpointsBase ? c.breakpointsBase : "container",
        _ = ["window", "container"].includes(c.breakpointsBase) || !c.breakpointsBase ? l.el : m.querySelector(c.breakpointsBase),
        v = l.getBreakpoint(p, g, _);
    if (!v || l.currentBreakpoint === v) return;
    const y = (v in p ? p[v] : void 0) || l.originalParams,
        b = isGridEnabled(l, c),
        S = isGridEnabled(l, y),
        C = l.params.grabCursor,
        E = y.grabCursor,
        P = c.enabled;
    b && !S ? (u.classList.remove(`${c.containerModifierClass}grid`, `${c.containerModifierClass}grid-column`), l.emitContainerClasses()) : !b && S && (u.classList.add(`${c.containerModifierClass}grid`), (y.grid.fill && y.grid.fill === "column" || !y.grid.fill && c.grid.fill === "column") && u.classList.add(`${c.containerModifierClass}grid-column`), l.emitContainerClasses()), C && !E ? l.unsetGrabCursor() : !C && E && l.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(R => {
        if (typeof y[R] > "u") return;
        const I = c[R] && c[R].enabled,
            k = y[R] && y[R].enabled;
        I && !k && l[R].disable(), !I && k && l[R].enable()
    });
    const w = y.direction && y.direction !== c.direction,
        T = c.loop && (y.slidesPerView !== c.slidesPerView || w),
        M = c.loop;
    w && o && l.changeDirection(), extend(l.params, y);
    const A = l.params.enabled,
        D = l.params.loop;
    Object.assign(l, {
        allowTouchMove: l.params.allowTouchMove,
        allowSlideNext: l.params.allowSlideNext,
        allowSlidePrev: l.params.allowSlidePrev
    }), P && !A ? l.disable() : !P && A && l.enable(), l.currentBreakpoint = v, l.emit("_beforeBreakpoint", y), o && (T ? (l.loopDestroy(), l.loopCreate(i), l.updateSlides()) : !M && D ? (l.loopCreate(i), l.updateSlides()) : M && !D && l.loopDestroy()), l.emit("breakpoint", y)
}

function getBreakpoint(l, i, o) {
    if (i === void 0 && (i = "window"), !l || i === "container" && !o) return;
    let c = !1;
    const u = getWindow(),
        p = i === "window" ? u.innerHeight : o.clientHeight,
        m = Object.keys(l).map(g => {
            if (typeof g == "string" && g.indexOf("@") === 0) {
                const _ = parseFloat(g.substr(1));
                return {
                    value: p * _,
                    point: g
                }
            }
            return {
                value: g,
                point: g
            }
        });
    m.sort((g, _) => parseInt(g.value, 10) - parseInt(_.value, 10));
    for (let g = 0; g < m.length; g += 1) {
        const {
            point: _,
            value: v
        } = m[g];
        i === "window" ? u.matchMedia(`(min-width: ${v}px)`).matches && (c = _) : v <= o.clientWidth && (c = _)
    }
    return c || "max"
}
var breakpoints = {
    setBreakpoint,
    getBreakpoint
};

function prepareClasses(l, i) {
    const o = [];
    return l.forEach(c => {
        typeof c == "object" ? Object.keys(c).forEach(u => {
            c[u] && o.push(i + u)
        }) : typeof c == "string" && o.push(i + c)
    }), o
}

function addClasses() {
    const l = this,
        {
            classNames: i,
            params: o,
            rtl: c,
            el: u,
            device: p
        } = l,
        m = prepareClasses(["initialized", o.direction, {
            "free-mode": l.params.freeMode && o.freeMode.enabled
        }, {
            autoheight: o.autoHeight
        }, {
            rtl: c
        }, {
            grid: o.grid && o.grid.rows > 1
        }, {
            "grid-column": o.grid && o.grid.rows > 1 && o.grid.fill === "column"
        }, {
            android: p.android
        }, {
            ios: p.ios
        }, {
            "css-mode": o.cssMode
        }, {
            centered: o.cssMode && o.centeredSlides
        }, {
            "watch-progress": o.watchSlidesProgress
        }], o.containerModifierClass);
    i.push(...m), u.classList.add(...i), l.emitContainerClasses()
}

function removeClasses() {
    const l = this,
        {
            el: i,
            classNames: o
        } = l;
    !i || typeof i == "string" || (i.classList.remove(...o), l.emitContainerClasses())
}
var classes = {
    addClasses,
    removeClasses
};

function checkOverflow() {
    const l = this,
        {
            isLocked: i,
            params: o
        } = l,
        {
            slidesOffsetBefore: c
        } = o;
    if (c) {
        const u = l.slides.length - 1,
            p = l.slidesGrid[u] + l.slidesSizesGrid[u] + c * 2;
        l.isLocked = l.size > p
    } else l.isLocked = l.snapGrid.length === 1;
    o.allowSlideNext === !0 && (l.allowSlideNext = !l.isLocked), o.allowSlidePrev === !0 && (l.allowSlidePrev = !l.isLocked), i && i !== l.isLocked && (l.isEnd = !1), i !== l.isLocked && l.emit(l.isLocked ? "lock" : "unlock")
}
var checkOverflow$1 = {
        checkOverflow
    },
    defaults = {
        init: !0,
        direction: "horizontal",
        oneWayMovement: !1,
        swiperElementNodeName: "SWIPER-CONTAINER",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        eventsPrefix: "swiper",
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 5,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        loop: !1,
        loopAddBlankSlides: !0,
        loopAdditionalSlides: 0,
        loopPreventsSliding: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-blank",
        slideActiveClass: "swiper-slide-active",
        slideVisibleClass: "swiper-slide-visible",
        slideFullyVisibleClass: "swiper-slide-fully-visible",
        slideNextClass: "swiper-slide-next",
        slidePrevClass: "swiper-slide-prev",
        wrapperClass: "swiper-wrapper",
        lazyPreloaderClass: "swiper-lazy-preloader",
        lazyPreloadPrevNext: 0,
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

function moduleExtendParams(l, i) {
    return function(c) {
        c === void 0 && (c = {});
        const u = Object.keys(c)[0],
            p = c[u];
        if (typeof p != "object" || p === null) {
            extend(i, c);
            return
        }
        if (l[u] === !0 && (l[u] = {
                enabled: !0
            }), u === "navigation" && l[u] && l[u].enabled && !l[u].prevEl && !l[u].nextEl && (l[u].auto = !0), ["pagination", "scrollbar"].indexOf(u) >= 0 && l[u] && l[u].enabled && !l[u].el && (l[u].auto = !0), !(u in l && "enabled" in p)) {
            extend(i, c);
            return
        }
        typeof l[u] == "object" && !("enabled" in l[u]) && (l[u].enabled = !0), l[u] || (l[u] = {
            enabled: !1
        }), extend(i, c)
    }
}
const prototypes = {
        eventsEmitter,
        update,
        translate,
        transition: transition$1,
        slide,
        loop,
        grabCursor,
        events: events$1$1,
        breakpoints,
        checkOverflow: checkOverflow$1,
        classes
    },
    extendedDefaults = {};
class Swiper {
    constructor() {
        let i, o;
        for (var c = arguments.length, u = new Array(c), p = 0; p < c; p++) u[p] = arguments[p];
        u.length === 1 && u[0].constructor && Object.prototype.toString.call(u[0]).slice(8, -1) === "Object" ? o = u[0] : [i, o] = u, o || (o = {}), o = extend({}, o), i && !o.el && (o.el = i);
        const m = getDocument();
        if (o.el && typeof o.el == "string" && m.querySelectorAll(o.el).length > 1) {
            const x = [];
            return m.querySelectorAll(o.el).forEach(y => {
                const b = extend({}, o, {
                    el: y
                });
                x.push(new Swiper(b))
            }), x
        }
        const g = this;
        g.__swiper__ = !0, g.support = getSupport(), g.device = getDevice({
            userAgent: o.userAgent
        }), g.browser = getBrowser(), g.eventsListeners = {}, g.eventsAnyListeners = [], g.modules = [...g.__modules__], o.modules && Array.isArray(o.modules) && g.modules.push(...o.modules);
        const _ = {};
        g.modules.forEach(x => {
            x({
                params: o,
                swiper: g,
                extendParams: moduleExtendParams(o, _),
                on: g.on.bind(g),
                once: g.once.bind(g),
                off: g.off.bind(g),
                emit: g.emit.bind(g)
            })
        });
        const v = extend({}, defaults, _);
        return g.params = extend({}, v, extendedDefaults, o), g.originalParams = extend({}, g.params), g.passedParams = extend({}, o), g.params && g.params.on && Object.keys(g.params.on).forEach(x => {
            g.on(x, g.params.on[x])
        }), g.params && g.params.onAny && g.onAny(g.params.onAny), Object.assign(g, {
            enabled: g.params.enabled,
            el: i,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return g.params.direction === "horizontal"
            },
            isVertical() {
                return g.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
            },
            allowSlideNext: g.params.allowSlideNext,
            allowSlidePrev: g.params.allowSlidePrev,
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: g.params.focusableElements,
                lastClickTime: 0,
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            allowClick: !0,
            allowTouchMove: g.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }), g.emit("_swiper"), g.params.init && g.init(), g
    }
    getDirectionLabel(i) {
        return this.isHorizontal() ? i : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[i]
    }
    getSlideIndex(i) {
        const {
            slidesEl: o,
            params: c
        } = this, u = elementChildren(o, `.${c.slideClass}, swiper-slide`), p = elementIndex(u[0]);
        return elementIndex(i) - p
    }
    getSlideIndexByData(i) {
        return this.getSlideIndex(this.slides.find(o => o.getAttribute("data-swiper-slide-index") * 1 === i))
    }
    recalcSlides() {
        const i = this,
            {
                slidesEl: o,
                params: c
            } = i;
        i.slides = elementChildren(o, `.${c.slideClass}, swiper-slide`)
    }
    enable() {
        const i = this;
        i.enabled || (i.enabled = !0, i.params.grabCursor && i.setGrabCursor(), i.emit("enable"))
    }
    disable() {
        const i = this;
        i.enabled && (i.enabled = !1, i.params.grabCursor && i.unsetGrabCursor(), i.emit("disable"))
    }
    setProgress(i, o) {
        const c = this;
        i = Math.min(Math.max(i, 0), 1);
        const u = c.minTranslate(),
            m = (c.maxTranslate() - u) * i + u;
        c.translateTo(m, typeof o > "u" ? 0 : o), c.updateActiveIndex(), c.updateSlidesClasses()
    }
    emitContainerClasses() {
        const i = this;
        if (!i.params._emitClasses || !i.el) return;
        const o = i.el.className.split(" ").filter(c => c.indexOf("swiper") === 0 || c.indexOf(i.params.containerModifierClass) === 0);
        i.emit("_containerClasses", o.join(" "))
    }
    getSlideClasses(i) {
        const o = this;
        return o.destroyed ? "" : i.className.split(" ").filter(c => c.indexOf("swiper-slide") === 0 || c.indexOf(o.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const i = this;
        if (!i.params._emitClasses || !i.el) return;
        const o = [];
        i.slides.forEach(c => {
            const u = i.getSlideClasses(c);
            o.push({
                slideEl: c,
                classNames: u
            }), i.emit("_slideClass", c, u)
        }), i.emit("_slideClasses", o)
    }
    slidesPerViewDynamic(i, o) {
        i === void 0 && (i = "current"), o === void 0 && (o = !1);
        const c = this,
            {
                params: u,
                slides: p,
                slidesGrid: m,
                slidesSizesGrid: g,
                size: _,
                activeIndex: v
            } = c;
        let x = 1;
        if (typeof u.slidesPerView == "number") return u.slidesPerView;
        if (u.centeredSlides) {
            let y = p[v] ? Math.ceil(p[v].swiperSlideSize) : 0,
                b;
            for (let S = v + 1; S < p.length; S += 1) p[S] && !b && (y += Math.ceil(p[S].swiperSlideSize), x += 1, y > _ && (b = !0));
            for (let S = v - 1; S >= 0; S -= 1) p[S] && !b && (y += p[S].swiperSlideSize, x += 1, y > _ && (b = !0))
        } else if (i === "current")
            for (let y = v + 1; y < p.length; y += 1)(o ? m[y] + g[y] - m[v] < _ : m[y] - m[v] < _) && (x += 1);
        else
            for (let y = v - 1; y >= 0; y -= 1) m[v] - m[y] < _ && (x += 1);
        return x
    }
    update() {
        const i = this;
        if (!i || i.destroyed) return;
        const {
            snapGrid: o,
            params: c
        } = i;
        c.breakpoints && i.setBreakpoint(), [...i.el.querySelectorAll('[loading="lazy"]')].forEach(m => {
            m.complete && processLazyPreloader(i, m)
        }), i.updateSize(), i.updateSlides(), i.updateProgress(), i.updateSlidesClasses();

        function u() {
            const m = i.rtlTranslate ? i.translate * -1 : i.translate,
                g = Math.min(Math.max(m, i.maxTranslate()), i.minTranslate());
            i.setTranslate(g), i.updateActiveIndex(), i.updateSlidesClasses()
        }
        let p;
        if (c.freeMode && c.freeMode.enabled && !c.cssMode) u(), c.autoHeight && i.updateAutoHeight();
        else {
            if ((c.slidesPerView === "auto" || c.slidesPerView > 1) && i.isEnd && !c.centeredSlides) {
                const m = i.virtual && c.virtual.enabled ? i.virtual.slides : i.slides;
                p = i.slideTo(m.length - 1, 0, !1, !0)
            } else p = i.slideTo(i.activeIndex, 0, !1, !0);
            p || u()
        }
        c.watchOverflow && o !== i.snapGrid && i.checkOverflow(), i.emit("update")
    }
    changeDirection(i, o) {
        o === void 0 && (o = !0);
        const c = this,
            u = c.params.direction;
        return i || (i = u === "horizontal" ? "vertical" : "horizontal"), i === u || i !== "horizontal" && i !== "vertical" || (c.el.classList.remove(`${c.params.containerModifierClass}${u}`), c.el.classList.add(`${c.params.containerModifierClass}${i}`), c.emitContainerClasses(), c.params.direction = i, c.slides.forEach(p => {
            i === "vertical" ? p.style.width = "" : p.style.height = ""
        }), c.emit("changeDirection"), o && c.update()), c
    }
    changeLanguageDirection(i) {
        const o = this;
        o.rtl && i === "rtl" || !o.rtl && i === "ltr" || (o.rtl = i === "rtl", o.rtlTranslate = o.params.direction === "horizontal" && o.rtl, o.rtl ? (o.el.classList.add(`${o.params.containerModifierClass}rtl`), o.el.dir = "rtl") : (o.el.classList.remove(`${o.params.containerModifierClass}rtl`), o.el.dir = "ltr"), o.update())
    }
    mount(i) {
        const o = this;
        if (o.mounted) return !0;
        let c = i || o.params.el;
        if (typeof c == "string" && (c = document.querySelector(c)), !c) return !1;
        c.swiper = o, c.parentNode && c.parentNode.host && c.parentNode.host.nodeName === o.params.swiperElementNodeName.toUpperCase() && (o.isElement = !0);
        const u = () => `.${(o.params.wrapperClass||"").trim().split(" ").join(".")}`;
        let m = c && c.shadowRoot && c.shadowRoot.querySelector ? c.shadowRoot.querySelector(u()) : elementChildren(c, u())[0];
        return !m && o.params.createElements && (m = createElement("div", o.params.wrapperClass), c.append(m), elementChildren(c, `.${o.params.slideClass}`).forEach(g => {
            m.append(g)
        })), Object.assign(o, {
            el: c,
            wrapperEl: m,
            slidesEl: o.isElement && !c.parentNode.host.slideSlots ? c.parentNode.host : m,
            hostEl: o.isElement ? c.parentNode.host : c,
            mounted: !0,
            rtl: c.dir.toLowerCase() === "rtl" || elementStyle(c, "direction") === "rtl",
            rtlTranslate: o.params.direction === "horizontal" && (c.dir.toLowerCase() === "rtl" || elementStyle(c, "direction") === "rtl"),
            wrongRTL: elementStyle(m, "display") === "-webkit-box"
        }), !0
    }
    init(i) {
        const o = this;
        if (o.initialized || o.mount(i) === !1) return o;
        o.emit("beforeInit"), o.params.breakpoints && o.setBreakpoint(), o.addClasses(), o.updateSize(), o.updateSlides(), o.params.watchOverflow && o.checkOverflow(), o.params.grabCursor && o.enabled && o.setGrabCursor(), o.params.loop && o.virtual && o.params.virtual.enabled ? o.slideTo(o.params.initialSlide + o.virtual.slidesBefore, 0, o.params.runCallbacksOnInit, !1, !0) : o.slideTo(o.params.initialSlide, 0, o.params.runCallbacksOnInit, !1, !0), o.params.loop && o.loopCreate(void 0, !0), o.attachEvents();
        const u = [...o.el.querySelectorAll('[loading="lazy"]')];
        return o.isElement && u.push(...o.hostEl.querySelectorAll('[loading="lazy"]')), u.forEach(p => {
            p.complete ? processLazyPreloader(o, p) : p.addEventListener("load", m => {
                processLazyPreloader(o, m.target)
            })
        }), preload(o), o.initialized = !0, preload(o), o.emit("init"), o.emit("afterInit"), o
    }
    destroy(i, o) {
        i === void 0 && (i = !0), o === void 0 && (o = !0);
        const c = this,
            {
                params: u,
                el: p,
                wrapperEl: m,
                slides: g
            } = c;
        return typeof c.params > "u" || c.destroyed || (c.emit("beforeDestroy"), c.initialized = !1, c.detachEvents(), u.loop && c.loopDestroy(), o && (c.removeClasses(), p && typeof p != "string" && p.removeAttribute("style"), m && m.removeAttribute("style"), g && g.length && g.forEach(_ => {
            _.classList.remove(u.slideVisibleClass, u.slideFullyVisibleClass, u.slideActiveClass, u.slideNextClass, u.slidePrevClass), _.removeAttribute("style"), _.removeAttribute("data-swiper-slide-index")
        })), c.emit("destroy"), Object.keys(c.eventsListeners).forEach(_ => {
            c.off(_)
        }), i !== !1 && (c.el && typeof c.el != "string" && (c.el.swiper = null), deleteProps(c)), c.destroyed = !0), null
    }
    static extendDefaults(i) {
        extend(extendedDefaults, i)
    }
    static get extendedDefaults() {
        return extendedDefaults
    }
    static get defaults() {
        return defaults
    }
    static installModule(i) {
        Swiper.prototype.__modules__ || (Swiper.prototype.__modules__ = []);
        const o = Swiper.prototype.__modules__;
        typeof i == "function" && o.indexOf(i) < 0 && o.push(i)
    }
    static use(i) {
        return Array.isArray(i) ? (i.forEach(o => Swiper.installModule(o)), Swiper) : (Swiper.installModule(i), Swiper)
    }
}
Object.keys(prototypes).forEach(l => {
    Object.keys(prototypes[l]).forEach(i => {
        Swiper.prototype[i] = prototypes[l][i]
    })
});
Swiper.use([Resize, Observer]);

function Mousewheel(l) {
    let {
        swiper: i,
        extendParams: o,
        on: c,
        emit: u
    } = l;
    const p = getWindow();
    o({
        mousewheel: {
            enabled: !1,
            releaseOnEdges: !1,
            invert: !1,
            forceToAxis: !1,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null,
            noMousewheelClass: "swiper-no-mousewheel"
        }
    }), i.mousewheel = {
        enabled: !1
    };
    let m, g = now(),
        _;
    const v = [];

    function x(M) {
        let I = 0,
            k = 0,
            F = 0,
            V = 0;
        return "detail" in M && (k = M.detail), "wheelDelta" in M && (k = -M.wheelDelta / 120), "wheelDeltaY" in M && (k = -M.wheelDeltaY / 120), "wheelDeltaX" in M && (I = -M.wheelDeltaX / 120), "axis" in M && M.axis === M.HORIZONTAL_AXIS && (I = k, k = 0), F = I * 10, V = k * 10, "deltaY" in M && (V = M.deltaY), "deltaX" in M && (F = M.deltaX), M.shiftKey && !F && (F = V, V = 0), (F || V) && M.deltaMode && (M.deltaMode === 1 ? (F *= 40, V *= 40) : (F *= 800, V *= 800)), F && !I && (I = F < 1 ? -1 : 1), V && !k && (k = V < 1 ? -1 : 1), {
            spinX: I,
            spinY: k,
            pixelX: F,
            pixelY: V
        }
    }

    function y() {
        i.enabled && (i.mouseEntered = !0)
    }

    function b() {
        i.enabled && (i.mouseEntered = !1)
    }

    function S(M) {
        return i.params.mousewheel.thresholdDelta && M.delta < i.params.mousewheel.thresholdDelta || i.params.mousewheel.thresholdTime && now() - g < i.params.mousewheel.thresholdTime ? !1 : M.delta >= 6 && now() - g < 60 ? !0 : (M.direction < 0 ? (!i.isEnd || i.params.loop) && !i.animating && (i.slideNext(), u("scroll", M.raw)) : (!i.isBeginning || i.params.loop) && !i.animating && (i.slidePrev(), u("scroll", M.raw)), g = new p.Date().getTime(), !1)
    }

    function C(M) {
        const A = i.params.mousewheel;
        if (M.direction < 0) {
            if (i.isEnd && !i.params.loop && A.releaseOnEdges) return !0
        } else if (i.isBeginning && !i.params.loop && A.releaseOnEdges) return !0;
        return !1
    }

    function E(M) {
        let A = M,
            D = !0;
        if (!i.enabled || M.target.closest(`.${i.params.mousewheel.noMousewheelClass}`)) return;
        const R = i.params.mousewheel;
        i.params.cssMode && A.preventDefault();
        let I = i.el;
        i.params.mousewheel.eventsTarget !== "container" && (I = document.querySelector(i.params.mousewheel.eventsTarget));
        const k = I && I.contains(A.target);
        if (!i.mouseEntered && !k && !R.releaseOnEdges) return !0;
        A.originalEvent && (A = A.originalEvent);
        let F = 0;
        const V = i.rtlTranslate ? -1 : 1,
            B = x(A);
        if (R.forceToAxis)
            if (i.isHorizontal())
                if (Math.abs(B.pixelX) > Math.abs(B.pixelY)) F = -B.pixelX * V;
                else return !0;
        else if (Math.abs(B.pixelY) > Math.abs(B.pixelX)) F = -B.pixelY;
        else return !0;
        else F = Math.abs(B.pixelX) > Math.abs(B.pixelY) ? -B.pixelX * V : -B.pixelY;
        if (F === 0) return !0;
        R.invert && (F = -F);
        let U = i.getTranslate() + F * R.sensitivity;
        if (U >= i.minTranslate() && (U = i.minTranslate()), U <= i.maxTranslate() && (U = i.maxTranslate()), D = i.params.loop ? !0 : !(U === i.minTranslate() || U === i.maxTranslate()), D && i.params.nested && A.stopPropagation(), !i.params.freeMode || !i.params.freeMode.enabled) {
            const H = {
                time: now(),
                delta: Math.abs(F),
                direction: Math.sign(F),
                raw: M
            };
            v.length >= 2 && v.shift();
            const Q = v.length ? v[v.length - 1] : void 0;
            if (v.push(H), Q ? (H.direction !== Q.direction || H.delta > Q.delta || H.time > Q.time + 150) && S(H) : S(H), C(H)) return !0
        } else {
            const H = {
                    time: now(),
                    delta: Math.abs(F),
                    direction: Math.sign(F)
                },
                Q = _ && H.time < _.time + 500 && H.delta <= _.delta && H.direction === _.direction;
            if (!Q) {
                _ = void 0;
                let Y = i.getTranslate() + F * R.sensitivity;
                const O = i.isBeginning,
                    G = i.isEnd;
                if (Y >= i.minTranslate() && (Y = i.minTranslate()), Y <= i.maxTranslate() && (Y = i.maxTranslate()), i.setTransition(0), i.setTranslate(Y), i.updateProgress(), i.updateActiveIndex(), i.updateSlidesClasses(), (!O && i.isBeginning || !G && i.isEnd) && i.updateSlidesClasses(), i.params.loop && i.loopFix({
                        direction: H.direction < 0 ? "next" : "prev",
                        byMousewheel: !0
                    }), i.params.freeMode.sticky) {
                    clearTimeout(m), m = void 0, v.length >= 15 && v.shift();
                    const L = v.length ? v[v.length - 1] : void 0,
                        N = v[0];
                    if (v.push(H), L && (H.delta > L.delta || H.direction !== L.direction)) v.splice(0);
                    else if (v.length >= 15 && H.time - N.time < 500 && N.delta - H.delta >= 1 && H.delta <= 6) {
                        const K = F > 0 ? .8 : .2;
                        _ = H, v.splice(0), m = nextTick(() => {
                            i.destroyed || !i.params || i.slideToClosest(i.params.speed, !0, void 0, K)
                        }, 0)
                    }
                    m || (m = nextTick(() => {
                        if (i.destroyed || !i.params) return;
                        const K = .5;
                        _ = H, v.splice(0), i.slideToClosest(i.params.speed, !0, void 0, K)
                    }, 500))
                }
                if (Q || u("scroll", A), i.params.autoplay && i.params.autoplay.disableOnInteraction && i.autoplay.stop(), R.releaseOnEdges && (Y === i.minTranslate() || Y === i.maxTranslate())) return !0
            }
        }
        return A.preventDefault ? A.preventDefault() : A.returnValue = !1, !1
    }

    function P(M) {
        let A = i.el;
        i.params.mousewheel.eventsTarget !== "container" && (A = document.querySelector(i.params.mousewheel.eventsTarget)), A[M]("mouseenter", y), A[M]("mouseleave", b), A[M]("wheel", E)
    }

    function w() {
        return i.params.cssMode ? (i.wrapperEl.removeEventListener("wheel", E), !0) : i.mousewheel.enabled ? !1 : (P("addEventListener"), i.mousewheel.enabled = !0, !0)
    }

    function T() {
        return i.params.cssMode ? (i.wrapperEl.addEventListener(event, E), !0) : i.mousewheel.enabled ? (P("removeEventListener"), i.mousewheel.enabled = !1, !0) : !1
    }
    c("init", () => {
        !i.params.mousewheel.enabled && i.params.cssMode && T(), i.params.mousewheel.enabled && w()
    }), c("destroy", () => {
        i.params.cssMode && w(), i.mousewheel.enabled && T()
    }), Object.assign(i.mousewheel, {
        enable: w,
        disable: T
    })
}

function createElementIfNotDefined(l, i, o, c) {
    return l.params.createElements && Object.keys(c).forEach(u => {
        if (!o[u] && o.auto === !0) {
            let p = elementChildren(l.el, `.${c[u]}`)[0];
            p || (p = createElement("div", c[u]), p.className = c[u], l.el.append(p)), o[u] = p, i[u] = p
        }
    }), o
}

function classesToSelector(l) {
    return l === void 0 && (l = ""), `.${l.trim().replace(/([\.:!+\/])/g,"\\$1").replace(/ /g,".")}`
}

function Pagination(l) {
    let {
        swiper: i,
        extendParams: o,
        on: c,
        emit: u
    } = l;
    const p = "swiper-pagination";
    o({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: T => T,
            formatFractionTotal: T => T,
            bulletClass: `${p}-bullet`,
            bulletActiveClass: `${p}-bullet-active`,
            modifierClass: `${p}-`,
            currentClass: `${p}-current`,
            totalClass: `${p}-total`,
            hiddenClass: `${p}-hidden`,
            progressbarFillClass: `${p}-progressbar-fill`,
            progressbarOppositeClass: `${p}-progressbar-opposite`,
            clickableClass: `${p}-clickable`,
            lockClass: `${p}-lock`,
            horizontalClass: `${p}-horizontal`,
            verticalClass: `${p}-vertical`,
            paginationDisabledClass: `${p}-disabled`
        }
    }), i.pagination = {
        el: null,
        bullets: []
    };
    let m, g = 0;

    function _() {
        return !i.params.pagination.el || !i.pagination.el || Array.isArray(i.pagination.el) && i.pagination.el.length === 0
    }

    function v(T, M) {
        const {
            bulletActiveClass: A
        } = i.params.pagination;
        T && (T = T[`${M==="prev"?"previous":"next"}ElementSibling`], T && (T.classList.add(`${A}-${M}`), T = T[`${M==="prev"?"previous":"next"}ElementSibling`], T && T.classList.add(`${A}-${M}-${M}`)))
    }

    function x(T, M, A) {
        if (T = T % A, M = M % A, M === T + 1) return "next";
        if (M === T - 1) return "previous"
    }

    function y(T) {
        const M = T.target.closest(classesToSelector(i.params.pagination.bulletClass));
        if (!M) return;
        T.preventDefault();
        const A = elementIndex(M) * i.params.slidesPerGroup;
        if (i.params.loop) {
            if (i.realIndex === A) return;
            const D = x(i.realIndex, A, i.slides.length);
            D === "next" ? i.slideNext() : D === "previous" ? i.slidePrev() : i.slideToLoop(A)
        } else i.slideTo(A)
    }

    function b() {
        const T = i.rtl,
            M = i.params.pagination;
        if (_()) return;
        let A = i.pagination.el;
        A = makeElementsArray(A);
        let D, R;
        const I = i.virtual && i.params.virtual.enabled ? i.virtual.slides.length : i.slides.length,
            k = i.params.loop ? Math.ceil(I / i.params.slidesPerGroup) : i.snapGrid.length;
        if (i.params.loop ? (R = i.previousRealIndex || 0, D = i.params.slidesPerGroup > 1 ? Math.floor(i.realIndex / i.params.slidesPerGroup) : i.realIndex) : typeof i.snapIndex < "u" ? (D = i.snapIndex, R = i.previousSnapIndex) : (R = i.previousIndex || 0, D = i.activeIndex || 0), M.type === "bullets" && i.pagination.bullets && i.pagination.bullets.length > 0) {
            const F = i.pagination.bullets;
            let V, B, U;
            if (M.dynamicBullets && (m = elementOuterSize(F[0], i.isHorizontal() ? "width" : "height"), A.forEach(H => {
                    H.style[i.isHorizontal() ? "width" : "height"] = `${m*(M.dynamicMainBullets+4)}px`
                }), M.dynamicMainBullets > 1 && R !== void 0 && (g += D - (R || 0), g > M.dynamicMainBullets - 1 ? g = M.dynamicMainBullets - 1 : g < 0 && (g = 0)), V = Math.max(D - g, 0), B = V + (Math.min(F.length, M.dynamicMainBullets) - 1), U = (B + V) / 2), F.forEach(H => {
                    const Q = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(Y => `${M.bulletActiveClass}${Y}`)].map(Y => typeof Y == "string" && Y.includes(" ") ? Y.split(" ") : Y).flat();
                    H.classList.remove(...Q)
                }), A.length > 1) F.forEach(H => {
                const Q = elementIndex(H);
                Q === D ? H.classList.add(...M.bulletActiveClass.split(" ")) : i.isElement && H.setAttribute("part", "bullet"), M.dynamicBullets && (Q >= V && Q <= B && H.classList.add(...`${M.bulletActiveClass}-main`.split(" ")), Q === V && v(H, "prev"), Q === B && v(H, "next"))
            });
            else {
                const H = F[D];
                if (H && H.classList.add(...M.bulletActiveClass.split(" ")), i.isElement && F.forEach((Q, Y) => {
                        Q.setAttribute("part", Y === D ? "bullet-active" : "bullet")
                    }), M.dynamicBullets) {
                    const Q = F[V],
                        Y = F[B];
                    for (let O = V; O <= B; O += 1) F[O] && F[O].classList.add(...`${M.bulletActiveClass}-main`.split(" "));
                    v(Q, "prev"), v(Y, "next")
                }
            }
            if (M.dynamicBullets) {
                const H = Math.min(F.length, M.dynamicMainBullets + 4),
                    Q = (m * H - m) / 2 - U * m,
                    Y = T ? "right" : "left";
                F.forEach(O => {
                    O.style[i.isHorizontal() ? Y : "top"] = `${Q}px`
                })
            }
        }
        A.forEach((F, V) => {
            if (M.type === "fraction" && (F.querySelectorAll(classesToSelector(M.currentClass)).forEach(B => {
                    B.textContent = M.formatFractionCurrent(D + 1)
                }), F.querySelectorAll(classesToSelector(M.totalClass)).forEach(B => {
                    B.textContent = M.formatFractionTotal(k)
                })), M.type === "progressbar") {
                let B;
                M.progressbarOpposite ? B = i.isHorizontal() ? "vertical" : "horizontal" : B = i.isHorizontal() ? "horizontal" : "vertical";
                const U = (D + 1) / k;
                let H = 1,
                    Q = 1;
                B === "horizontal" ? H = U : Q = U, F.querySelectorAll(classesToSelector(M.progressbarFillClass)).forEach(Y => {
                    Y.style.transform = `translate3d(0,0,0) scaleX(${H}) scaleY(${Q})`, Y.style.transitionDuration = `${i.params.speed}ms`
                })
            }
            M.type === "custom" && M.renderCustom ? (setInnerHTML(F, M.renderCustom(i, D + 1, k)), V === 0 && u("paginationRender", F)) : (V === 0 && u("paginationRender", F), u("paginationUpdate", F)), i.params.watchOverflow && i.enabled && F.classList[i.isLocked ? "add" : "remove"](M.lockClass)
        })
    }

    function S() {
        const T = i.params.pagination;
        if (_()) return;
        const M = i.virtual && i.params.virtual.enabled ? i.virtual.slides.length : i.grid && i.params.grid.rows > 1 ? i.slides.length / Math.ceil(i.params.grid.rows) : i.slides.length;
        let A = i.pagination.el;
        A = makeElementsArray(A);
        let D = "";
        if (T.type === "bullets") {
            let R = i.params.loop ? Math.ceil(M / i.params.slidesPerGroup) : i.snapGrid.length;
            i.params.freeMode && i.params.freeMode.enabled && R > M && (R = M);
            for (let I = 0; I < R; I += 1) T.renderBullet ? D += T.renderBullet.call(i, I, T.bulletClass) : D += `<${T.bulletElement} ${i.isElement?'part="bullet"':""} class="${T.bulletClass}"></${T.bulletElement}>`
        }
        T.type === "fraction" && (T.renderFraction ? D = T.renderFraction.call(i, T.currentClass, T.totalClass) : D = `<span class="${T.currentClass}"></span> / <span class="${T.totalClass}"></span>`), T.type === "progressbar" && (T.renderProgressbar ? D = T.renderProgressbar.call(i, T.progressbarFillClass) : D = `<span class="${T.progressbarFillClass}"></span>`), i.pagination.bullets = [], A.forEach(R => {
            T.type !== "custom" && setInnerHTML(R, D || ""), T.type === "bullets" && i.pagination.bullets.push(...R.querySelectorAll(classesToSelector(T.bulletClass)))
        }), T.type !== "custom" && u("paginationRender", A[0])
    }

    function C() {
        i.params.pagination = createElementIfNotDefined(i, i.originalParams.pagination, i.params.pagination, {
            el: "swiper-pagination"
        });
        const T = i.params.pagination;
        if (!T.el) return;
        let M;
        typeof T.el == "string" && i.isElement && (M = i.el.querySelector(T.el)), !M && typeof T.el == "string" && (M = [...document.querySelectorAll(T.el)]), M || (M = T.el), !(!M || M.length === 0) && (i.params.uniqueNavElements && typeof T.el == "string" && Array.isArray(M) && M.length > 1 && (M = [...i.el.querySelectorAll(T.el)], M.length > 1 && (M = M.find(A => elementParents(A, ".swiper")[0] === i.el))), Array.isArray(M) && M.length === 1 && (M = M[0]), Object.assign(i.pagination, {
            el: M
        }), M = makeElementsArray(M), M.forEach(A => {
            T.type === "bullets" && T.clickable && A.classList.add(...(T.clickableClass || "").split(" ")), A.classList.add(T.modifierClass + T.type), A.classList.add(i.isHorizontal() ? T.horizontalClass : T.verticalClass), T.type === "bullets" && T.dynamicBullets && (A.classList.add(`${T.modifierClass}${T.type}-dynamic`), g = 0, T.dynamicMainBullets < 1 && (T.dynamicMainBullets = 1)), T.type === "progressbar" && T.progressbarOpposite && A.classList.add(T.progressbarOppositeClass), T.clickable && A.addEventListener("click", y), i.enabled || A.classList.add(T.lockClass)
        }))
    }

    function E() {
        const T = i.params.pagination;
        if (_()) return;
        let M = i.pagination.el;
        M && (M = makeElementsArray(M), M.forEach(A => {
            A.classList.remove(T.hiddenClass), A.classList.remove(T.modifierClass + T.type), A.classList.remove(i.isHorizontal() ? T.horizontalClass : T.verticalClass), T.clickable && (A.classList.remove(...(T.clickableClass || "").split(" ")), A.removeEventListener("click", y))
        })), i.pagination.bullets && i.pagination.bullets.forEach(A => A.classList.remove(...T.bulletActiveClass.split(" ")))
    }
    c("changeDirection", () => {
        if (!i.pagination || !i.pagination.el) return;
        const T = i.params.pagination;
        let {
            el: M
        } = i.pagination;
        M = makeElementsArray(M), M.forEach(A => {
            A.classList.remove(T.horizontalClass, T.verticalClass), A.classList.add(i.isHorizontal() ? T.horizontalClass : T.verticalClass)
        })
    }), c("init", () => {
        i.params.pagination.enabled === !1 ? w() : (C(), S(), b())
    }), c("activeIndexChange", () => {
        typeof i.snapIndex > "u" && b()
    }), c("snapIndexChange", () => {
        b()
    }), c("snapGridLengthChange", () => {
        S(), b()
    }), c("destroy", () => {
        E()
    }), c("enable disable", () => {
        let {
            el: T
        } = i.pagination;
        T && (T = makeElementsArray(T), T.forEach(M => M.classList[i.enabled ? "remove" : "add"](i.params.pagination.lockClass)))
    }), c("lock unlock", () => {
        b()
    }), c("click", (T, M) => {
        const A = M.target,
            D = makeElementsArray(i.pagination.el);
        if (i.params.pagination.el && i.params.pagination.hideOnClick && D && D.length > 0 && !A.classList.contains(i.params.pagination.bulletClass)) {
            if (i.navigation && (i.navigation.nextEl && A === i.navigation.nextEl || i.navigation.prevEl && A === i.navigation.prevEl)) return;
            const R = D[0].classList.contains(i.params.pagination.hiddenClass);
            u(R === !0 ? "paginationShow" : "paginationHide"), D.forEach(I => I.classList.toggle(i.params.pagination.hiddenClass))
        }
    });
    const P = () => {
            i.el.classList.remove(i.params.pagination.paginationDisabledClass);
            let {
                el: T
            } = i.pagination;
            T && (T = makeElementsArray(T), T.forEach(M => M.classList.remove(i.params.pagination.paginationDisabledClass))), C(), S(), b()
        },
        w = () => {
            i.el.classList.add(i.params.pagination.paginationDisabledClass);
            let {
                el: T
            } = i.pagination;
            T && (T = makeElementsArray(T), T.forEach(M => M.classList.add(i.params.pagination.paginationDisabledClass))), E()
        };
    Object.assign(i.pagination, {
        enable: P,
        disable: w,
        render: S,
        update: b,
        init: C,
        destroy: E
    })
}

function Autoplay(l) {
    let {
        swiper: i,
        extendParams: o,
        on: c,
        emit: u,
        params: p
    } = l;
    i.autoplay = {
        running: !1,
        paused: !1,
        timeLeft: 0
    }, o({
        autoplay: {
            enabled: !1,
            delay: 3e3,
            waitForTransition: !0,
            disableOnInteraction: !1,
            stopOnLastSlide: !1,
            reverseDirection: !1,
            pauseOnMouseEnter: !1
        }
    });
    let m, g, _ = p && p.autoplay ? p.autoplay.delay : 3e3,
        v = p && p.autoplay ? p.autoplay.delay : 3e3,
        x, y = new Date().getTime(),
        b, S, C, E, P, w, T;

    function M(L) {
        !i || i.destroyed || !i.wrapperEl || L.target === i.wrapperEl && (i.wrapperEl.removeEventListener("transitionend", M), !(T || L.detail && L.detail.bySwiperTouchMove) && V())
    }
    const A = () => {
            if (i.destroyed || !i.autoplay.running) return;
            i.autoplay.paused ? b = !0 : b && (v = x, b = !1);
            const L = i.autoplay.paused ? x : y + v - new Date().getTime();
            i.autoplay.timeLeft = L, u("autoplayTimeLeft", L, L / _), g = requestAnimationFrame(() => {
                A()
            })
        },
        D = () => {
            let L;
            return i.virtual && i.params.virtual.enabled ? L = i.slides.find(K => K.classList.contains("swiper-slide-active")) : L = i.slides[i.activeIndex], L ? parseInt(L.getAttribute("data-swiper-autoplay"), 10) : void 0
        },
        R = L => {
            if (i.destroyed || !i.autoplay.running) return;
            cancelAnimationFrame(g), A();
            let N = typeof L > "u" ? i.params.autoplay.delay : L;
            _ = i.params.autoplay.delay, v = i.params.autoplay.delay;
            const K = D();
            !Number.isNaN(K) && K > 0 && typeof L > "u" && (N = K, _ = K, v = K), x = N;
            const Z = i.params.speed,
                he = () => {
                    !i || i.destroyed || (i.params.autoplay.reverseDirection ? !i.isBeginning || i.params.loop || i.params.rewind ? (i.slidePrev(Z, !0, !0), u("autoplay")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(i.slides.length - 1, Z, !0, !0), u("autoplay")) : !i.isEnd || i.params.loop || i.params.rewind ? (i.slideNext(Z, !0, !0), u("autoplay")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(0, Z, !0, !0), u("autoplay")), i.params.cssMode && (y = new Date().getTime(), requestAnimationFrame(() => {
                        R()
                    })))
                };
            return N > 0 ? (clearTimeout(m), m = setTimeout(() => {
                he()
            }, N)) : requestAnimationFrame(() => {
                he()
            }), N
        },
        I = () => {
            y = new Date().getTime(), i.autoplay.running = !0, R(), u("autoplayStart")
        },
        k = () => {
            i.autoplay.running = !1, clearTimeout(m), cancelAnimationFrame(g), u("autoplayStop")
        },
        F = (L, N) => {
            if (i.destroyed || !i.autoplay.running) return;
            clearTimeout(m), L || (w = !0);
            const K = () => {
                u("autoplayPause"), i.params.autoplay.waitForTransition ? i.wrapperEl.addEventListener("transitionend", M) : V()
            };
            if (i.autoplay.paused = !0, N) {
                P && (x = i.params.autoplay.delay), P = !1, K();
                return
            }
            x = (x || i.params.autoplay.delay) - (new Date().getTime() - y), !(i.isEnd && x < 0 && !i.params.loop) && (x < 0 && (x = 0), K())
        },
        V = () => {
            i.isEnd && x < 0 && !i.params.loop || i.destroyed || !i.autoplay.running || (y = new Date().getTime(), w ? (w = !1, R(x)) : R(), i.autoplay.paused = !1, u("autoplayResume"))
        },
        B = () => {
            if (i.destroyed || !i.autoplay.running) return;
            const L = getDocument();
            L.visibilityState === "hidden" && (w = !0, F(!0)), L.visibilityState === "visible" && V()
        },
        U = L => {
            L.pointerType === "mouse" && (w = !0, T = !0, !(i.animating || i.autoplay.paused) && F(!0))
        },
        H = L => {
            L.pointerType === "mouse" && (T = !1, i.autoplay.paused && V())
        },
        Q = () => {
            i.params.autoplay.pauseOnMouseEnter && (i.el.addEventListener("pointerenter", U), i.el.addEventListener("pointerleave", H))
        },
        Y = () => {
            i.el && typeof i.el != "string" && (i.el.removeEventListener("pointerenter", U), i.el.removeEventListener("pointerleave", H))
        },
        O = () => {
            getDocument().addEventListener("visibilitychange", B)
        },
        G = () => {
            getDocument().removeEventListener("visibilitychange", B)
        };
    c("init", () => {
        i.params.autoplay.enabled && (Q(), O(), I())
    }), c("destroy", () => {
        Y(), G(), i.autoplay.running && k()
    }), c("_freeModeStaticRelease", () => {
        (C || w) && V()
    }), c("_freeModeNoMomentumRelease", () => {
        i.params.autoplay.disableOnInteraction ? k() : F(!0, !0)
    }), c("beforeTransitionStart", (L, N, K) => {
        i.destroyed || !i.autoplay.running || (K || !i.params.autoplay.disableOnInteraction ? F(!0, !0) : k())
    }), c("sliderFirstMove", () => {
        if (!(i.destroyed || !i.autoplay.running)) {
            if (i.params.autoplay.disableOnInteraction) {
                k();
                return
            }
            S = !0, C = !1, w = !1, E = setTimeout(() => {
                w = !0, C = !0, F(!0)
            }, 200)
        }
    }), c("touchEnd", () => {
        if (!(i.destroyed || !i.autoplay.running || !S)) {
            if (clearTimeout(E), clearTimeout(m), i.params.autoplay.disableOnInteraction) {
                C = !1, S = !1;
                return
            }
            C && i.params.cssMode && V(), C = !1, S = !1
        }
    }), c("slideChange", () => {
        i.destroyed || !i.autoplay.running || (P = !0)
    }), Object.assign(i.autoplay, {
        start: I,
        stop: k,
        pause: F,
        resume: V
    })
}
class WorksDetailSwiper {
    static instance = null;
    swiper = null;
    swiperContainer = null;
    clickHandler = null;
    resizeHandler = null;
    currentWorksId = null;
    currentSlide = null;
    constructor() {
        this.swiperContainer = document.querySelector(".swiper"), this.swiperContainer && (this.initializeSwiper(), this.updateActiveSlide(void 0, !0), this.setupEventHandlers())
    }
    initializeSwiper() {
        this.swiper = new Swiper(this.swiperContainer, {
            modules: [Pagination, Mousewheel],
            slidesPerView: "auto",
            spaceBetween: 40,
            centeredSlides: !1,
            freeMode: !1,
            allowTouchMove: !1,
            breakpoints: {
                769: {
                    spaceBetween: 40,
                    allowTouchMove: !0
                },
                768: {
                    spaceBetween: 15,
                    allowTouchMove: !1
                },
                480: {
                    spaceBetween: 10,
                    allowTouchMove: !1
                }
            }
        })
    }
    setupEventHandlers() {
        this.setupSlideClickHandlers(), this.setupResizeHandler()
    }
    setupSlideClickHandlers() {
        this.swiperContainer && (this.clickHandler = async () => {
            const i = event.currentTarget,
                o = i.querySelector("a");
            if (!o) return;
            event.preventDefault();
            const c = i.getAttribute("data-id"),
                u = o.getAttribute("href");
            c && u && (this.updateActiveSlide(c), (await swupPromise).navigate(u))
        }, this.swiperContainer.querySelectorAll(".swiper-slide").forEach(i => {
            i.addEventListener("click", this.clickHandler)
        }))
    }
    setupResizeHandler() {
        this.resizeHandler = () => {
            this.swiper && (this.currentSlide !== null && this.swiper.slideTo(this.currentSlide), this.swiper.update())
        }, window.addEventListener("resize", this.resizeHandler)
    }
    static getInstance() {
        return WorksDetailSwiper.instance || (WorksDetailSwiper.instance = new WorksDetailSwiper), WorksDetailSwiper.instance
    }
    static deleteInstance() {
        WorksDetailSwiper.instance ? .destroy(), WorksDetailSwiper.instance = null
    }
    updateActiveSlide(i, o) {
        if (!this.swiper || !this.swiperContainer) return;
        const c = this.getCurrentWorksId(i);
        if (!c || this.currentWorksId === c) return;
        const u = this.swiperContainer.querySelector(`[data-id="${c}"]`);
        if (!u) return;
        const p = Array.from(this.swiperContainer.querySelectorAll(".swiper-slide")),
            m = p.indexOf(u);
        if (m === -1) return;
        this.currentWorksId = c, this.currentSlide = m;
        const g = window.innerWidth <= 768;
        this.animateSlideWithFLIP(u, p, m, g, o)
    }
    getCurrentWorksId(i) {
        if (i) return i;
        const o = window.location.pathname.match(/\/works\/detail\/([^\/]+)/);
        return o ? o[1] : null
    }
    animateSlideWithFLIP(i, o, c, u, p) {
        if (!this.swiper) return;
        const m = u || p ? 0 : partialStartDuration / 1e3,
            g = this.swiper.getTranslate(),
            _ = this.swiperContainer.querySelector('[data-current="true"]');
        _ && _.removeAttribute("data-current"), i.setAttribute("data-current", "true"), _ && _ !== i && (_.style.height = "50%"), i.style.height = "100%", this.swiper.update(), this.swiper.slideTo(c, 0);
        const v = this.swiper.getTranslate();
        this.swiper.setTranslate(g);
        const x = gsapWithCSS.parseEase("power2.out"),
            y = gsapWithCSS.timeline({
                defaults: {
                    duration: m,
                    ease: x
                },
                onUpdate: () => {
                    const b = x(y.progress());
                    this.swiper.setTranslate(g + (v - g) * b)
                },
                onComplete: () => {
                    this.swiper.update(), this.swiper.slideTo(c, 0)
                }
            });
        !u && _ && _ !== i && (y.fromTo(_, {
            height: "100%"
        }, {
            height: "50%"
        }, 0), y.fromTo(i, {
            height: "50%"
        }, {
            height: "100%"
        }, 0))
    }
    destroy() {
        this.swiperContainer && this.clickHandler && this.swiperContainer.querySelectorAll(".swiper-slide").forEach(i => {
            i.removeEventListener("click", this.clickHandler)
        }), this.resizeHandler && window.removeEventListener("resize", this.resizeHandler), this.swiper ? .destroy(!0, !0), this.swiper = null, this.clickHandler = null, this.resizeHandler = null, WorksDetailSwiper.instance = null
    }
}
class PageWorksDetail extends PageSub {
    swiper = null;
    constructor() {
        super()
    }
    inStart(i) {
        super.inStart(i), setTimeout(() => {
            this.swiper = WorksDetailSwiper.getInstance(), this.swiper.updateActiveSlide()
        }, 10)
    }
}
class PageNews extends PageSub {
    newsItems = null;
    constructor() {
        super()
    }
    inStart(i) {
        super.inStart(i), this.setupAccordion(), this.setupBorderAnimation(), setTimeout(() => {
            this.handleAutoOpen()
        }, 100)
    }
    setupAccordion() {
        this.newsItems = document.querySelectorAll("[data-news-item]"), this.newsItems.forEach(i => {
            const o = i,
                c = i.parentElement ? .querySelector("[data-news-body]"),
                u = c ? .querySelector('[class*="listItem_body_wrapper"]'),
                p = o.querySelector("[data-news-title]"),
                m = o.querySelector("[data-news-icon]");
            !c || !u || !p || !m || (gsapWithCSS.set(c, {
                height: 0
            }), o.setAttribute("data-open", "false"), p.setAttribute("data-open", "false"), m.setAttribute("data-open", "false"), o.addEventListener("click", () => {
                !(o.getAttribute("data-open") === "true") ? this.openItem(o, c, u, p, m): this.closeItem(o, c, p, m)
            }))
        })
    }
    openItem(i, o, c, u, p) {
        const m = c.scrollHeight;
        gsapWithCSS.to(o, {
            height: m,
            duration: .4,
            ease: "power2.out"
        }), i.setAttribute("data-open", "true"), u.setAttribute("data-open", "true"), p.setAttribute("data-open", "true")
    }
    closeItem(i, o, c, u) {
        gsapWithCSS.to(o, {
            height: 0,
            duration: .3,
            ease: "power2.inOut"
        }), i.setAttribute("data-open", "false"), c.setAttribute("data-open", "false"), u.setAttribute("data-open", "false")
    }
    closeOtherItems(i) {
        this.newsItems ? .forEach(o => {
            if (o === i) return;
            const c = o,
                u = o.parentElement ? .querySelector("[data-news-body]"),
                p = c.querySelector("[data-news-title]"),
                m = c.querySelector("[data-news-icon]");
            u && p && m && this.closeItem(c, u, p, m)
        })
    }
    setupBorderAnimation() {
        const i = document.querySelectorAll("[data-news-id]");
        i.forEach((o, c) => {
            o.style.setProperty("--item-index", c.toString())
        }), setTimeout(() => {
            i.forEach(o => {
                o.setAttribute("data-animate", "true")
            })
        }, 400)
    }
    handleAutoOpen() {
        const o = new URLSearchParams(window.location.search).get("openNews");
        if (o) {
            const c = document.querySelector(`[data-news-id="${o}"]`);
            if (c) {
                const u = c.querySelector("[data-news-item]"),
                    p = c.querySelector("[data-news-body]"),
                    m = p ? .querySelector('[class*="listItem_body_wrapper"]'),
                    g = u ? .querySelector("[data-news-title]"),
                    _ = u ? .querySelector("[data-news-icon]");
                if (u && p && m && g && _) {
                    this.openItem(u, p, m, g, _);
                    const v = c.getBoundingClientRect().top + window.scrollY;
                    lenis.scrollTo(v, {
                        duration: 1.4,
                        offset: -100
                    })
                }
            }
        }
    }
}
class PageNewsDetail extends PageSub {
    constructor() {
        super()
    }
    inStart(i) {
        super.inStart(i)
    }
}
class PageContact extends PageSub {
    constructor() {
        super()
    }
}
class LogoSlider {
    _topSwiper = null;
    _bottomSwiper = null;
    constructor() {} in () {
        this._topSwiper = new Swiper(".collaboration-swiper-top", {
            modules: [Autoplay],
            slidesPerView: 3,
            loop: !0,
            speed: 6e3,
            autoplay: {
                delay: 0,
                disableOnInteraction: !1
            },
            allowTouchMove: !1,
            breakpoints: {
                768: {
                    slidesPerView: 6
                }
            }
        }), this._bottomSwiper = new Swiper(".collaboration-swiper-bottom", {
            modules: [Autoplay],
            slidesPerView: 3,
            loop: !0,
            speed: 6e3,
            autoplay: {
                delay: 0,
                disableOnInteraction: !1,
                reverseDirection: !0
            },
            allowTouchMove: !1,
            breakpoints: {
                768: {
                    slidesPerView: 6
                }
            }
        })
    }
    out() {
        this._topSwiper && (this._topSwiper.destroy(), this._topSwiper = null), this._bottomSwiper && (this._bottomSwiper.destroy(), this._bottomSwiper = null)
    }
}
gsapWithCSS.registerPlugin(ScrollTriggerExports.ScrollTrigger);
class AboutAnimations {
    _scrollTriggers = [];
    constructor() {} in () {
        this._animateGalleryImages()
    }
    _animateTextElements() {
        let i = 0;
        const o = document.querySelector('[class*="about_mission_title"]');
        o && this._animateTextCharByChar(o, i, !0);
        const c = document.querySelector('[class*="about_mission_text"]');
        c && this._animateTextCharByChar(c, i, !0);
        const u = document.querySelector('[class*="about_description"]');
        u && (this._animateTextCharByChar(u, i, !0), i += 1);
        const p = document.querySelector('[class*="about_img"]');
        if (p) {
            gsapWithCSS.set(p, {
                y: 10,
                opacity: 0
            });
            const m = ScrollTriggerExports.ScrollTrigger.create({
                trigger: p,
                start: "top 80%",
                end: "bottom 20%",
                onEnter: () => {
                    gsapWithCSS.to(p, {
                        y: 0,
                        opacity: 1,
                        duration: 1.2,
                        ease: "power1.out",
                        delay: i
                    })
                }
            });
            this._scrollTriggers.push(m)
        }
    }
    _animateTextCharByChar(i, o = 0, c = !1) {
        const p = (i.textContent || "").split("");
        i.innerHTML = p.map(_ => `<span style="display: inline-block;">${_===" "?"&nbsp;":_}</span>`).join("");
        const m = gsapWithCSS.utils.toArray(i.children);
        gsapWithCSS.set(m, {
            y: c ? 0 : 20,
            opacity: 0
        });
        const g = ScrollTriggerExports.ScrollTrigger.create({
            trigger: i,
            start: "top 80%",
            end: "bottom 20%",
            onEnter: () => {
                const _ = {
                    opacity: 1,
                    duration: 2,
                    ease: "power1.out",
                    stagger: .004,
                    delay: o
                };
                c || (_.y = 0), gsapWithCSS.to(m, _)
            }
        });
        this._scrollTriggers.push(g)
    }
    _animateGalleryImages() {
        const i = document.querySelectorAll('[class*="gallery_item"]');
        i.length !== 0 && (gsapWithCSS.set(i, {
            y: 50,
            opacity: 0,
            transition: "none"
        }), i.forEach((o, c) => {
            const u = ScrollTriggerExports.ScrollTrigger.create({
                trigger: o,
                start: "top 85%",
                end: "bottom 15%",
                onEnter: () => {
                    gsapWithCSS.to(o, {
                        y: 0,
                        opacity: 1,
                        duration: 1,
                        ease: "power1.out",
                        delay: c * .1,
                        clearProps: "transition"
                    })
                }
            });
            this._scrollTriggers.push(u)
        }))
    }
    out() {
        this._scrollTriggers.forEach(i => {
            i && i.kill()
        }), this._scrollTriggers = []
    }
}
class PageAbout extends PageSub {
    _logoSlider;
    _aboutAnimations;
    constructor() {
        super(), this._logoSlider = new LogoSlider, this._aboutAnimations = new AboutAnimations
    }
    inStart(i) {
        super.inStart(i), this._logoSlider.in(), this._aboutAnimations.in()
    }
    outStart(i) {
        super.outStart(i), this._logoSlider.out(), this._aboutAnimations.out()
    }
}
class PageManager {
    pages;
    currentPage;
    currentPageName = "";
    constructor() {
        this.pages = new Map([
            ["top", new PageTop],
            ["stellla", new PageStellla],
            ["works", new PageSub],
            ["works-detail", new PageWorksDetail],
            ["news", new PageNews],
            ["news-detail", new PageNewsDetail],
            ["contact", new PageContact],
            ["about", new PageAbout],
            ["sub", new PageSub]
        ]), this.currentPage = null
    }
    getPageNameFromUrl(i) {
        const o = i.split("?")[0];
        if (o === "/") return "top";
        const c = o.substring(1).split("/");
        return c.length >= 3 && c[0] === "works" && c[1] === "detail" ? "works-detail" : c.length >= 3 && c[0] === "news" && c[1] === "detail" ? "news-detail" : c[0] || "sub"
    }
    getCurrentPageName() {
        return this.currentPageName
    }
    inStart(i) {
        const o = this.currentPageName,
            c = this.getPageNameFromUrl(i.to.url);
        transition.setPageInfo(o, c), pageLoadingManager.setCurrentPathname(i.to.url);
        const u = this.pages.get(c) || this.pages.get("sub");
        u && (this.currentPage && this.currentPage.outEnd(i), this.currentPage = u, this.currentPageName = c, this.currentPage.inStart(i))
    }
    inEnd(i) {
        this.currentPage && this.currentPage.inEnd(i)
    }
    contentReplace(i) {
        this.currentPage && this.currentPage.contentReplace(i)
    }
    outStart(i) {
        this.currentPage && this.currentPage.outStart(i)
    }
    outEnd(i) {
        this.currentPage && (this.currentPage.outEnd(i), this.currentPage = null)
    }
}

function calculateMissionVisionSnapArray(l) {
    const i = l.children.length;
    let o = 0;
    for (let p = 0; p < i; p++) o += Number(l.children[p].getAttribute("data-snap-ratio") || "1");
    o = o - 1;
    const c = [.5 / o];
    let u = 0;
    for (let p = 0; p < i; p++) {
        const m = Number(l.children[p].getAttribute("data-snap-ratio") || "1") / o;
        u += m, c.push(u)
    }
    return c
}

function calculateServiceSnapArray(l) {
    const i = [];
    for (let o = 0; o < l - 1; o++) i.push(o * (1 / (l - .5)));
    return i
}

function getServiceItemName(l, i) {
    return l.getAttribute("data-service_scroll_item") || "service_" + i
}
const sectionNames = ["kv", "works_intro", "works", "works_outro", "mission_in", "mission", "mission_out", "vision", "vision_out", "service_in", "service", "stellla"];
class SectionConfig {
    name;
    element;
    config;
    constructor(i, o, c) {
        this.name = i, this.element = o, this.config = c
    }
    getCurrentConfig() {
        const i = deviceManager.isSPLayout,
            o = {
                triggerId: this.config.triggerId,
                pathname: this.config.pathname,
                trigger: this.config.trigger
            };
        if (i && this.config.sp) {
            const {
                triggerId: _,
                pathname: v,
                trigger: x,
                sp: y,
                ...b
            } = this.config, S = { ...o,
                ...b
            };
            for (const [C, E] of Object.entries(this.config.sp)) E === void 0 ? delete S[C] : S[C] = E;
            return S
        }
        const {
            triggerId: c,
            pathname: u,
            trigger: p,
            sp: m,
            ...g
        } = this.config;
        return { ...o,
            ...g
        }
    }
}
class TopScrollManager extends EventEmitter$1 {
    _sections;
    _sectionConfigs;
    _currentSection = null;
    constructor() {
        super(), this._sections = new Map, this._sectionConfigs = new Map, ScrollTriggerFactory.setActivePage("/")
    }
    registerSection(i, o, c) {
        if (this._sections.has(i) && this._sections.get(i).scrollTrigger.kill(), c.sp) {
            const u = new SectionConfig(i, o, c);
            this._sectionConfigs.set(i, u);
            const p = u.getCurrentConfig(),
                m = ScrollTriggerFactory.create(p),
                g = {
                    name: i,
                    element: o,
                    scrollTrigger: m
                };
            return this._sections.set(i, g), g
        } else {
            const {
                triggerId: u,
                pathname: p,
                trigger: m,
                ...g
            } = c, _ = {
                triggerId: u,
                pathname: p,
                trigger: m,
                ...g
            }, v = ScrollTriggerFactory.create(_), x = {
                name: i,
                element: o,
                scrollTrigger: v
            };
            return this._sections.set(i, x), x
        }
    }
    createTrigger() {
        const i = document.querySelector('[data-top_section="kv"]');
        this.registerSection("kv", i, {
            triggerId: "top_kv",
            pathname: "/",
            trigger: i,
            start: "top bottom",
            end: "bottom bottom-=100px",
            onEnter: () => this._onSectionEnter("kv", "enter"),
            onEnterBack: () => this._onSectionEnter("kv", "enterBack")
        });
        const o = document.querySelector('[data-top_section="works_intro"]');
        this.registerSection("works_intro", o, {
            triggerId: "top_works_intro",
            pathname: "/",
            trigger: o,
            start: "top bottom",
            end: "bottom bottom",
            onEnter: () => this._onSectionEnter("works_intro", "enter"),
            onEnterBack: () => this._onSectionEnter("works_intro", "enterBack")
        });
        const c = document.querySelector('[data-top_section="works"]'),
            u = c.querySelectorAll("[data-top_works_item]");
        this.registerSection("works", c, {
            triggerId: "top_works",
            pathname: "/",
            trigger: c,
            start: "top top",
            end: "bottom bottom",
            snap: {
                snapTo: 1 / (u.length - 1),
                duration: 1,
                directional: !1
            }
        }), this.registerSection("works_event", c, {
            triggerId: "top_works_event",
            pathname: "/",
            trigger: c,
            start: "top bottom",
            end: "bottom bottom",
            onEnter: () => this._onSectionEnter("works", "enter"),
            onEnterBack: () => this._onSectionEnter("works", "enterBack")
        }), this.registerSection("works_progress", c, {
            triggerId: "top_works_progress",
            pathname: "/",
            trigger: c,
            start: "top bottom",
            end: "bottom top",
            onUpdate: w => this.emit("works/progress", w.progress)
        }), u.forEach((w, T) => {
            this.registerSection(`works_item_${T}`, w, {
                triggerId: `top_works_item_${T}`,
                pathname: "/",
                trigger: w,
                start: "top center",
                end: "bottom center",
                onEnter: () => this.emit("works/item_enter", T),
                onEnterBack: () => this.emit("works/item_enter", T),
                onLeave: () => this.emit("works/item_leave", T),
                onLeaveBack: () => this.emit("works/item_leave", T)
            })
        });
        const p = document.querySelector('[data-top_section="works_outro"]');
        this.registerSection("works_outro", p, {
            triggerId: "top_works_outro",
            pathname: "/",
            trigger: p,
            start: "top bottom",
            end: "bottom bottom",
            onEnter: () => this._onSectionEnter("works_outro", "enter"),
            onEnterBack: () => this._onSectionEnter("works_outro", "enterBack")
        });
        const m = document.querySelector('[data-top_section="mission_in"]');
        this.registerSection("mission_in", m, {
            triggerId: "top_mission_in",
            pathname: "/",
            trigger: m,
            start: "top bottom",
            end: "top top",
            onEnter: () => this._onSectionEnter("mission_in", "enter"),
            onEnterBack: () => this._onSectionEnter("mission_in", "enterBack"),
            onUpdate: w => this.emit("mission_in/progress", w.progress)
        });
        const g = document.querySelector('[data-top_section="mission"]');
        this.registerSection("mission", g, {
            triggerId: "top_mission",
            pathname: "/",
            trigger: g,
            start: "top bottom",
            end: "bottom bottom",
            onEnter: () => this._onSectionEnter("mission", "enter"),
            onEnterBack: () => this._onSectionEnter("mission", "enterBack")
        });
        const _ = document.querySelector('[data-top_section="vision"]');
        this.registerSection("vision", _, {
            triggerId: "top_vision",
            pathname: "/",
            trigger: _,
            start: "top bottom",
            end: "top top",
            onEnter: () => this._onSectionEnter("vision", "enter"),
            onEnterBack: () => this._onSectionEnter("vision", "enterBack"),
            sp: {
                start: "top bottom",
                end: "top 70%"
            }
        });
        const v = document.querySelector('[data-top_section="vision_out"]');
        this.registerSection("vision_out", v, {
            triggerId: "top_vision_out",
            pathname: "/",
            trigger: v,
            start: "top bottom",
            end: "top top",
            onEnter: () => this._onSectionEnter("vision_out", "enter"),
            onEnterBack: () => this._onSectionEnter("vision_out", "enterBack"),
            sp: {
                start: "top bottom-=50%",
                end: "top top"
            }
        }), document.querySelectorAll("[data-snapper]").forEach(w => {
            const T = calculateMissionVisionSnapArray(w);
            this.registerSection("mission_vision_snapper", w, {
                triggerId: "top_mission_vision_snapper",
                pathname: "/",
                trigger: w,
                start: "top top",
                end: "bottom bottom",
                snap: {
                    snapTo: T,
                    duration: 1,
                    directional: !1
                },
                sp: {
                    start: "top top",
                    end: "bottom bottom",
                    snap: void 0
                }
            })
        });
        const y = document.querySelector('[data-section_wrap="vision_service"]');
        this.registerSection("vision_service_wrap", y, {
            triggerId: "top_vision_service_wrap",
            pathname: "/",
            trigger: y,
            start: "top bottom",
            end: "bottom top",
            snap: {
                snapTo: [0, 1],
                duration: 1,
                directional: !1
            },
            sp: {
                start: "top 30%",
                end: "bottom top",
                snap: {
                    snapTo: [1],
                    duration: 1,
                    directional: !1
                }
            }
        });
        const b = document.querySelector('[data-top_section="service_in"]');
        this.registerSection("service_in", b, {
            triggerId: "top_service_in",
            pathname: "/",
            trigger: b,
            start: "top bottom+=150%",
            end: "top center",
            onEnter: () => this._onSectionEnter("service_in", "enter"),
            onEnterBack: () => this._onSectionEnter("service_in", "enterBack")
        });
        const S = document.querySelector('[data-top_section="service"]'),
            C = S.querySelectorAll("[data-service_scroll_item]");
        this.registerSection("service_snap", S, {
            triggerId: "top_service",
            pathname: "/",
            trigger: S,
            start: "top top",
            end: "bottom bottom",
            snap: {
                snapTo: calculateServiceSnapArray(C.length),
                duration: 1,
                directional: !1
            }
        }), this.registerSection("service_progress", S, {
            triggerId: "top_service_progress",
            pathname: "/",
            trigger: S,
            start: "top bottom",
            end: "bottom top"
        }), C.forEach((w, T) => {
            const M = getServiceItemName(w, T);
            this.registerSection(`service_scroll_item_${T}`, w, {
                triggerId: `top_service_scroll_item_${T}`,
                pathname: "/",
                trigger: w,
                start: "top bottom",
                end: "bottom bottom",
                onEnter: () => {
                    this.emit("service/item_enter", T), this._onSectionEnter(M, "enter")
                },
                onEnterBack: () => {
                    this.emit("service/item_enter", T), this._onSectionEnter(M, "enterBack")
                },
                onLeave: () => {
                    this.emit("service/item_leave", T)
                },
                onLeaveBack: () => {
                    this.emit("service/item_leave", T)
                }
            })
        });
        const E = document.querySelector('[data-service_scroll_item="stellla"]');
        this.registerSection("stellla_in", E, {
            triggerId: "top_stellla_in",
            pathname: "/",
            trigger: E,
            start: "top bottom",
            end: "bottom bottom"
        });
        const P = document.querySelector('[data-top_section="stellla"]');
        this.registerSection("stellla", P, {
            triggerId: "top_stellla",
            pathname: "/",
            trigger: P,
            start: "top bottom",
            end: "bottom bottom",
            snap: {
                snapTo: [.9],
                duration: 1,
                directional: !1
            },
            onEnterBack: () => this._onSectionEnter("stellla", "enterBack"),
            onLeave: () => this._onSectionEnter("footer", "enter")
        })
    } in () {
        this.createTrigger(), requestAnimationFrame(() => {
            this.checkCurrentSection(), ScrollTriggerFactory.notifyAllInitialized("/"), this.emit("scroll_triggers_initialized")
        })
    }
    out() {
        ScrollTriggerFactory.killAll(), this._sections.clear(), this._sectionConfigs.clear(), this._currentSection = null, document.body.removeAttribute("data-current_section")
    }
    checkCurrentSection() {
        this._sections.forEach((i, o) => {
            if (i.scrollTrigger.isActive) {
                if (sectionNames.includes(o) && this._onSectionEnter(o, "enter"), o.startsWith("works_item_")) {
                    const c = parseInt(o.replace("works_item_", ""));
                    this.emit("works/item_enter", c)
                } else if (o.startsWith("service_scroll_item_")) {
                    const c = parseInt(o.replace("service_scroll_item_", ""));
                    this.emit("service/item_enter", c)
                }
            }
        })
    }
    _onSectionEnter(i, o) {
        this.emit("section/enter", {
            sectionName: i,
            direction: o
        }), this._currentSection !== i && (this._currentSection = i, document.body.setAttribute("data-current_section", i), this.emit("section/change", {
            sectionName: i,
            direction: o
        }))
    }
    getTrigger(i) {
        const o = this._sections.get(i);
        return o ? o.scrollTrigger : null
    }
}
const topScrollSections = [{
    id: "kv",
    label: "TOP",
    scrollTriggerIds: ["works_intro"],
    subsections: [{
        index: 0
    }, {
        index: 1
    }]
}, {
    id: "works",
    label: "WORKS",
    scrollTriggerIds: ["works", "works_outro", "mission_in"],
    subsections: [{
        index: 0
    }, {
        index: 1
    }]
}, {
    id: "mission",
    label: "ABOUT",
    scrollTriggerIds: ["mission"],
    subsections: [{
        index: 0
    }, {
        index: 1
    }]
}, {
    id: "vision",
    label: "VISION",
    scrollTriggerIds: ["vision", "vision_out", "service_in"],
    subsections: [{
        index: 0
    }, {
        index: 1
    }]
}, {
    id: "service",
    label: "SERVICE",
    scrollTriggerIds: ["service", "stellla"],
    subsections: [{
        index: 0
    }, {
        index: 1
    }]
}];
class TopScrollIndicatorController {
    _element = null;
    _sectionItems = null;
    _subsectionItems = null;
    _isInitialized = !1;
    constructor() {} in () {
        this._initializeIfNeeded()
    }
    out() {
        this._cleanup()
    }
    update() {
        deviceManager.isSPLayout || this._updateIndicatorStates()
    }
    _initializeIfNeeded() {
        if (deviceManager.isSPLayout) {
            this._hideIndicator();
            return
        }
        if (this._isInitialized) {
            this._showIndicator();
            return
        }
        this._element = document.querySelector("[data-top-scroll-indicator]"), this._element && (this._sectionItems = this._element.querySelectorAll("[data-section]"), this._subsectionItems = this._element.querySelectorAll("[data-subsection]")), !(!this._element || !this._sectionItems || !this._subsectionItems) && (this._sectionItems.forEach(i => {
            const o = i.querySelector("[data-section-label]");
            o && o.addEventListener("click", () => {
                const c = i.getAttribute("data-section");
                c && this._scrollToSection(c)
            })
        }), this._subsectionItems.forEach(i => {
            i.addEventListener("click", () => {
                const o = i.closest("[data-section]") ? .getAttribute("data-section"),
                    c = i.getAttribute("data-subsection");
                o && c && this._scrollToSubsection(o, parseInt(c))
            })
        }), this._updateIndicatorStates(), this._showIndicator(), this._isInitialized = !0)
    }
    _cleanup() {
        this._isInitialized = !1
    }
    _showIndicator() {
        this._element && (this._element.style.display = "block")
    }
    _hideIndicator() {
        this._element && (this._element.style.display = "none")
    }
    _updateIndicatorStates() {
        if (!this._element) return;
        const i = this._getCurrentActiveSection();
        topScrollSections.forEach((o, c) => {
            const u = this._calculateSectionProgress(o),
                p = c === i && (c === 0 || u > 0),
                m = this._element.querySelector(`[data-section="${o.id}"]`);
            m && (p ? m.setAttribute("data-active", "true") : m.removeAttribute("data-active")), p ? this._updateSubsectionStates(o, u) : this._clearSubsectionStates(o)
        })
    }
    _getCurrentActiveSection() {
        const i = topScrollSections.map((p, m) => {
                const g = this._calculateSectionProgress(p);
                return {
                    index: m,
                    section: p,
                    progress: g
                }
            }),
            o = i.filter(p => p.progress > 0 && p.progress < 1),
            c = i.filter(p => p.progress === 1),
            u = i.filter(p => p.progress === 0);
        return o.length > 0 ? o[o.length - 1].index : c.length > 0 ? c[c.length - 1].index : u.length > 0 ? u[0].index : 0
    }
    _calculateSectionProgress(i) {
        if (i.scrollTriggerIds.length === 0) return 0;
        const o = i.scrollTriggerIds.map(c => topScrollManager.getTrigger(c) ? .progress || 0);
        return Math.max(...o)
    }
    _updateSubsectionStates(i, o) {
        if (!this._element || i.subsections.length === 0) return;
        const c = i.subsections.length,
            u = Math.max(0, Math.min(1, o)),
            p = Math.floor(u * c);
        i.subsections.forEach((m, g) => {
            const _ = this._element.querySelector(`[data-section="${i.id}"] [data-subsection="${m.index}"]`),
                v = g < p;
            _ && (v ? _.setAttribute("data-active", "true") : _.removeAttribute("data-active"))
        })
    }
    _clearSubsectionStates(i) {
        !this._element || i.subsections.length === 0 || i.subsections.forEach(o => {
            const c = this._element.querySelector(`[data-section="${i.id}"] [data-subsection="${o.index}"]`);
            c && c.toggleAttribute("data-active", !1)
        })
    }
    _scrollToSection(i) {
        const o = topScrollSections.find(p => p.id === i);
        if (!o || o.scrollTriggerIds.length === 0) return;
        const c = o.scrollTriggerIds[0],
            u = topScrollManager.getTrigger(c);
        if (u && u.trigger) {
            const m = u.trigger.offsetTop;
            lenis.scrollTo(m, {
                duration: 1.2,
                easing: g => Math.min(1, 1.001 - Math.pow(2, -10 * g))
            })
        }
    }
    _scrollToSubsection(i, o) {
        const c = topScrollSections.find(g => g.id === i);
        if (!c || c.scrollTriggerIds.length === 0) return;
        const u = Math.min(o, c.scrollTriggerIds.length - 1),
            p = c.scrollTriggerIds[u],
            m = topScrollManager.getTrigger(p);
        if (m && m.trigger) {
            const g = m.trigger,
                _ = (o + .5) / c.subsections.length,
                v = g.offsetHeight,
                x = g.offsetTop + v * _;
            lenis.scrollTo(x, {
                duration: 1.2,
                easing: y => Math.min(1, 1.001 - Math.pow(2, -10 * y))
            })
        }
    }
    dispose() {
        this._cleanup()
    }
}
class Lerper {
    _beforeTime;
    _values;
    constructor() {
        this._beforeTime = null, this._values = new Map
    }
    set(i, o, c = 1) {
        const u = this._values.get(i);
        return u === void 0 ? (this._values.set(i, {
            target: o,
            current: o,
            velocity: 0,
            multiplier: c
        }), o) : (u.target = o, u.velocity = u.target - u.current, u.current)
    }
    get(i) {
        return this._values.get(i)
    }
    update(i) {
        this._beforeTime === null && (this._beforeTime = i);
        const o = (i - this._beforeTime) / 1e3;
        this._beforeTime = i, this._values.forEach((c, u) => {
            c.velocity = c.target - c.current, c.current += c.velocity * Math.min(1, o * (10 * c.multiplier))
        })
    }
}
class DebugManager {
    _pane = null;
    _isEnabled = !1;
    constructor() {
        this._isEnabled = !1
    }
    init() {
        this._isEnabled && (this._pane = new Pane({
            title: "Debug Menu",
            expanded: !1
        }), console.warn("DebugManager: createWindow method needs to be updated to use container-based approach"), this._createSectionNavigation())
    }
    applyTheme(i) {
        i.style.setProperty("--tp-base-background-color", "rgba(0, 0, 0, 0.8)"), i.style.setProperty("--tp-container-background-color", "transparent"), i.style.setProperty("--tp-input-background-color", "rgba(255, 255, 255, 0.9)"), i.style.setProperty("--tp-button-background-color", "rgba(255, 255, 255, 0.9)"), i.style.setProperty("--tp-label-foreground-color", "#ffffff"), i.style.setProperty("--tp-input-foreground-color", "#000000"), i.style.setProperty("--tp-button-foreground-color", "#000000")
    }
    _createSectionNavigation() {
        if (!this._pane) return;
        const i = this._pane.addFolder({
            title: "Quick Jump",
            expanded: !0
        });
        ["kv", "works", "mission", "vision", "service", "stellla"].forEach(c => {
            i.addButton({
                title: this._getSectionDisplayName(c)
            }).on("click", () => {
                this._jumpToSection(c)
            })
        })
    }
    _jumpToSection(i) {
        const o = topScrollManager.getTrigger(i);
        if (!o) {
            console.warn(`Section "${i}" not found`);
            return
        }
        const c = o.vars.trigger;
        c && c.scrollIntoView({
            behavior: "smooth",
            block: "start"
        })
    }
    _getSectionDisplayName(i) {
        return {
            kv: "KV (Key Visual)",
            works_intro: "Works Intro",
            works: "Works",
            works_outro: "Works Outro",
            mission_in: "Mission In",
            mission: "Mission",
            vision: "Vision",
            service_in: "Service In",
            service: "Service",
            stellla: "Stellla"
        }[i] || i
    }
    dispose() {
        this._pane && (this._pane.dispose(), this._pane = null)
    }
}
class PageLoadingManager extends EventEmitter$1 {
    _loadingItems;
    _isLoading;
    _totalProgress;
    _webGLItemsTotal;
    _webGLItemsLoaded;
    _isInitialLoad;
    _scrollTriggerRegistrations;
    _currentPathname;
    _loadingCompletePromise;
    _loadingCompleteResolve;
    _shaderPrecompileCompleted;
    constructor() {
        super(), this._isLoading = !1, this._totalProgress = 0, this._loadingItems = new Map, this._webGLItemsTotal = 0, this._webGLItemsLoaded = 0, this._isInitialLoad = !0, this._scrollTriggerRegistrations = new Map, this._currentPathname = null, this._loadingCompletePromise = null, this._loadingCompleteResolve = null, this._shaderPrecompileCompleted = !1, this._setupWebGLLoadingManager(), this._isInitialLoad && this.startLoading()
    }
    _setupWebGLLoadingManager() {
        loadingManager.onProgress = (i, o, c) => {
            this._webGLItemsLoaded = o, this._webGLItemsTotal = c;
            for (let u = 0; u < c; u++) {
                const p = `webgl_asset_${u}`;
                if (!this._loadingItems.has(p)) this._loadingItems.set(p, {
                    id: p,
                    completed: u < o
                });
                else if (u < o) {
                    const m = this._loadingItems.get(p);
                    m.completed = !0
                }
            }
            this._isLoading && this._calculateProgress()
        }, loadingManager.onLoad = () => {
            for (let i = 0; i < this._webGLItemsTotal; i++) {
                const o = `webgl_asset_${i}`,
                    c = this._loadingItems.get(o);
                c && (c.completed = !0)
            }
            this._isLoading && this._calculateProgress()
        }, loadingManager.onError = i => {
            console.error(`Asset loading failed: ${i}`), this.emit("error", `Failed to load asset: ${i}`)
        }
    }
    startShaderPrecompile() {
        this._shaderPrecompileCompleted || (this._loadingItems.set("shader_precompile", {
            id: "shader_precompile",
            completed: !1
        }), this._isLoading && this._calculateProgress())
    }
    updateShaderPrecompileProgress(i) {
        this.emit("shader_precompile_progress", {
            type: "shader_precompile",
            ...i
        })
    }
    completeShaderPrecompile() {
        this._shaderPrecompileCompleted = !0;
        const i = this._loadingItems.get("shader_precompile");
        i && (i.completed = !0, this._isLoading && this._calculateProgress()), this.emit("shader_precompile_complete")
    }
    _calculateProgress() {
        const i = Array.from(this._loadingItems.values()).filter(c => c.completed).length,
            o = this._loadingItems.size;
        this._totalProgress = o > 0 ? i / o : 0, this.emit("progress", {
            totalProgress: this._totalProgress,
            completedCount: i,
            totalCount: o
        }), i === o && o > 0 && this._completeLoading()
    }
    _completeLoading() {
        this._isLoading = !1, this._totalProgress = 1, this._isInitialLoad = !1, this.emit("complete"), this._loadingCompleteResolve && (this._loadingCompleteResolve(), this._loadingCompleteResolve = null, this._loadingCompletePromise = null)
    }
    registerScrollTrigger(i, o) {
        const c = {
            pathname: i,
            triggerId: o,
            initialized: !1
        };
        this._scrollTriggerRegistrations.set(o, c), this._currentPathname === i && this._isLoading && (this._loadingItems.set(o, {
            id: o,
            completed: !1
        }), this._calculateProgress())
    }
    notifyScrollTriggerInitialized(i) {
        const o = this._scrollTriggerRegistrations.get(i);
        if (o) {
            o.initialized = !0;
            const c = this._loadingItems.get(i);
            c && (c.completed = !0, this._isLoading && this._calculateProgress())
        }
    }
    setCurrentPathname(i) {
        this._currentPathname = i, this._scrollTriggerRegistrations.forEach(o => {
            o.initialized = !1
        })
    }
    async startLoading() {
        if (!(this._isLoading || !this._isInitialLoad)) {
            this._isLoading = !0, this._loadingItems.clear(), this._totalProgress = 0, this._loadingCompletePromise = new Promise(i => {
                this._loadingCompleteResolve = i
            }), this.emit("start"), this._currentPathname && Array.from(this._scrollTriggerRegistrations.values()).filter(o => o.pathname === this._currentPathname).forEach(o => {
                this._loadingItems.set(o.triggerId, {
                    id: o.triggerId,
                    completed: o.initialized
                })
            });
            for (let i = 0; i < this._webGLItemsTotal; i++) this._loadingItems.set(`webgl_asset_${i}`, {
                id: `webgl_asset_${i}`,
                completed: i < this._webGLItemsLoaded
            });
            this._calculateProgress()
        }
    }
    getLoadingState() {
        return {
            isLoading: this._isLoading,
            totalProgress: this._totalProgress,
            items: Array.from(this._loadingItems.values())
        }
    }
    cancel() {
        this._isLoading = !1, this._loadingItems.clear(), this._totalProgress = 0, this.emit("cancel"), this._loadingCompleteResolve && (this._loadingCompleteResolve(), this._loadingCompleteResolve = null, this._loadingCompletePromise = null)
    }
    waitForLoading() {
        return !this._isInitialLoad || !this._isLoading ? Promise.resolve() : this._loadingCompletePromise || Promise.resolve()
    }
}
var howler = {};
/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
var hasRequiredHowler;

function requireHowler() {
    return hasRequiredHowler || (hasRequiredHowler = 1, function(l) {
        (function() {
            var i = function() {
                this.init()
            };
            i.prototype = {
                init: function() {
                    var y = this || o;
                    return y._counter = 1e3, y._html5AudioPool = [], y.html5PoolSize = 10, y._codecs = {}, y._howls = [], y._muted = !1, y._volume = 1, y._canPlayEvent = "canplaythrough", y._navigator = typeof window < "u" && window.navigator ? window.navigator : null, y.masterGain = null, y.noAudio = !1, y.usingWebAudio = !0, y.autoSuspend = !0, y.ctx = null, y.autoUnlock = !0, y._setup(), y
                },
                volume: function(y) {
                    var b = this || o;
                    if (y = parseFloat(y), b.ctx || x(), typeof y < "u" && y >= 0 && y <= 1) {
                        if (b._volume = y, b._muted) return b;
                        b.usingWebAudio && b.masterGain.gain.setValueAtTime(y, o.ctx.currentTime);
                        for (var S = 0; S < b._howls.length; S++)
                            if (!b._howls[S]._webAudio)
                                for (var C = b._howls[S]._getSoundIds(), E = 0; E < C.length; E++) {
                                    var P = b._howls[S]._soundById(C[E]);
                                    P && P._node && (P._node.volume = P._volume * y)
                                }
                        return b
                    }
                    return b._volume
                },
                mute: function(y) {
                    var b = this || o;
                    b.ctx || x(), b._muted = y, b.usingWebAudio && b.masterGain.gain.setValueAtTime(y ? 0 : b._volume, o.ctx.currentTime);
                    for (var S = 0; S < b._howls.length; S++)
                        if (!b._howls[S]._webAudio)
                            for (var C = b._howls[S]._getSoundIds(), E = 0; E < C.length; E++) {
                                var P = b._howls[S]._soundById(C[E]);
                                P && P._node && (P._node.muted = y ? !0 : P._muted)
                            }
                    return b
                },
                stop: function() {
                    for (var y = this || o, b = 0; b < y._howls.length; b++) y._howls[b].stop();
                    return y
                },
                unload: function() {
                    for (var y = this || o, b = y._howls.length - 1; b >= 0; b--) y._howls[b].unload();
                    return y.usingWebAudio && y.ctx && typeof y.ctx.close < "u" && (y.ctx.close(), y.ctx = null, x()), y
                },
                codecs: function(y) {
                    return (this || o)._codecs[y.replace(/^x-/, "")]
                },
                _setup: function() {
                    var y = this || o;
                    if (y.state = y.ctx && y.ctx.state || "suspended", y._autoSuspend(), !y.usingWebAudio)
                        if (typeof Audio < "u") try {
                            var b = new Audio;
                            typeof b.oncanplaythrough > "u" && (y._canPlayEvent = "canplay")
                        } catch {
                            y.noAudio = !0
                        } else y.noAudio = !0;
                    try {
                        var b = new Audio;
                        b.muted && (y.noAudio = !0)
                    } catch {}
                    return y.noAudio || y._setupCodecs(), y
                },
                _setupCodecs: function() {
                    var y = this || o,
                        b = null;
                    try {
                        b = typeof Audio < "u" ? new Audio : null
                    } catch {
                        return y
                    }
                    if (!b || typeof b.canPlayType != "function") return y;
                    var S = b.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                        C = y._navigator ? y._navigator.userAgent : "",
                        E = C.match(/OPR\/(\d+)/g),
                        P = E && parseInt(E[0].split("/")[1], 10) < 33,
                        w = C.indexOf("Safari") !== -1 && C.indexOf("Chrome") === -1,
                        T = C.match(/Version\/(.*?) /),
                        M = w && T && parseInt(T[1], 10) < 15;
                    return y._codecs = {
                        mp3: !!(!P && (S || b.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                        mpeg: !!S,
                        opus: !!b.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                        ogg: !!b.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        oga: !!b.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        wav: !!(b.canPlayType('audio/wav; codecs="1"') || b.canPlayType("audio/wav")).replace(/^no$/, ""),
                        aac: !!b.canPlayType("audio/aac;").replace(/^no$/, ""),
                        caf: !!b.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                        m4a: !!(b.canPlayType("audio/x-m4a;") || b.canPlayType("audio/m4a;") || b.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        m4b: !!(b.canPlayType("audio/x-m4b;") || b.canPlayType("audio/m4b;") || b.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        mp4: !!(b.canPlayType("audio/x-mp4;") || b.canPlayType("audio/mp4;") || b.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        weba: !!(!M && b.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                        webm: !!(!M && b.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                        dolby: !!b.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                        flac: !!(b.canPlayType("audio/x-flac;") || b.canPlayType("audio/flac;")).replace(/^no$/, "")
                    }, y
                },
                _unlockAudio: function() {
                    var y = this || o;
                    if (!(y._audioUnlocked || !y.ctx)) {
                        y._audioUnlocked = !1, y.autoUnlock = !1, !y._mobileUnloaded && y.ctx.sampleRate !== 44100 && (y._mobileUnloaded = !0, y.unload()), y._scratchBuffer = y.ctx.createBuffer(1, 1, 22050);
                        var b = function(S) {
                            for (; y._html5AudioPool.length < y.html5PoolSize;) try {
                                var C = new Audio;
                                C._unlocked = !0, y._releaseHtml5Audio(C)
                            } catch {
                                y.noAudio = !0;
                                break
                            }
                            for (var E = 0; E < y._howls.length; E++)
                                if (!y._howls[E]._webAudio)
                                    for (var P = y._howls[E]._getSoundIds(), w = 0; w < P.length; w++) {
                                        var T = y._howls[E]._soundById(P[w]);
                                        T && T._node && !T._node._unlocked && (T._node._unlocked = !0, T._node.load())
                                    }
                            y._autoResume();
                            var M = y.ctx.createBufferSource();
                            M.buffer = y._scratchBuffer, M.connect(y.ctx.destination), typeof M.start > "u" ? M.noteOn(0) : M.start(0), typeof y.ctx.resume == "function" && y.ctx.resume(), M.onended = function() {
                                M.disconnect(0), y._audioUnlocked = !0, document.removeEventListener("touchstart", b, !0), document.removeEventListener("touchend", b, !0), document.removeEventListener("click", b, !0), document.removeEventListener("keydown", b, !0);
                                for (var A = 0; A < y._howls.length; A++) y._howls[A]._emit("unlock")
                            }
                        };
                        return document.addEventListener("touchstart", b, !0), document.addEventListener("touchend", b, !0), document.addEventListener("click", b, !0), document.addEventListener("keydown", b, !0), y
                    }
                },
                _obtainHtml5Audio: function() {
                    var y = this || o;
                    if (y._html5AudioPool.length) return y._html5AudioPool.pop();
                    var b = new Audio().play();
                    return b && typeof Promise < "u" && (b instanceof Promise || typeof b.then == "function") && b.catch(function() {
                        console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                    }), new Audio
                },
                _releaseHtml5Audio: function(y) {
                    var b = this || o;
                    return y._unlocked && b._html5AudioPool.push(y), b
                },
                _autoSuspend: function() {
                    var y = this;
                    if (!(!y.autoSuspend || !y.ctx || typeof y.ctx.suspend > "u" || !o.usingWebAudio)) {
                        for (var b = 0; b < y._howls.length; b++)
                            if (y._howls[b]._webAudio) {
                                for (var S = 0; S < y._howls[b]._sounds.length; S++)
                                    if (!y._howls[b]._sounds[S]._paused) return y
                            }
                        return y._suspendTimer && clearTimeout(y._suspendTimer), y._suspendTimer = setTimeout(function() {
                            if (y.autoSuspend) {
                                y._suspendTimer = null, y.state = "suspending";
                                var C = function() {
                                    y.state = "suspended", y._resumeAfterSuspend && (delete y._resumeAfterSuspend, y._autoResume())
                                };
                                y.ctx.suspend().then(C, C)
                            }
                        }, 3e4), y
                    }
                },
                _autoResume: function() {
                    var y = this;
                    if (!(!y.ctx || typeof y.ctx.resume > "u" || !o.usingWebAudio)) return y.state === "running" && y.ctx.state !== "interrupted" && y._suspendTimer ? (clearTimeout(y._suspendTimer), y._suspendTimer = null) : y.state === "suspended" || y.state === "running" && y.ctx.state === "interrupted" ? (y.ctx.resume().then(function() {
                        y.state = "running";
                        for (var b = 0; b < y._howls.length; b++) y._howls[b]._emit("resume")
                    }), y._suspendTimer && (clearTimeout(y._suspendTimer), y._suspendTimer = null)) : y.state === "suspending" && (y._resumeAfterSuspend = !0), y
                }
            };
            var o = new i,
                c = function(y) {
                    var b = this;
                    if (!y.src || y.src.length === 0) {
                        console.error("An array of source files must be passed with any new Howl.");
                        return
                    }
                    b.init(y)
                };
            c.prototype = {
                init: function(y) {
                    var b = this;
                    return o.ctx || x(), b._autoplay = y.autoplay || !1, b._format = typeof y.format != "string" ? y.format : [y.format], b._html5 = y.html5 || !1, b._muted = y.mute || !1, b._loop = y.loop || !1, b._pool = y.pool || 5, b._preload = typeof y.preload == "boolean" || y.preload === "metadata" ? y.preload : !0, b._rate = y.rate || 1, b._sprite = y.sprite || {}, b._src = typeof y.src != "string" ? y.src : [y.src], b._volume = y.volume !== void 0 ? y.volume : 1, b._xhr = {
                        method: y.xhr && y.xhr.method ? y.xhr.method : "GET",
                        headers: y.xhr && y.xhr.headers ? y.xhr.headers : null,
                        withCredentials: y.xhr && y.xhr.withCredentials ? y.xhr.withCredentials : !1
                    }, b._duration = 0, b._state = "unloaded", b._sounds = [], b._endTimers = {}, b._queue = [], b._playLock = !1, b._onend = y.onend ? [{
                        fn: y.onend
                    }] : [], b._onfade = y.onfade ? [{
                        fn: y.onfade
                    }] : [], b._onload = y.onload ? [{
                        fn: y.onload
                    }] : [], b._onloaderror = y.onloaderror ? [{
                        fn: y.onloaderror
                    }] : [], b._onplayerror = y.onplayerror ? [{
                        fn: y.onplayerror
                    }] : [], b._onpause = y.onpause ? [{
                        fn: y.onpause
                    }] : [], b._onplay = y.onplay ? [{
                        fn: y.onplay
                    }] : [], b._onstop = y.onstop ? [{
                        fn: y.onstop
                    }] : [], b._onmute = y.onmute ? [{
                        fn: y.onmute
                    }] : [], b._onvolume = y.onvolume ? [{
                        fn: y.onvolume
                    }] : [], b._onrate = y.onrate ? [{
                        fn: y.onrate
                    }] : [], b._onseek = y.onseek ? [{
                        fn: y.onseek
                    }] : [], b._onunlock = y.onunlock ? [{
                        fn: y.onunlock
                    }] : [], b._onresume = [], b._webAudio = o.usingWebAudio && !b._html5, typeof o.ctx < "u" && o.ctx && o.autoUnlock && o._unlockAudio(), o._howls.push(b), b._autoplay && b._queue.push({
                        event: "play",
                        action: function() {
                            b.play()
                        }
                    }), b._preload && b._preload !== "none" && b.load(), b
                },
                load: function() {
                    var y = this,
                        b = null;
                    if (o.noAudio) {
                        y._emit("loaderror", null, "No audio support.");
                        return
                    }
                    typeof y._src == "string" && (y._src = [y._src]);
                    for (var S = 0; S < y._src.length; S++) {
                        var C, E;
                        if (y._format && y._format[S]) C = y._format[S];
                        else {
                            if (E = y._src[S], typeof E != "string") {
                                y._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                continue
                            }
                            C = /^data:audio\/([^;,]+);/i.exec(E), C || (C = /\.([^.]+)$/.exec(E.split("?", 1)[0])), C && (C = C[1].toLowerCase())
                        }
                        if (C || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), C && o.codecs(C)) {
                            b = y._src[S];
                            break
                        }
                    }
                    if (!b) {
                        y._emit("loaderror", null, "No codec support for selected audio sources.");
                        return
                    }
                    return y._src = b, y._state = "loading", window.location.protocol === "https:" && b.slice(0, 5) === "http:" && (y._html5 = !0, y._webAudio = !1), new u(y), y._webAudio && m(y), y
                },
                play: function(y, b) {
                    var S = this,
                        C = null;
                    if (typeof y == "number") C = y, y = null;
                    else {
                        if (typeof y == "string" && S._state === "loaded" && !S._sprite[y]) return null;
                        if (typeof y > "u" && (y = "__default", !S._playLock)) {
                            for (var E = 0, P = 0; P < S._sounds.length; P++) S._sounds[P]._paused && !S._sounds[P]._ended && (E++, C = S._sounds[P]._id);
                            E === 1 ? y = null : C = null
                        }
                    }
                    var w = C ? S._soundById(C) : S._inactiveSound();
                    if (!w) return null;
                    if (C && !y && (y = w._sprite || "__default"), S._state !== "loaded") {
                        w._sprite = y, w._ended = !1;
                        var T = w._id;
                        return S._queue.push({
                            event: "play",
                            action: function() {
                                S.play(T)
                            }
                        }), T
                    }
                    if (C && !w._paused) return b || S._loadQueue("play"), w._id;
                    S._webAudio && o._autoResume();
                    var M = Math.max(0, w._seek > 0 ? w._seek : S._sprite[y][0] / 1e3),
                        A = Math.max(0, (S._sprite[y][0] + S._sprite[y][1]) / 1e3 - M),
                        D = A * 1e3 / Math.abs(w._rate),
                        R = S._sprite[y][0] / 1e3,
                        I = (S._sprite[y][0] + S._sprite[y][1]) / 1e3;
                    w._sprite = y, w._ended = !1;
                    var k = function() {
                        w._paused = !1, w._seek = M, w._start = R, w._stop = I, w._loop = !!(w._loop || S._sprite[y][2])
                    };
                    if (M >= I) {
                        S._ended(w);
                        return
                    }
                    var F = w._node;
                    if (S._webAudio) {
                        var V = function() {
                            S._playLock = !1, k(), S._refreshBuffer(w);
                            var Q = w._muted || S._muted ? 0 : w._volume;
                            F.gain.setValueAtTime(Q, o.ctx.currentTime), w._playStart = o.ctx.currentTime, typeof F.bufferSource.start > "u" ? w._loop ? F.bufferSource.noteGrainOn(0, M, 86400) : F.bufferSource.noteGrainOn(0, M, A) : w._loop ? F.bufferSource.start(0, M, 86400) : F.bufferSource.start(0, M, A), D !== 1 / 0 && (S._endTimers[w._id] = setTimeout(S._ended.bind(S, w), D)), b || setTimeout(function() {
                                S._emit("play", w._id), S._loadQueue()
                            }, 0)
                        };
                        o.state === "running" && o.ctx.state !== "interrupted" ? V() : (S._playLock = !0, S.once("resume", V), S._clearTimer(w._id))
                    } else {
                        var B = function() {
                            F.currentTime = M, F.muted = w._muted || S._muted || o._muted || F.muted, F.volume = w._volume * o.volume(), F.playbackRate = w._rate;
                            try {
                                var Q = F.play();
                                if (Q && typeof Promise < "u" && (Q instanceof Promise || typeof Q.then == "function") ? (S._playLock = !0, k(), Q.then(function() {
                                        S._playLock = !1, F._unlocked = !0, b ? S._loadQueue() : S._emit("play", w._id)
                                    }).catch(function() {
                                        S._playLock = !1, S._emit("playerror", w._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), w._ended = !0, w._paused = !0
                                    })) : b || (S._playLock = !1, k(), S._emit("play", w._id)), F.playbackRate = w._rate, F.paused) {
                                    S._emit("playerror", w._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                    return
                                }
                                y !== "__default" || w._loop ? S._endTimers[w._id] = setTimeout(S._ended.bind(S, w), D) : (S._endTimers[w._id] = function() {
                                    S._ended(w), F.removeEventListener("ended", S._endTimers[w._id], !1)
                                }, F.addEventListener("ended", S._endTimers[w._id], !1))
                            } catch (Y) {
                                S._emit("playerror", w._id, Y)
                            }
                        };
                        F.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (F.src = S._src, F.load());
                        var U = window && window.ejecta || !F.readyState && o._navigator.isCocoonJS;
                        if (F.readyState >= 3 || U) B();
                        else {
                            S._playLock = !0, S._state = "loading";
                            var H = function() {
                                S._state = "loaded", B(), F.removeEventListener(o._canPlayEvent, H, !1)
                            };
                            F.addEventListener(o._canPlayEvent, H, !1), S._clearTimer(w._id)
                        }
                    }
                    return w._id
                },
                pause: function(y) {
                    var b = this;
                    if (b._state !== "loaded" || b._playLock) return b._queue.push({
                        event: "pause",
                        action: function() {
                            b.pause(y)
                        }
                    }), b;
                    for (var S = b._getSoundIds(y), C = 0; C < S.length; C++) {
                        b._clearTimer(S[C]);
                        var E = b._soundById(S[C]);
                        if (E && !E._paused && (E._seek = b.seek(S[C]), E._rateSeek = 0, E._paused = !0, b._stopFade(S[C]), E._node))
                            if (b._webAudio) {
                                if (!E._node.bufferSource) continue;
                                typeof E._node.bufferSource.stop > "u" ? E._node.bufferSource.noteOff(0) : E._node.bufferSource.stop(0), b._cleanBuffer(E._node)
                            } else(!isNaN(E._node.duration) || E._node.duration === 1 / 0) && E._node.pause();
                        arguments[1] || b._emit("pause", E ? E._id : null)
                    }
                    return b
                },
                stop: function(y, b) {
                    var S = this;
                    if (S._state !== "loaded" || S._playLock) return S._queue.push({
                        event: "stop",
                        action: function() {
                            S.stop(y)
                        }
                    }), S;
                    for (var C = S._getSoundIds(y), E = 0; E < C.length; E++) {
                        S._clearTimer(C[E]);
                        var P = S._soundById(C[E]);
                        P && (P._seek = P._start || 0, P._rateSeek = 0, P._paused = !0, P._ended = !0, S._stopFade(C[E]), P._node && (S._webAudio ? P._node.bufferSource && (typeof P._node.bufferSource.stop > "u" ? P._node.bufferSource.noteOff(0) : P._node.bufferSource.stop(0), S._cleanBuffer(P._node)) : (!isNaN(P._node.duration) || P._node.duration === 1 / 0) && (P._node.currentTime = P._start || 0, P._node.pause(), P._node.duration === 1 / 0 && S._clearSound(P._node))), b || S._emit("stop", P._id))
                    }
                    return S
                },
                mute: function(y, b) {
                    var S = this;
                    if (S._state !== "loaded" || S._playLock) return S._queue.push({
                        event: "mute",
                        action: function() {
                            S.mute(y, b)
                        }
                    }), S;
                    if (typeof b > "u")
                        if (typeof y == "boolean") S._muted = y;
                        else return S._muted;
                    for (var C = S._getSoundIds(b), E = 0; E < C.length; E++) {
                        var P = S._soundById(C[E]);
                        P && (P._muted = y, P._interval && S._stopFade(P._id), S._webAudio && P._node ? P._node.gain.setValueAtTime(y ? 0 : P._volume, o.ctx.currentTime) : P._node && (P._node.muted = o._muted ? !0 : y), S._emit("mute", P._id))
                    }
                    return S
                },
                volume: function() {
                    var y = this,
                        b = arguments,
                        S, C;
                    if (b.length === 0) return y._volume;
                    if (b.length === 1 || b.length === 2 && typeof b[1] > "u") {
                        var E = y._getSoundIds(),
                            P = E.indexOf(b[0]);
                        P >= 0 ? C = parseInt(b[0], 10) : S = parseFloat(b[0])
                    } else b.length >= 2 && (S = parseFloat(b[0]), C = parseInt(b[1], 10));
                    var w;
                    if (typeof S < "u" && S >= 0 && S <= 1) {
                        if (y._state !== "loaded" || y._playLock) return y._queue.push({
                            event: "volume",
                            action: function() {
                                y.volume.apply(y, b)
                            }
                        }), y;
                        typeof C > "u" && (y._volume = S), C = y._getSoundIds(C);
                        for (var T = 0; T < C.length; T++) w = y._soundById(C[T]), w && (w._volume = S, b[2] || y._stopFade(C[T]), y._webAudio && w._node && !w._muted ? w._node.gain.setValueAtTime(S, o.ctx.currentTime) : w._node && !w._muted && (w._node.volume = S * o.volume()), y._emit("volume", w._id))
                    } else return w = C ? y._soundById(C) : y._sounds[0], w ? w._volume : 0;
                    return y
                },
                fade: function(y, b, S, C) {
                    var E = this;
                    if (E._state !== "loaded" || E._playLock) return E._queue.push({
                        event: "fade",
                        action: function() {
                            E.fade(y, b, S, C)
                        }
                    }), E;
                    y = Math.min(Math.max(0, parseFloat(y)), 1), b = Math.min(Math.max(0, parseFloat(b)), 1), S = parseFloat(S), E.volume(y, C);
                    for (var P = E._getSoundIds(C), w = 0; w < P.length; w++) {
                        var T = E._soundById(P[w]);
                        if (T) {
                            if (C || E._stopFade(P[w]), E._webAudio && !T._muted) {
                                var M = o.ctx.currentTime,
                                    A = M + S / 1e3;
                                T._volume = y, T._node.gain.setValueAtTime(y, M), T._node.gain.linearRampToValueAtTime(b, A)
                            }
                            E._startFadeInterval(T, y, b, S, P[w], typeof C > "u")
                        }
                    }
                    return E
                },
                _startFadeInterval: function(y, b, S, C, E, P) {
                    var w = this,
                        T = b,
                        M = S - b,
                        A = Math.abs(M / .01),
                        D = Math.max(4, A > 0 ? C / A : C),
                        R = Date.now();
                    y._fadeTo = S, y._interval = setInterval(function() {
                        var I = (Date.now() - R) / C;
                        R = Date.now(), T += M * I, T = Math.round(T * 100) / 100, M < 0 ? T = Math.max(S, T) : T = Math.min(S, T), w._webAudio ? y._volume = T : w.volume(T, y._id, !0), P && (w._volume = T), (S < b && T <= S || S > b && T >= S) && (clearInterval(y._interval), y._interval = null, y._fadeTo = null, w.volume(S, y._id), w._emit("fade", y._id))
                    }, D)
                },
                _stopFade: function(y) {
                    var b = this,
                        S = b._soundById(y);
                    return S && S._interval && (b._webAudio && S._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(S._interval), S._interval = null, b.volume(S._fadeTo, y), S._fadeTo = null, b._emit("fade", y)), b
                },
                loop: function() {
                    var y = this,
                        b = arguments,
                        S, C, E;
                    if (b.length === 0) return y._loop;
                    if (b.length === 1)
                        if (typeof b[0] == "boolean") S = b[0], y._loop = S;
                        else return E = y._soundById(parseInt(b[0], 10)), E ? E._loop : !1;
                    else b.length === 2 && (S = b[0], C = parseInt(b[1], 10));
                    for (var P = y._getSoundIds(C), w = 0; w < P.length; w++) E = y._soundById(P[w]), E && (E._loop = S, y._webAudio && E._node && E._node.bufferSource && (E._node.bufferSource.loop = S, S && (E._node.bufferSource.loopStart = E._start || 0, E._node.bufferSource.loopEnd = E._stop, y.playing(P[w]) && (y.pause(P[w], !0), y.play(P[w], !0)))));
                    return y
                },
                rate: function() {
                    var y = this,
                        b = arguments,
                        S, C;
                    if (b.length === 0) C = y._sounds[0]._id;
                    else if (b.length === 1) {
                        var E = y._getSoundIds(),
                            P = E.indexOf(b[0]);
                        P >= 0 ? C = parseInt(b[0], 10) : S = parseFloat(b[0])
                    } else b.length === 2 && (S = parseFloat(b[0]), C = parseInt(b[1], 10));
                    var w;
                    if (typeof S == "number") {
                        if (y._state !== "loaded" || y._playLock) return y._queue.push({
                            event: "rate",
                            action: function() {
                                y.rate.apply(y, b)
                            }
                        }), y;
                        typeof C > "u" && (y._rate = S), C = y._getSoundIds(C);
                        for (var T = 0; T < C.length; T++)
                            if (w = y._soundById(C[T]), w) {
                                y.playing(C[T]) && (w._rateSeek = y.seek(C[T]), w._playStart = y._webAudio ? o.ctx.currentTime : w._playStart), w._rate = S, y._webAudio && w._node && w._node.bufferSource ? w._node.bufferSource.playbackRate.setValueAtTime(S, o.ctx.currentTime) : w._node && (w._node.playbackRate = S);
                                var M = y.seek(C[T]),
                                    A = (y._sprite[w._sprite][0] + y._sprite[w._sprite][1]) / 1e3 - M,
                                    D = A * 1e3 / Math.abs(w._rate);
                                (y._endTimers[C[T]] || !w._paused) && (y._clearTimer(C[T]), y._endTimers[C[T]] = setTimeout(y._ended.bind(y, w), D)), y._emit("rate", w._id)
                            }
                    } else return w = y._soundById(C), w ? w._rate : y._rate;
                    return y
                },
                seek: function() {
                    var y = this,
                        b = arguments,
                        S, C;
                    if (b.length === 0) y._sounds.length && (C = y._sounds[0]._id);
                    else if (b.length === 1) {
                        var E = y._getSoundIds(),
                            P = E.indexOf(b[0]);
                        P >= 0 ? C = parseInt(b[0], 10) : y._sounds.length && (C = y._sounds[0]._id, S = parseFloat(b[0]))
                    } else b.length === 2 && (S = parseFloat(b[0]), C = parseInt(b[1], 10));
                    if (typeof C > "u") return 0;
                    if (typeof S == "number" && (y._state !== "loaded" || y._playLock)) return y._queue.push({
                        event: "seek",
                        action: function() {
                            y.seek.apply(y, b)
                        }
                    }), y;
                    var w = y._soundById(C);
                    if (w)
                        if (typeof S == "number" && S >= 0) {
                            var T = y.playing(C);
                            T && y.pause(C, !0), w._seek = S, w._ended = !1, y._clearTimer(C), !y._webAudio && w._node && !isNaN(w._node.duration) && (w._node.currentTime = S);
                            var M = function() {
                                T && y.play(C, !0), y._emit("seek", C)
                            };
                            if (T && !y._webAudio) {
                                var A = function() {
                                    y._playLock ? setTimeout(A, 0) : M()
                                };
                                setTimeout(A, 0)
                            } else M()
                        } else if (y._webAudio) {
                        var D = y.playing(C) ? o.ctx.currentTime - w._playStart : 0,
                            R = w._rateSeek ? w._rateSeek - w._seek : 0;
                        return w._seek + (R + D * Math.abs(w._rate))
                    } else return w._node.currentTime;
                    return y
                },
                playing: function(y) {
                    var b = this;
                    if (typeof y == "number") {
                        var S = b._soundById(y);
                        return S ? !S._paused : !1
                    }
                    for (var C = 0; C < b._sounds.length; C++)
                        if (!b._sounds[C]._paused) return !0;
                    return !1
                },
                duration: function(y) {
                    var b = this,
                        S = b._duration,
                        C = b._soundById(y);
                    return C && (S = b._sprite[C._sprite][1] / 1e3), S
                },
                state: function() {
                    return this._state
                },
                unload: function() {
                    for (var y = this, b = y._sounds, S = 0; S < b.length; S++) b[S]._paused || y.stop(b[S]._id), y._webAudio || (y._clearSound(b[S]._node), b[S]._node.removeEventListener("error", b[S]._errorFn, !1), b[S]._node.removeEventListener(o._canPlayEvent, b[S]._loadFn, !1), b[S]._node.removeEventListener("ended", b[S]._endFn, !1), o._releaseHtml5Audio(b[S]._node)), delete b[S]._node, y._clearTimer(b[S]._id);
                    var C = o._howls.indexOf(y);
                    C >= 0 && o._howls.splice(C, 1);
                    var E = !0;
                    for (S = 0; S < o._howls.length; S++)
                        if (o._howls[S]._src === y._src || y._src.indexOf(o._howls[S]._src) >= 0) {
                            E = !1;
                            break
                        }
                    return p && E && delete p[y._src], o.noAudio = !1, y._state = "unloaded", y._sounds = [], y = null, null
                },
                on: function(y, b, S, C) {
                    var E = this,
                        P = E["_on" + y];
                    return typeof b == "function" && P.push(C ? {
                        id: S,
                        fn: b,
                        once: C
                    } : {
                        id: S,
                        fn: b
                    }), E
                },
                off: function(y, b, S) {
                    var C = this,
                        E = C["_on" + y],
                        P = 0;
                    if (typeof b == "number" && (S = b, b = null), b || S)
                        for (P = 0; P < E.length; P++) {
                            var w = S === E[P].id;
                            if (b === E[P].fn && w || !b && w) {
                                E.splice(P, 1);
                                break
                            }
                        } else if (y) C["_on" + y] = [];
                        else {
                            var T = Object.keys(C);
                            for (P = 0; P < T.length; P++) T[P].indexOf("_on") === 0 && Array.isArray(C[T[P]]) && (C[T[P]] = [])
                        }
                    return C
                },
                once: function(y, b, S) {
                    var C = this;
                    return C.on(y, b, S, 1), C
                },
                _emit: function(y, b, S) {
                    for (var C = this, E = C["_on" + y], P = E.length - 1; P >= 0; P--)(!E[P].id || E[P].id === b || y === "load") && (setTimeout(function(w) {
                        w.call(this, b, S)
                    }.bind(C, E[P].fn), 0), E[P].once && C.off(y, E[P].fn, E[P].id));
                    return C._loadQueue(y), C
                },
                _loadQueue: function(y) {
                    var b = this;
                    if (b._queue.length > 0) {
                        var S = b._queue[0];
                        S.event === y && (b._queue.shift(), b._loadQueue()), y || S.action()
                    }
                    return b
                },
                _ended: function(y) {
                    var b = this,
                        S = y._sprite;
                    if (!b._webAudio && y._node && !y._node.paused && !y._node.ended && y._node.currentTime < y._stop) return setTimeout(b._ended.bind(b, y), 100), b;
                    var C = !!(y._loop || b._sprite[S][2]);
                    if (b._emit("end", y._id), !b._webAudio && C && b.stop(y._id, !0).play(y._id), b._webAudio && C) {
                        b._emit("play", y._id), y._seek = y._start || 0, y._rateSeek = 0, y._playStart = o.ctx.currentTime;
                        var E = (y._stop - y._start) * 1e3 / Math.abs(y._rate);
                        b._endTimers[y._id] = setTimeout(b._ended.bind(b, y), E)
                    }
                    return b._webAudio && !C && (y._paused = !0, y._ended = !0, y._seek = y._start || 0, y._rateSeek = 0, b._clearTimer(y._id), b._cleanBuffer(y._node), o._autoSuspend()), !b._webAudio && !C && b.stop(y._id, !0), b
                },
                _clearTimer: function(y) {
                    var b = this;
                    if (b._endTimers[y]) {
                        if (typeof b._endTimers[y] != "function") clearTimeout(b._endTimers[y]);
                        else {
                            var S = b._soundById(y);
                            S && S._node && S._node.removeEventListener("ended", b._endTimers[y], !1)
                        }
                        delete b._endTimers[y]
                    }
                    return b
                },
                _soundById: function(y) {
                    for (var b = this, S = 0; S < b._sounds.length; S++)
                        if (y === b._sounds[S]._id) return b._sounds[S];
                    return null
                },
                _inactiveSound: function() {
                    var y = this;
                    y._drain();
                    for (var b = 0; b < y._sounds.length; b++)
                        if (y._sounds[b]._ended) return y._sounds[b].reset();
                    return new u(y)
                },
                _drain: function() {
                    var y = this,
                        b = y._pool,
                        S = 0,
                        C = 0;
                    if (!(y._sounds.length < b)) {
                        for (C = 0; C < y._sounds.length; C++) y._sounds[C]._ended && S++;
                        for (C = y._sounds.length - 1; C >= 0; C--) {
                            if (S <= b) return;
                            y._sounds[C]._ended && (y._webAudio && y._sounds[C]._node && y._sounds[C]._node.disconnect(0), y._sounds.splice(C, 1), S--)
                        }
                    }
                },
                _getSoundIds: function(y) {
                    var b = this;
                    if (typeof y > "u") {
                        for (var S = [], C = 0; C < b._sounds.length; C++) S.push(b._sounds[C]._id);
                        return S
                    } else return [y]
                },
                _refreshBuffer: function(y) {
                    var b = this;
                    return y._node.bufferSource = o.ctx.createBufferSource(), y._node.bufferSource.buffer = p[b._src], y._panner ? y._node.bufferSource.connect(y._panner) : y._node.bufferSource.connect(y._node), y._node.bufferSource.loop = y._loop, y._loop && (y._node.bufferSource.loopStart = y._start || 0, y._node.bufferSource.loopEnd = y._stop || 0), y._node.bufferSource.playbackRate.setValueAtTime(y._rate, o.ctx.currentTime), b
                },
                _cleanBuffer: function(y) {
                    var b = this,
                        S = o._navigator && o._navigator.vendor.indexOf("Apple") >= 0;
                    if (!y.bufferSource) return b;
                    if (o._scratchBuffer && y.bufferSource && (y.bufferSource.onended = null, y.bufferSource.disconnect(0), S)) try {
                        y.bufferSource.buffer = o._scratchBuffer
                    } catch {}
                    return y.bufferSource = null, b
                },
                _clearSound: function(y) {
                    var b = /MSIE |Trident\//.test(o._navigator && o._navigator.userAgent);
                    b || (y.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                }
            };
            var u = function(y) {
                this._parent = y, this.init()
            };
            u.prototype = {
                init: function() {
                    var y = this,
                        b = y._parent;
                    return y._muted = b._muted, y._loop = b._loop, y._volume = b._volume, y._rate = b._rate, y._seek = 0, y._paused = !0, y._ended = !0, y._sprite = "__default", y._id = ++o._counter, b._sounds.push(y), y.create(), y
                },
                create: function() {
                    var y = this,
                        b = y._parent,
                        S = o._muted || y._muted || y._parent._muted ? 0 : y._volume;
                    return b._webAudio ? (y._node = typeof o.ctx.createGain > "u" ? o.ctx.createGainNode() : o.ctx.createGain(), y._node.gain.setValueAtTime(S, o.ctx.currentTime), y._node.paused = !0, y._node.connect(o.masterGain)) : o.noAudio || (y._node = o._obtainHtml5Audio(), y._errorFn = y._errorListener.bind(y), y._node.addEventListener("error", y._errorFn, !1), y._loadFn = y._loadListener.bind(y), y._node.addEventListener(o._canPlayEvent, y._loadFn, !1), y._endFn = y._endListener.bind(y), y._node.addEventListener("ended", y._endFn, !1), y._node.src = b._src, y._node.preload = b._preload === !0 ? "auto" : b._preload, y._node.volume = S * o.volume(), y._node.load()), y
                },
                reset: function() {
                    var y = this,
                        b = y._parent;
                    return y._muted = b._muted, y._loop = b._loop, y._volume = b._volume, y._rate = b._rate, y._seek = 0, y._rateSeek = 0, y._paused = !0, y._ended = !0, y._sprite = "__default", y._id = ++o._counter, y
                },
                _errorListener: function() {
                    var y = this;
                    y._parent._emit("loaderror", y._id, y._node.error ? y._node.error.code : 0), y._node.removeEventListener("error", y._errorFn, !1)
                },
                _loadListener: function() {
                    var y = this,
                        b = y._parent;
                    b._duration = Math.ceil(y._node.duration * 10) / 10, Object.keys(b._sprite).length === 0 && (b._sprite = {
                        __default: [0, b._duration * 1e3]
                    }), b._state !== "loaded" && (b._state = "loaded", b._emit("load"), b._loadQueue()), y._node.removeEventListener(o._canPlayEvent, y._loadFn, !1)
                },
                _endListener: function() {
                    var y = this,
                        b = y._parent;
                    b._duration === 1 / 0 && (b._duration = Math.ceil(y._node.duration * 10) / 10, b._sprite.__default[1] === 1 / 0 && (b._sprite.__default[1] = b._duration * 1e3), b._ended(y)), y._node.removeEventListener("ended", y._endFn, !1)
                }
            };
            var p = {},
                m = function(y) {
                    var b = y._src;
                    if (p[b]) {
                        y._duration = p[b].duration, v(y);
                        return
                    }
                    if (/^data:[^;]+;base64,/.test(b)) {
                        for (var S = atob(b.split(",")[1]), C = new Uint8Array(S.length), E = 0; E < S.length; ++E) C[E] = S.charCodeAt(E);
                        _(C.buffer, y)
                    } else {
                        var P = new XMLHttpRequest;
                        P.open(y._xhr.method, b, !0), P.withCredentials = y._xhr.withCredentials, P.responseType = "arraybuffer", y._xhr.headers && Object.keys(y._xhr.headers).forEach(function(w) {
                            P.setRequestHeader(w, y._xhr.headers[w])
                        }), P.onload = function() {
                            var w = (P.status + "")[0];
                            if (w !== "0" && w !== "2" && w !== "3") {
                                y._emit("loaderror", null, "Failed loading audio file with status: " + P.status + ".");
                                return
                            }
                            _(P.response, y)
                        }, P.onerror = function() {
                            y._webAudio && (y._html5 = !0, y._webAudio = !1, y._sounds = [], delete p[b], y.load())
                        }, g(P)
                    }
                },
                g = function(y) {
                    try {
                        y.send()
                    } catch {
                        y.onerror()
                    }
                },
                _ = function(y, b) {
                    var S = function() {
                            b._emit("loaderror", null, "Decoding audio data failed.")
                        },
                        C = function(E) {
                            E && b._sounds.length > 0 ? (p[b._src] = E, v(b, E)) : S()
                        };
                    typeof Promise < "u" && o.ctx.decodeAudioData.length === 1 ? o.ctx.decodeAudioData(y).then(C).catch(S) : o.ctx.decodeAudioData(y, C, S)
                },
                v = function(y, b) {
                    b && !y._duration && (y._duration = b.duration), Object.keys(y._sprite).length === 0 && (y._sprite = {
                        __default: [0, y._duration * 1e3]
                    }), y._state !== "loaded" && (y._state = "loaded", y._emit("load"), y._loadQueue())
                },
                x = function() {
                    if (o.usingWebAudio) {
                        try {
                            typeof AudioContext < "u" ? o.ctx = new AudioContext : typeof webkitAudioContext < "u" ? o.ctx = new webkitAudioContext : o.usingWebAudio = !1
                        } catch {
                            o.usingWebAudio = !1
                        }
                        o.ctx || (o.usingWebAudio = !1);
                        var y = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform),
                            b = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                            S = b ? parseInt(b[1], 10) : null;
                        if (y && S && S < 9) {
                            var C = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
                            o._navigator && !C && (o.usingWebAudio = !1)
                        }
                        o.usingWebAudio && (o.masterGain = typeof o.ctx.createGain > "u" ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : o._volume, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup()
                    }
                };
            l.Howler = o, l.Howl = c, typeof commonjsGlobal < "u" ? (commonjsGlobal.HowlerGlobal = i, commonjsGlobal.Howler = o, commonjsGlobal.Howl = c, commonjsGlobal.Sound = u) : typeof window < "u" && (window.HowlerGlobal = i, window.Howler = o, window.Howl = c, window.Sound = u)
        })();
        /*!
         *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
         *  
         *  howler.js v2.2.4
         *  howlerjs.com
         *
         *  (c) 2013-2020, James Simpson of GoldFire Studios
         *  goldfirestudios.com
         *
         *  MIT License
         */
        (function() {
            HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(o) {
                var c = this;
                if (!c.ctx || !c.ctx.listener) return c;
                for (var u = c._howls.length - 1; u >= 0; u--) c._howls[u].stereo(o);
                return c
            }, HowlerGlobal.prototype.pos = function(o, c, u) {
                var p = this;
                if (!p.ctx || !p.ctx.listener) return p;
                if (c = typeof c != "number" ? p._pos[1] : c, u = typeof u != "number" ? p._pos[2] : u, typeof o == "number") p._pos = [o, c, u], typeof p.ctx.listener.positionX < "u" ? (p.ctx.listener.positionX.setTargetAtTime(p._pos[0], Howler.ctx.currentTime, .1), p.ctx.listener.positionY.setTargetAtTime(p._pos[1], Howler.ctx.currentTime, .1), p.ctx.listener.positionZ.setTargetAtTime(p._pos[2], Howler.ctx.currentTime, .1)) : p.ctx.listener.setPosition(p._pos[0], p._pos[1], p._pos[2]);
                else return p._pos;
                return p
            }, HowlerGlobal.prototype.orientation = function(o, c, u, p, m, g) {
                var _ = this;
                if (!_.ctx || !_.ctx.listener) return _;
                var v = _._orientation;
                if (c = typeof c != "number" ? v[1] : c, u = typeof u != "number" ? v[2] : u, p = typeof p != "number" ? v[3] : p, m = typeof m != "number" ? v[4] : m, g = typeof g != "number" ? v[5] : g, typeof o == "number") _._orientation = [o, c, u, p, m, g], typeof _.ctx.listener.forwardX < "u" ? (_.ctx.listener.forwardX.setTargetAtTime(o, Howler.ctx.currentTime, .1), _.ctx.listener.forwardY.setTargetAtTime(c, Howler.ctx.currentTime, .1), _.ctx.listener.forwardZ.setTargetAtTime(u, Howler.ctx.currentTime, .1), _.ctx.listener.upX.setTargetAtTime(p, Howler.ctx.currentTime, .1), _.ctx.listener.upY.setTargetAtTime(m, Howler.ctx.currentTime, .1), _.ctx.listener.upZ.setTargetAtTime(g, Howler.ctx.currentTime, .1)) : _.ctx.listener.setOrientation(o, c, u, p, m, g);
                else return v;
                return _
            }, Howl.prototype.init = function(o) {
                return function(c) {
                    var u = this;
                    return u._orientation = c.orientation || [1, 0, 0], u._stereo = c.stereo || null, u._pos = c.pos || null, u._pannerAttr = {
                        coneInnerAngle: typeof c.coneInnerAngle < "u" ? c.coneInnerAngle : 360,
                        coneOuterAngle: typeof c.coneOuterAngle < "u" ? c.coneOuterAngle : 360,
                        coneOuterGain: typeof c.coneOuterGain < "u" ? c.coneOuterGain : 0,
                        distanceModel: typeof c.distanceModel < "u" ? c.distanceModel : "inverse",
                        maxDistance: typeof c.maxDistance < "u" ? c.maxDistance : 1e4,
                        panningModel: typeof c.panningModel < "u" ? c.panningModel : "HRTF",
                        refDistance: typeof c.refDistance < "u" ? c.refDistance : 1,
                        rolloffFactor: typeof c.rolloffFactor < "u" ? c.rolloffFactor : 1
                    }, u._onstereo = c.onstereo ? [{
                        fn: c.onstereo
                    }] : [], u._onpos = c.onpos ? [{
                        fn: c.onpos
                    }] : [], u._onorientation = c.onorientation ? [{
                        fn: c.onorientation
                    }] : [], o.call(this, c)
                }
            }(Howl.prototype.init), Howl.prototype.stereo = function(o, c) {
                var u = this;
                if (!u._webAudio) return u;
                if (u._state !== "loaded") return u._queue.push({
                    event: "stereo",
                    action: function() {
                        u.stereo(o, c)
                    }
                }), u;
                var p = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
                if (typeof c > "u")
                    if (typeof o == "number") u._stereo = o, u._pos = [o, 0, 0];
                    else return u._stereo;
                for (var m = u._getSoundIds(c), g = 0; g < m.length; g++) {
                    var _ = u._soundById(m[g]);
                    if (_)
                        if (typeof o == "number") _._stereo = o, _._pos = [o, 0, 0], _._node && (_._pannerAttr.panningModel = "equalpower", (!_._panner || !_._panner.pan) && i(_, p), p === "spatial" ? typeof _._panner.positionX < "u" ? (_._panner.positionX.setValueAtTime(o, Howler.ctx.currentTime), _._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), _._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : _._panner.setPosition(o, 0, 0) : _._panner.pan.setValueAtTime(o, Howler.ctx.currentTime)), u._emit("stereo", _._id);
                        else return _._stereo
                }
                return u
            }, Howl.prototype.pos = function(o, c, u, p) {
                var m = this;
                if (!m._webAudio) return m;
                if (m._state !== "loaded") return m._queue.push({
                    event: "pos",
                    action: function() {
                        m.pos(o, c, u, p)
                    }
                }), m;
                if (c = typeof c != "number" ? 0 : c, u = typeof u != "number" ? -.5 : u, typeof p > "u")
                    if (typeof o == "number") m._pos = [o, c, u];
                    else return m._pos;
                for (var g = m._getSoundIds(p), _ = 0; _ < g.length; _++) {
                    var v = m._soundById(g[_]);
                    if (v)
                        if (typeof o == "number") v._pos = [o, c, u], v._node && ((!v._panner || v._panner.pan) && i(v, "spatial"), typeof v._panner.positionX < "u" ? (v._panner.positionX.setValueAtTime(o, Howler.ctx.currentTime), v._panner.positionY.setValueAtTime(c, Howler.ctx.currentTime), v._panner.positionZ.setValueAtTime(u, Howler.ctx.currentTime)) : v._panner.setPosition(o, c, u)), m._emit("pos", v._id);
                        else return v._pos
                }
                return m
            }, Howl.prototype.orientation = function(o, c, u, p) {
                var m = this;
                if (!m._webAudio) return m;
                if (m._state !== "loaded") return m._queue.push({
                    event: "orientation",
                    action: function() {
                        m.orientation(o, c, u, p)
                    }
                }), m;
                if (c = typeof c != "number" ? m._orientation[1] : c, u = typeof u != "number" ? m._orientation[2] : u, typeof p > "u")
                    if (typeof o == "number") m._orientation = [o, c, u];
                    else return m._orientation;
                for (var g = m._getSoundIds(p), _ = 0; _ < g.length; _++) {
                    var v = m._soundById(g[_]);
                    if (v)
                        if (typeof o == "number") v._orientation = [o, c, u], v._node && (v._panner || (v._pos || (v._pos = m._pos || [0, 0, -.5]), i(v, "spatial")), typeof v._panner.orientationX < "u" ? (v._panner.orientationX.setValueAtTime(o, Howler.ctx.currentTime), v._panner.orientationY.setValueAtTime(c, Howler.ctx.currentTime), v._panner.orientationZ.setValueAtTime(u, Howler.ctx.currentTime)) : v._panner.setOrientation(o, c, u)), m._emit("orientation", v._id);
                        else return v._orientation
                }
                return m
            }, Howl.prototype.pannerAttr = function() {
                var o = this,
                    c = arguments,
                    u, p, m;
                if (!o._webAudio) return o;
                if (c.length === 0) return o._pannerAttr;
                if (c.length === 1)
                    if (typeof c[0] == "object") u = c[0], typeof p > "u" && (u.pannerAttr || (u.pannerAttr = {
                        coneInnerAngle: u.coneInnerAngle,
                        coneOuterAngle: u.coneOuterAngle,
                        coneOuterGain: u.coneOuterGain,
                        distanceModel: u.distanceModel,
                        maxDistance: u.maxDistance,
                        refDistance: u.refDistance,
                        rolloffFactor: u.rolloffFactor,
                        panningModel: u.panningModel
                    }), o._pannerAttr = {
                        coneInnerAngle: typeof u.pannerAttr.coneInnerAngle < "u" ? u.pannerAttr.coneInnerAngle : o._coneInnerAngle,
                        coneOuterAngle: typeof u.pannerAttr.coneOuterAngle < "u" ? u.pannerAttr.coneOuterAngle : o._coneOuterAngle,
                        coneOuterGain: typeof u.pannerAttr.coneOuterGain < "u" ? u.pannerAttr.coneOuterGain : o._coneOuterGain,
                        distanceModel: typeof u.pannerAttr.distanceModel < "u" ? u.pannerAttr.distanceModel : o._distanceModel,
                        maxDistance: typeof u.pannerAttr.maxDistance < "u" ? u.pannerAttr.maxDistance : o._maxDistance,
                        refDistance: typeof u.pannerAttr.refDistance < "u" ? u.pannerAttr.refDistance : o._refDistance,
                        rolloffFactor: typeof u.pannerAttr.rolloffFactor < "u" ? u.pannerAttr.rolloffFactor : o._rolloffFactor,
                        panningModel: typeof u.pannerAttr.panningModel < "u" ? u.pannerAttr.panningModel : o._panningModel
                    });
                    else return m = o._soundById(parseInt(c[0], 10)), m ? m._pannerAttr : o._pannerAttr;
                else c.length === 2 && (u = c[0], p = parseInt(c[1], 10));
                for (var g = o._getSoundIds(p), _ = 0; _ < g.length; _++)
                    if (m = o._soundById(g[_]), m) {
                        var v = m._pannerAttr;
                        v = {
                            coneInnerAngle: typeof u.coneInnerAngle < "u" ? u.coneInnerAngle : v.coneInnerAngle,
                            coneOuterAngle: typeof u.coneOuterAngle < "u" ? u.coneOuterAngle : v.coneOuterAngle,
                            coneOuterGain: typeof u.coneOuterGain < "u" ? u.coneOuterGain : v.coneOuterGain,
                            distanceModel: typeof u.distanceModel < "u" ? u.distanceModel : v.distanceModel,
                            maxDistance: typeof u.maxDistance < "u" ? u.maxDistance : v.maxDistance,
                            refDistance: typeof u.refDistance < "u" ? u.refDistance : v.refDistance,
                            rolloffFactor: typeof u.rolloffFactor < "u" ? u.rolloffFactor : v.rolloffFactor,
                            panningModel: typeof u.panningModel < "u" ? u.panningModel : v.panningModel
                        };
                        var x = m._panner;
                        x || (m._pos || (m._pos = o._pos || [0, 0, -.5]), i(m, "spatial"), x = m._panner), x.coneInnerAngle = v.coneInnerAngle, x.coneOuterAngle = v.coneOuterAngle, x.coneOuterGain = v.coneOuterGain, x.distanceModel = v.distanceModel, x.maxDistance = v.maxDistance, x.refDistance = v.refDistance, x.rolloffFactor = v.rolloffFactor, x.panningModel = v.panningModel
                    }
                return o
            }, Sound.prototype.init = function(o) {
                return function() {
                    var c = this,
                        u = c._parent;
                    c._orientation = u._orientation, c._stereo = u._stereo, c._pos = u._pos, c._pannerAttr = u._pannerAttr, o.call(this), c._stereo ? u.stereo(c._stereo) : c._pos && u.pos(c._pos[0], c._pos[1], c._pos[2], c._id)
                }
            }(Sound.prototype.init), Sound.prototype.reset = function(o) {
                return function() {
                    var c = this,
                        u = c._parent;
                    return c._orientation = u._orientation, c._stereo = u._stereo, c._pos = u._pos, c._pannerAttr = u._pannerAttr, c._stereo ? u.stereo(c._stereo) : c._pos ? u.pos(c._pos[0], c._pos[1], c._pos[2], c._id) : c._panner && (c._panner.disconnect(0), c._panner = void 0, u._refreshBuffer(c)), o.call(this)
                }
            }(Sound.prototype.reset);
            var i = function(o, c) {
                c = c || "spatial", c === "spatial" ? (o._panner = Howler.ctx.createPanner(), o._panner.coneInnerAngle = o._pannerAttr.coneInnerAngle, o._panner.coneOuterAngle = o._pannerAttr.coneOuterAngle, o._panner.coneOuterGain = o._pannerAttr.coneOuterGain, o._panner.distanceModel = o._pannerAttr.distanceModel, o._panner.maxDistance = o._pannerAttr.maxDistance, o._panner.refDistance = o._pannerAttr.refDistance, o._panner.rolloffFactor = o._pannerAttr.rolloffFactor, o._panner.panningModel = o._pannerAttr.panningModel, typeof o._panner.positionX < "u" ? (o._panner.positionX.setValueAtTime(o._pos[0], Howler.ctx.currentTime), o._panner.positionY.setValueAtTime(o._pos[1], Howler.ctx.currentTime), o._panner.positionZ.setValueAtTime(o._pos[2], Howler.ctx.currentTime)) : o._panner.setPosition(o._pos[0], o._pos[1], o._pos[2]), typeof o._panner.orientationX < "u" ? (o._panner.orientationX.setValueAtTime(o._orientation[0], Howler.ctx.currentTime), o._panner.orientationY.setValueAtTime(o._orientation[1], Howler.ctx.currentTime), o._panner.orientationZ.setValueAtTime(o._orientation[2], Howler.ctx.currentTime)) : o._panner.setOrientation(o._orientation[0], o._orientation[1], o._orientation[2])) : (o._panner = Howler.ctx.createStereoPanner(), o._panner.pan.setValueAtTime(o._stereo, Howler.ctx.currentTime)), o._panner.connect(o._node), o._paused || o._parent.pause(o._id, !0).play(o._id, !0)
            }
        })()
    }(howler)), howler
}
var howlerExports = requireHowler();
class SoundManager {
    _bgm = null;
    _sounds = new Map;
    _bgmVolume = .08;
    _seVolume = .1;
    _fadeInDuration = 1500;
    _bgmStarting = !1;
    _currentBGMId = null;
    _isMuted = !1;
    constructor() {
        const i = localStorage.getItem("sound-muted");
        this._isMuted = i === "true", howlerExports.Howler.volume(this._isMuted ? 0 : 1), this._initBGM(), this._preloadSE(["mission_in", "typing", "works_in"])
    }
    _initBGM() {
        this._bgm = new howlerExports.Howl({
            src: ["/sounds/bgm.mp3"],
            loop: !0,
            volume: 0,
            onloaderror: () => {
                console.warn("BGM load failed: /sounds/bgm.mp3")
            }
        })
    }
    _preloadSE(i) {
        i.forEach(o => {
            const c = new howlerExports.Howl({
                src: [`/sounds/${o}.mp3`],
                volume: this._seVolume,
                onloaderror: () => {
                    console.warn(`SE load failed: ${o}`)
                }
            });
            this._sounds.set(o, c)
        })
    }
    async startBGM() {
        if (!this._bgm ? .playing()) try {
            this._currentBGMId !== null && this._bgm && (this._bgm.stop(this._currentBGMId), this._currentBGMId = null), this._bgm && (this._currentBGMId = this._bgm.play(), this._bgm.fade(0, this._bgmVolume, this._fadeInDuration, this._currentBGMId))
        } catch (i) {
            console.error(i)
        }
    }
    stopBGM() {
        this._bgmStarting = !1, this._currentBGMId !== null && this._bgm && (this._bgm.stop(this._currentBGMId), this._currentBGMId = null)
    }
    pauseBGM() {
        this._currentBGMId !== null && this._bgm && this._bgm.pause(this._currentBGMId)
    }
    resumeBGM() {
        this._currentBGMId !== null && this._bgm && !this._bgmStarting && this._bgm.play(this._currentBGMId)
    }
    fadeOutBGM(i = 1e3) {
        if (this._currentBGMId !== null && this._bgm) {
            const o = this._bgm.volume(this._currentBGMId);
            this._bgm.fade(o, 0, i, this._currentBGMId), setTimeout(() => {
                this.stopBGM()
            }, i)
        }
    }
    playSE(i) {
        if (this._sounds.has(i)) {
            this._sounds.get(i).play();
            return
        }
        const o = new howlerExports.Howl({
            src: [`/sounds/${i}.mp3`],
            volume: this._seVolume,
            onload: () => {
                o.play()
            },
            onloaderror: () => {
                console.warn(`SE load failed: ${i}`)
            }
        });
        this._sounds.set(i, o)
    }
    stopSE(i) {
        const o = this._sounds.get(i);
        o ? .playing() && o.stop()
    }
    toggleMute() {
        return this._isMuted = !this._isMuted, localStorage.setItem("sound-muted", this._isMuted.toString()), this._isMuted ? howlerExports.Howler.volume(0) : howlerExports.Howler.volume(1), this._isMuted
    }
    setMute(i) {
        this._isMuted = i, localStorage.setItem("sound-muted", i.toString()), i ? howlerExports.Howler.volume(0) : howlerExports.Howler.volume(1)
    }
    getMuted() {
        return this._isMuted
    }
    stopAll() {
        this.stopBGM(), this._sounds.forEach(i => {
            i.playing() && i.stop()
        })
    }
    dispose() {
        this.stopAll(), this._bgm && (this._bgm.unload(), this._bgm = null), this._sounds.forEach(i => {
            i.unload()
        }), this._sounds.clear()
    }
}
class SoundToggleController {
    _button = null;
    _bars = [];
    _animationFrame = null;
    _isAnimating = !1;
    _animationStartTime = 0;
    _barConfigs = [{
        baseHeight: 12,
        amplitude: 6,
        frequency: .8,
        phase: 0
    }, {
        baseHeight: 14,
        amplitude: 8,
        frequency: 1.2,
        phase: Math.PI / 3
    }, {
        baseHeight: 10,
        amplitude: 5,
        frequency: .6,
        phase: 2 * Math.PI / 3
    }];
    _targetAmplitudes = [0, 0, 0];
    _currentAmplitudes = [0, 0, 0];
    _transitionSpeed = .08;
    constructor() {
        this._init()
    }
    _init() {
        if (this._button = document.querySelector("[data-sound-toggle]"), !this._button) {
            console.warn("Sound toggle button not found");
            return
        }
        if (this._bars = Array.from(this._button.querySelectorAll(".bar")), this._bars.length !== 3) {
            console.warn("Sound toggle bars not found or incorrect count");
            return
        }
        this._updateButtonState(), this._isAnimating = !0, this._animationStartTime = performance.now(), this._button.addEventListener("click", this._handleClick.bind(this))
    }
    _handleClick() {
        const i = soundManager.toggleMute();
        this._updateButtonState(i)
    }
    _updateButtonState(i) {
        if (!this._button) return;
        const o = i !== void 0 ? i : this._getCurrentMutedState();
        this._button.setAttribute("data-muted", o.toString());
        const c = o ? "ON" : "OFF";
        this._button.setAttribute("aria-label", c), o ? this._stopAnimation() : this._startAnimation()
    }
    _getCurrentMutedState() {
        return soundManager.getMuted()
    }
    _startAnimation() {
        this._isAnimating || (this._isAnimating = !0, this._animationStartTime = performance.now()), this._targetAmplitudes = this._barConfigs.map(i => i.amplitude)
    }
    _stopAnimation() {
        this._targetAmplitudes = [0, 0, 0]
    }
    _animateWaves(i) {
        if (!this._isAnimating) return;
        const o = (i - this._animationStartTime) / 1e3;
        this._bars.forEach((c, u) => {
            const p = this._barConfigs[u],
                m = this._targetAmplitudes[u];
            this._currentAmplitudes[u] += (m - this._currentAmplitudes[u]) * this._transitionSpeed;
            const g = Math.sin(o * p.frequency * 2 * Math.PI + p.phase),
                _ = p.baseHeight + this._currentAmplitudes[u] * g * .5,
                v = Math.max(2, _);
            c.style.height = `${v}px`
        })
    }
    update() {
        const i = performance.now();
        this._animateWaves(i)
    }
    updateState() {
        this._updateButtonState()
    }
    dispose() {
        this._stopAnimation(), this._button && (this._button.removeEventListener("click", this._handleClick.bind(this)), this._button = null), this._bars = []
    }
}
class EasyRaycaster extends EventDispatcher {
    _raycaster;
    _touchableObjects;
    _hoverMemObj;
    _clickStart;
    _touchStartObj;
    constructor() {
        super(), this._raycaster = new Raycaster, this._touchableObjects = [], this._hoverMemObj = null, this._touchStartObj = null, this._clickStart = 0
    }
    get touchableObjects() {
        return this._touchableObjects
    }
    _dispatchMouseEvent(i, o, c) {
        this.dispatchEvent({
            type: i + "/" + o,
            intersection: c
        })
    }
    getIntersection(i, o, c) {
        this._raycaster.setFromCamera(i, o);
        const u = this._raycaster.intersectObjects(c);
        for (let p = 0; p < u.length; p++)
            if (u[p].object.visible) return u[p];
        return null
    }
    update(i, o) {
        const c = this.getIntersection(i, o, this._touchableObjects);
        return c ? (this._hoverMemObj ? "isObject3D" in this._hoverMemObj && (c.object.uuid == this._hoverMemObj.uuid ? this._dispatchMouseEvent("hover", c.object.name, c) : (this._dispatchMouseEvent("out", this._hoverMemObj.name), this._dispatchMouseEvent("enter", c.object.name, c))) : this._dispatchMouseEvent("enter", c.object.name, c), this._hoverMemObj = c.object) : this._hoverMemObj && "isObject3D" in this._hoverMemObj && this._dispatchMouseEvent("out", this._hoverMemObj.name), this._hoverMemObj = c && c.object || null, []
    }
    touchStart(i, o) {
        const c = this.getIntersection(i, o, this._touchableObjects);
        c && (this._clickStart = new Date().getTime(), this._touchStartObj = c.object)
    }
    touchEnd(i, o) {
        const c = this.getIntersection(i, o, this._touchableObjects);
        if (c && this._touchStartObj) {
            const u = new Date().getTime() - this._clickStart;
            "isObject3D" in this._touchStartObj && c.object.uuid == this._touchStartObj.uuid && u < 300 && this._dispatchMouseEvent("click", c.object.name, c)
        }
    }
}
var events = {
        exports: {}
    },
    hasRequiredEvents;

function requireEvents() {
    if (hasRequiredEvents) return events.exports;
    hasRequiredEvents = 1;
    var l = typeof Reflect == "object" ? Reflect : null,
        i = l && typeof l.apply == "function" ? l.apply : function(D, R, I) {
            return Function.prototype.apply.call(D, R, I)
        },
        o;
    l && typeof l.ownKeys == "function" ? o = l.ownKeys : Object.getOwnPropertySymbols ? o = function(D) {
        return Object.getOwnPropertyNames(D).concat(Object.getOwnPropertySymbols(D))
    } : o = function(D) {
        return Object.getOwnPropertyNames(D)
    };

    function c(A) {
        console && console.warn && console.warn(A)
    }
    var u = Number.isNaN || function(D) {
        return D !== D
    };

    function p() {
        p.init.call(this)
    }
    events.exports = p, events.exports.once = w, p.EventEmitter = p, p.prototype._events = void 0, p.prototype._eventsCount = 0, p.prototype._maxListeners = void 0;
    var m = 10;

    function g(A) {
        if (typeof A != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof A)
    }
    Object.defineProperty(p, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return m
        },
        set: function(A) {
            if (typeof A != "number" || A < 0 || u(A)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + A + ".");
            m = A
        }
    }), p.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
    }, p.prototype.setMaxListeners = function(D) {
        if (typeof D != "number" || D < 0 || u(D)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + D + ".");
        return this._maxListeners = D, this
    };

    function _(A) {
        return A._maxListeners === void 0 ? p.defaultMaxListeners : A._maxListeners
    }
    p.prototype.getMaxListeners = function() {
        return _(this)
    }, p.prototype.emit = function(D) {
        for (var R = [], I = 1; I < arguments.length; I++) R.push(arguments[I]);
        var k = D === "error",
            F = this._events;
        if (F !== void 0) k = k && F.error === void 0;
        else if (!k) return !1;
        if (k) {
            var V;
            if (R.length > 0 && (V = R[0]), V instanceof Error) throw V;
            var B = new Error("Unhandled error." + (V ? " (" + V.message + ")" : ""));
            throw B.context = V, B
        }
        var U = F[D];
        if (U === void 0) return !1;
        if (typeof U == "function") i(U, this, R);
        else
            for (var H = U.length, Q = C(U, H), I = 0; I < H; ++I) i(Q[I], this, R);
        return !0
    };

    function v(A, D, R, I) {
        var k, F, V;
        if (g(R), F = A._events, F === void 0 ? (F = A._events = Object.create(null), A._eventsCount = 0) : (F.newListener !== void 0 && (A.emit("newListener", D, R.listener ? R.listener : R), F = A._events), V = F[D]), V === void 0) V = F[D] = R, ++A._eventsCount;
        else if (typeof V == "function" ? V = F[D] = I ? [R, V] : [V, R] : I ? V.unshift(R) : V.push(R), k = _(A), k > 0 && V.length > k && !V.warned) {
            V.warned = !0;
            var B = new Error("Possible EventEmitter memory leak detected. " + V.length + " " + String(D) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            B.name = "MaxListenersExceededWarning", B.emitter = A, B.type = D, B.count = V.length, c(B)
        }
        return A
    }
    p.prototype.addListener = function(D, R) {
        return v(this, D, R, !1)
    }, p.prototype.on = p.prototype.addListener, p.prototype.prependListener = function(D, R) {
        return v(this, D, R, !0)
    };

    function x() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }

    function y(A, D, R) {
        var I = {
                fired: !1,
                wrapFn: void 0,
                target: A,
                type: D,
                listener: R
            },
            k = x.bind(I);
        return k.listener = R, I.wrapFn = k, k
    }
    p.prototype.once = function(D, R) {
        return g(R), this.on(D, y(this, D, R)), this
    }, p.prototype.prependOnceListener = function(D, R) {
        return g(R), this.prependListener(D, y(this, D, R)), this
    }, p.prototype.removeListener = function(D, R) {
        var I, k, F, V, B;
        if (g(R), k = this._events, k === void 0) return this;
        if (I = k[D], I === void 0) return this;
        if (I === R || I.listener === R) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete k[D], k.removeListener && this.emit("removeListener", D, I.listener || R));
        else if (typeof I != "function") {
            for (F = -1, V = I.length - 1; V >= 0; V--)
                if (I[V] === R || I[V].listener === R) {
                    B = I[V].listener, F = V;
                    break
                }
            if (F < 0) return this;
            F === 0 ? I.shift() : E(I, F), I.length === 1 && (k[D] = I[0]), k.removeListener !== void 0 && this.emit("removeListener", D, B || R)
        }
        return this
    }, p.prototype.off = p.prototype.removeListener, p.prototype.removeAllListeners = function(D) {
        var R, I, k;
        if (I = this._events, I === void 0) return this;
        if (I.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : I[D] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete I[D]), this;
        if (arguments.length === 0) {
            var F = Object.keys(I),
                V;
            for (k = 0; k < F.length; ++k) V = F[k], V !== "removeListener" && this.removeAllListeners(V);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
        }
        if (R = I[D], typeof R == "function") this.removeListener(D, R);
        else if (R !== void 0)
            for (k = R.length - 1; k >= 0; k--) this.removeListener(D, R[k]);
        return this
    };

    function b(A, D, R) {
        var I = A._events;
        if (I === void 0) return [];
        var k = I[D];
        return k === void 0 ? [] : typeof k == "function" ? R ? [k.listener || k] : [k] : R ? P(k) : C(k, k.length)
    }
    p.prototype.listeners = function(D) {
        return b(this, D, !0)
    }, p.prototype.rawListeners = function(D) {
        return b(this, D, !1)
    }, p.listenerCount = function(A, D) {
        return typeof A.listenerCount == "function" ? A.listenerCount(D) : S.call(A, D)
    }, p.prototype.listenerCount = S;

    function S(A) {
        var D = this._events;
        if (D !== void 0) {
            var R = D[A];
            if (typeof R == "function") return 1;
            if (R !== void 0) return R.length
        }
        return 0
    }
    p.prototype.eventNames = function() {
        return this._eventsCount > 0 ? o(this._events) : []
    };

    function C(A, D) {
        for (var R = new Array(D), I = 0; I < D; ++I) R[I] = A[I];
        return R
    }

    function E(A, D) {
        for (; D + 1 < A.length; D++) A[D] = A[D + 1];
        A.pop()
    }

    function P(A) {
        for (var D = new Array(A.length), R = 0; R < D.length; ++R) D[R] = A[R].listener || A[R];
        return D
    }

    function w(A, D) {
        return new Promise(function(R, I) {
            function k(V) {
                A.removeListener(D, F), I(V)
            }

            function F() {
                typeof A.removeListener == "function" && A.removeListener("error", k), R([].slice.call(arguments))
            }
            M(A, D, F, {
                once: !0
            }), D !== "error" && T(A, k, {
                once: !0
            })
        })
    }

    function T(A, D, R) {
        typeof A.on == "function" && M(A, "error", D, R)
    }

    function M(A, D, R, I) {
        if (typeof A.on == "function") I.once ? A.once(D, R) : A.on(D, R);
        else if (typeof A.addEventListener == "function") A.addEventListener(D, function k(F) {
            I.once && A.removeEventListener(D, k), R(F)
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof A)
    }
    return events.exports
}
var eventsExports = requireEvents();
const EventEmitter = getDefaultExportFromCjs(eventsExports);
class DeviceManager extends EventEmitter {
    _isMobile = !1;
    _isSPLayout = !1;
    _width = 0;
    _height = 0;
    _onResize;
    static MD_WIDTH = 768;
    constructor() {
        super(), this._onResize = this.onResize.bind(this), this.detectMobileDevice(), this.updateViewport(), this.addEventListeners()
    }
    detectMobileDevice() {
        const i = navigator.userAgent;
        this._isMobile = /android|iphone|ipad|ipod|blackberry|windows phone|mobile/i.test(i)
    }
    addEventListeners() {
        window.addEventListener("resize", this._onResize)
    }
    onResize() {
        const i = this._isSPLayout;
        this.updateViewport(), i !== this._isSPLayout && window.location.reload()
    }
    updateViewport() {
        this._width = window.innerWidth, this._height = window.innerHeight, this._isSPLayout = this._width <= DeviceManager.MD_WIDTH
    }
    get isMobile() {
        return this._isMobile
    }
    get isSPLayout() {
        return this._isSPLayout
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    dispose() {
        window.removeEventListener("resize", this._onResize), this.removeAllListeners()
    }
}
class DebugController extends EventEmitter$1 {
    _enabled = !1;
    _keyMap = new Map;
    _disableSnap = !1;
    constructor() {
        super(), this.checkUrlParams(), this.setupEventListeners()
    }
    setupEventListeners() {
        window.addEventListener("keydown", i => {
            i.code === "KeyS" && !this._keyMap.get("KeyS") && (this._enabled = !this._enabled, this.emit("toggle", this._enabled)), this._keyMap.set(i.code, !0)
        }), window.addEventListener("keyup", i => {
            this._keyMap.set(i.code, !1)
        })
    }
    checkUrlParams() {
        const i = new URLSearchParams(window.location.search);
        this._disableSnap = i.get("disableSnap") === "true", this._disableSnap && (this._enabled = !0)
    }
    get enabled() {
        return this._enabled
    }
    toggle() {
        this._enabled = !this._enabled, this.emit("toggle", this._enabled)
    }
}
var lottie$2 = {
        exports: {}
    },
    lottie$1 = lottie$2.exports,
    hasRequiredLottie;

function requireLottie() {
    return hasRequiredLottie || (hasRequiredLottie = 1, function(module, exports) {
        typeof document < "u" && typeof navigator < "u" && function(l, i) {
            module.exports = i()
        }(lottie$1, function() {
            var svgNS = "http://www.w3.org/2000/svg",
                locationHref = "",
                _useWebWorker = !1,
                initialDefaultFrame = -999999,
                setWebWorker = function(i) {
                    _useWebWorker = !!i
                },
                getWebWorker = function() {
                    return _useWebWorker
                },
                setLocationHref = function(i) {
                    locationHref = i
                },
                getLocationHref = function() {
                    return locationHref
                };

            function createTag(l) {
                return document.createElement(l)
            }

            function extendPrototype(l, i) {
                var o, c = l.length,
                    u;
                for (o = 0; o < c; o += 1) {
                    u = l[o].prototype;
                    for (var p in u) Object.prototype.hasOwnProperty.call(u, p) && (i.prototype[p] = u[p])
                }
            }

            function getDescriptor(l, i) {
                return Object.getOwnPropertyDescriptor(l, i)
            }

            function createProxyFunction(l) {
                function i() {}
                return i.prototype = l, i
            }
            var audioControllerFactory = function() {
                    function l(i) {
                        this.audios = [], this.audioFactory = i, this._volume = 1, this._isMuted = !1
                    }
                    return l.prototype = {
                            addAudio: function(o) {
                                this.audios.push(o)
                            },
                            pause: function() {
                                var o, c = this.audios.length;
                                for (o = 0; o < c; o += 1) this.audios[o].pause()
                            },
                            resume: function() {
                                var o, c = this.audios.length;
                                for (o = 0; o < c; o += 1) this.audios[o].resume()
                            },
                            setRate: function(o) {
                                var c, u = this.audios.length;
                                for (c = 0; c < u; c += 1) this.audios[c].setRate(o)
                            },
                            createAudio: function(o) {
                                return this.audioFactory ? this.audioFactory(o) : window.Howl ? new window.Howl({
                                    src: [o]
                                }) : {
                                    isPlaying: !1,
                                    play: function() {
                                        this.isPlaying = !0
                                    },
                                    seek: function() {
                                        this.isPlaying = !1
                                    },
                                    playing: function() {},
                                    rate: function() {},
                                    setVolume: function() {}
                                }
                            },
                            setAudioFactory: function(o) {
                                this.audioFactory = o
                            },
                            setVolume: function(o) {
                                this._volume = o, this._updateVolume()
                            },
                            mute: function() {
                                this._isMuted = !0, this._updateVolume()
                            },
                            unmute: function() {
                                this._isMuted = !1, this._updateVolume()
                            },
                            getVolume: function() {
                                return this._volume
                            },
                            _updateVolume: function() {
                                var o, c = this.audios.length;
                                for (o = 0; o < c; o += 1) this.audios[o].volume(this._volume * (this._isMuted ? 0 : 1))
                            }
                        },
                        function() {
                            return new l
                        }
                }(),
                createTypedArray = function() {
                    function l(o, c) {
                        var u = 0,
                            p = [],
                            m;
                        switch (o) {
                            case "int16":
                            case "uint8c":
                                m = 1;
                                break;
                            default:
                                m = 1.1;
                                break
                        }
                        for (u = 0; u < c; u += 1) p.push(m);
                        return p
                    }

                    function i(o, c) {
                        return o === "float32" ? new Float32Array(c) : o === "int16" ? new Int16Array(c) : o === "uint8c" ? new Uint8ClampedArray(c) : l(o, c)
                    }
                    return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? i : l
                }();

            function createSizedArray(l) {
                return Array.apply(null, {
                    length: l
                })
            }

            function _typeof$6(l) {
                "@babel/helpers - typeof";
                return _typeof$6 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
                    return typeof i
                } : function(i) {
                    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i
                }, _typeof$6(l)
            }
            var subframeEnabled = !0,
                expressionsPlugin = null,
                expressionsInterfaces = null,
                idPrefix$1 = "",
                isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                bmPow = Math.pow,
                bmSqrt = Math.sqrt,
                bmFloor = Math.floor,
                bmMax = Math.max,
                bmMin = Math.min,
                BMMath = {};
            (function() {
                var l = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"],
                    i, o = l.length;
                for (i = 0; i < o; i += 1) BMMath[l[i]] = Math[l[i]]
            })(), BMMath.random = Math.random, BMMath.abs = function(l) {
                var i = _typeof$6(l);
                if (i === "object" && l.length) {
                    var o = createSizedArray(l.length),
                        c, u = l.length;
                    for (c = 0; c < u; c += 1) o[c] = Math.abs(l[c]);
                    return o
                }
                return Math.abs(l)
            };
            var defaultCurveSegments = 150,
                degToRads = Math.PI / 180,
                roundCorner = .5519;

            function styleDiv(l) {
                l.style.position = "absolute", l.style.top = 0, l.style.left = 0, l.style.display = "block", l.style.transformOrigin = "0 0", l.style.webkitTransformOrigin = "0 0", l.style.backfaceVisibility = "visible", l.style.webkitBackfaceVisibility = "visible", l.style.transformStyle = "preserve-3d", l.style.webkitTransformStyle = "preserve-3d", l.style.mozTransformStyle = "preserve-3d"
            }

            function BMEnterFrameEvent(l, i, o, c) {
                this.type = l, this.currentTime = i, this.totalTime = o, this.direction = c < 0 ? -1 : 1
            }

            function BMCompleteEvent(l, i) {
                this.type = l, this.direction = i < 0 ? -1 : 1
            }

            function BMCompleteLoopEvent(l, i, o, c) {
                this.type = l, this.currentLoop = o, this.totalLoops = i, this.direction = c < 0 ? -1 : 1
            }

            function BMSegmentStartEvent(l, i, o) {
                this.type = l, this.firstFrame = i, this.totalFrames = o
            }

            function BMDestroyEvent(l, i) {
                this.type = l, this.target = i
            }

            function BMRenderFrameErrorEvent(l, i) {
                this.type = "renderFrameError", this.nativeError = l, this.currentTime = i
            }

            function BMConfigErrorEvent(l) {
                this.type = "configError", this.nativeError = l
            }
            var createElementID = function() {
                var l = 0;
                return function() {
                    return l += 1, idPrefix$1 + "__lottie_element_" + l
                }
            }();

            function HSVtoRGB(l, i, o) {
                var c, u, p, m, g, _, v, x;
                switch (m = Math.floor(l * 6), g = l * 6 - m, _ = o * (1 - i), v = o * (1 - g * i), x = o * (1 - (1 - g) * i), m % 6) {
                    case 0:
                        c = o, u = x, p = _;
                        break;
                    case 1:
                        c = v, u = o, p = _;
                        break;
                    case 2:
                        c = _, u = o, p = x;
                        break;
                    case 3:
                        c = _, u = v, p = o;
                        break;
                    case 4:
                        c = x, u = _, p = o;
                        break;
                    case 5:
                        c = o, u = _, p = v;
                        break
                }
                return [c, u, p]
            }

            function RGBtoHSV(l, i, o) {
                var c = Math.max(l, i, o),
                    u = Math.min(l, i, o),
                    p = c - u,
                    m, g = c === 0 ? 0 : p / c,
                    _ = c / 255;
                switch (c) {
                    case u:
                        m = 0;
                        break;
                    case l:
                        m = i - o + p * (i < o ? 6 : 0), m /= 6 * p;
                        break;
                    case i:
                        m = o - l + p * 2, m /= 6 * p;
                        break;
                    case o:
                        m = l - i + p * 4, m /= 6 * p;
                        break
                }
                return [m, g, _]
            }

            function addSaturationToRGB(l, i) {
                var o = RGBtoHSV(l[0] * 255, l[1] * 255, l[2] * 255);
                return o[1] += i, o[1] > 1 ? o[1] = 1 : o[1] <= 0 && (o[1] = 0), HSVtoRGB(o[0], o[1], o[2])
            }

            function addBrightnessToRGB(l, i) {
                var o = RGBtoHSV(l[0] * 255, l[1] * 255, l[2] * 255);
                return o[2] += i, o[2] > 1 ? o[2] = 1 : o[2] < 0 && (o[2] = 0), HSVtoRGB(o[0], o[1], o[2])
            }

            function addHueToRGB(l, i) {
                var o = RGBtoHSV(l[0] * 255, l[1] * 255, l[2] * 255);
                return o[0] += i / 360, o[0] > 1 ? o[0] -= 1 : o[0] < 0 && (o[0] += 1), HSVtoRGB(o[0], o[1], o[2])
            }
            var rgbToHex = function() {
                    var l = [],
                        i, o;
                    for (i = 0; i < 256; i += 1) o = i.toString(16), l[i] = o.length === 1 ? "0" + o : o;
                    return function(c, u, p) {
                        return c < 0 && (c = 0), u < 0 && (u = 0), p < 0 && (p = 0), "#" + l[c] + l[u] + l[p]
                    }
                }(),
                setSubframeEnabled = function(i) {
                    subframeEnabled = !!i
                },
                getSubframeEnabled = function() {
                    return subframeEnabled
                },
                setExpressionsPlugin = function(i) {
                    expressionsPlugin = i
                },
                getExpressionsPlugin = function() {
                    return expressionsPlugin
                },
                setExpressionInterfaces = function(i) {
                    expressionsInterfaces = i
                },
                getExpressionInterfaces = function() {
                    return expressionsInterfaces
                },
                setDefaultCurveSegments = function(i) {
                    defaultCurveSegments = i
                },
                getDefaultCurveSegments = function() {
                    return defaultCurveSegments
                },
                setIdPrefix = function(i) {
                    idPrefix$1 = i
                };

            function createNS(l) {
                return document.createElementNS(svgNS, l)
            }

            function _typeof$5(l) {
                "@babel/helpers - typeof";
                return _typeof$5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
                    return typeof i
                } : function(i) {
                    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i
                }, _typeof$5(l)
            }
            var dataManager = function() {
                    var l = 1,
                        i = [],
                        o, c, u = {
                            onmessage: function() {},
                            postMessage: function(S) {
                                o({
                                    data: S
                                })
                            }
                        },
                        p = {
                            postMessage: function(S) {
                                u.onmessage({
                                    data: S
                                })
                            }
                        };

                    function m(b) {
                        if (window.Worker && window.Blob && getWebWorker()) {
                            var S = new Blob(["var _workerSelf = self; self.onmessage = ", b.toString()], {
                                    type: "text/javascript"
                                }),
                                C = URL.createObjectURL(S);
                            return new Worker(C)
                        }
                        return o = b, u
                    }

                    function g() {
                        c || (c = m(function(S) {
                            function C() {
                                function P(Y, O) {
                                    var G, L, N = Y.length,
                                        K, Z, he, we;
                                    for (L = 0; L < N; L += 1)
                                        if (G = Y[L], "ks" in G && !G.completed) {
                                            if (G.completed = !0, G.hasMask) {
                                                var ie = G.masksProperties;
                                                for (Z = ie.length, K = 0; K < Z; K += 1)
                                                    if (ie[K].pt.k.i) D(ie[K].pt.k);
                                                    else
                                                        for (we = ie[K].pt.k.length, he = 0; he < we; he += 1) ie[K].pt.k[he].s && D(ie[K].pt.k[he].s[0]), ie[K].pt.k[he].e && D(ie[K].pt.k[he].e[0])
                                            }
                                            G.ty === 0 ? (G.layers = M(G.refId, O), P(G.layers, O)) : G.ty === 4 ? A(G.shapes) : G.ty === 5 && H(G)
                                        }
                                }

                                function w(Y, O) {
                                    if (Y) {
                                        var G = 0,
                                            L = Y.length;
                                        for (G = 0; G < L; G += 1) Y[G].t === 1 && (Y[G].data.layers = M(Y[G].data.refId, O), P(Y[G].data.layers, O))
                                    }
                                }

                                function T(Y, O) {
                                    for (var G = 0, L = O.length; G < L;) {
                                        if (O[G].id === Y) return O[G];
                                        G += 1
                                    }
                                    return null
                                }

                                function M(Y, O) {
                                    var G = T(Y, O);
                                    return G ? G.layers.__used ? JSON.parse(JSON.stringify(G.layers)) : (G.layers.__used = !0, G.layers) : null
                                }

                                function A(Y) {
                                    var O, G = Y.length,
                                        L, N;
                                    for (O = G - 1; O >= 0; O -= 1)
                                        if (Y[O].ty === "sh")
                                            if (Y[O].ks.k.i) D(Y[O].ks.k);
                                            else
                                                for (N = Y[O].ks.k.length, L = 0; L < N; L += 1) Y[O].ks.k[L].s && D(Y[O].ks.k[L].s[0]), Y[O].ks.k[L].e && D(Y[O].ks.k[L].e[0]);
                                    else Y[O].ty === "gr" && A(Y[O].it)
                                }

                                function D(Y) {
                                    var O, G = Y.i.length;
                                    for (O = 0; O < G; O += 1) Y.i[O][0] += Y.v[O][0], Y.i[O][1] += Y.v[O][1], Y.o[O][0] += Y.v[O][0], Y.o[O][1] += Y.v[O][1]
                                }

                                function R(Y, O) {
                                    var G = O ? O.split(".") : [100, 100, 100];
                                    return Y[0] > G[0] ? !0 : G[0] > Y[0] ? !1 : Y[1] > G[1] ? !0 : G[1] > Y[1] ? !1 : Y[2] > G[2] ? !0 : G[2] > Y[2] ? !1 : null
                                }
                                var I = function() {
                                        var Y = [4, 4, 14];

                                        function O(L) {
                                            var N = L.t.d;
                                            L.t.d = {
                                                k: [{
                                                    s: N,
                                                    t: 0
                                                }]
                                            }
                                        }

                                        function G(L) {
                                            var N, K = L.length;
                                            for (N = 0; N < K; N += 1) L[N].ty === 5 && O(L[N])
                                        }
                                        return function(L) {
                                            if (R(Y, L.v) && (G(L.layers), L.assets)) {
                                                var N, K = L.assets.length;
                                                for (N = 0; N < K; N += 1) L.assets[N].layers && G(L.assets[N].layers)
                                            }
                                        }
                                    }(),
                                    k = function() {
                                        var Y = [4, 7, 99];
                                        return function(O) {
                                            if (O.chars && !R(Y, O.v)) {
                                                var G, L = O.chars.length;
                                                for (G = 0; G < L; G += 1) {
                                                    var N = O.chars[G];
                                                    N.data && N.data.shapes && (A(N.data.shapes), N.data.ip = 0, N.data.op = 99999, N.data.st = 0, N.data.sr = 1, N.data.ks = {
                                                        p: {
                                                            k: [0, 0],
                                                            a: 0
                                                        },
                                                        s: {
                                                            k: [100, 100],
                                                            a: 0
                                                        },
                                                        a: {
                                                            k: [0, 0],
                                                            a: 0
                                                        },
                                                        r: {
                                                            k: 0,
                                                            a: 0
                                                        },
                                                        o: {
                                                            k: 100,
                                                            a: 0
                                                        }
                                                    }, O.chars[G].t || (N.data.shapes.push({
                                                        ty: "no"
                                                    }), N.data.shapes[0].it.push({
                                                        p: {
                                                            k: [0, 0],
                                                            a: 0
                                                        },
                                                        s: {
                                                            k: [100, 100],
                                                            a: 0
                                                        },
                                                        a: {
                                                            k: [0, 0],
                                                            a: 0
                                                        },
                                                        r: {
                                                            k: 0,
                                                            a: 0
                                                        },
                                                        o: {
                                                            k: 100,
                                                            a: 0
                                                        },
                                                        sk: {
                                                            k: 0,
                                                            a: 0
                                                        },
                                                        sa: {
                                                            k: 0,
                                                            a: 0
                                                        },
                                                        ty: "tr"
                                                    })))
                                                }
                                            }
                                        }
                                    }(),
                                    F = function() {
                                        var Y = [5, 7, 15];

                                        function O(L) {
                                            var N = L.t.p;
                                            typeof N.a == "number" && (N.a = {
                                                a: 0,
                                                k: N.a
                                            }), typeof N.p == "number" && (N.p = {
                                                a: 0,
                                                k: N.p
                                            }), typeof N.r == "number" && (N.r = {
                                                a: 0,
                                                k: N.r
                                            })
                                        }

                                        function G(L) {
                                            var N, K = L.length;
                                            for (N = 0; N < K; N += 1) L[N].ty === 5 && O(L[N])
                                        }
                                        return function(L) {
                                            if (R(Y, L.v) && (G(L.layers), L.assets)) {
                                                var N, K = L.assets.length;
                                                for (N = 0; N < K; N += 1) L.assets[N].layers && G(L.assets[N].layers)
                                            }
                                        }
                                    }(),
                                    V = function() {
                                        var Y = [4, 1, 9];

                                        function O(L) {
                                            var N, K = L.length,
                                                Z, he;
                                            for (N = 0; N < K; N += 1)
                                                if (L[N].ty === "gr") O(L[N].it);
                                                else if (L[N].ty === "fl" || L[N].ty === "st")
                                                if (L[N].c.k && L[N].c.k[0].i)
                                                    for (he = L[N].c.k.length, Z = 0; Z < he; Z += 1) L[N].c.k[Z].s && (L[N].c.k[Z].s[0] /= 255, L[N].c.k[Z].s[1] /= 255, L[N].c.k[Z].s[2] /= 255, L[N].c.k[Z].s[3] /= 255), L[N].c.k[Z].e && (L[N].c.k[Z].e[0] /= 255, L[N].c.k[Z].e[1] /= 255, L[N].c.k[Z].e[2] /= 255, L[N].c.k[Z].e[3] /= 255);
                                                else L[N].c.k[0] /= 255, L[N].c.k[1] /= 255, L[N].c.k[2] /= 255, L[N].c.k[3] /= 255
                                        }

                                        function G(L) {
                                            var N, K = L.length;
                                            for (N = 0; N < K; N += 1) L[N].ty === 4 && O(L[N].shapes)
                                        }
                                        return function(L) {
                                            if (R(Y, L.v) && (G(L.layers), L.assets)) {
                                                var N, K = L.assets.length;
                                                for (N = 0; N < K; N += 1) L.assets[N].layers && G(L.assets[N].layers)
                                            }
                                        }
                                    }(),
                                    B = function() {
                                        var Y = [4, 4, 18];

                                        function O(L) {
                                            var N, K = L.length,
                                                Z, he;
                                            for (N = K - 1; N >= 0; N -= 1)
                                                if (L[N].ty === "sh")
                                                    if (L[N].ks.k.i) L[N].ks.k.c = L[N].closed;
                                                    else
                                                        for (he = L[N].ks.k.length, Z = 0; Z < he; Z += 1) L[N].ks.k[Z].s && (L[N].ks.k[Z].s[0].c = L[N].closed), L[N].ks.k[Z].e && (L[N].ks.k[Z].e[0].c = L[N].closed);
                                            else L[N].ty === "gr" && O(L[N].it)
                                        }

                                        function G(L) {
                                            var N, K, Z = L.length,
                                                he, we, ie, _e;
                                            for (K = 0; K < Z; K += 1) {
                                                if (N = L[K], N.hasMask) {
                                                    var Te = N.masksProperties;
                                                    for (we = Te.length, he = 0; he < we; he += 1)
                                                        if (Te[he].pt.k.i) Te[he].pt.k.c = Te[he].cl;
                                                        else
                                                            for (_e = Te[he].pt.k.length, ie = 0; ie < _e; ie += 1) Te[he].pt.k[ie].s && (Te[he].pt.k[ie].s[0].c = Te[he].cl), Te[he].pt.k[ie].e && (Te[he].pt.k[ie].e[0].c = Te[he].cl)
                                                }
                                                N.ty === 4 && O(N.shapes)
                                            }
                                        }
                                        return function(L) {
                                            if (R(Y, L.v) && (G(L.layers), L.assets)) {
                                                var N, K = L.assets.length;
                                                for (N = 0; N < K; N += 1) L.assets[N].layers && G(L.assets[N].layers)
                                            }
                                        }
                                    }();

                                function U(Y) {
                                    Y.__complete || (V(Y), I(Y), k(Y), F(Y), B(Y), P(Y.layers, Y.assets), w(Y.chars, Y.assets), Y.__complete = !0)
                                }

                                function H(Y) {
                                    Y.t.a.length === 0 && "m" in Y.t.p
                                }
                                var Q = {};
                                return Q.completeData = U, Q.checkColors = V, Q.checkChars = k, Q.checkPathProperties = F, Q.checkShapes = B, Q.completeLayers = P, Q
                            }
                            if (p.dataManager || (p.dataManager = C()), p.assetLoader || (p.assetLoader = function() {
                                    function P(T) {
                                        var M = T.getResponseHeader("content-type");
                                        return M && T.responseType === "json" && M.indexOf("json") !== -1 || T.response && _typeof$5(T.response) === "object" ? T.response : T.response && typeof T.response == "string" ? JSON.parse(T.response) : T.responseText ? JSON.parse(T.responseText) : null
                                    }

                                    function w(T, M, A, D) {
                                        var R, I = new XMLHttpRequest;
                                        try {
                                            I.responseType = "json"
                                        } catch {}
                                        I.onreadystatechange = function() {
                                            if (I.readyState === 4)
                                                if (I.status === 200) R = P(I), A(R);
                                                else try {
                                                    R = P(I), A(R)
                                                } catch (k) {
                                                    D && D(k)
                                                }
                                        };
                                        try {
                                            I.open(["G", "E", "T"].join(""), T, !0)
                                        } catch {
                                            I.open(["G", "E", "T"].join(""), M + "/" + T, !0)
                                        }
                                        I.send()
                                    }
                                    return {
                                        load: w
                                    }
                                }()), S.data.type === "loadAnimation") p.assetLoader.load(S.data.path, S.data.fullPath, function(P) {
                                p.dataManager.completeData(P), p.postMessage({
                                    id: S.data.id,
                                    payload: P,
                                    status: "success"
                                })
                            }, function() {
                                p.postMessage({
                                    id: S.data.id,
                                    status: "error"
                                })
                            });
                            else if (S.data.type === "complete") {
                                var E = S.data.animation;
                                p.dataManager.completeData(E), p.postMessage({
                                    id: S.data.id,
                                    payload: E,
                                    status: "success"
                                })
                            } else S.data.type === "loadData" && p.assetLoader.load(S.data.path, S.data.fullPath, function(P) {
                                p.postMessage({
                                    id: S.data.id,
                                    payload: P,
                                    status: "success"
                                })
                            }, function() {
                                p.postMessage({
                                    id: S.data.id,
                                    status: "error"
                                })
                            })
                        }), c.onmessage = function(b) {
                            var S = b.data,
                                C = S.id,
                                E = i[C];
                            i[C] = null, S.status === "success" ? E.onComplete(S.payload) : E.onError && E.onError()
                        })
                    }

                    function _(b, S) {
                        l += 1;
                        var C = "processId_" + l;
                        return i[C] = {
                            onComplete: b,
                            onError: S
                        }, C
                    }

                    function v(b, S, C) {
                        g();
                        var E = _(S, C);
                        c.postMessage({
                            type: "loadAnimation",
                            path: b,
                            fullPath: window.location.origin + window.location.pathname,
                            id: E
                        })
                    }

                    function x(b, S, C) {
                        g();
                        var E = _(S, C);
                        c.postMessage({
                            type: "loadData",
                            path: b,
                            fullPath: window.location.origin + window.location.pathname,
                            id: E
                        })
                    }

                    function y(b, S, C) {
                        g();
                        var E = _(S, C);
                        c.postMessage({
                            type: "complete",
                            animation: b,
                            id: E
                        })
                    }
                    return {
                        loadAnimation: v,
                        loadData: x,
                        completeAnimation: y
                    }
                }(),
                ImagePreloader = function() {
                    var l = function() {
                        var w = createTag("canvas");
                        w.width = 1, w.height = 1;
                        var T = w.getContext("2d");
                        return T.fillStyle = "rgba(0,0,0,0)", T.fillRect(0, 0, 1, 1), w
                    }();

                    function i() {
                        this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                    }

                    function o() {
                        this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                    }

                    function c(w, T, M) {
                        var A = "";
                        if (w.e) A = w.p;
                        else if (T) {
                            var D = w.p;
                            D.indexOf("images/") !== -1 && (D = D.split("/")[1]), A = T + D
                        } else A = M, A += w.u ? w.u : "", A += w.p;
                        return A
                    }

                    function u(w) {
                        var T = 0,
                            M = setInterval(function() {
                                var A = w.getBBox();
                                (A.width || T > 500) && (this._imageLoaded(), clearInterval(M)), T += 1
                            }.bind(this), 50)
                    }

                    function p(w) {
                        var T = c(w, this.assetsPath, this.path),
                            M = createNS("image");
                        isSafari ? this.testImageLoaded(M) : M.addEventListener("load", this._imageLoaded, !1), M.addEventListener("error", function() {
                            A.img = l, this._imageLoaded()
                        }.bind(this), !1), M.setAttributeNS("http://www.w3.org/1999/xlink", "href", T), this._elementHelper.append ? this._elementHelper.append(M) : this._elementHelper.appendChild(M);
                        var A = {
                            img: M,
                            assetData: w
                        };
                        return A
                    }

                    function m(w) {
                        var T = c(w, this.assetsPath, this.path),
                            M = createTag("img");
                        M.crossOrigin = "anonymous", M.addEventListener("load", this._imageLoaded, !1), M.addEventListener("error", function() {
                            A.img = l, this._imageLoaded()
                        }.bind(this), !1), M.src = T;
                        var A = {
                            img: M,
                            assetData: w
                        };
                        return A
                    }

                    function g(w) {
                        var T = {
                                assetData: w
                            },
                            M = c(w, this.assetsPath, this.path);
                        return dataManager.loadData(M, function(A) {
                            T.img = A, this._footageLoaded()
                        }.bind(this), function() {
                            T.img = {}, this._footageLoaded()
                        }.bind(this)), T
                    }

                    function _(w, T) {
                        this.imagesLoadedCb = T;
                        var M, A = w.length;
                        for (M = 0; M < A; M += 1) w[M].layers || (!w[M].t || w[M].t === "seq" ? (this.totalImages += 1, this.images.push(this._createImageData(w[M]))) : w[M].t === 3 && (this.totalFootages += 1, this.images.push(this.createFootageData(w[M]))))
                    }

                    function v(w) {
                        this.path = w || ""
                    }

                    function x(w) {
                        this.assetsPath = w || ""
                    }

                    function y(w) {
                        for (var T = 0, M = this.images.length; T < M;) {
                            if (this.images[T].assetData === w) return this.images[T].img;
                            T += 1
                        }
                        return null
                    }

                    function b() {
                        this.imagesLoadedCb = null, this.images.length = 0
                    }

                    function S() {
                        return this.totalImages === this.loadedAssets
                    }

                    function C() {
                        return this.totalFootages === this.loadedFootagesCount
                    }

                    function E(w, T) {
                        w === "svg" ? (this._elementHelper = T, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
                    }

                    function P() {
                        this._imageLoaded = i.bind(this), this._footageLoaded = o.bind(this), this.testImageLoaded = u.bind(this), this.createFootageData = g.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = []
                    }
                    return P.prototype = {
                        loadAssets: _,
                        setAssetsPath: x,
                        setPath: v,
                        loadedImages: S,
                        loadedFootages: C,
                        destroy: b,
                        getAsset: y,
                        createImgData: m,
                        createImageData: p,
                        imageLoaded: i,
                        footageLoaded: o,
                        setCacheType: E
                    }, P
                }();

            function BaseEvent() {}
            BaseEvent.prototype = {
                triggerEvent: function(i, o) {
                    if (this._cbs[i])
                        for (var c = this._cbs[i], u = 0; u < c.length; u += 1) c[u](o)
                },
                addEventListener: function(i, o) {
                    return this._cbs[i] || (this._cbs[i] = []), this._cbs[i].push(o),
                        function() {
                            this.removeEventListener(i, o)
                        }.bind(this)
                },
                removeEventListener: function(i, o) {
                    if (!o) this._cbs[i] = null;
                    else if (this._cbs[i]) {
                        for (var c = 0, u = this._cbs[i].length; c < u;) this._cbs[i][c] === o && (this._cbs[i].splice(c, 1), c -= 1, u -= 1), c += 1;
                        this._cbs[i].length || (this._cbs[i] = null)
                    }
                }
            };
            var markerParser = function() {
                    function l(i) {
                        for (var o = i.split(`\r
`), c = {}, u, p = 0, m = 0; m < o.length; m += 1) u = o[m].split(":"), u.length === 2 && (c[u[0]] = u[1].trim(), p += 1);
                        if (p === 0) throw new Error;
                        return c
                    }
                    return function(i) {
                        for (var o = [], c = 0; c < i.length; c += 1) {
                            var u = i[c],
                                p = {
                                    time: u.tm,
                                    duration: u.dr
                                };
                            try {
                                p.payload = JSON.parse(i[c].cm)
                            } catch {
                                try {
                                    p.payload = l(i[c].cm)
                                } catch {
                                    p.payload = {
                                        name: i[c].cm
                                    }
                                }
                            }
                            o.push(p)
                        }
                        return o
                    }
                }(),
                ProjectInterface = function() {
                    function l(i) {
                        this.compositions.push(i)
                    }
                    return function() {
                        function i(o) {
                            for (var c = 0, u = this.compositions.length; c < u;) {
                                if (this.compositions[c].data && this.compositions[c].data.nm === o) return this.compositions[c].prepareFrame && this.compositions[c].data.xt && this.compositions[c].prepareFrame(this.currentFrame), this.compositions[c].compInterface;
                                c += 1
                            }
                            return null
                        }
                        return i.compositions = [], i.currentFrame = 0, i.registerComposition = l, i
                    }
                }(),
                renderers = {},
                registerRenderer = function(i, o) {
                    renderers[i] = o
                };

            function getRenderer(l) {
                return renderers[l]
            }

            function getRegisteredRenderer() {
                if (renderers.canvas) return "canvas";
                for (var l in renderers)
                    if (renderers[l]) return l;
                return ""
            }

            function _typeof$4(l) {
                "@babel/helpers - typeof";
                return _typeof$4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
                    return typeof i
                } : function(i) {
                    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i
                }, _typeof$4(l)
            }
            var AnimationItem = function() {
                this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0), this.expressionsPlugin = getExpressionsPlugin()
            };
            extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function(l) {
                (l.wrapper || l.container) && (this.wrapper = l.wrapper || l.container);
                var i = "svg";
                l.animType ? i = l.animType : l.renderer && (i = l.renderer);
                var o = getRenderer(i);
                this.renderer = new o(this, l.rendererSettings), this.imagePreloader.setCacheType(i, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = i, l.loop === "" || l.loop === null || l.loop === void 0 || l.loop === !0 ? this.loop = !0 : l.loop === !1 ? this.loop = !1 : this.loop = parseInt(l.loop, 10), this.autoplay = "autoplay" in l ? l.autoplay : !0, this.name = l.name ? l.name : "", this.autoloadSegments = Object.prototype.hasOwnProperty.call(l, "autoloadSegments") ? l.autoloadSegments : !0, this.assetsPath = l.assetsPath, this.initialSegment = l.initialSegment, l.audioFactory && this.audioController.setAudioFactory(l.audioFactory), l.animationData ? this.setupAnimation(l.animationData) : l.path && (l.path.lastIndexOf("\\") !== -1 ? this.path = l.path.substr(0, l.path.lastIndexOf("\\") + 1) : this.path = l.path.substr(0, l.path.lastIndexOf("/") + 1), this.fileName = l.path.substr(l.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(l.path, this.configAnimation, this.onSetupError))
            }, AnimationItem.prototype.onSetupError = function() {
                this.trigger("data_failed")
            }, AnimationItem.prototype.setupAnimation = function(l) {
                dataManager.completeAnimation(l, this.configAnimation)
            }, AnimationItem.prototype.setData = function(l, i) {
                i && _typeof$4(i) !== "object" && (i = JSON.parse(i));
                var o = {
                        wrapper: l,
                        animationData: i
                    },
                    c = l.attributes;
                o.path = c.getNamedItem("data-animation-path") ? c.getNamedItem("data-animation-path").value : c.getNamedItem("data-bm-path") ? c.getNamedItem("data-bm-path").value : c.getNamedItem("bm-path") ? c.getNamedItem("bm-path").value : "", o.animType = c.getNamedItem("data-anim-type") ? c.getNamedItem("data-anim-type").value : c.getNamedItem("data-bm-type") ? c.getNamedItem("data-bm-type").value : c.getNamedItem("bm-type") ? c.getNamedItem("bm-type").value : c.getNamedItem("data-bm-renderer") ? c.getNamedItem("data-bm-renderer").value : c.getNamedItem("bm-renderer") ? c.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
                var u = c.getNamedItem("data-anim-loop") ? c.getNamedItem("data-anim-loop").value : c.getNamedItem("data-bm-loop") ? c.getNamedItem("data-bm-loop").value : c.getNamedItem("bm-loop") ? c.getNamedItem("bm-loop").value : "";
                u === "false" ? o.loop = !1 : u === "true" ? o.loop = !0 : u !== "" && (o.loop = parseInt(u, 10));
                var p = c.getNamedItem("data-anim-autoplay") ? c.getNamedItem("data-anim-autoplay").value : c.getNamedItem("data-bm-autoplay") ? c.getNamedItem("data-bm-autoplay").value : c.getNamedItem("bm-autoplay") ? c.getNamedItem("bm-autoplay").value : !0;
                o.autoplay = p !== "false", o.name = c.getNamedItem("data-name") ? c.getNamedItem("data-name").value : c.getNamedItem("data-bm-name") ? c.getNamedItem("data-bm-name").value : c.getNamedItem("bm-name") ? c.getNamedItem("bm-name").value : "";
                var m = c.getNamedItem("data-anim-prerender") ? c.getNamedItem("data-anim-prerender").value : c.getNamedItem("data-bm-prerender") ? c.getNamedItem("data-bm-prerender").value : c.getNamedItem("bm-prerender") ? c.getNamedItem("bm-prerender").value : "";
                m === "false" && (o.prerender = !1), o.path ? this.setParams(o) : this.trigger("destroy")
            }, AnimationItem.prototype.includeLayers = function(l) {
                l.op > this.animationData.op && (this.animationData.op = l.op, this.totalFrames = Math.floor(l.op - this.animationData.ip));
                var i = this.animationData.layers,
                    o, c = i.length,
                    u = l.layers,
                    p, m = u.length;
                for (p = 0; p < m; p += 1)
                    for (o = 0; o < c;) {
                        if (i[o].id === u[p].id) {
                            i[o] = u[p];
                            break
                        }
                        o += 1
                    }
                if ((l.chars || l.fonts) && (this.renderer.globalData.fontManager.addChars(l.chars), this.renderer.globalData.fontManager.addFonts(l.fonts, this.renderer.globalData.defs)), l.assets)
                    for (c = l.assets.length, o = 0; o < c; o += 1) this.animationData.assets.push(l.assets[o]);
                this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
            }, AnimationItem.prototype.onSegmentComplete = function(l) {
                this.animationData = l;
                var i = getExpressionsPlugin();
                i && i.initExpressions(this), this.loadNextSegment()
            }, AnimationItem.prototype.loadNextSegment = function() {
                var l = this.animationData.segments;
                if (!l || l.length === 0 || !this.autoloadSegments) {
                    this.trigger("data_ready"), this.timeCompleted = this.totalFrames;
                    return
                }
                var i = l.shift();
                this.timeCompleted = i.time * this.frameRate;
                var o = this.path + this.fileName + "_" + this.segmentPos + ".json";
                this.segmentPos += 1, dataManager.loadData(o, this.includeLayers.bind(this), function() {
                    this.trigger("data_failed")
                }.bind(this))
            }, AnimationItem.prototype.loadSegments = function() {
                var l = this.animationData.segments;
                l || (this.timeCompleted = this.totalFrames), this.loadNextSegment()
            }, AnimationItem.prototype.imagesLoaded = function() {
                this.trigger("loaded_images"), this.checkLoaded()
            }, AnimationItem.prototype.preloadImages = function() {
                this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
            }, AnimationItem.prototype.configAnimation = function(l) {
                if (this.renderer) try {
                    this.animationData = l, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(l), l.assets || (l.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(l.assets), this.markers = markerParser(l.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause()
                } catch (i) {
                    this.triggerConfigError(i)
                }
            }, AnimationItem.prototype.waitForFontsLoaded = function() {
                this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
            }, AnimationItem.prototype.checkLoaded = function() {
                if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
                    this.isLoaded = !0;
                    var l = getExpressionsPlugin();
                    l && l.initExpressions(this), this.renderer.initItems(), setTimeout(function() {
                        this.trigger("DOMLoaded")
                    }.bind(this), 0), this.gotoFrame(), this.autoplay && this.play()
                }
            }, AnimationItem.prototype.resize = function(l, i) {
                var o = typeof l == "number" ? l : void 0,
                    c = typeof i == "number" ? i : void 0;
                this.renderer.updateContainerSize(o, c)
            }, AnimationItem.prototype.setSubframe = function(l) {
                this.isSubframeEnabled = !!l
            }, AnimationItem.prototype.gotoFrame = function() {
                this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame")
            }, AnimationItem.prototype.renderFrame = function() {
                if (!(this.isLoaded === !1 || !this.renderer)) try {
                    this.expressionsPlugin && this.expressionsPlugin.resetFrame(), this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                } catch (l) {
                    this.triggerRenderFrameError(l)
                }
            }, AnimationItem.prototype.play = function(l) {
                l && this.name !== l || this.isPaused === !0 && (this.isPaused = !1, this.trigger("_play"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")))
            }, AnimationItem.prototype.pause = function(l) {
                l && this.name !== l || this.isPaused === !1 && (this.isPaused = !0, this.trigger("_pause"), this._idle = !0, this.trigger("_idle"), this.audioController.pause())
            }, AnimationItem.prototype.togglePause = function(l) {
                l && this.name !== l || (this.isPaused === !0 ? this.play() : this.pause())
            }, AnimationItem.prototype.stop = function(l) {
                l && this.name !== l || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0))
            }, AnimationItem.prototype.getMarkerData = function(l) {
                for (var i, o = 0; o < this.markers.length; o += 1)
                    if (i = this.markers[o], i.payload && i.payload.name === l) return i;
                return null
            }, AnimationItem.prototype.goToAndStop = function(l, i, o) {
                if (!(o && this.name !== o)) {
                    var c = Number(l);
                    if (isNaN(c)) {
                        var u = this.getMarkerData(l);
                        u && this.goToAndStop(u.time, !0)
                    } else i ? this.setCurrentRawFrameValue(l) : this.setCurrentRawFrameValue(l * this.frameModifier);
                    this.pause()
                }
            }, AnimationItem.prototype.goToAndPlay = function(l, i, o) {
                if (!(o && this.name !== o)) {
                    var c = Number(l);
                    if (isNaN(c)) {
                        var u = this.getMarkerData(l);
                        u && (u.duration ? this.playSegments([u.time, u.time + u.duration], !0) : this.goToAndStop(u.time, !0))
                    } else this.goToAndStop(c, i, o);
                    this.play()
                }
            }, AnimationItem.prototype.advanceTime = function(l) {
                if (!(this.isPaused === !0 || this.isLoaded === !1)) {
                    var i = this.currentRawFrame + l * this.frameModifier,
                        o = !1;
                    i >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(i > this.totalFrames ? i % this.totalFrames : 0) || (o = !0, i = this.totalFrames - 1) : i >= this.totalFrames ? (this.playCount += 1, this.checkSegments(i % this.totalFrames) || (this.setCurrentRawFrameValue(i % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(i) : i < 0 ? this.checkSegments(i % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + i % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (o = !0, i = 0)) : this.setCurrentRawFrameValue(i), o && (this.setCurrentRawFrameValue(i), this.pause(), this.trigger("complete"))
                }
            }, AnimationItem.prototype.adjustSegment = function(l, i) {
                this.playCount = 0, l[1] < l[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = l[0] - l[1], this.timeCompleted = this.totalFrames, this.firstFrame = l[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - i)) : l[1] > l[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = l[1] - l[0], this.timeCompleted = this.totalFrames, this.firstFrame = l[0], this.setCurrentRawFrameValue(.001 + i)), this.trigger("segmentStart")
            }, AnimationItem.prototype.setSegment = function(l, i) {
                var o = -1;
                this.isPaused && (this.currentRawFrame + this.firstFrame < l ? o = l : this.currentRawFrame + this.firstFrame > i && (o = i - l)), this.firstFrame = l, this.totalFrames = i - l, this.timeCompleted = this.totalFrames, o !== -1 && this.goToAndStop(o, !0)
            }, AnimationItem.prototype.playSegments = function(l, i) {
                if (i && (this.segments.length = 0), _typeof$4(l[0]) === "object") {
                    var o, c = l.length;
                    for (o = 0; o < c; o += 1) this.segments.push(l[o])
                } else this.segments.push(l);
                this.segments.length && i && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play()
            }, AnimationItem.prototype.resetSegments = function(l) {
                this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), l && this.checkSegments(0)
            }, AnimationItem.prototype.checkSegments = function(l) {
                return this.segments.length ? (this.adjustSegment(this.segments.shift(), l), !0) : !1
            }, AnimationItem.prototype.destroy = function(l) {
                l && this.name !== l || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.expressionsPlugin = null, this.imagePreloader = null, this.projectInterface = null)
            }, AnimationItem.prototype.setCurrentRawFrameValue = function(l) {
                this.currentRawFrame = l, this.gotoFrame()
            }, AnimationItem.prototype.setSpeed = function(l) {
                this.playSpeed = l, this.updaFrameModifier()
            }, AnimationItem.prototype.setDirection = function(l) {
                this.playDirection = l < 0 ? -1 : 1, this.updaFrameModifier()
            }, AnimationItem.prototype.setLoop = function(l) {
                this.loop = l
            }, AnimationItem.prototype.setVolume = function(l, i) {
                i && this.name !== i || this.audioController.setVolume(l)
            }, AnimationItem.prototype.getVolume = function() {
                return this.audioController.getVolume()
            }, AnimationItem.prototype.mute = function(l) {
                l && this.name !== l || this.audioController.mute()
            }, AnimationItem.prototype.unmute = function(l) {
                l && this.name !== l || this.audioController.unmute()
            }, AnimationItem.prototype.updaFrameModifier = function() {
                this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection)
            }, AnimationItem.prototype.getPath = function() {
                return this.path
            }, AnimationItem.prototype.getAssetsPath = function(l) {
                var i = "";
                if (l.e) i = l.p;
                else if (this.assetsPath) {
                    var o = l.p;
                    o.indexOf("images/") !== -1 && (o = o.split("/")[1]), i = this.assetsPath + o
                } else i = this.path, i += l.u ? l.u : "", i += l.p;
                return i
            }, AnimationItem.prototype.getAssetData = function(l) {
                for (var i = 0, o = this.assets.length; i < o;) {
                    if (l === this.assets[i].id) return this.assets[i];
                    i += 1
                }
                return null
            }, AnimationItem.prototype.hide = function() {
                this.renderer.hide()
            }, AnimationItem.prototype.show = function() {
                this.renderer.show()
            }, AnimationItem.prototype.getDuration = function(l) {
                return l ? this.totalFrames : this.totalFrames / this.frameRate
            }, AnimationItem.prototype.updateDocumentData = function(l, i, o) {
                try {
                    var c = this.renderer.getElementByPath(l);
                    c.updateDocumentData(i, o)
                } catch {}
            }, AnimationItem.prototype.trigger = function(l) {
                if (this._cbs && this._cbs[l]) switch (l) {
                    case "enterFrame":
                        this.triggerEvent(l, new BMEnterFrameEvent(l, this.currentFrame, this.totalFrames, this.frameModifier));
                        break;
                    case "drawnFrame":
                        this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(l, this.drawnFrameEvent);
                        break;
                    case "loopComplete":
                        this.triggerEvent(l, new BMCompleteLoopEvent(l, this.loop, this.playCount, this.frameMult));
                        break;
                    case "complete":
                        this.triggerEvent(l, new BMCompleteEvent(l, this.frameMult));
                        break;
                    case "segmentStart":
                        this.triggerEvent(l, new BMSegmentStartEvent(l, this.firstFrame, this.totalFrames));
                        break;
                    case "destroy":
                        this.triggerEvent(l, new BMDestroyEvent(l, this));
                        break;
                    default:
                        this.triggerEvent(l)
                }
                l === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(l, this.currentFrame, this.totalFrames, this.frameMult)), l === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(l, this.loop, this.playCount, this.frameMult)), l === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(l, this.frameMult)), l === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(l, this.firstFrame, this.totalFrames)), l === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(l, this))
            }, AnimationItem.prototype.triggerRenderFrameError = function(l) {
                var i = new BMRenderFrameErrorEvent(l, this.currentFrame);
                this.triggerEvent("error", i), this.onError && this.onError.call(this, i)
            }, AnimationItem.prototype.triggerConfigError = function(l) {
                var i = new BMConfigErrorEvent(l, this.currentFrame);
                this.triggerEvent("error", i), this.onError && this.onError.call(this, i)
            };
            var animationManager = function() {
                    var l = {},
                        i = [],
                        o = 0,
                        c = 0,
                        u = 0,
                        p = !0,
                        m = !1;

                    function g(O) {
                        for (var G = 0, L = O.target; G < c;) i[G].animation === L && (i.splice(G, 1), G -= 1, c -= 1, L.isPaused || y()), G += 1
                    }

                    function _(O, G) {
                        if (!O) return null;
                        for (var L = 0; L < c;) {
                            if (i[L].elem === O && i[L].elem !== null) return i[L].animation;
                            L += 1
                        }
                        var N = new AnimationItem;
                        return b(N, O), N.setData(O, G), N
                    }

                    function v() {
                        var O, G = i.length,
                            L = [];
                        for (O = 0; O < G; O += 1) L.push(i[O].animation);
                        return L
                    }

                    function x() {
                        u += 1, V()
                    }

                    function y() {
                        u -= 1
                    }

                    function b(O, G) {
                        O.addEventListener("destroy", g), O.addEventListener("_active", x), O.addEventListener("_idle", y), i.push({
                            elem: G,
                            animation: O
                        }), c += 1
                    }

                    function S(O) {
                        var G = new AnimationItem;
                        return b(G, null), G.setParams(O), G
                    }

                    function C(O, G) {
                        var L;
                        for (L = 0; L < c; L += 1) i[L].animation.setSpeed(O, G)
                    }

                    function E(O, G) {
                        var L;
                        for (L = 0; L < c; L += 1) i[L].animation.setDirection(O, G)
                    }

                    function P(O) {
                        var G;
                        for (G = 0; G < c; G += 1) i[G].animation.play(O)
                    }

                    function w(O) {
                        var G = O - o,
                            L;
                        for (L = 0; L < c; L += 1) i[L].animation.advanceTime(G);
                        o = O, u && !m ? window.requestAnimationFrame(w) : p = !0
                    }

                    function T(O) {
                        o = O, window.requestAnimationFrame(w)
                    }

                    function M(O) {
                        var G;
                        for (G = 0; G < c; G += 1) i[G].animation.pause(O)
                    }

                    function A(O, G, L) {
                        var N;
                        for (N = 0; N < c; N += 1) i[N].animation.goToAndStop(O, G, L)
                    }

                    function D(O) {
                        var G;
                        for (G = 0; G < c; G += 1) i[G].animation.stop(O)
                    }

                    function R(O) {
                        var G;
                        for (G = 0; G < c; G += 1) i[G].animation.togglePause(O)
                    }

                    function I(O) {
                        var G;
                        for (G = c - 1; G >= 0; G -= 1) i[G].animation.destroy(O)
                    }

                    function k(O, G, L) {
                        var N = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))),
                            K, Z = N.length;
                        for (K = 0; K < Z; K += 1) L && N[K].setAttribute("data-bm-type", L), _(N[K], O);
                        if (G && Z === 0) {
                            L || (L = "svg");
                            var he = document.getElementsByTagName("body")[0];
                            he.innerText = "";
                            var we = createTag("div");
                            we.style.width = "100%", we.style.height = "100%", we.setAttribute("data-bm-type", L), he.appendChild(we), _(we, O)
                        }
                    }

                    function F() {
                        var O;
                        for (O = 0; O < c; O += 1) i[O].animation.resize()
                    }

                    function V() {
                        !m && u && p && (window.requestAnimationFrame(T), p = !1)
                    }

                    function B() {
                        m = !0
                    }

                    function U() {
                        m = !1, V()
                    }

                    function H(O, G) {
                        var L;
                        for (L = 0; L < c; L += 1) i[L].animation.setVolume(O, G)
                    }

                    function Q(O) {
                        var G;
                        for (G = 0; G < c; G += 1) i[G].animation.mute(O)
                    }

                    function Y(O) {
                        var G;
                        for (G = 0; G < c; G += 1) i[G].animation.unmute(O)
                    }
                    return l.registerAnimation = _, l.loadAnimation = S, l.setSpeed = C, l.setDirection = E, l.play = P, l.pause = M, l.stop = D, l.togglePause = R, l.searchAnimations = k, l.resize = F, l.goToAndStop = A, l.destroy = I, l.freeze = B, l.unfreeze = U, l.setVolume = H, l.mute = Q, l.unmute = Y, l.getRegisteredAnimations = v, l
                }(),
                BezierFactory = function() {
                    var l = {};
                    l.getBezierEasing = o;
                    var i = {};

                    function o(T, M, A, D, R) {
                        var I = R || ("bez_" + T + "_" + M + "_" + A + "_" + D).replace(/\./g, "p");
                        if (i[I]) return i[I];
                        var k = new w([T, M, A, D]);
                        return i[I] = k, k
                    }
                    var c = 4,
                        u = .001,
                        p = 1e-7,
                        m = 10,
                        g = 11,
                        _ = 1 / (g - 1),
                        v = typeof Float32Array == "function";

                    function x(T, M) {
                        return 1 - 3 * M + 3 * T
                    }

                    function y(T, M) {
                        return 3 * M - 6 * T
                    }

                    function b(T) {
                        return 3 * T
                    }

                    function S(T, M, A) {
                        return ((x(M, A) * T + y(M, A)) * T + b(M)) * T
                    }

                    function C(T, M, A) {
                        return 3 * x(M, A) * T * T + 2 * y(M, A) * T + b(M)
                    }

                    function E(T, M, A, D, R) {
                        var I, k, F = 0;
                        do k = M + (A - M) / 2, I = S(k, D, R) - T, I > 0 ? A = k : M = k; while (Math.abs(I) > p && ++F < m);
                        return k
                    }

                    function P(T, M, A, D) {
                        for (var R = 0; R < c; ++R) {
                            var I = C(M, A, D);
                            if (I === 0) return M;
                            var k = S(M, A, D) - T;
                            M -= k / I
                        }
                        return M
                    }

                    function w(T) {
                        this._p = T, this._mSampleValues = v ? new Float32Array(g) : new Array(g), this._precomputed = !1, this.get = this.get.bind(this)
                    }
                    return w.prototype = {
                        get: function(M) {
                            var A = this._p[0],
                                D = this._p[1],
                                R = this._p[2],
                                I = this._p[3];
                            return this._precomputed || this._precompute(), A === D && R === I ? M : M === 0 ? 0 : M === 1 ? 1 : S(this._getTForX(M), D, I)
                        },
                        _precompute: function() {
                            var M = this._p[0],
                                A = this._p[1],
                                D = this._p[2],
                                R = this._p[3];
                            this._precomputed = !0, (M !== A || D !== R) && this._calcSampleValues()
                        },
                        _calcSampleValues: function() {
                            for (var M = this._p[0], A = this._p[2], D = 0; D < g; ++D) this._mSampleValues[D] = S(D * _, M, A)
                        },
                        _getTForX: function(M) {
                            for (var A = this._p[0], D = this._p[2], R = this._mSampleValues, I = 0, k = 1, F = g - 1; k !== F && R[k] <= M; ++k) I += _;
                            --k;
                            var V = (M - R[k]) / (R[k + 1] - R[k]),
                                B = I + V * _,
                                U = C(B, A, D);
                            return U >= u ? P(M, B, A, D) : U === 0 ? B : E(M, I, I + _, A, D)
                        }
                    }, l
                }(),
                pooling = function() {
                    function l(i) {
                        return i.concat(createSizedArray(i.length))
                    }
                    return {
                        double: l
                    }
                }(),
                poolFactory = function() {
                    return function(l, i, o) {
                        var c = 0,
                            u = l,
                            p = createSizedArray(u),
                            m = {
                                newElement: g,
                                release: _
                            };

                        function g() {
                            var v;
                            return c ? (c -= 1, v = p[c]) : v = i(), v
                        }

                        function _(v) {
                            c === u && (p = pooling.double(p), u *= 2), o && o(v), p[c] = v, c += 1
                        }
                        return m
                    }
                }(),
                bezierLengthPool = function() {
                    function l() {
                        return {
                            addedLength: 0,
                            percents: createTypedArray("float32", getDefaultCurveSegments()),
                            lengths: createTypedArray("float32", getDefaultCurveSegments())
                        }
                    }
                    return poolFactory(8, l)
                }(),
                segmentsLengthPool = function() {
                    function l() {
                        return {
                            lengths: [],
                            totalLength: 0
                        }
                    }

                    function i(o) {
                        var c, u = o.lengths.length;
                        for (c = 0; c < u; c += 1) bezierLengthPool.release(o.lengths[c]);
                        o.lengths.length = 0
                    }
                    return poolFactory(8, l, i)
                }();

            function bezFunction() {
                var l = Math;

                function i(b, S, C, E, P, w) {
                    var T = b * E + S * P + C * w - P * E - w * b - C * S;
                    return T > -.001 && T < .001
                }

                function o(b, S, C, E, P, w, T, M, A) {
                    if (C === 0 && w === 0 && A === 0) return i(b, S, E, P, T, M);
                    var D = l.sqrt(l.pow(E - b, 2) + l.pow(P - S, 2) + l.pow(w - C, 2)),
                        R = l.sqrt(l.pow(T - b, 2) + l.pow(M - S, 2) + l.pow(A - C, 2)),
                        I = l.sqrt(l.pow(T - E, 2) + l.pow(M - P, 2) + l.pow(A - w, 2)),
                        k;
                    return D > R ? D > I ? k = D - R - I : k = I - R - D : I > R ? k = I - R - D : k = R - D - I, k > -1e-4 && k < 1e-4
                }
                var c = function() {
                    return function(b, S, C, E) {
                        var P = getDefaultCurveSegments(),
                            w, T, M, A, D, R = 0,
                            I, k = [],
                            F = [],
                            V = bezierLengthPool.newElement();
                        for (M = C.length, w = 0; w < P; w += 1) {
                            for (D = w / (P - 1), I = 0, T = 0; T < M; T += 1) A = bmPow(1 - D, 3) * b[T] + 3 * bmPow(1 - D, 2) * D * C[T] + 3 * (1 - D) * bmPow(D, 2) * E[T] + bmPow(D, 3) * S[T], k[T] = A, F[T] !== null && (I += bmPow(k[T] - F[T], 2)), F[T] = k[T];
                            I && (I = bmSqrt(I), R += I), V.percents[w] = D, V.lengths[w] = R
                        }
                        return V.addedLength = R, V
                    }
                }();

                function u(b) {
                    var S = segmentsLengthPool.newElement(),
                        C = b.c,
                        E = b.v,
                        P = b.o,
                        w = b.i,
                        T, M = b._length,
                        A = S.lengths,
                        D = 0;
                    for (T = 0; T < M - 1; T += 1) A[T] = c(E[T], E[T + 1], P[T], w[T + 1]), D += A[T].addedLength;
                    return C && M && (A[T] = c(E[T], E[0], P[T], w[0]), D += A[T].addedLength), S.totalLength = D, S
                }

                function p(b) {
                    this.segmentLength = 0, this.points = new Array(b)
                }

                function m(b, S) {
                    this.partialLength = b, this.point = S
                }
                var g = function() {
                    var b = {};
                    return function(S, C, E, P) {
                        var w = (S[0] + "_" + S[1] + "_" + C[0] + "_" + C[1] + "_" + E[0] + "_" + E[1] + "_" + P[0] + "_" + P[1]).replace(/\./g, "p");
                        if (!b[w]) {
                            var T = getDefaultCurveSegments(),
                                M, A, D, R, I, k = 0,
                                F, V, B = null;
                            S.length === 2 && (S[0] !== C[0] || S[1] !== C[1]) && i(S[0], S[1], C[0], C[1], S[0] + E[0], S[1] + E[1]) && i(S[0], S[1], C[0], C[1], C[0] + P[0], C[1] + P[1]) && (T = 2);
                            var U = new p(T);
                            for (D = E.length, M = 0; M < T; M += 1) {
                                for (V = createSizedArray(D), I = M / (T - 1), F = 0, A = 0; A < D; A += 1) R = bmPow(1 - I, 3) * S[A] + 3 * bmPow(1 - I, 2) * I * (S[A] + E[A]) + 3 * (1 - I) * bmPow(I, 2) * (C[A] + P[A]) + bmPow(I, 3) * C[A], V[A] = R, B !== null && (F += bmPow(V[A] - B[A], 2));
                                F = bmSqrt(F), k += F, U.points[M] = new m(F, V), B = V
                            }
                            U.segmentLength = k, b[w] = U
                        }
                        return b[w]
                    }
                }();

                function _(b, S) {
                    var C = S.percents,
                        E = S.lengths,
                        P = C.length,
                        w = bmFloor((P - 1) * b),
                        T = b * S.addedLength,
                        M = 0;
                    if (w === P - 1 || w === 0 || T === E[w]) return C[w];
                    for (var A = E[w] > T ? -1 : 1, D = !0; D;)
                        if (E[w] <= T && E[w + 1] > T ? (M = (T - E[w]) / (E[w + 1] - E[w]), D = !1) : w += A, w < 0 || w >= P - 1) {
                            if (w === P - 1) return C[w];
                            D = !1
                        }
                    return C[w] + (C[w + 1] - C[w]) * M
                }

                function v(b, S, C, E, P, w) {
                    var T = _(P, w),
                        M = 1 - T,
                        A = l.round((M * M * M * b[0] + (T * M * M + M * T * M + M * M * T) * C[0] + (T * T * M + M * T * T + T * M * T) * E[0] + T * T * T * S[0]) * 1e3) / 1e3,
                        D = l.round((M * M * M * b[1] + (T * M * M + M * T * M + M * M * T) * C[1] + (T * T * M + M * T * T + T * M * T) * E[1] + T * T * T * S[1]) * 1e3) / 1e3;
                    return [A, D]
                }
                var x = createTypedArray("float32", 8);

                function y(b, S, C, E, P, w, T) {
                    P < 0 ? P = 0 : P > 1 && (P = 1);
                    var M = _(P, T);
                    w = w > 1 ? 1 : w;
                    var A = _(w, T),
                        D, R = b.length,
                        I = 1 - M,
                        k = 1 - A,
                        F = I * I * I,
                        V = M * I * I * 3,
                        B = M * M * I * 3,
                        U = M * M * M,
                        H = I * I * k,
                        Q = M * I * k + I * M * k + I * I * A,
                        Y = M * M * k + I * M * A + M * I * A,
                        O = M * M * A,
                        G = I * k * k,
                        L = M * k * k + I * A * k + I * k * A,
                        N = M * A * k + I * A * A + M * k * A,
                        K = M * A * A,
                        Z = k * k * k,
                        he = A * k * k + k * A * k + k * k * A,
                        we = A * A * k + k * A * A + A * k * A,
                        ie = A * A * A;
                    for (D = 0; D < R; D += 1) x[D * 4] = l.round((F * b[D] + V * C[D] + B * E[D] + U * S[D]) * 1e3) / 1e3, x[D * 4 + 1] = l.round((H * b[D] + Q * C[D] + Y * E[D] + O * S[D]) * 1e3) / 1e3, x[D * 4 + 2] = l.round((G * b[D] + L * C[D] + N * E[D] + K * S[D]) * 1e3) / 1e3, x[D * 4 + 3] = l.round((Z * b[D] + he * C[D] + we * E[D] + ie * S[D]) * 1e3) / 1e3;
                    return x
                }
                return {
                    getSegmentsLength: u,
                    getNewSegment: y,
                    getPointInSegment: v,
                    buildBezierData: g,
                    pointOnLine2D: i,
                    pointOnLine3D: o
                }
            }
            var bez = bezFunction(),
                initFrame = initialDefaultFrame,
                mathAbs = Math.abs;

            function interpolateValue(l, i) {
                var o = this.offsetTime,
                    c;
                this.propType === "multidimensional" && (c = createTypedArray("float32", this.pv.length));
                for (var u = i.lastIndex, p = u, m = this.keyframes.length - 1, g = !0, _, v, x; g;) {
                    if (_ = this.keyframes[p], v = this.keyframes[p + 1], p === m - 1 && l >= v.t - o) {
                        _.h && (_ = v), u = 0;
                        break
                    }
                    if (v.t - o > l) {
                        u = p;
                        break
                    }
                    p < m - 1 ? p += 1 : (u = 0, g = !1)
                }
                x = this.keyframesMetadata[p] || {};
                var y, b, S, C, E, P, w = v.t - o,
                    T = _.t - o,
                    M;
                if (_.to) {
                    x.bezierData || (x.bezierData = bez.buildBezierData(_.s, v.s || _.e, _.to, _.ti));
                    var A = x.bezierData;
                    if (l >= w || l < T) {
                        var D = l >= w ? A.points.length - 1 : 0;
                        for (b = A.points[D].point.length, y = 0; y < b; y += 1) c[y] = A.points[D].point[y]
                    } else {
                        x.__fnct ? P = x.__fnct : (P = BezierFactory.getBezierEasing(_.o.x, _.o.y, _.i.x, _.i.y, _.n).get, x.__fnct = P), S = P((l - T) / (w - T));
                        var R = A.segmentLength * S,
                            I, k = i.lastFrame < l && i._lastKeyframeIndex === p ? i._lastAddedLength : 0;
                        for (E = i.lastFrame < l && i._lastKeyframeIndex === p ? i._lastPoint : 0, g = !0, C = A.points.length; g;) {
                            if (k += A.points[E].partialLength, R === 0 || S === 0 || E === A.points.length - 1) {
                                for (b = A.points[E].point.length, y = 0; y < b; y += 1) c[y] = A.points[E].point[y];
                                break
                            } else if (R >= k && R < k + A.points[E + 1].partialLength) {
                                for (I = (R - k) / A.points[E + 1].partialLength, b = A.points[E].point.length, y = 0; y < b; y += 1) c[y] = A.points[E].point[y] + (A.points[E + 1].point[y] - A.points[E].point[y]) * I;
                                break
                            }
                            E < C - 1 ? E += 1 : g = !1
                        }
                        i._lastPoint = E, i._lastAddedLength = k - A.points[E].partialLength, i._lastKeyframeIndex = p
                    }
                } else {
                    var F, V, B, U, H;
                    if (m = _.s.length, M = v.s || _.e, this.sh && _.h !== 1)
                        if (l >= w) c[0] = M[0], c[1] = M[1], c[2] = M[2];
                        else if (l <= T) c[0] = _.s[0], c[1] = _.s[1], c[2] = _.s[2];
                    else {
                        var Q = createQuaternion(_.s),
                            Y = createQuaternion(M),
                            O = (l - T) / (w - T);
                        quaternionToEuler(c, slerp(Q, Y, O))
                    } else
                        for (p = 0; p < m; p += 1) _.h !== 1 && (l >= w ? S = 1 : l < T ? S = 0 : (_.o.x.constructor === Array ? (x.__fnct || (x.__fnct = []), x.__fnct[p] ? P = x.__fnct[p] : (F = _.o.x[p] === void 0 ? _.o.x[0] : _.o.x[p], V = _.o.y[p] === void 0 ? _.o.y[0] : _.o.y[p], B = _.i.x[p] === void 0 ? _.i.x[0] : _.i.x[p], U = _.i.y[p] === void 0 ? _.i.y[0] : _.i.y[p], P = BezierFactory.getBezierEasing(F, V, B, U).get, x.__fnct[p] = P)) : x.__fnct ? P = x.__fnct : (F = _.o.x, V = _.o.y, B = _.i.x, U = _.i.y, P = BezierFactory.getBezierEasing(F, V, B, U).get, _.keyframeMetadata = P), S = P((l - T) / (w - T)))), M = v.s || _.e, H = _.h === 1 ? _.s[p] : _.s[p] + (M[p] - _.s[p]) * S, this.propType === "multidimensional" ? c[p] = H : c = H
                }
                return i.lastIndex = u, c
            }

            function slerp(l, i, o) {
                var c = [],
                    u = l[0],
                    p = l[1],
                    m = l[2],
                    g = l[3],
                    _ = i[0],
                    v = i[1],
                    x = i[2],
                    y = i[3],
                    b, S, C, E, P;
                return S = u * _ + p * v + m * x + g * y, S < 0 && (S = -S, _ = -_, v = -v, x = -x, y = -y), 1 - S > 1e-6 ? (b = Math.acos(S), C = Math.sin(b), E = Math.sin((1 - o) * b) / C, P = Math.sin(o * b) / C) : (E = 1 - o, P = o), c[0] = E * u + P * _, c[1] = E * p + P * v, c[2] = E * m + P * x, c[3] = E * g + P * y, c
            }

            function quaternionToEuler(l, i) {
                var o = i[0],
                    c = i[1],
                    u = i[2],
                    p = i[3],
                    m = Math.atan2(2 * c * p - 2 * o * u, 1 - 2 * c * c - 2 * u * u),
                    g = Math.asin(2 * o * c + 2 * u * p),
                    _ = Math.atan2(2 * o * p - 2 * c * u, 1 - 2 * o * o - 2 * u * u);
                l[0] = m / degToRads, l[1] = g / degToRads, l[2] = _ / degToRads
            }

            function createQuaternion(l) {
                var i = l[0] * degToRads,
                    o = l[1] * degToRads,
                    c = l[2] * degToRads,
                    u = Math.cos(i / 2),
                    p = Math.cos(o / 2),
                    m = Math.cos(c / 2),
                    g = Math.sin(i / 2),
                    _ = Math.sin(o / 2),
                    v = Math.sin(c / 2),
                    x = u * p * m - g * _ * v,
                    y = g * _ * m + u * p * v,
                    b = g * p * m + u * _ * v,
                    S = u * _ * m - g * p * v;
                return [y, b, S, x]
            }

            function getValueAtCurrentTime() {
                var l = this.comp.renderedFrame - this.offsetTime,
                    i = this.keyframes[0].t - this.offsetTime,
                    o = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                if (!(l === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= o && l >= o || this._caching.lastFrame < i && l < i))) {
                    this._caching.lastFrame >= l && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
                    var c = this.interpolateValue(l, this._caching);
                    this.pv = c
                }
                return this._caching.lastFrame = l, this.pv
            }

            function setVValue(l) {
                var i;
                if (this.propType === "unidimensional") i = l * this.mult, mathAbs(this.v - i) > 1e-5 && (this.v = i, this._mdf = !0);
                else
                    for (var o = 0, c = this.v.length; o < c;) i = l[o] * this.mult, mathAbs(this.v[o] - i) > 1e-5 && (this.v[o] = i, this._mdf = !0), o += 1
            }

            function processEffectsSequence() {
                if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) {
                    if (this.lock) {
                        this.setVValue(this.pv);
                        return
                    }
                    this.lock = !0, this._mdf = this._isFirstFrame;
                    var l, i = this.effectsSequence.length,
                        o = this.kf ? this.pv : this.data.k;
                    for (l = 0; l < i; l += 1) o = this.effectsSequence[l](o);
                    this.setVValue(o), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId
                }
            }

            function addEffect(l) {
                this.effectsSequence.push(l), this.container.addDynamicProperty(this)
            }

            function ValueProperty(l, i, o, c) {
                this.propType = "unidimensional", this.mult = o || 1, this.data = i, this.v = o ? i.k * o : i.k, this.pv = i.k, this._mdf = !1, this.elem = l, this.container = c, this.comp = l.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect
            }

            function MultiDimensionalProperty(l, i, o, c) {
                this.propType = "multidimensional", this.mult = o || 1, this.data = i, this._mdf = !1, this.elem = l, this.container = c, this.comp = l.comp, this.k = !1, this.kf = !1, this.frameId = -1;
                var u, p = i.k.length;
                for (this.v = createTypedArray("float32", p), this.pv = createTypedArray("float32", p), this.vel = createTypedArray("float32", p), u = 0; u < p; u += 1) this.v[u] = i.k[u] * this.mult, this.pv[u] = i.k[u];
                this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect
            }

            function KeyframedValueProperty(l, i, o, c) {
                this.propType = "unidimensional", this.keyframes = i.k, this.keyframesMetadata = [], this.offsetTime = l.data.st, this.frameId = -1, this._caching = {
                    lastFrame: initFrame,
                    lastIndex: 0,
                    value: 0,
                    _lastKeyframeIndex: -1
                }, this.k = !0, this.kf = !0, this.data = i, this.mult = o || 1, this.elem = l, this.container = c, this.comp = l.comp, this.v = initFrame, this.pv = initFrame, this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.addEffect = addEffect
            }

            function KeyframedMultidimensionalProperty(l, i, o, c) {
                this.propType = "multidimensional";
                var u, p = i.k.length,
                    m, g, _, v;
                for (u = 0; u < p - 1; u += 1) i.k[u].to && i.k[u].s && i.k[u + 1] && i.k[u + 1].s && (m = i.k[u].s, g = i.k[u + 1].s, _ = i.k[u].to, v = i.k[u].ti, (m.length === 2 && !(m[0] === g[0] && m[1] === g[1]) && bez.pointOnLine2D(m[0], m[1], g[0], g[1], m[0] + _[0], m[1] + _[1]) && bez.pointOnLine2D(m[0], m[1], g[0], g[1], g[0] + v[0], g[1] + v[1]) || m.length === 3 && !(m[0] === g[0] && m[1] === g[1] && m[2] === g[2]) && bez.pointOnLine3D(m[0], m[1], m[2], g[0], g[1], g[2], m[0] + _[0], m[1] + _[1], m[2] + _[2]) && bez.pointOnLine3D(m[0], m[1], m[2], g[0], g[1], g[2], g[0] + v[0], g[1] + v[1], g[2] + v[2])) && (i.k[u].to = null, i.k[u].ti = null), m[0] === g[0] && m[1] === g[1] && _[0] === 0 && _[1] === 0 && v[0] === 0 && v[1] === 0 && (m.length === 2 || m[2] === g[2] && _[2] === 0 && v[2] === 0) && (i.k[u].to = null, i.k[u].ti = null));
                this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.data = i, this.keyframes = i.k, this.keyframesMetadata = [], this.offsetTime = l.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = o || 1, this.elem = l, this.container = c, this.comp = l.comp, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.frameId = -1;
                var x = i.k[0].s.length;
                for (this.v = createTypedArray("float32", x), this.pv = createTypedArray("float32", x), u = 0; u < x; u += 1) this.v[u] = initFrame, this.pv[u] = initFrame;
                this._caching = {
                    lastFrame: initFrame,
                    lastIndex: 0,
                    value: createTypedArray("float32", x)
                }, this.addEffect = addEffect
            }
            var PropertyFactory = function() {
                function l(o, c, u, p, m) {
                    c.sid && (c = o.globalData.slotManager.getProp(c));
                    var g;
                    if (!c.k.length) g = new ValueProperty(o, c, p, m);
                    else if (typeof c.k[0] == "number") g = new MultiDimensionalProperty(o, c, p, m);
                    else switch (u) {
                        case 0:
                            g = new KeyframedValueProperty(o, c, p, m);
                            break;
                        case 1:
                            g = new KeyframedMultidimensionalProperty(o, c, p, m);
                            break
                    }
                    return g.effectsSequence.length && m.addDynamicProperty(g), g
                }
                var i = {
                    getProp: l
                };
                return i
            }();

            function DynamicPropertyContainer() {}
            DynamicPropertyContainer.prototype = {
                addDynamicProperty: function(i) {
                    this.dynamicProperties.indexOf(i) === -1 && (this.dynamicProperties.push(i), this.container.addDynamicProperty(this), this._isAnimated = !0)
                },
                iterateDynamicProperties: function() {
                    this._mdf = !1;
                    var i, o = this.dynamicProperties.length;
                    for (i = 0; i < o; i += 1) this.dynamicProperties[i].getValue(), this.dynamicProperties[i]._mdf && (this._mdf = !0)
                },
                initDynamicPropertyContainer: function(i) {
                    this.container = i, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1
                }
            };
            var pointPool = function() {
                function l() {
                    return createTypedArray("float32", 2)
                }
                return poolFactory(8, l)
            }();

            function ShapePath() {
                this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength)
            }
            ShapePath.prototype.setPathData = function(l, i) {
                this.c = l, this.setLength(i);
                for (var o = 0; o < i;) this.v[o] = pointPool.newElement(), this.o[o] = pointPool.newElement(), this.i[o] = pointPool.newElement(), o += 1
            }, ShapePath.prototype.setLength = function(l) {
                for (; this._maxLength < l;) this.doubleArrayLength();
                this._length = l
            }, ShapePath.prototype.doubleArrayLength = function() {
                this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2
            }, ShapePath.prototype.setXYAt = function(l, i, o, c, u) {
                var p;
                switch (this._length = Math.max(this._length, c + 1), this._length >= this._maxLength && this.doubleArrayLength(), o) {
                    case "v":
                        p = this.v;
                        break;
                    case "i":
                        p = this.i;
                        break;
                    case "o":
                        p = this.o;
                        break;
                    default:
                        p = [];
                        break
                }(!p[c] || p[c] && !u) && (p[c] = pointPool.newElement()), p[c][0] = l, p[c][1] = i
            }, ShapePath.prototype.setTripleAt = function(l, i, o, c, u, p, m, g) {
                this.setXYAt(l, i, "v", m, g), this.setXYAt(o, c, "o", m, g), this.setXYAt(u, p, "i", m, g)
            }, ShapePath.prototype.reverse = function() {
                var l = new ShapePath;
                l.setPathData(this.c, this._length);
                var i = this.v,
                    o = this.o,
                    c = this.i,
                    u = 0;
                this.c && (l.setTripleAt(i[0][0], i[0][1], c[0][0], c[0][1], o[0][0], o[0][1], 0, !1), u = 1);
                var p = this._length - 1,
                    m = this._length,
                    g;
                for (g = u; g < m; g += 1) l.setTripleAt(i[p][0], i[p][1], c[p][0], c[p][1], o[p][0], o[p][1], g, !1), p -= 1;
                return l
            }, ShapePath.prototype.length = function() {
                return this._length
            };
            var shapePool = function() {
                function l() {
                    return new ShapePath
                }

                function i(u) {
                    var p = u._length,
                        m;
                    for (m = 0; m < p; m += 1) pointPool.release(u.v[m]), pointPool.release(u.i[m]), pointPool.release(u.o[m]), u.v[m] = null, u.i[m] = null, u.o[m] = null;
                    u._length = 0, u.c = !1
                }

                function o(u) {
                    var p = c.newElement(),
                        m, g = u._length === void 0 ? u.v.length : u._length;
                    for (p.setLength(g), p.c = u.c, m = 0; m < g; m += 1) p.setTripleAt(u.v[m][0], u.v[m][1], u.o[m][0], u.o[m][1], u.i[m][0], u.i[m][1], m);
                    return p
                }
                var c = poolFactory(4, l, i);
                return c.clone = o, c
            }();

            function ShapeCollection() {
                this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength)
            }
            ShapeCollection.prototype.addShape = function(l) {
                this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = l, this._length += 1
            }, ShapeCollection.prototype.releaseShapes = function() {
                var l;
                for (l = 0; l < this._length; l += 1) shapePool.release(this.shapes[l]);
                this._length = 0
            };
            var shapeCollectionPool = function() {
                    var l = {
                            newShapeCollection: u,
                            release: p
                        },
                        i = 0,
                        o = 4,
                        c = createSizedArray(o);

                    function u() {
                        var m;
                        return i ? (i -= 1, m = c[i]) : m = new ShapeCollection, m
                    }

                    function p(m) {
                        var g, _ = m._length;
                        for (g = 0; g < _; g += 1) shapePool.release(m.shapes[g]);
                        m._length = 0, i === o && (c = pooling.double(c), o *= 2), c[i] = m, i += 1
                    }
                    return l
                }(),
                ShapePropertyFactory = function() {
                    var l = -999999;

                    function i(w, T, M) {
                        var A = M.lastIndex,
                            D, R, I, k, F, V, B, U, H, Q = this.keyframes;
                        if (w < Q[0].t - this.offsetTime) D = Q[0].s[0], I = !0, A = 0;
                        else if (w >= Q[Q.length - 1].t - this.offsetTime) D = Q[Q.length - 1].s ? Q[Q.length - 1].s[0] : Q[Q.length - 2].e[0], I = !0;
                        else {
                            for (var Y = A, O = Q.length - 1, G = !0, L, N, K; G && (L = Q[Y], N = Q[Y + 1], !(N.t - this.offsetTime > w));) Y < O - 1 ? Y += 1 : G = !1;
                            if (K = this.keyframesMetadata[Y] || {}, I = L.h === 1, A = Y, !I) {
                                if (w >= N.t - this.offsetTime) U = 1;
                                else if (w < L.t - this.offsetTime) U = 0;
                                else {
                                    var Z;
                                    K.__fnct ? Z = K.__fnct : (Z = BezierFactory.getBezierEasing(L.o.x, L.o.y, L.i.x, L.i.y).get, K.__fnct = Z), U = Z((w - (L.t - this.offsetTime)) / (N.t - this.offsetTime - (L.t - this.offsetTime)))
                                }
                                R = N.s ? N.s[0] : L.e[0]
                            }
                            D = L.s[0]
                        }
                        for (V = T._length, B = D.i[0].length, M.lastIndex = A, k = 0; k < V; k += 1)
                            for (F = 0; F < B; F += 1) H = I ? D.i[k][F] : D.i[k][F] + (R.i[k][F] - D.i[k][F]) * U, T.i[k][F] = H, H = I ? D.o[k][F] : D.o[k][F] + (R.o[k][F] - D.o[k][F]) * U, T.o[k][F] = H, H = I ? D.v[k][F] : D.v[k][F] + (R.v[k][F] - D.v[k][F]) * U, T.v[k][F] = H
                    }

                    function o() {
                        var w = this.comp.renderedFrame - this.offsetTime,
                            T = this.keyframes[0].t - this.offsetTime,
                            M = this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
                            A = this._caching.lastFrame;
                        return A !== l && (A < T && w < T || A > M && w > M) || (this._caching.lastIndex = A < w ? this._caching.lastIndex : 0, this.interpolateShape(w, this.pv, this._caching)), this._caching.lastFrame = w, this.pv
                    }

                    function c() {
                        this.paths = this.localShapeCollection
                    }

                    function u(w, T) {
                        if (w._length !== T._length || w.c !== T.c) return !1;
                        var M, A = w._length;
                        for (M = 0; M < A; M += 1)
                            if (w.v[M][0] !== T.v[M][0] || w.v[M][1] !== T.v[M][1] || w.o[M][0] !== T.o[M][0] || w.o[M][1] !== T.o[M][1] || w.i[M][0] !== T.i[M][0] || w.i[M][1] !== T.i[M][1]) return !1;
                        return !0
                    }

                    function p(w) {
                        u(this.v, w) || (this.v = shapePool.clone(w), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection)
                    }

                    function m() {
                        if (this.elem.globalData.frameId !== this.frameId) {
                            if (!this.effectsSequence.length) {
                                this._mdf = !1;
                                return
                            }
                            if (this.lock) {
                                this.setVValue(this.pv);
                                return
                            }
                            this.lock = !0, this._mdf = !1;
                            var w;
                            this.kf ? w = this.pv : this.data.ks ? w = this.data.ks.k : w = this.data.pt.k;
                            var T, M = this.effectsSequence.length;
                            for (T = 0; T < M; T += 1) w = this.effectsSequence[T](w);
                            this.setVValue(w), this.lock = !1, this.frameId = this.elem.globalData.frameId
                        }
                    }

                    function g(w, T, M) {
                        this.propType = "shape", this.comp = w.comp, this.container = w, this.elem = w, this.data = T, this.k = !1, this.kf = !1, this._mdf = !1;
                        var A = M === 3 ? T.pt.k : T.ks.k;
                        this.v = shapePool.clone(A), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = c, this.effectsSequence = []
                    }

                    function _(w) {
                        this.effectsSequence.push(w), this.container.addDynamicProperty(this)
                    }
                    g.prototype.interpolateShape = i, g.prototype.getValue = m, g.prototype.setVValue = p, g.prototype.addEffect = _;

                    function v(w, T, M) {
                        this.propType = "shape", this.comp = w.comp, this.elem = w, this.container = w, this.offsetTime = w.data.st, this.keyframes = M === 3 ? T.pt.k : T.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0;
                        var A = this.keyframes[0].s[0].i.length;
                        this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, A), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = l, this.reset = c, this._caching = {
                            lastFrame: l,
                            lastIndex: 0
                        }, this.effectsSequence = [o.bind(this)]
                    }
                    v.prototype.getValue = m, v.prototype.interpolateShape = i, v.prototype.setVValue = p, v.prototype.addEffect = _;
                    var x = function() {
                            var w = roundCorner;

                            function T(M, A) {
                                this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = A.d, this.elem = M, this.comp = M.comp, this.frameId = -1, this.initDynamicPropertyContainer(M), this.p = PropertyFactory.getProp(M, A.p, 1, 0, this), this.s = PropertyFactory.getProp(M, A.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath())
                            }
                            return T.prototype = {
                                reset: c,
                                getValue: function() {
                                    this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath())
                                },
                                convertEllToPath: function() {
                                    var A = this.p.v[0],
                                        D = this.p.v[1],
                                        R = this.s.v[0] / 2,
                                        I = this.s.v[1] / 2,
                                        k = this.d !== 3,
                                        F = this.v;
                                    F.v[0][0] = A, F.v[0][1] = D - I, F.v[1][0] = k ? A + R : A - R, F.v[1][1] = D, F.v[2][0] = A, F.v[2][1] = D + I, F.v[3][0] = k ? A - R : A + R, F.v[3][1] = D, F.i[0][0] = k ? A - R * w : A + R * w, F.i[0][1] = D - I, F.i[1][0] = k ? A + R : A - R, F.i[1][1] = D - I * w, F.i[2][0] = k ? A + R * w : A - R * w, F.i[2][1] = D + I, F.i[3][0] = k ? A - R : A + R, F.i[3][1] = D + I * w, F.o[0][0] = k ? A + R * w : A - R * w, F.o[0][1] = D - I, F.o[1][0] = k ? A + R : A - R, F.o[1][1] = D + I * w, F.o[2][0] = k ? A - R * w : A + R * w, F.o[2][1] = D + I, F.o[3][0] = k ? A - R : A + R, F.o[3][1] = D - I * w
                                }
                            }, extendPrototype([DynamicPropertyContainer], T), T
                        }(),
                        y = function() {
                            function w(T, M) {
                                this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = T, this.comp = T.comp, this.data = M, this.frameId = -1, this.d = M.d, this.initDynamicPropertyContainer(T), M.sy === 1 ? (this.ir = PropertyFactory.getProp(T, M.ir, 0, 0, this), this.is = PropertyFactory.getProp(T, M.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(T, M.pt, 0, 0, this), this.p = PropertyFactory.getProp(T, M.p, 1, 0, this), this.r = PropertyFactory.getProp(T, M.r, 0, degToRads, this), this.or = PropertyFactory.getProp(T, M.or, 0, 0, this), this.os = PropertyFactory.getProp(T, M.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath())
                            }
                            return w.prototype = {
                                reset: c,
                                getValue: function() {
                                    this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath())
                                },
                                convertStarToPath: function() {
                                    var M = Math.floor(this.pt.v) * 2,
                                        A = Math.PI * 2 / M,
                                        D = !0,
                                        R = this.or.v,
                                        I = this.ir.v,
                                        k = this.os.v,
                                        F = this.is.v,
                                        V = 2 * Math.PI * R / (M * 2),
                                        B = 2 * Math.PI * I / (M * 2),
                                        U, H, Q, Y, O = -Math.PI / 2;
                                    O += this.r.v;
                                    var G = this.data.d === 3 ? -1 : 1;
                                    for (this.v._length = 0, U = 0; U < M; U += 1) {
                                        H = D ? R : I, Q = D ? k : F, Y = D ? V : B;
                                        var L = H * Math.cos(O),
                                            N = H * Math.sin(O),
                                            K = L === 0 && N === 0 ? 0 : N / Math.sqrt(L * L + N * N),
                                            Z = L === 0 && N === 0 ? 0 : -L / Math.sqrt(L * L + N * N);
                                        L += +this.p.v[0], N += +this.p.v[1], this.v.setTripleAt(L, N, L - K * Y * Q * G, N - Z * Y * Q * G, L + K * Y * Q * G, N + Z * Y * Q * G, U, !0), D = !D, O += A * G
                                    }
                                },
                                convertPolygonToPath: function() {
                                    var M = Math.floor(this.pt.v),
                                        A = Math.PI * 2 / M,
                                        D = this.or.v,
                                        R = this.os.v,
                                        I = 2 * Math.PI * D / (M * 4),
                                        k, F = -Math.PI * .5,
                                        V = this.data.d === 3 ? -1 : 1;
                                    for (F += this.r.v, this.v._length = 0, k = 0; k < M; k += 1) {
                                        var B = D * Math.cos(F),
                                            U = D * Math.sin(F),
                                            H = B === 0 && U === 0 ? 0 : U / Math.sqrt(B * B + U * U),
                                            Q = B === 0 && U === 0 ? 0 : -B / Math.sqrt(B * B + U * U);
                                        B += +this.p.v[0], U += +this.p.v[1], this.v.setTripleAt(B, U, B - H * I * R * V, U - Q * I * R * V, B + H * I * R * V, U + Q * I * R * V, k, !0), F += A * V
                                    }
                                    this.paths.length = 0, this.paths[0] = this.v
                                }
                            }, extendPrototype([DynamicPropertyContainer], w), w
                        }(),
                        b = function() {
                            function w(T, M) {
                                this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = T, this.comp = T.comp, this.frameId = -1, this.d = M.d, this.initDynamicPropertyContainer(T), this.p = PropertyFactory.getProp(T, M.p, 1, 0, this), this.s = PropertyFactory.getProp(T, M.s, 1, 0, this), this.r = PropertyFactory.getProp(T, M.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath())
                            }
                            return w.prototype = {
                                convertRectToPath: function() {
                                    var M = this.p.v[0],
                                        A = this.p.v[1],
                                        D = this.s.v[0] / 2,
                                        R = this.s.v[1] / 2,
                                        I = bmMin(D, R, this.r.v),
                                        k = I * (1 - roundCorner);
                                    this.v._length = 0, this.d === 2 || this.d === 1 ? (this.v.setTripleAt(M + D, A - R + I, M + D, A - R + I, M + D, A - R + k, 0, !0), this.v.setTripleAt(M + D, A + R - I, M + D, A + R - k, M + D, A + R - I, 1, !0), I !== 0 ? (this.v.setTripleAt(M + D - I, A + R, M + D - I, A + R, M + D - k, A + R, 2, !0), this.v.setTripleAt(M - D + I, A + R, M - D + k, A + R, M - D + I, A + R, 3, !0), this.v.setTripleAt(M - D, A + R - I, M - D, A + R - I, M - D, A + R - k, 4, !0), this.v.setTripleAt(M - D, A - R + I, M - D, A - R + k, M - D, A - R + I, 5, !0), this.v.setTripleAt(M - D + I, A - R, M - D + I, A - R, M - D + k, A - R, 6, !0), this.v.setTripleAt(M + D - I, A - R, M + D - k, A - R, M + D - I, A - R, 7, !0)) : (this.v.setTripleAt(M - D, A + R, M - D + k, A + R, M - D, A + R, 2), this.v.setTripleAt(M - D, A - R, M - D, A - R + k, M - D, A - R, 3))) : (this.v.setTripleAt(M + D, A - R + I, M + D, A - R + k, M + D, A - R + I, 0, !0), I !== 0 ? (this.v.setTripleAt(M + D - I, A - R, M + D - I, A - R, M + D - k, A - R, 1, !0), this.v.setTripleAt(M - D + I, A - R, M - D + k, A - R, M - D + I, A - R, 2, !0), this.v.setTripleAt(M - D, A - R + I, M - D, A - R + I, M - D, A - R + k, 3, !0), this.v.setTripleAt(M - D, A + R - I, M - D, A + R - k, M - D, A + R - I, 4, !0), this.v.setTripleAt(M - D + I, A + R, M - D + I, A + R, M - D + k, A + R, 5, !0), this.v.setTripleAt(M + D - I, A + R, M + D - k, A + R, M + D - I, A + R, 6, !0), this.v.setTripleAt(M + D, A + R - I, M + D, A + R - I, M + D, A + R - k, 7, !0)) : (this.v.setTripleAt(M - D, A - R, M - D + k, A - R, M - D, A - R, 1, !0), this.v.setTripleAt(M - D, A + R, M - D, A + R - k, M - D, A + R, 2, !0), this.v.setTripleAt(M + D, A + R, M + D - k, A + R, M + D, A + R, 3, !0)))
                                },
                                getValue: function() {
                                    this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath())
                                },
                                reset: c
                            }, extendPrototype([DynamicPropertyContainer], w), w
                        }();

                    function S(w, T, M) {
                        var A;
                        if (M === 3 || M === 4) {
                            var D = M === 3 ? T.pt : T.ks,
                                R = D.k;
                            R.length ? A = new v(w, T, M) : A = new g(w, T, M)
                        } else M === 5 ? A = new b(w, T) : M === 6 ? A = new x(w, T) : M === 7 && (A = new y(w, T));
                        return A.k && w.addDynamicProperty(A), A
                    }

                    function C() {
                        return g
                    }

                    function E() {
                        return v
                    }
                    var P = {};
                    return P.getShapeProp = S, P.getConstructorFunction = C, P.getKeyframedConstructorFunction = E, P
                }();
            /*!
             Transformation Matrix v2.0
             (c) Epistemex 2014-2015
             www.epistemex.com
             By Ken Fyrstenberg
             Contributions by leeoniya.
             License: MIT, header required.
             */
            var Matrix = function() {
                var l = Math.cos,
                    i = Math.sin,
                    o = Math.tan,
                    c = Math.round;

                function u() {
                    return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this
                }

                function p(L) {
                    if (L === 0) return this;
                    var N = l(L),
                        K = i(L);
                    return this._t(N, -K, 0, 0, K, N, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                }

                function m(L) {
                    if (L === 0) return this;
                    var N = l(L),
                        K = i(L);
                    return this._t(1, 0, 0, 0, 0, N, -K, 0, 0, K, N, 0, 0, 0, 0, 1)
                }

                function g(L) {
                    if (L === 0) return this;
                    var N = l(L),
                        K = i(L);
                    return this._t(N, 0, K, 0, 0, 1, 0, 0, -K, 0, N, 0, 0, 0, 0, 1)
                }

                function _(L) {
                    if (L === 0) return this;
                    var N = l(L),
                        K = i(L);
                    return this._t(N, -K, 0, 0, K, N, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                }

                function v(L, N) {
                    return this._t(1, N, L, 1, 0, 0)
                }

                function x(L, N) {
                    return this.shear(o(L), o(N))
                }

                function y(L, N) {
                    var K = l(N),
                        Z = i(N);
                    return this._t(K, Z, 0, 0, -Z, K, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, o(L), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(K, -Z, 0, 0, Z, K, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                }

                function b(L, N, K) {
                    return !K && K !== 0 && (K = 1), L === 1 && N === 1 && K === 1 ? this : this._t(L, 0, 0, 0, 0, N, 0, 0, 0, 0, K, 0, 0, 0, 0, 1)
                }

                function S(L, N, K, Z, he, we, ie, _e, Te, Me, Pe, be, Be, De, We, Re) {
                    return this.props[0] = L, this.props[1] = N, this.props[2] = K, this.props[3] = Z, this.props[4] = he, this.props[5] = we, this.props[6] = ie, this.props[7] = _e, this.props[8] = Te, this.props[9] = Me, this.props[10] = Pe, this.props[11] = be, this.props[12] = Be, this.props[13] = De, this.props[14] = We, this.props[15] = Re, this
                }

                function C(L, N, K) {
                    return K = K || 0, L !== 0 || N !== 0 || K !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, L, N, K, 1) : this
                }

                function E(L, N, K, Z, he, we, ie, _e, Te, Me, Pe, be, Be, De, We, Re) {
                    var q = this.props;
                    if (L === 1 && N === 0 && K === 0 && Z === 0 && he === 0 && we === 1 && ie === 0 && _e === 0 && Te === 0 && Me === 0 && Pe === 1 && be === 0) return q[12] = q[12] * L + q[15] * Be, q[13] = q[13] * we + q[15] * De, q[14] = q[14] * Pe + q[15] * We, q[15] *= Re, this._identityCalculated = !1, this;
                    var At = q[0],
                        dt = q[1],
                        tt = q[2],
                        ke = q[3],
                        ot = q[4],
                        ze = q[5],
                        Ie = q[6],
                        Dt = q[7],
                        J = q[8],
                        $ = q[9],
                        ae = q[10],
                        ge = q[11],
                        ye = q[12],
                        fe = q[13],
                        Ke = q[14],
                        Le = q[15];
                    return q[0] = At * L + dt * he + tt * Te + ke * Be, q[1] = At * N + dt * we + tt * Me + ke * De, q[2] = At * K + dt * ie + tt * Pe + ke * We, q[3] = At * Z + dt * _e + tt * be + ke * Re, q[4] = ot * L + ze * he + Ie * Te + Dt * Be, q[5] = ot * N + ze * we + Ie * Me + Dt * De, q[6] = ot * K + ze * ie + Ie * Pe + Dt * We, q[7] = ot * Z + ze * _e + Ie * be + Dt * Re, q[8] = J * L + $ * he + ae * Te + ge * Be, q[9] = J * N + $ * we + ae * Me + ge * De, q[10] = J * K + $ * ie + ae * Pe + ge * We, q[11] = J * Z + $ * _e + ae * be + ge * Re, q[12] = ye * L + fe * he + Ke * Te + Le * Be, q[13] = ye * N + fe * we + Ke * Me + Le * De, q[14] = ye * K + fe * ie + Ke * Pe + Le * We, q[15] = ye * Z + fe * _e + Ke * be + Le * Re, this._identityCalculated = !1, this
                }

                function P(L) {
                    var N = L.props;
                    return this.transform(N[0], N[1], N[2], N[3], N[4], N[5], N[6], N[7], N[8], N[9], N[10], N[11], N[12], N[13], N[14], N[15])
                }

                function w() {
                    return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1), this._identityCalculated = !0), this._identity
                }

                function T(L) {
                    for (var N = 0; N < 16;) {
                        if (L.props[N] !== this.props[N]) return !1;
                        N += 1
                    }
                    return !0
                }

                function M(L) {
                    var N;
                    for (N = 0; N < 16; N += 1) L.props[N] = this.props[N];
                    return L
                }

                function A(L) {
                    var N;
                    for (N = 0; N < 16; N += 1) this.props[N] = L[N]
                }

                function D(L, N, K) {
                    return {
                        x: L * this.props[0] + N * this.props[4] + K * this.props[8] + this.props[12],
                        y: L * this.props[1] + N * this.props[5] + K * this.props[9] + this.props[13],
                        z: L * this.props[2] + N * this.props[6] + K * this.props[10] + this.props[14]
                    }
                }

                function R(L, N, K) {
                    return L * this.props[0] + N * this.props[4] + K * this.props[8] + this.props[12]
                }

                function I(L, N, K) {
                    return L * this.props[1] + N * this.props[5] + K * this.props[9] + this.props[13]
                }

                function k(L, N, K) {
                    return L * this.props[2] + N * this.props[6] + K * this.props[10] + this.props[14]
                }

                function F() {
                    var L = this.props[0] * this.props[5] - this.props[1] * this.props[4],
                        N = this.props[5] / L,
                        K = -this.props[1] / L,
                        Z = -this.props[4] / L,
                        he = this.props[0] / L,
                        we = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / L,
                        ie = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / L,
                        _e = new Matrix;
                    return _e.props[0] = N, _e.props[1] = K, _e.props[4] = Z, _e.props[5] = he, _e.props[12] = we, _e.props[13] = ie, _e
                }

                function V(L) {
                    var N = this.getInverseMatrix();
                    return N.applyToPointArray(L[0], L[1], L[2] || 0)
                }

                function B(L) {
                    var N, K = L.length,
                        Z = [];
                    for (N = 0; N < K; N += 1) Z[N] = V(L[N]);
                    return Z
                }

                function U(L, N, K) {
                    var Z = createTypedArray("float32", 6);
                    if (this.isIdentity()) Z[0] = L[0], Z[1] = L[1], Z[2] = N[0], Z[3] = N[1], Z[4] = K[0], Z[5] = K[1];
                    else {
                        var he = this.props[0],
                            we = this.props[1],
                            ie = this.props[4],
                            _e = this.props[5],
                            Te = this.props[12],
                            Me = this.props[13];
                        Z[0] = L[0] * he + L[1] * ie + Te, Z[1] = L[0] * we + L[1] * _e + Me, Z[2] = N[0] * he + N[1] * ie + Te, Z[3] = N[0] * we + N[1] * _e + Me, Z[4] = K[0] * he + K[1] * ie + Te, Z[5] = K[0] * we + K[1] * _e + Me
                    }
                    return Z
                }

                function H(L, N, K) {
                    var Z;
                    return this.isIdentity() ? Z = [L, N, K] : Z = [L * this.props[0] + N * this.props[4] + K * this.props[8] + this.props[12], L * this.props[1] + N * this.props[5] + K * this.props[9] + this.props[13], L * this.props[2] + N * this.props[6] + K * this.props[10] + this.props[14]], Z
                }

                function Q(L, N) {
                    if (this.isIdentity()) return L + "," + N;
                    var K = this.props;
                    return Math.round((L * K[0] + N * K[4] + K[12]) * 100) / 100 + "," + Math.round((L * K[1] + N * K[5] + K[13]) * 100) / 100
                }

                function Y() {
                    for (var L = 0, N = this.props, K = "matrix3d(", Z = 1e4; L < 16;) K += c(N[L] * Z) / Z, K += L === 15 ? ")" : ",", L += 1;
                    return K
                }

                function O(L) {
                    var N = 1e4;
                    return L < 1e-6 && L > 0 || L > -1e-6 && L < 0 ? c(L * N) / N : L
                }

                function G() {
                    var L = this.props,
                        N = O(L[0]),
                        K = O(L[1]),
                        Z = O(L[4]),
                        he = O(L[5]),
                        we = O(L[12]),
                        ie = O(L[13]);
                    return "matrix(" + N + "," + K + "," + Z + "," + he + "," + we + "," + ie + ")"
                }
                return function() {
                    this.reset = u, this.rotate = p, this.rotateX = m, this.rotateY = g, this.rotateZ = _, this.skew = x, this.skewFromAxis = y, this.shear = v, this.scale = b, this.setTransform = S, this.translate = C, this.transform = E, this.multiply = P, this.applyToPoint = D, this.applyToX = R, this.applyToY = I, this.applyToZ = k, this.applyToPointArray = H, this.applyToTriplePoints = U, this.applyToPointStringified = Q, this.toCSS = Y, this.to2dCSS = G, this.clone = M, this.cloneFromProps = A, this.equals = T, this.inversePoints = B, this.inversePoint = V, this.getInverseMatrix = F, this._t = this.transform, this.isIdentity = w, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset()
                }
            }();

            function _typeof$3(l) {
                "@babel/helpers - typeof";
                return _typeof$3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
                    return typeof i
                } : function(i) {
                    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i
                }, _typeof$3(l)
            }
            var lottie = {};

            function setLocation(l) {
                setLocationHref(l)
            }

            function searchAnimations() {
                animationManager.searchAnimations()
            }

            function setSubframeRendering(l) {
                setSubframeEnabled(l)
            }

            function setPrefix(l) {
                setIdPrefix(l)
            }

            function loadAnimation(l) {
                return animationManager.loadAnimation(l)
            }

            function setQuality(l) {
                if (typeof l == "string") switch (l) {
                    case "high":
                        setDefaultCurveSegments(200);
                        break;
                    default:
                    case "medium":
                        setDefaultCurveSegments(50);
                        break;
                    case "low":
                        setDefaultCurveSegments(10);
                        break
                } else !isNaN(l) && l > 1 && setDefaultCurveSegments(l)
            }

            function inBrowser() {
                return typeof navigator < "u"
            }

            function installPlugin(l, i) {
                l === "expressions" && setExpressionsPlugin(i)
            }

            function getFactory(l) {
                switch (l) {
                    case "propertyFactory":
                        return PropertyFactory;
                    case "shapePropertyFactory":
                        return ShapePropertyFactory;
                    case "matrix":
                        return Matrix;
                    default:
                        return null
                }
            }
            lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.13.0";

            function checkReady() {
                document.readyState === "complete" && (clearInterval(readyStateCheckInterval), searchAnimations())
            }

            function getQueryVariable(l) {
                for (var i = queryString.split("&"), o = 0; o < i.length; o += 1) {
                    var c = i[o].split("=");
                    if (decodeURIComponent(c[0]) == l) return decodeURIComponent(c[1])
                }
                return null
            }
            var queryString = ""; {
                var scripts = document.getElementsByTagName("script"),
                    index = scripts.length - 1,
                    myScript = scripts[index] || {
                        src: ""
                    };
                queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", getQueryVariable("renderer")
            }
            var readyStateCheckInterval = setInterval(checkReady, 100);
            try {
                _typeof$3(exports) !== "object" && (window.bodymovin = lottie)
            } catch (l) {}
            var ShapeModifiers = function() {
                var l = {},
                    i = {};
                l.registerModifier = o, l.getModifier = c;

                function o(u, p) {
                    i[u] || (i[u] = p)
                }

                function c(u, p, m) {
                    return new i[u](p, m)
                }
                return l
            }();

            function ShapeModifier() {}
            ShapeModifier.prototype.initModifierProperties = function() {}, ShapeModifier.prototype.addShapeToModifier = function() {}, ShapeModifier.prototype.addShape = function(l) {
                if (!this.closed) {
                    l.sh.container.addDynamicProperty(l.sh);
                    var i = {
                        shape: l.sh,
                        data: l,
                        localShapeCollection: shapeCollectionPool.newShapeCollection()
                    };
                    this.shapes.push(i), this.addShapeToModifier(i), this._isAnimated && l.setAsAnimated()
                }
            }, ShapeModifier.prototype.init = function(l, i) {
                this.shapes = [], this.elem = l, this.initDynamicPropertyContainer(l), this.initModifierProperties(l, i), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
            }, ShapeModifier.prototype.processKeys = function() {
                this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties())
            }, extendPrototype([DynamicPropertyContainer], ShapeModifier);

            function TrimModifier() {}
            extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function(l, i) {
                this.s = PropertyFactory.getProp(l, i.s, 0, .01, this), this.e = PropertyFactory.getProp(l, i.e, 0, .01, this), this.o = PropertyFactory.getProp(l, i.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = i.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
            }, TrimModifier.prototype.addShapeToModifier = function(l) {
                l.pathsData = []
            }, TrimModifier.prototype.calculateShapeEdges = function(l, i, o, c, u) {
                var p = [];
                i <= 1 ? p.push({
                    s: l,
                    e: i
                }) : l >= 1 ? p.push({
                    s: l - 1,
                    e: i - 1
                }) : (p.push({
                    s: l,
                    e: 1
                }), p.push({
                    s: 0,
                    e: i - 1
                }));
                var m = [],
                    g, _ = p.length,
                    v;
                for (g = 0; g < _; g += 1)
                    if (v = p[g], !(v.e * u < c || v.s * u > c + o)) {
                        var x, y;
                        v.s * u <= c ? x = 0 : x = (v.s * u - c) / o, v.e * u >= c + o ? y = 1 : y = (v.e * u - c) / o, m.push([x, y])
                    }
                return m.length || m.push([0, 0]), m
            }, TrimModifier.prototype.releasePathsData = function(l) {
                var i, o = l.length;
                for (i = 0; i < o; i += 1) segmentsLengthPool.release(l[i]);
                return l.length = 0, l
            }, TrimModifier.prototype.processShapes = function(l) {
                var i, o;
                if (this._mdf || l) {
                    var c = this.o.v % 360 / 360;
                    if (c < 0 && (c += 1), this.s.v > 1 ? i = 1 + c : this.s.v < 0 ? i = 0 + c : i = this.s.v + c, this.e.v > 1 ? o = 1 + c : this.e.v < 0 ? o = 0 + c : o = this.e.v + c, i > o) {
                        var u = i;
                        i = o, o = u
                    }
                    i = Math.round(i * 1e4) * 1e-4, o = Math.round(o * 1e4) * 1e-4, this.sValue = i, this.eValue = o
                } else i = this.sValue, o = this.eValue;
                var p, m, g = this.shapes.length,
                    _, v, x, y, b, S = 0;
                if (o === i)
                    for (m = 0; m < g; m += 1) this.shapes[m].localShapeCollection.releaseShapes(), this.shapes[m].shape._mdf = !0, this.shapes[m].shape.paths = this.shapes[m].localShapeCollection, this._mdf && (this.shapes[m].pathsData.length = 0);
                else if (o === 1 && i === 0 || o === 0 && i === 1) {
                    if (this._mdf)
                        for (m = 0; m < g; m += 1) this.shapes[m].pathsData.length = 0, this.shapes[m].shape._mdf = !0
                } else {
                    var C = [],
                        E, P;
                    for (m = 0; m < g; m += 1)
                        if (E = this.shapes[m], !E.shape._mdf && !this._mdf && !l && this.m !== 2) E.shape.paths = E.localShapeCollection;
                        else {
                            if (p = E.shape.paths, v = p._length, b = 0, !E.shape._mdf && E.pathsData.length) b = E.totalShapeLength;
                            else {
                                for (x = this.releasePathsData(E.pathsData), _ = 0; _ < v; _ += 1) y = bez.getSegmentsLength(p.shapes[_]), x.push(y), b += y.totalLength;
                                E.totalShapeLength = b, E.pathsData = x
                            }
                            S += b, E.shape._mdf = !0
                        }
                    var w = i,
                        T = o,
                        M = 0,
                        A;
                    for (m = g - 1; m >= 0; m -= 1)
                        if (E = this.shapes[m], E.shape._mdf) {
                            for (P = E.localShapeCollection, P.releaseShapes(), this.m === 2 && g > 1 ? (A = this.calculateShapeEdges(i, o, E.totalShapeLength, M, S), M += E.totalShapeLength) : A = [
                                    [w, T]
                                ], v = A.length, _ = 0; _ < v; _ += 1) {
                                w = A[_][0], T = A[_][1], C.length = 0, T <= 1 ? C.push({
                                    s: E.totalShapeLength * w,
                                    e: E.totalShapeLength * T
                                }) : w >= 1 ? C.push({
                                    s: E.totalShapeLength * (w - 1),
                                    e: E.totalShapeLength * (T - 1)
                                }) : (C.push({
                                    s: E.totalShapeLength * w,
                                    e: E.totalShapeLength
                                }), C.push({
                                    s: 0,
                                    e: E.totalShapeLength * (T - 1)
                                }));
                                var D = this.addShapes(E, C[0]);
                                if (C[0].s !== C[0].e) {
                                    if (C.length > 1) {
                                        var R = E.shape.paths.shapes[E.shape.paths._length - 1];
                                        if (R.c) {
                                            var I = D.pop();
                                            this.addPaths(D, P), D = this.addShapes(E, C[1], I)
                                        } else this.addPaths(D, P), D = this.addShapes(E, C[1])
                                    }
                                    this.addPaths(D, P)
                                }
                            }
                            E.shape.paths = P
                        }
                }
            }, TrimModifier.prototype.addPaths = function(l, i) {
                var o, c = l.length;
                for (o = 0; o < c; o += 1) i.addShape(l[o])
            }, TrimModifier.prototype.addSegment = function(l, i, o, c, u, p, m) {
                u.setXYAt(i[0], i[1], "o", p), u.setXYAt(o[0], o[1], "i", p + 1), m && u.setXYAt(l[0], l[1], "v", p), u.setXYAt(c[0], c[1], "v", p + 1)
            }, TrimModifier.prototype.addSegmentFromArray = function(l, i, o, c) {
                i.setXYAt(l[1], l[5], "o", o), i.setXYAt(l[2], l[6], "i", o + 1), c && i.setXYAt(l[0], l[4], "v", o), i.setXYAt(l[3], l[7], "v", o + 1)
            }, TrimModifier.prototype.addShapes = function(l, i, o) {
                var c = l.pathsData,
                    u = l.shape.paths.shapes,
                    p, m = l.shape.paths._length,
                    g, _, v = 0,
                    x, y, b, S, C = [],
                    E, P = !0;
                for (o ? (y = o._length, E = o._length) : (o = shapePool.newElement(), y = 0, E = 0), C.push(o), p = 0; p < m; p += 1) {
                    for (b = c[p].lengths, o.c = u[p].c, _ = u[p].c ? b.length : b.length + 1, g = 1; g < _; g += 1)
                        if (x = b[g - 1], v + x.addedLength < i.s) v += x.addedLength, o.c = !1;
                        else if (v > i.e) {
                        o.c = !1;
                        break
                    } else i.s <= v && i.e >= v + x.addedLength ? (this.addSegment(u[p].v[g - 1], u[p].o[g - 1], u[p].i[g], u[p].v[g], o, y, P), P = !1) : (S = bez.getNewSegment(u[p].v[g - 1], u[p].v[g], u[p].o[g - 1], u[p].i[g], (i.s - v) / x.addedLength, (i.e - v) / x.addedLength, b[g - 1]), this.addSegmentFromArray(S, o, y, P), P = !1, o.c = !1), v += x.addedLength, y += 1;
                    if (u[p].c && b.length) {
                        if (x = b[g - 1], v <= i.e) {
                            var w = b[g - 1].addedLength;
                            i.s <= v && i.e >= v + w ? (this.addSegment(u[p].v[g - 1], u[p].o[g - 1], u[p].i[0], u[p].v[0], o, y, P), P = !1) : (S = bez.getNewSegment(u[p].v[g - 1], u[p].v[0], u[p].o[g - 1], u[p].i[0], (i.s - v) / w, (i.e - v) / w, b[g - 1]), this.addSegmentFromArray(S, o, y, P), P = !1, o.c = !1)
                        } else o.c = !1;
                        v += x.addedLength, y += 1
                    }
                    if (o._length && (o.setXYAt(o.v[E][0], o.v[E][1], "i", E), o.setXYAt(o.v[o._length - 1][0], o.v[o._length - 1][1], "o", o._length - 1)), v > i.e) break;
                    p < m - 1 && (o = shapePool.newElement(), P = !0, C.push(o), y = 0)
                }
                return C
            };

            function PuckerAndBloatModifier() {}
            extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function(l, i) {
                this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(l, i.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length
            }, PuckerAndBloatModifier.prototype.processPath = function(l, i) {
                var o = i / 100,
                    c = [0, 0],
                    u = l._length,
                    p = 0;
                for (p = 0; p < u; p += 1) c[0] += l.v[p][0], c[1] += l.v[p][1];
                c[0] /= u, c[1] /= u;
                var m = shapePool.newElement();
                m.c = l.c;
                var g, _, v, x, y, b;
                for (p = 0; p < u; p += 1) g = l.v[p][0] + (c[0] - l.v[p][0]) * o, _ = l.v[p][1] + (c[1] - l.v[p][1]) * o, v = l.o[p][0] + (c[0] - l.o[p][0]) * -o, x = l.o[p][1] + (c[1] - l.o[p][1]) * -o, y = l.i[p][0] + (c[0] - l.i[p][0]) * -o, b = l.i[p][1] + (c[1] - l.i[p][1]) * -o, m.setTripleAt(g, _, v, x, y, b, p);
                return m
            }, PuckerAndBloatModifier.prototype.processShapes = function(l) {
                var i, o, c = this.shapes.length,
                    u, p, m = this.amount.v;
                if (m !== 0) {
                    var g, _;
                    for (o = 0; o < c; o += 1) {
                        if (g = this.shapes[o], _ = g.localShapeCollection, !(!g.shape._mdf && !this._mdf && !l))
                            for (_.releaseShapes(), g.shape._mdf = !0, i = g.shape.paths.shapes, p = g.shape.paths._length, u = 0; u < p; u += 1) _.addShape(this.processPath(i[u], m));
                        g.shape.paths = g.localShapeCollection
                    }
                }
                this.dynamicProperties.length || (this._mdf = !1)
            };
            var TransformPropertyFactory = function() {
                var l = [0, 0];

                function i(_) {
                    var v = this._mdf;
                    this.iterateDynamicProperties(), this._mdf = this._mdf || v, this.a && _.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && _.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && _.skewFromAxis(-this.sk.v, this.sa.v), this.r ? _.rotate(-this.r.v) : _.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? _.translate(this.px.v, this.py.v, -this.pz.v) : _.translate(this.px.v, this.py.v, 0) : _.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                }

                function o(_) {
                    if (this.elem.globalData.frameId !== this.frameId) {
                        if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || _) {
                            var v;
                            if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
                                var x, y;
                                if (v = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (x = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / v, 0), y = this.p.getValueAtTime(this.p.keyframes[0].t / v, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (x = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / v, 0), y = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / v, 0)) : (x = this.p.pv, y = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / v, this.p.offsetTime));
                                else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                    x = [], y = [];
                                    var b = this.px,
                                        S = this.py;
                                    b._caching.lastFrame + b.offsetTime <= b.keyframes[0].t ? (x[0] = b.getValueAtTime((b.keyframes[0].t + .01) / v, 0), x[1] = S.getValueAtTime((S.keyframes[0].t + .01) / v, 0), y[0] = b.getValueAtTime(b.keyframes[0].t / v, 0), y[1] = S.getValueAtTime(S.keyframes[0].t / v, 0)) : b._caching.lastFrame + b.offsetTime >= b.keyframes[b.keyframes.length - 1].t ? (x[0] = b.getValueAtTime(b.keyframes[b.keyframes.length - 1].t / v, 0), x[1] = S.getValueAtTime(S.keyframes[S.keyframes.length - 1].t / v, 0), y[0] = b.getValueAtTime((b.keyframes[b.keyframes.length - 1].t - .01) / v, 0), y[1] = S.getValueAtTime((S.keyframes[S.keyframes.length - 1].t - .01) / v, 0)) : (x = [b.pv, S.pv], y[0] = b.getValueAtTime((b._caching.lastFrame + b.offsetTime - .01) / v, b.offsetTime), y[1] = S.getValueAtTime((S._caching.lastFrame + S.offsetTime - .01) / v, S.offsetTime))
                                } else y = l, x = y;
                                this.v.rotate(-Math.atan2(x[1] - y[1], x[0] - y[0]))
                            }
                            this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                        }
                        this.frameId = this.elem.globalData.frameId
                    }
                }

                function c() {
                    if (this.appliedTransformations = 0, this.pre.reset(), !this.a.effectsSequence.length) this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1;
                    else return;
                    if (!this.s.effectsSequence.length) this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2;
                    else return;
                    if (this.sk)
                        if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3;
                        else return;
                    this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4)
                }

                function u() {}

                function p(_) {
                    this._addDynamicProperty(_), this.elem.addDynamicProperty(_), this._isDirty = !0
                }

                function m(_, v, x) {
                    if (this.elem = _, this.frameId = -1, this.propType = "transform", this.data = v, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(x || _), v.p && v.p.s ? (this.px = PropertyFactory.getProp(_, v.p.x, 0, 0, this), this.py = PropertyFactory.getProp(_, v.p.y, 0, 0, this), v.p.z && (this.pz = PropertyFactory.getProp(_, v.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(_, v.p || {
                            k: [0, 0, 0]
                        }, 1, 0, this), v.rx) {
                        if (this.rx = PropertyFactory.getProp(_, v.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(_, v.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(_, v.rz, 0, degToRads, this), v.or.k[0].ti) {
                            var y, b = v.or.k.length;
                            for (y = 0; y < b; y += 1) v.or.k[y].to = null, v.or.k[y].ti = null
                        }
                        this.or = PropertyFactory.getProp(_, v.or, 1, degToRads, this), this.or.sh = !0
                    } else this.r = PropertyFactory.getProp(_, v.r || {
                        k: 0
                    }, 0, degToRads, this);
                    v.sk && (this.sk = PropertyFactory.getProp(_, v.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(_, v.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(_, v.a || {
                        k: [0, 0, 0]
                    }, 1, 0, this), this.s = PropertyFactory.getProp(_, v.s || {
                        k: [100, 100, 100]
                    }, 1, .01, this), v.o ? this.o = PropertyFactory.getProp(_, v.o, 0, .01, _) : this.o = {
                        _mdf: !1,
                        v: 1
                    }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0)
                }
                m.prototype = {
                    applyToMatrix: i,
                    getValue: o,
                    precalculateMatrix: c,
                    autoOrient: u
                }, extendPrototype([DynamicPropertyContainer], m), m.prototype.addDynamicProperty = p, m.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;

                function g(_, v, x) {
                    return new m(_, v, x)
                }
                return {
                    getTransformProperty: g
                }
            }();

            function RepeaterModifier() {}
            extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function(l, i) {
                this.getValue = this.processKeys, this.c = PropertyFactory.getProp(l, i.c, 0, null, this), this.o = PropertyFactory.getProp(l, i.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(l, i.tr, this), this.so = PropertyFactory.getProp(l, i.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(l, i.tr.eo, 0, .01, this), this.data = i, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix
            }, RepeaterModifier.prototype.applyTransforms = function(l, i, o, c, u, p) {
                var m = p ? -1 : 1,
                    g = c.s.v[0] + (1 - c.s.v[0]) * (1 - u),
                    _ = c.s.v[1] + (1 - c.s.v[1]) * (1 - u);
                l.translate(c.p.v[0] * m * u, c.p.v[1] * m * u, c.p.v[2]), i.translate(-c.a.v[0], -c.a.v[1], c.a.v[2]), i.rotate(-c.r.v * m * u), i.translate(c.a.v[0], c.a.v[1], c.a.v[2]), o.translate(-c.a.v[0], -c.a.v[1], c.a.v[2]), o.scale(p ? 1 / g : g, p ? 1 / _ : _), o.translate(c.a.v[0], c.a.v[1], c.a.v[2])
            }, RepeaterModifier.prototype.init = function(l, i, o, c) {
                for (this.elem = l, this.arr = i, this.pos = o, this.elemsData = c, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(l), this.initModifierProperties(l, i[o]); o > 0;) o -= 1, this._elements.unshift(i[o]);
                this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
            }, RepeaterModifier.prototype.resetElements = function(l) {
                var i, o = l.length;
                for (i = 0; i < o; i += 1) l[i]._processed = !1, l[i].ty === "gr" && this.resetElements(l[i].it)
            }, RepeaterModifier.prototype.cloneElements = function(l) {
                var i = JSON.parse(JSON.stringify(l));
                return this.resetElements(i), i
            }, RepeaterModifier.prototype.changeGroupRender = function(l, i) {
                var o, c = l.length;
                for (o = 0; o < c; o += 1) l[o]._render = i, l[o].ty === "gr" && this.changeGroupRender(l[o].it, i)
            }, RepeaterModifier.prototype.processShapes = function(l) {
                var i, o, c, u, p, m = !1;
                if (this._mdf || l) {
                    var g = Math.ceil(this.c.v);
                    if (this._groups.length < g) {
                        for (; this._groups.length < g;) {
                            var _ = {
                                it: this.cloneElements(this._elements),
                                ty: "gr"
                            };
                            _.it.push({
                                a: {
                                    a: 0,
                                    ix: 1,
                                    k: [0, 0]
                                },
                                nm: "Transform",
                                o: {
                                    a: 0,
                                    ix: 7,
                                    k: 100
                                },
                                p: {
                                    a: 0,
                                    ix: 2,
                                    k: [0, 0]
                                },
                                r: {
                                    a: 1,
                                    ix: 6,
                                    k: [{
                                        s: 0,
                                        e: 0,
                                        t: 0
                                    }, {
                                        s: 0,
                                        e: 0,
                                        t: 1
                                    }]
                                },
                                s: {
                                    a: 0,
                                    ix: 3,
                                    k: [100, 100]
                                },
                                sa: {
                                    a: 0,
                                    ix: 5,
                                    k: 0
                                },
                                sk: {
                                    a: 0,
                                    ix: 4,
                                    k: 0
                                },
                                ty: "tr"
                            }), this.arr.splice(0, 0, _), this._groups.splice(0, 0, _), this._currentCopies += 1
                        }
                        this.elem.reloadShapes(), m = !0
                    }
                    p = 0;
                    var v;
                    for (c = 0; c <= this._groups.length - 1; c += 1) {
                        if (v = p < g, this._groups[c]._render = v, this.changeGroupRender(this._groups[c].it, v), !v) {
                            var x = this.elemsData[c].it,
                                y = x[x.length - 1];
                            y.transform.op.v !== 0 ? (y.transform.op._mdf = !0, y.transform.op.v = 0) : y.transform.op._mdf = !1
                        }
                        p += 1
                    }
                    this._currentCopies = g;
                    var b = this.o.v,
                        S = b % 1,
                        C = b > 0 ? Math.floor(b) : Math.ceil(b),
                        E = this.pMatrix.props,
                        P = this.rMatrix.props,
                        w = this.sMatrix.props;
                    this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
                    var T = 0;
                    if (b > 0) {
                        for (; T < C;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), T += 1;
                        S && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, S, !1), T += S)
                    } else if (b < 0) {
                        for (; T > C;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), T -= 1;
                        S && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -S, !0), T -= S)
                    }
                    c = this.data.m === 1 ? 0 : this._currentCopies - 1, u = this.data.m === 1 ? 1 : -1, p = this._currentCopies;
                    for (var M, A; p;) {
                        if (i = this.elemsData[c].it, o = i[i.length - 1].transform.mProps.v.props, A = o.length, i[i.length - 1].transform.mProps._mdf = !0, i[i.length - 1].transform.op._mdf = !0, i[i.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (c / (this._currentCopies - 1)), T !== 0) {
                            for ((c !== 0 && u === 1 || c !== this._currentCopies - 1 && u === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(P[0], P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8], P[9], P[10], P[11], P[12], P[13], P[14], P[15]), this.matrix.transform(w[0], w[1], w[2], w[3], w[4], w[5], w[6], w[7], w[8], w[9], w[10], w[11], w[12], w[13], w[14], w[15]), this.matrix.transform(E[0], E[1], E[2], E[3], E[4], E[5], E[6], E[7], E[8], E[9], E[10], E[11], E[12], E[13], E[14], E[15]), M = 0; M < A; M += 1) o[M] = this.matrix.props[M];
                            this.matrix.reset()
                        } else
                            for (this.matrix.reset(), M = 0; M < A; M += 1) o[M] = this.matrix.props[M];
                        T += 1, p -= 1, c += u
                    }
                } else
                    for (p = this._currentCopies, c = 0, u = 1; p;) i = this.elemsData[c].it, o = i[i.length - 1].transform.mProps.v.props, i[i.length - 1].transform.mProps._mdf = !1, i[i.length - 1].transform.op._mdf = !1, p -= 1, c += u;
                return m
            }, RepeaterModifier.prototype.addShape = function() {};

            function RoundCornersModifier() {}
            extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function(l, i) {
                this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(l, i.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length
            }, RoundCornersModifier.prototype.processPath = function(l, i) {
                var o = shapePool.newElement();
                o.c = l.c;
                var c, u = l._length,
                    p, m, g, _, v, x, y = 0,
                    b, S, C, E, P, w;
                for (c = 0; c < u; c += 1) p = l.v[c], g = l.o[c], m = l.i[c], p[0] === g[0] && p[1] === g[1] && p[0] === m[0] && p[1] === m[1] ? (c === 0 || c === u - 1) && !l.c ? (o.setTripleAt(p[0], p[1], g[0], g[1], m[0], m[1], y), y += 1) : (c === 0 ? _ = l.v[u - 1] : _ = l.v[c - 1], v = Math.sqrt(Math.pow(p[0] - _[0], 2) + Math.pow(p[1] - _[1], 2)), x = v ? Math.min(v / 2, i) / v : 0, P = p[0] + (_[0] - p[0]) * x, b = P, w = p[1] - (p[1] - _[1]) * x, S = w, C = b - (b - p[0]) * roundCorner, E = S - (S - p[1]) * roundCorner, o.setTripleAt(b, S, C, E, P, w, y), y += 1, c === u - 1 ? _ = l.v[0] : _ = l.v[c + 1], v = Math.sqrt(Math.pow(p[0] - _[0], 2) + Math.pow(p[1] - _[1], 2)), x = v ? Math.min(v / 2, i) / v : 0, C = p[0] + (_[0] - p[0]) * x, b = C, E = p[1] + (_[1] - p[1]) * x, S = E, P = b - (b - p[0]) * roundCorner, w = S - (S - p[1]) * roundCorner, o.setTripleAt(b, S, C, E, P, w, y), y += 1) : (o.setTripleAt(l.v[c][0], l.v[c][1], l.o[c][0], l.o[c][1], l.i[c][0], l.i[c][1], y), y += 1);
                return o
            }, RoundCornersModifier.prototype.processShapes = function(l) {
                var i, o, c = this.shapes.length,
                    u, p, m = this.rd.v;
                if (m !== 0) {
                    var g, _;
                    for (o = 0; o < c; o += 1) {
                        if (g = this.shapes[o], _ = g.localShapeCollection, !(!g.shape._mdf && !this._mdf && !l))
                            for (_.releaseShapes(), g.shape._mdf = !0, i = g.shape.paths.shapes, p = g.shape.paths._length, u = 0; u < p; u += 1) _.addShape(this.processPath(i[u], m));
                        g.shape.paths = g.localShapeCollection
                    }
                }
                this.dynamicProperties.length || (this._mdf = !1)
            };

            function floatEqual(l, i) {
                return Math.abs(l - i) * 1e5 <= Math.min(Math.abs(l), Math.abs(i))
            }

            function floatZero(l) {
                return Math.abs(l) <= 1e-5
            }

            function lerp(l, i, o) {
                return l * (1 - o) + i * o
            }

            function lerpPoint(l, i, o) {
                return [lerp(l[0], i[0], o), lerp(l[1], i[1], o)]
            }

            function quadRoots(l, i, o) {
                if (l === 0) return [];
                var c = i * i - 4 * l * o;
                if (c < 0) return [];
                var u = -i / (2 * l);
                if (c === 0) return [u];
                var p = Math.sqrt(c) / (2 * l);
                return [u - p, u + p]
            }

            function polynomialCoefficients(l, i, o, c) {
                return [-l + 3 * i - 3 * o + c, 3 * l - 6 * i + 3 * o, -3 * l + 3 * i, l]
            }

            function singlePoint(l) {
                return new PolynomialBezier(l, l, l, l, !1)
            }

            function PolynomialBezier(l, i, o, c, u) {
                u && pointEqual(l, i) && (i = lerpPoint(l, c, 1 / 3)), u && pointEqual(o, c) && (o = lerpPoint(l, c, 2 / 3));
                var p = polynomialCoefficients(l[0], i[0], o[0], c[0]),
                    m = polynomialCoefficients(l[1], i[1], o[1], c[1]);
                this.a = [p[0], m[0]], this.b = [p[1], m[1]], this.c = [p[2], m[2]], this.d = [p[3], m[3]], this.points = [l, i, o, c]
            }
            PolynomialBezier.prototype.point = function(l) {
                return [((this.a[0] * l + this.b[0]) * l + this.c[0]) * l + this.d[0], ((this.a[1] * l + this.b[1]) * l + this.c[1]) * l + this.d[1]]
            }, PolynomialBezier.prototype.derivative = function(l) {
                return [(3 * l * this.a[0] + 2 * this.b[0]) * l + this.c[0], (3 * l * this.a[1] + 2 * this.b[1]) * l + this.c[1]]
            }, PolynomialBezier.prototype.tangentAngle = function(l) {
                var i = this.derivative(l);
                return Math.atan2(i[1], i[0])
            }, PolynomialBezier.prototype.normalAngle = function(l) {
                var i = this.derivative(l);
                return Math.atan2(i[0], i[1])
            }, PolynomialBezier.prototype.inflectionPoints = function() {
                var l = this.a[1] * this.b[0] - this.a[0] * this.b[1];
                if (floatZero(l)) return [];
                var i = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / l,
                    o = i * i - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / l;
                if (o < 0) return [];
                var c = Math.sqrt(o);
                return floatZero(c) ? c > 0 && c < 1 ? [i] : [] : [i - c, i + c].filter(function(u) {
                    return u > 0 && u < 1
                })
            }, PolynomialBezier.prototype.split = function(l) {
                if (l <= 0) return [singlePoint(this.points[0]), this];
                if (l >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
                var i = lerpPoint(this.points[0], this.points[1], l),
                    o = lerpPoint(this.points[1], this.points[2], l),
                    c = lerpPoint(this.points[2], this.points[3], l),
                    u = lerpPoint(i, o, l),
                    p = lerpPoint(o, c, l),
                    m = lerpPoint(u, p, l);
                return [new PolynomialBezier(this.points[0], i, u, m, !0), new PolynomialBezier(m, p, c, this.points[3], !0)]
            };

            function extrema(l, i) {
                var o = l.points[0][i],
                    c = l.points[l.points.length - 1][i];
                if (o > c) {
                    var u = c;
                    c = o, o = u
                }
                for (var p = quadRoots(3 * l.a[i], 2 * l.b[i], l.c[i]), m = 0; m < p.length; m += 1)
                    if (p[m] > 0 && p[m] < 1) {
                        var g = l.point(p[m])[i];
                        g < o ? o = g : g > c && (c = g)
                    }
                return {
                    min: o,
                    max: c
                }
            }
            PolynomialBezier.prototype.bounds = function() {
                return {
                    x: extrema(this, 0),
                    y: extrema(this, 1)
                }
            }, PolynomialBezier.prototype.boundingBox = function() {
                var l = this.bounds();
                return {
                    left: l.x.min,
                    right: l.x.max,
                    top: l.y.min,
                    bottom: l.y.max,
                    width: l.x.max - l.x.min,
                    height: l.y.max - l.y.min,
                    cx: (l.x.max + l.x.min) / 2,
                    cy: (l.y.max + l.y.min) / 2
                }
            };

            function intersectData(l, i, o) {
                var c = l.boundingBox();
                return {
                    cx: c.cx,
                    cy: c.cy,
                    width: c.width,
                    height: c.height,
                    bez: l,
                    t: (i + o) / 2,
                    t1: i,
                    t2: o
                }
            }

            function splitData(l) {
                var i = l.bez.split(.5);
                return [intersectData(i[0], l.t1, l.t), intersectData(i[1], l.t, l.t2)]
            }

            function boxIntersect(l, i) {
                return Math.abs(l.cx - i.cx) * 2 < l.width + i.width && Math.abs(l.cy - i.cy) * 2 < l.height + i.height
            }

            function intersectsImpl(l, i, o, c, u, p) {
                if (boxIntersect(l, i)) {
                    if (o >= p || l.width <= c && l.height <= c && i.width <= c && i.height <= c) {
                        u.push([l.t, i.t]);
                        return
                    }
                    var m = splitData(l),
                        g = splitData(i);
                    intersectsImpl(m[0], g[0], o + 1, c, u, p), intersectsImpl(m[0], g[1], o + 1, c, u, p), intersectsImpl(m[1], g[0], o + 1, c, u, p), intersectsImpl(m[1], g[1], o + 1, c, u, p)
                }
            }
            PolynomialBezier.prototype.intersections = function(l, i, o) {
                i === void 0 && (i = 2), o === void 0 && (o = 7);
                var c = [];
                return intersectsImpl(intersectData(this, 0, 1), intersectData(l, 0, 1), 0, i, c, o), c
            }, PolynomialBezier.shapeSegment = function(l, i) {
                var o = (i + 1) % l.length();
                return new PolynomialBezier(l.v[i], l.o[i], l.i[o], l.v[o], !0)
            }, PolynomialBezier.shapeSegmentInverted = function(l, i) {
                var o = (i + 1) % l.length();
                return new PolynomialBezier(l.v[o], l.i[o], l.o[i], l.v[i], !0)
            };

            function crossProduct(l, i) {
                return [l[1] * i[2] - l[2] * i[1], l[2] * i[0] - l[0] * i[2], l[0] * i[1] - l[1] * i[0]]
            }

            function lineIntersection(l, i, o, c) {
                var u = [l[0], l[1], 1],
                    p = [i[0], i[1], 1],
                    m = [o[0], o[1], 1],
                    g = [c[0], c[1], 1],
                    _ = crossProduct(crossProduct(u, p), crossProduct(m, g));
                return floatZero(_[2]) ? null : [_[0] / _[2], _[1] / _[2]]
            }

            function polarOffset(l, i, o) {
                return [l[0] + Math.cos(i) * o, l[1] - Math.sin(i) * o]
            }

            function pointDistance(l, i) {
                return Math.hypot(l[0] - i[0], l[1] - i[1])
            }

            function pointEqual(l, i) {
                return floatEqual(l[0], i[0]) && floatEqual(l[1], i[1])
            }

            function ZigZagModifier() {}
            extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function(l, i) {
                this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(l, i.s, 0, null, this), this.frequency = PropertyFactory.getProp(l, i.r, 0, null, this), this.pointsType = PropertyFactory.getProp(l, i.pt, 0, null, this), this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0
            };

            function setPoint(l, i, o, c, u, p, m) {
                var g = o - Math.PI / 2,
                    _ = o + Math.PI / 2,
                    v = i[0] + Math.cos(o) * c * u,
                    x = i[1] - Math.sin(o) * c * u;
                l.setTripleAt(v, x, v + Math.cos(g) * p, x - Math.sin(g) * p, v + Math.cos(_) * m, x - Math.sin(_) * m, l.length())
            }

            function getPerpendicularVector(l, i) {
                var o = [i[0] - l[0], i[1] - l[1]],
                    c = -Math.PI * .5,
                    u = [Math.cos(c) * o[0] - Math.sin(c) * o[1], Math.sin(c) * o[0] + Math.cos(c) * o[1]];
                return u
            }

            function getProjectingAngle(l, i) {
                var o = i === 0 ? l.length() - 1 : i - 1,
                    c = (i + 1) % l.length(),
                    u = l.v[o],
                    p = l.v[c],
                    m = getPerpendicularVector(u, p);
                return Math.atan2(0, 1) - Math.atan2(m[1], m[0])
            }

            function zigZagCorner(l, i, o, c, u, p, m) {
                var g = getProjectingAngle(i, o),
                    _ = i.v[o % i._length],
                    v = i.v[o === 0 ? i._length - 1 : o - 1],
                    x = i.v[(o + 1) % i._length],
                    y = p === 2 ? Math.sqrt(Math.pow(_[0] - v[0], 2) + Math.pow(_[1] - v[1], 2)) : 0,
                    b = p === 2 ? Math.sqrt(Math.pow(_[0] - x[0], 2) + Math.pow(_[1] - x[1], 2)) : 0;
                setPoint(l, i.v[o % i._length], g, m, c, b / ((u + 1) * 2), y / ((u + 1) * 2))
            }

            function zigZagSegment(l, i, o, c, u, p) {
                for (var m = 0; m < c; m += 1) {
                    var g = (m + 1) / (c + 1),
                        _ = u === 2 ? Math.sqrt(Math.pow(i.points[3][0] - i.points[0][0], 2) + Math.pow(i.points[3][1] - i.points[0][1], 2)) : 0,
                        v = i.normalAngle(g),
                        x = i.point(g);
                    setPoint(l, x, v, p, o, _ / ((c + 1) * 2), _ / ((c + 1) * 2)), p = -p
                }
                return p
            }
            ZigZagModifier.prototype.processPath = function(l, i, o, c) {
                var u = l._length,
                    p = shapePool.newElement();
                if (p.c = l.c, l.c || (u -= 1), u === 0) return p;
                var m = -1,
                    g = PolynomialBezier.shapeSegment(l, 0);
                zigZagCorner(p, l, 0, i, o, c, m);
                for (var _ = 0; _ < u; _ += 1) m = zigZagSegment(p, g, i, o, c, -m), _ === u - 1 && !l.c ? g = null : g = PolynomialBezier.shapeSegment(l, (_ + 1) % u), zigZagCorner(p, l, _ + 1, i, o, c, m);
                return p
            }, ZigZagModifier.prototype.processShapes = function(l) {
                var i, o, c = this.shapes.length,
                    u, p, m = this.amplitude.v,
                    g = Math.max(0, Math.round(this.frequency.v)),
                    _ = this.pointsType.v;
                if (m !== 0) {
                    var v, x;
                    for (o = 0; o < c; o += 1) {
                        if (v = this.shapes[o], x = v.localShapeCollection, !(!v.shape._mdf && !this._mdf && !l))
                            for (x.releaseShapes(), v.shape._mdf = !0, i = v.shape.paths.shapes, p = v.shape.paths._length, u = 0; u < p; u += 1) x.addShape(this.processPath(i[u], m, g, _));
                        v.shape.paths = v.localShapeCollection
                    }
                }
                this.dynamicProperties.length || (this._mdf = !1)
            };

            function linearOffset(l, i, o) {
                var c = Math.atan2(i[0] - l[0], i[1] - l[1]);
                return [polarOffset(l, c, o), polarOffset(i, c, o)]
            }

            function offsetSegment(l, i) {
                var o, c, u, p, m, g, _;
                _ = linearOffset(l.points[0], l.points[1], i), o = _[0], c = _[1], _ = linearOffset(l.points[1], l.points[2], i), u = _[0], p = _[1], _ = linearOffset(l.points[2], l.points[3], i), m = _[0], g = _[1];
                var v = lineIntersection(o, c, u, p);
                v === null && (v = c);
                var x = lineIntersection(m, g, u, p);
                return x === null && (x = m), new PolynomialBezier(o, v, x, g)
            }

            function joinLines(l, i, o, c, u) {
                var p = i.points[3],
                    m = o.points[0];
                if (c === 3 || pointEqual(p, m)) return p;
                if (c === 2) {
                    var g = -i.tangentAngle(1),
                        _ = -o.tangentAngle(0) + Math.PI,
                        v = lineIntersection(p, polarOffset(p, g + Math.PI / 2, 100), m, polarOffset(m, g + Math.PI / 2, 100)),
                        x = v ? pointDistance(v, p) : pointDistance(p, m) / 2,
                        y = polarOffset(p, g, 2 * x * roundCorner);
                    return l.setXYAt(y[0], y[1], "o", l.length() - 1), y = polarOffset(m, _, 2 * x * roundCorner), l.setTripleAt(m[0], m[1], m[0], m[1], y[0], y[1], l.length()), m
                }
                var b = pointEqual(p, i.points[2]) ? i.points[0] : i.points[2],
                    S = pointEqual(m, o.points[1]) ? o.points[3] : o.points[1],
                    C = lineIntersection(b, p, m, S);
                return C && pointDistance(C, p) < u ? (l.setTripleAt(C[0], C[1], C[0], C[1], C[0], C[1], l.length()), C) : p
            }

            function getIntersection(l, i) {
                var o = l.intersections(i);
                return o.length && floatEqual(o[0][0], 1) && o.shift(), o.length ? o[0] : null
            }

            function pruneSegmentIntersection(l, i) {
                var o = l.slice(),
                    c = i.slice(),
                    u = getIntersection(l[l.length - 1], i[0]);
                return u && (o[l.length - 1] = l[l.length - 1].split(u[0])[0], c[0] = i[0].split(u[1])[1]), l.length > 1 && i.length > 1 && (u = getIntersection(l[0], i[i.length - 1]), u) ? [
                    [l[0].split(u[0])[0]],
                    [i[i.length - 1].split(u[1])[1]]
                ] : [o, c]
            }

            function pruneIntersections(l) {
                for (var i, o = 1; o < l.length; o += 1) i = pruneSegmentIntersection(l[o - 1], l[o]), l[o - 1] = i[0], l[o] = i[1];
                return l.length > 1 && (i = pruneSegmentIntersection(l[l.length - 1], l[0]), l[l.length - 1] = i[0], l[0] = i[1]), l
            }

            function offsetSegmentSplit(l, i) {
                var o = l.inflectionPoints(),
                    c, u, p, m;
                if (o.length === 0) return [offsetSegment(l, i)];
                if (o.length === 1 || floatEqual(o[1], 1)) return p = l.split(o[0]), c = p[0], u = p[1], [offsetSegment(c, i), offsetSegment(u, i)];
                p = l.split(o[0]), c = p[0];
                var g = (o[1] - o[0]) / (1 - o[0]);
                return p = p[1].split(g), m = p[0], u = p[1], [offsetSegment(c, i), offsetSegment(m, i), offsetSegment(u, i)]
            }

            function OffsetPathModifier() {}
            extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function(l, i) {
                this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(l, i.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(l, i.ml, 0, null, this), this.lineJoin = i.lj, this._isAnimated = this.amount.effectsSequence.length !== 0
            }, OffsetPathModifier.prototype.processPath = function(l, i, o, c) {
                var u = shapePool.newElement();
                u.c = l.c;
                var p = l.length();
                l.c || (p -= 1);
                var m, g, _, v = [];
                for (m = 0; m < p; m += 1) _ = PolynomialBezier.shapeSegment(l, m), v.push(offsetSegmentSplit(_, i));
                if (!l.c)
                    for (m = p - 1; m >= 0; m -= 1) _ = PolynomialBezier.shapeSegmentInverted(l, m), v.push(offsetSegmentSplit(_, i));
                v = pruneIntersections(v);
                var x = null,
                    y = null;
                for (m = 0; m < v.length; m += 1) {
                    var b = v[m];
                    for (y && (x = joinLines(u, y, b[0], o, c)), y = b[b.length - 1], g = 0; g < b.length; g += 1) _ = b[g], x && pointEqual(_.points[0], x) ? u.setXYAt(_.points[1][0], _.points[1][1], "o", u.length() - 1) : u.setTripleAt(_.points[0][0], _.points[0][1], _.points[1][0], _.points[1][1], _.points[0][0], _.points[0][1], u.length()), u.setTripleAt(_.points[3][0], _.points[3][1], _.points[3][0], _.points[3][1], _.points[2][0], _.points[2][1], u.length()), x = _.points[3]
                }
                return v.length && joinLines(u, y, v[0][0], o, c), u
            }, OffsetPathModifier.prototype.processShapes = function(l) {
                var i, o, c = this.shapes.length,
                    u, p, m = this.amount.v,
                    g = this.miterLimit.v,
                    _ = this.lineJoin;
                if (m !== 0) {
                    var v, x;
                    for (o = 0; o < c; o += 1) {
                        if (v = this.shapes[o], x = v.localShapeCollection, !(!v.shape._mdf && !this._mdf && !l))
                            for (x.releaseShapes(), v.shape._mdf = !0, i = v.shape.paths.shapes, p = v.shape.paths._length, u = 0; u < p; u += 1) x.addShape(this.processPath(i[u], m, _, g));
                        v.shape.paths = v.localShapeCollection
                    }
                }
                this.dynamicProperties.length || (this._mdf = !1)
            };

            function getFontProperties(l) {
                for (var i = l.fStyle ? l.fStyle.split(" ") : [], o = "normal", c = "normal", u = i.length, p, m = 0; m < u; m += 1) switch (p = i[m].toLowerCase(), p) {
                    case "italic":
                        c = "italic";
                        break;
                    case "bold":
                        o = "700";
                        break;
                    case "black":
                        o = "900";
                        break;
                    case "medium":
                        o = "500";
                        break;
                    case "regular":
                    case "normal":
                        o = "400";
                        break;
                    case "light":
                    case "thin":
                        o = "200";
                        break
                }
                return {
                    style: c,
                    weight: l.fWeight || o
                }
            }
            var FontManager = function() {
                var l = 5e3,
                    i = {
                        w: 0,
                        size: 0,
                        shapes: [],
                        data: {
                            shapes: []
                        }
                    },
                    o = [];
                o = o.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
                var c = 127988,
                    u = 917631,
                    p = 917601,
                    m = 917626,
                    g = 65039,
                    _ = 8205,
                    v = 127462,
                    x = 127487,
                    y = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];

                function b(O) {
                    var G = O.split(","),
                        L, N = G.length,
                        K = [];
                    for (L = 0; L < N; L += 1) G[L] !== "sans-serif" && G[L] !== "monospace" && K.push(G[L]);
                    return K.join(",")
                }

                function S(O, G) {
                    var L = createTag("span");
                    L.setAttribute("aria-hidden", !0), L.style.fontFamily = G;
                    var N = createTag("span");
                    N.innerText = "giItT1WQy@!-/#", L.style.position = "absolute", L.style.left = "-10000px", L.style.top = "-10000px", L.style.fontSize = "300px", L.style.fontVariant = "normal", L.style.fontStyle = "normal", L.style.fontWeight = "normal", L.style.letterSpacing = "0", L.appendChild(N), document.body.appendChild(L);
                    var K = N.offsetWidth;
                    return N.style.fontFamily = b(O) + ", " + G, {
                        node: N,
                        w: K,
                        parent: L
                    }
                }

                function C() {
                    var O, G = this.fonts.length,
                        L, N, K = G;
                    for (O = 0; O < G; O += 1) this.fonts[O].loaded ? K -= 1 : this.fonts[O].fOrigin === "n" || this.fonts[O].origin === 0 ? this.fonts[O].loaded = !0 : (L = this.fonts[O].monoCase.node, N = this.fonts[O].monoCase.w, L.offsetWidth !== N ? (K -= 1, this.fonts[O].loaded = !0) : (L = this.fonts[O].sansCase.node, N = this.fonts[O].sansCase.w, L.offsetWidth !== N && (K -= 1, this.fonts[O].loaded = !0)), this.fonts[O].loaded && (this.fonts[O].sansCase.parent.parentNode.removeChild(this.fonts[O].sansCase.parent), this.fonts[O].monoCase.parent.parentNode.removeChild(this.fonts[O].monoCase.parent)));
                    K !== 0 && Date.now() - this.initTime < l ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
                }

                function E(O, G) {
                    var L = document.body && G ? "svg" : "canvas",
                        N, K = getFontProperties(O);
                    if (L === "svg") {
                        var Z = createNS("text");
                        Z.style.fontSize = "100px", Z.setAttribute("font-family", O.fFamily), Z.setAttribute("font-style", K.style), Z.setAttribute("font-weight", K.weight), Z.textContent = "1", O.fClass ? (Z.style.fontFamily = "inherit", Z.setAttribute("class", O.fClass)) : Z.style.fontFamily = O.fFamily, G.appendChild(Z), N = Z
                    } else {
                        var he = new OffscreenCanvas(500, 500).getContext("2d");
                        he.font = K.style + " " + K.weight + " 100px " + O.fFamily, N = he
                    }

                    function we(ie) {
                        return L === "svg" ? (N.textContent = ie, N.getComputedTextLength()) : N.measureText(ie).width
                    }
                    return {
                        measureText: we
                    }
                }

                function P(O, G) {
                    if (!O) {
                        this.isLoaded = !0;
                        return
                    }
                    if (this.chars) {
                        this.isLoaded = !0, this.fonts = O.list;
                        return
                    }
                    if (!document.body) {
                        this.isLoaded = !0, O.list.forEach(function(Pe) {
                            Pe.helper = E(Pe), Pe.cache = {}
                        }), this.fonts = O.list;
                        return
                    }
                    var L = O.list,
                        N, K = L.length,
                        Z = K;
                    for (N = 0; N < K; N += 1) {
                        var he = !0,
                            we, ie;
                        if (L[N].loaded = !1, L[N].monoCase = S(L[N].fFamily, "monospace"), L[N].sansCase = S(L[N].fFamily, "sans-serif"), !L[N].fPath) L[N].loaded = !0, Z -= 1;
                        else if (L[N].fOrigin === "p" || L[N].origin === 3) {
                            if (we = document.querySelectorAll('style[f-forigin="p"][f-family="' + L[N].fFamily + '"], style[f-origin="3"][f-family="' + L[N].fFamily + '"]'), we.length > 0 && (he = !1), he) {
                                var _e = createTag("style");
                                _e.setAttribute("f-forigin", L[N].fOrigin), _e.setAttribute("f-origin", L[N].origin), _e.setAttribute("f-family", L[N].fFamily), _e.type = "text/css", _e.innerText = "@font-face {font-family: " + L[N].fFamily + "; font-style: normal; src: url('" + L[N].fPath + "');}", G.appendChild(_e)
                            }
                        } else if (L[N].fOrigin === "g" || L[N].origin === 1) {
                            for (we = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), ie = 0; ie < we.length; ie += 1) we[ie].href.indexOf(L[N].fPath) !== -1 && (he = !1);
                            if (he) {
                                var Te = createTag("link");
                                Te.setAttribute("f-forigin", L[N].fOrigin), Te.setAttribute("f-origin", L[N].origin), Te.type = "text/css", Te.rel = "stylesheet", Te.href = L[N].fPath, document.body.appendChild(Te)
                            }
                        } else if (L[N].fOrigin === "t" || L[N].origin === 2) {
                            for (we = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), ie = 0; ie < we.length; ie += 1) L[N].fPath === we[ie].src && (he = !1);
                            if (he) {
                                var Me = createTag("link");
                                Me.setAttribute("f-forigin", L[N].fOrigin), Me.setAttribute("f-origin", L[N].origin), Me.setAttribute("rel", "stylesheet"), Me.setAttribute("href", L[N].fPath), G.appendChild(Me)
                            }
                        }
                        L[N].helper = E(L[N], G), L[N].cache = {}, this.fonts.push(L[N])
                    }
                    Z === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
                }

                function w(O) {
                    if (O) {
                        this.chars || (this.chars = []);
                        var G, L = O.length,
                            N, K = this.chars.length,
                            Z;
                        for (G = 0; G < L; G += 1) {
                            for (N = 0, Z = !1; N < K;) this.chars[N].style === O[G].style && this.chars[N].fFamily === O[G].fFamily && this.chars[N].ch === O[G].ch && (Z = !0), N += 1;
                            Z || (this.chars.push(O[G]), K += 1)
                        }
                    }
                }

                function T(O, G, L) {
                    for (var N = 0, K = this.chars.length; N < K;) {
                        if (this.chars[N].ch === O && this.chars[N].style === G && this.chars[N].fFamily === L) return this.chars[N];
                        N += 1
                    }
                    return (typeof O == "string" && O.charCodeAt(0) !== 13 || !O) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", O, G, L)), i
                }

                function M(O, G, L) {
                    var N = this.getFontByName(G),
                        K = O;
                    if (!N.cache[K]) {
                        var Z = N.helper;
                        if (O === " ") {
                            var he = Z.measureText("|" + O + "|"),
                                we = Z.measureText("||");
                            N.cache[K] = (he - we) / 100
                        } else N.cache[K] = Z.measureText(O) / 100
                    }
                    return N.cache[K] * L
                }

                function A(O) {
                    for (var G = 0, L = this.fonts.length; G < L;) {
                        if (this.fonts[G].fName === O) return this.fonts[G];
                        G += 1
                    }
                    return this.fonts[0]
                }

                function D(O) {
                    var G = 0,
                        L = O.charCodeAt(0);
                    if (L >= 55296 && L <= 56319) {
                        var N = O.charCodeAt(1);
                        N >= 56320 && N <= 57343 && (G = (L - 55296) * 1024 + N - 56320 + 65536)
                    }
                    return G
                }

                function R(O, G) {
                    var L = O.toString(16) + G.toString(16);
                    return y.indexOf(L) !== -1
                }

                function I(O) {
                    return O === _
                }

                function k(O) {
                    return O === g
                }

                function F(O) {
                    var G = D(O);
                    return G >= v && G <= x
                }

                function V(O) {
                    return F(O.substr(0, 2)) && F(O.substr(2, 2))
                }

                function B(O) {
                    return o.indexOf(O) !== -1
                }

                function U(O, G) {
                    var L = D(O.substr(G, 2));
                    if (L !== c) return !1;
                    var N = 0;
                    for (G += 2; N < 5;) {
                        if (L = D(O.substr(G, 2)), L < p || L > m) return !1;
                        N += 1, G += 2
                    }
                    return D(O.substr(G, 2)) === u
                }

                function H() {
                    this.isLoaded = !0
                }
                var Q = function() {
                    this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
                };
                Q.isModifier = R, Q.isZeroWidthJoiner = I, Q.isFlagEmoji = V, Q.isRegionalCode = F, Q.isCombinedCharacter = B, Q.isRegionalFlag = U, Q.isVariationSelector = k, Q.BLACK_FLAG_CODE_POINT = c;
                var Y = {
                    addChars: w,
                    addFonts: P,
                    getCharData: T,
                    getFontByName: A,
                    measureText: M,
                    checkLoadedFonts: C,
                    setIsLoaded: H
                };
                return Q.prototype = Y, Q
            }();

            function SlotManager(l) {
                this.animationData = l
            }
            SlotManager.prototype.getProp = function(l) {
                return this.animationData.slots && this.animationData.slots[l.sid] ? Object.assign(l, this.animationData.slots[l.sid].p) : l
            };

            function slotFactory(l) {
                return new SlotManager(l)
            }

            function RenderableElement() {}
            RenderableElement.prototype = {
                initRenderable: function() {
                    this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = []
                },
                addRenderableComponent: function(i) {
                    this.renderableComponents.indexOf(i) === -1 && this.renderableComponents.push(i)
                },
                removeRenderableComponent: function(i) {
                    this.renderableComponents.indexOf(i) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(i), 1)
                },
                prepareRenderableFrame: function(i) {
                    this.checkLayerLimits(i)
                },
                checkTransparency: function() {
                    this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show())
                },
                checkLayerLimits: function(i) {
                    this.data.ip - this.data.st <= i && this.data.op - this.data.st > i ? this.isInRange !== !0 && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0, this.isInRange = !1, this.hide())
                },
                renderRenderable: function() {
                    var i, o = this.renderableComponents.length;
                    for (i = 0; i < o; i += 1) this.renderableComponents[i].renderFrame(this._isFirstFrame)
                },
                sourceRectAtTime: function() {
                    return {
                        top: 0,
                        left: 0,
                        width: 100,
                        height: 100
                    }
                },
                getLayerSize: function() {
                    return this.data.ty === 5 ? {
                        w: this.data.textData.width,
                        h: this.data.textData.height
                    } : {
                        w: this.data.width,
                        h: this.data.height
                    }
                }
            };
            var getBlendMode = function() {
                var l = {
                    0: "source-over",
                    1: "multiply",
                    2: "screen",
                    3: "overlay",
                    4: "darken",
                    5: "lighten",
                    6: "color-dodge",
                    7: "color-burn",
                    8: "hard-light",
                    9: "soft-light",
                    10: "difference",
                    11: "exclusion",
                    12: "hue",
                    13: "saturation",
                    14: "color",
                    15: "luminosity"
                };
                return function(i) {
                    return l[i] || ""
                }
            }();

            function SliderEffect(l, i, o) {
                this.p = PropertyFactory.getProp(i, l.v, 0, 0, o)
            }

            function AngleEffect(l, i, o) {
                this.p = PropertyFactory.getProp(i, l.v, 0, 0, o)
            }

            function ColorEffect(l, i, o) {
                this.p = PropertyFactory.getProp(i, l.v, 1, 0, o)
            }

            function PointEffect(l, i, o) {
                this.p = PropertyFactory.getProp(i, l.v, 1, 0, o)
            }

            function LayerIndexEffect(l, i, o) {
                this.p = PropertyFactory.getProp(i, l.v, 0, 0, o)
            }

            function MaskIndexEffect(l, i, o) {
                this.p = PropertyFactory.getProp(i, l.v, 0, 0, o)
            }

            function CheckboxEffect(l, i, o) {
                this.p = PropertyFactory.getProp(i, l.v, 0, 0, o)
            }

            function NoValueEffect() {
                this.p = {}
            }

            function EffectsManager(l, i) {
                var o = l.ef || [];
                this.effectElements = [];
                var c, u = o.length,
                    p;
                for (c = 0; c < u; c += 1) p = new GroupEffect(o[c], i), this.effectElements.push(p)
            }

            function GroupEffect(l, i) {
                this.init(l, i)
            }
            extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function(l, i) {
                this.data = l, this.effectElements = [], this.initDynamicPropertyContainer(i);
                var o, c = this.data.ef.length,
                    u, p = this.data.ef;
                for (o = 0; o < c; o += 1) {
                    switch (u = null, p[o].ty) {
                        case 0:
                            u = new SliderEffect(p[o], i, this);
                            break;
                        case 1:
                            u = new AngleEffect(p[o], i, this);
                            break;
                        case 2:
                            u = new ColorEffect(p[o], i, this);
                            break;
                        case 3:
                            u = new PointEffect(p[o], i, this);
                            break;
                        case 4:
                        case 7:
                            u = new CheckboxEffect(p[o], i, this);
                            break;
                        case 10:
                            u = new LayerIndexEffect(p[o], i, this);
                            break;
                        case 11:
                            u = new MaskIndexEffect(p[o], i, this);
                            break;
                        case 5:
                            u = new EffectsManager(p[o], i);
                            break;
                        default:
                            u = new NoValueEffect(p[o]);
                            break
                    }
                    u && this.effectElements.push(u)
                }
            };

            function BaseElement() {}
            BaseElement.prototype = {
                checkMasks: function() {
                    if (!this.data.hasMask) return !1;
                    for (var i = 0, o = this.data.masksProperties.length; i < o;) {
                        if (this.data.masksProperties[i].mode !== "n" && this.data.masksProperties[i].cl !== !1) return !0;
                        i += 1
                    }
                    return !1
                },
                initExpressions: function() {
                    var i = getExpressionInterfaces();
                    if (i) {
                        var o = i("layer"),
                            c = i("effects"),
                            u = i("shape"),
                            p = i("text"),
                            m = i("comp");
                        this.layerInterface = o(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                        var g = c.createEffectsInterface(this, this.layerInterface);
                        this.layerInterface.registerEffectsInterface(g), this.data.ty === 0 || this.data.xt ? this.compInterface = m(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = u(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = p(this), this.layerInterface.text = this.layerInterface.textInterface)
                    }
                },
                setBlendMode: function() {
                    var i = getBlendMode(this.data.bm),
                        o = this.baseElement || this.layerElement;
                    o.style["mix-blend-mode"] = i
                },
                initBaseData: function(i, o, c) {
                    this.globalData = o, this.comp = c, this.data = i, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties)
                },
                getType: function() {
                    return this.type
                },
                sourceRectAtTime: function() {}
            };

            function FrameElement() {}
            FrameElement.prototype = {
                initFrame: function() {
                    this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1
                },
                prepareProperties: function(i, o) {
                    var c, u = this.dynamicProperties.length;
                    for (c = 0; c < u; c += 1)(o || this._isParent && this.dynamicProperties[c].propType === "transform") && (this.dynamicProperties[c].getValue(), this.dynamicProperties[c]._mdf && (this.globalData._mdf = !0, this._mdf = !0))
                },
                addDynamicProperty: function(i) {
                    this.dynamicProperties.indexOf(i) === -1 && this.dynamicProperties.push(i)
                }
            };

            function FootageElement(l, i, o) {
                this.initFrame(), this.initRenderable(), this.assetData = i.getAssetData(l.refId), this.footageData = i.imageLoader.getAsset(this.assetData), this.initBaseData(l, i, o)
            }
            FootageElement.prototype.prepareFrame = function() {}, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function() {
                return null
            }, FootageElement.prototype.renderFrame = function() {}, FootageElement.prototype.destroy = function() {}, FootageElement.prototype.initExpressions = function() {
                var l = getExpressionInterfaces();
                if (l) {
                    var i = l("footage");
                    this.layerInterface = i(this)
                }
            }, FootageElement.prototype.getFootageData = function() {
                return this.footageData
            };

            function AudioElement(l, i, o) {
                this.initFrame(), this.initRenderable(), this.assetData = i.getAssetData(l.refId), this.initBaseData(l, i, o), this._isPlaying = !1, this._canPlay = !1;
                var c = this.globalData.getAssetsPath(this.assetData);
                this.audio = this.globalData.audioController.createAudio(c), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = l.tm ? PropertyFactory.getProp(this, l.tm, 0, i.frameRate, this) : {
                    _placeholder: !0
                }, this.lv = PropertyFactory.getProp(this, l.au && l.au.lv ? l.au.lv : {
                    k: [100]
                }, 1, .01, this)
            }
            AudioElement.prototype.prepareFrame = function(l) {
                if (this.prepareRenderableFrame(l, !0), this.prepareProperties(l, !0), this.tm._placeholder) this._currentTime = l / this.data.sr;
                else {
                    var i = this.tm.v;
                    this._currentTime = i
                }
                this._volume = this.lv.v[0];
                var o = this._volume * this._volumeMultiplier;
                this._previousVolume !== o && (this._previousVolume = o, this.audio.volume(o))
            }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function() {
                this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0))
            }, AudioElement.prototype.show = function() {}, AudioElement.prototype.hide = function() {
                this.audio.pause(), this._isPlaying = !1
            }, AudioElement.prototype.pause = function() {
                this.audio.pause(), this._isPlaying = !1, this._canPlay = !1
            }, AudioElement.prototype.resume = function() {
                this._canPlay = !0
            }, AudioElement.prototype.setRate = function(l) {
                this.audio.rate(l)
            }, AudioElement.prototype.volume = function(l) {
                this._volumeMultiplier = l, this._previousVolume = l * this._volume, this.audio.volume(this._previousVolume)
            }, AudioElement.prototype.getBaseElement = function() {
                return null
            }, AudioElement.prototype.destroy = function() {}, AudioElement.prototype.sourceRectAtTime = function() {}, AudioElement.prototype.initExpressions = function() {};

            function BaseRenderer() {}
            BaseRenderer.prototype.checkLayers = function(l) {
                var i, o = this.layers.length,
                    c;
                for (this.completeLayers = !0, i = o - 1; i >= 0; i -= 1) this.elements[i] || (c = this.layers[i], c.ip - c.st <= l - this.layers[i].st && c.op - c.st > l - this.layers[i].st && this.buildItem(i)), this.completeLayers = this.elements[i] ? this.completeLayers : !1;
                this.checkPendingElements()
            }, BaseRenderer.prototype.createItem = function(l) {
                switch (l.ty) {
                    case 2:
                        return this.createImage(l);
                    case 0:
                        return this.createComp(l);
                    case 1:
                        return this.createSolid(l);
                    case 3:
                        return this.createNull(l);
                    case 4:
                        return this.createShape(l);
                    case 5:
                        return this.createText(l);
                    case 6:
                        return this.createAudio(l);
                    case 13:
                        return this.createCamera(l);
                    case 15:
                        return this.createFootage(l);
                    default:
                        return this.createNull(l)
                }
            }, BaseRenderer.prototype.createCamera = function() {
                throw new Error("You're using a 3d camera. Try the html renderer.")
            }, BaseRenderer.prototype.createAudio = function(l) {
                return new AudioElement(l, this.globalData, this)
            }, BaseRenderer.prototype.createFootage = function(l) {
                return new FootageElement(l, this.globalData, this)
            }, BaseRenderer.prototype.buildAllItems = function() {
                var l, i = this.layers.length;
                for (l = 0; l < i; l += 1) this.buildItem(l);
                this.checkPendingElements()
            }, BaseRenderer.prototype.includeLayers = function(l) {
                this.completeLayers = !1;
                var i, o = l.length,
                    c, u = this.layers.length;
                for (i = 0; i < o; i += 1)
                    for (c = 0; c < u;) {
                        if (this.layers[c].id === l[i].id) {
                            this.layers[c] = l[i];
                            break
                        }
                        c += 1
                    }
            }, BaseRenderer.prototype.setProjectInterface = function(l) {
                this.globalData.projectInterface = l
            }, BaseRenderer.prototype.initItems = function() {
                this.globalData.progressiveLoad || this.buildAllItems()
            }, BaseRenderer.prototype.buildElementParenting = function(l, i, o) {
                for (var c = this.elements, u = this.layers, p = 0, m = u.length; p < m;) u[p].ind == i && (!c[p] || c[p] === !0 ? (this.buildItem(p), this.addPendingElement(l)) : (o.push(c[p]), c[p].setAsParent(), u[p].parent !== void 0 ? this.buildElementParenting(l, u[p].parent, o) : l.setHierarchy(o))), p += 1
            }, BaseRenderer.prototype.addPendingElement = function(l) {
                this.pendingElements.push(l)
            }, BaseRenderer.prototype.searchExtraCompositions = function(l) {
                var i, o = l.length;
                for (i = 0; i < o; i += 1)
                    if (l[i].xt) {
                        var c = this.createComp(l[i]);
                        c.initExpressions(), this.globalData.projectInterface.registerComposition(c)
                    }
            }, BaseRenderer.prototype.getElementById = function(l) {
                var i, o = this.elements.length;
                for (i = 0; i < o; i += 1)
                    if (this.elements[i].data.ind === l) return this.elements[i];
                return null
            }, BaseRenderer.prototype.getElementByPath = function(l) {
                var i = l.shift(),
                    o;
                if (typeof i == "number") o = this.elements[i];
                else {
                    var c, u = this.elements.length;
                    for (c = 0; c < u; c += 1)
                        if (this.elements[c].data.nm === i) {
                            o = this.elements[c];
                            break
                        }
                }
                return l.length === 0 ? o : o.getElementByPath(l)
            }, BaseRenderer.prototype.setupGlobalData = function(l, i) {
                this.globalData.fontManager = new FontManager, this.globalData.slotManager = slotFactory(l), this.globalData.fontManager.addChars(l.chars), this.globalData.fontManager.addFonts(l.fonts, i), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = l.fr, this.globalData.nm = l.nm, this.globalData.compSize = {
                    w: l.w,
                    h: l.h
                }
            };
            var effectTypes = {
                TRANSFORM_EFFECT: "transformEFfect"
            };

            function TransformElement() {}
            TransformElement.prototype = {
                initTransform: function() {
                    var i = new Matrix;
                    this.finalTransform = {
                        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                            o: 0
                        },
                        _matMdf: !1,
                        _localMatMdf: !1,
                        _opMdf: !1,
                        mat: i,
                        localMat: i,
                        localOpacity: 1
                    }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty
                },
                renderTransform: function() {
                    if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
                        var i, o = this.finalTransform.mat,
                            c = 0,
                            u = this.hierarchy.length;
                        if (!this.finalTransform._matMdf)
                            for (; c < u;) {
                                if (this.hierarchy[c].finalTransform.mProp._mdf) {
                                    this.finalTransform._matMdf = !0;
                                    break
                                }
                                c += 1
                            }
                        if (this.finalTransform._matMdf)
                            for (i = this.finalTransform.mProp.v.props, o.cloneFromProps(i), c = 0; c < u; c += 1) o.multiply(this.hierarchy[c].finalTransform.mProp.v)
                    }(!this.localTransforms || this.finalTransform._matMdf) && (this.finalTransform._localMatMdf = this.finalTransform._matMdf), this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v)
                },
                renderLocalTransform: function() {
                    if (this.localTransforms) {
                        var i = 0,
                            o = this.localTransforms.length;
                        if (this.finalTransform._localMatMdf = this.finalTransform._matMdf, !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
                            for (; i < o;) this.localTransforms[i]._mdf && (this.finalTransform._localMatMdf = !0), this.localTransforms[i]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v, this.finalTransform._opMdf = !0), i += 1;
                        if (this.finalTransform._localMatMdf) {
                            var c = this.finalTransform.localMat;
                            for (this.localTransforms[0].matrix.clone(c), i = 1; i < o; i += 1) {
                                var u = this.localTransforms[i].matrix;
                                c.multiply(u)
                            }
                            c.multiply(this.finalTransform.mat)
                        }
                        if (this.finalTransform._opMdf) {
                            var p = this.finalTransform.localOpacity;
                            for (i = 0; i < o; i += 1) p *= this.localTransforms[i].opacity * .01;
                            this.finalTransform.localOpacity = p
                        }
                    }
                },
                searchEffectTransforms: function() {
                    if (this.renderableEffectsManager) {
                        var i = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                        if (i.length) {
                            this.localTransforms = [], this.finalTransform.localMat = new Matrix;
                            var o = 0,
                                c = i.length;
                            for (o = 0; o < c; o += 1) this.localTransforms.push(i[o])
                        }
                    }
                },
                globalToLocal: function(i) {
                    var o = [];
                    o.push(this.finalTransform);
                    for (var c = !0, u = this.comp; c;) u.finalTransform ? (u.data.hasMask && o.splice(0, 0, u.finalTransform), u = u.comp) : c = !1;
                    var p, m = o.length,
                        g;
                    for (p = 0; p < m; p += 1) g = o[p].mat.applyToPointArray(0, 0, 0), i = [i[0] - g[0], i[1] - g[1], 0];
                    return i
                },
                mHelper: new Matrix
            };

            function MaskElement(l, i, o) {
                this.data = l, this.element = i, this.globalData = o, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
                var c = this.globalData.defs,
                    u, p = this.masksProperties ? this.masksProperties.length : 0;
                this.viewData = createSizedArray(p), this.solidPath = "";
                var m, g = this.masksProperties,
                    _ = 0,
                    v = [],
                    x, y, b = createElementID(),
                    S, C, E, P, w = "clipPath",
                    T = "clip-path";
                for (u = 0; u < p; u += 1)
                    if ((g[u].mode !== "a" && g[u].mode !== "n" || g[u].inv || g[u].o.k !== 100 || g[u].o.x) && (w = "mask", T = "mask"), (g[u].mode === "s" || g[u].mode === "i") && _ === 0 ? (S = createNS("rect"), S.setAttribute("fill", "#ffffff"), S.setAttribute("width", this.element.comp.data.w || 0), S.setAttribute("height", this.element.comp.data.h || 0), v.push(S)) : S = null, m = createNS("path"), g[u].mode === "n") this.viewData[u] = {
                        op: PropertyFactory.getProp(this.element, g[u].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, g[u], 3),
                        elem: m,
                        lastPath: ""
                    }, c.appendChild(m);
                    else {
                        _ += 1, m.setAttribute("fill", g[u].mode === "s" ? "#000000" : "#ffffff"), m.setAttribute("clip-rule", "nonzero");
                        var M;
                        if (g[u].x.k !== 0 ? (w = "mask", T = "mask", P = PropertyFactory.getProp(this.element, g[u].x, 0, null, this.element), M = createElementID(), C = createNS("filter"), C.setAttribute("id", M), E = createNS("feMorphology"), E.setAttribute("operator", "erode"), E.setAttribute("in", "SourceGraphic"), E.setAttribute("radius", "0"), C.appendChild(E), c.appendChild(C), m.setAttribute("stroke", g[u].mode === "s" ? "#000000" : "#ffffff")) : (E = null, P = null), this.storedData[u] = {
                                elem: m,
                                x: P,
                                expan: E,
                                lastPath: "",
                                lastOperator: "",
                                filterId: M,
                                lastRadius: 0
                            }, g[u].mode === "i") {
                            y = v.length;
                            var A = createNS("g");
                            for (x = 0; x < y; x += 1) A.appendChild(v[x]);
                            var D = createNS("mask");
                            D.setAttribute("mask-type", "alpha"), D.setAttribute("id", b + "_" + _), D.appendChild(m), c.appendChild(D), A.setAttribute("mask", "url(" + getLocationHref() + "#" + b + "_" + _ + ")"), v.length = 0, v.push(A)
                        } else v.push(m);
                        g[u].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[u] = {
                            elem: m,
                            lastPath: "",
                            op: PropertyFactory.getProp(this.element, g[u].o, 0, .01, this.element),
                            prop: ShapePropertyFactory.getShapeProp(this.element, g[u], 3),
                            invRect: S
                        }, this.viewData[u].prop.k || this.drawPath(g[u], this.viewData[u].prop.v, this.viewData[u])
                    }
                for (this.maskElement = createNS(w), p = v.length, u = 0; u < p; u += 1) this.maskElement.appendChild(v[u]);
                _ > 0 && (this.maskElement.setAttribute("id", b), this.element.maskedElement.setAttribute(T, "url(" + getLocationHref() + "#" + b + ")"), c.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this)
            }
            MaskElement.prototype.getMaskProperty = function(l) {
                return this.viewData[l].prop
            }, MaskElement.prototype.renderFrame = function(l) {
                var i = this.element.finalTransform.mat,
                    o, c = this.masksProperties.length;
                for (o = 0; o < c; o += 1)
                    if ((this.viewData[o].prop._mdf || l) && this.drawPath(this.masksProperties[o], this.viewData[o].prop.v, this.viewData[o]), (this.viewData[o].op._mdf || l) && this.viewData[o].elem.setAttribute("fill-opacity", this.viewData[o].op.v), this.masksProperties[o].mode !== "n" && (this.viewData[o].invRect && (this.element.finalTransform.mProp._mdf || l) && this.viewData[o].invRect.setAttribute("transform", i.getInverseMatrix().to2dCSS()), this.storedData[o].x && (this.storedData[o].x._mdf || l))) {
                        var u = this.storedData[o].expan;
                        this.storedData[o].x.v < 0 ? (this.storedData[o].lastOperator !== "erode" && (this.storedData[o].lastOperator = "erode", this.storedData[o].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[o].filterId + ")")), u.setAttribute("radius", -this.storedData[o].x.v)) : (this.storedData[o].lastOperator !== "dilate" && (this.storedData[o].lastOperator = "dilate", this.storedData[o].elem.setAttribute("filter", null)), this.storedData[o].elem.setAttribute("stroke-width", this.storedData[o].x.v * 2))
                    }
            }, MaskElement.prototype.getMaskelement = function() {
                return this.maskElement
            }, MaskElement.prototype.createLayerSolidPath = function() {
                var l = "M0,0 ";
                return l += " h" + this.globalData.compSize.w, l += " v" + this.globalData.compSize.h, l += " h-" + this.globalData.compSize.w, l += " v-" + this.globalData.compSize.h + " ", l
            }, MaskElement.prototype.drawPath = function(l, i, o) {
                var c = " M" + i.v[0][0] + "," + i.v[0][1],
                    u, p;
                for (p = i._length, u = 1; u < p; u += 1) c += " C" + i.o[u - 1][0] + "," + i.o[u - 1][1] + " " + i.i[u][0] + "," + i.i[u][1] + " " + i.v[u][0] + "," + i.v[u][1];
                if (i.c && p > 1 && (c += " C" + i.o[u - 1][0] + "," + i.o[u - 1][1] + " " + i.i[0][0] + "," + i.i[0][1] + " " + i.v[0][0] + "," + i.v[0][1]), o.lastPath !== c) {
                    var m = "";
                    o.elem && (i.c && (m = l.inv ? this.solidPath + c : c), o.elem.setAttribute("d", m)), o.lastPath = c
                }
            }, MaskElement.prototype.destroy = function() {
                this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null
            };
            var filtersFactory = function() {
                    var l = {};
                    l.createFilter = i, l.createAlphaToLuminanceFilter = o;

                    function i(c, u) {
                        var p = createNS("filter");
                        return p.setAttribute("id", c), u !== !0 && (p.setAttribute("filterUnits", "objectBoundingBox"), p.setAttribute("x", "0%"), p.setAttribute("y", "0%"), p.setAttribute("width", "100%"), p.setAttribute("height", "100%")), p
                    }

                    function o() {
                        var c = createNS("feColorMatrix");
                        return c.setAttribute("type", "matrix"), c.setAttribute("color-interpolation-filters", "sRGB"), c.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), c
                    }
                    return l
                }(),
                featureSupport = function() {
                    var l = {
                        maskType: !0,
                        svgLumaHidden: !0,
                        offscreenCanvas: typeof OffscreenCanvas < "u"
                    };
                    return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (l.maskType = !1), /firefox/i.test(navigator.userAgent) && (l.svgLumaHidden = !1), l
                }(),
                registeredEffects$1 = {},
                idPrefix = "filter_result_";

            function SVGEffects(l) {
                var i, o = "SourceGraphic",
                    c = l.data.ef ? l.data.ef.length : 0,
                    u = createElementID(),
                    p = filtersFactory.createFilter(u, !0),
                    m = 0;
                this.filters = [];
                var g;
                for (i = 0; i < c; i += 1) {
                    g = null;
                    var _ = l.data.ef[i].ty;
                    if (registeredEffects$1[_]) {
                        var v = registeredEffects$1[_].effect;
                        g = new v(p, l.effectsManager.effectElements[i], l, idPrefix + m, o), o = idPrefix + m, registeredEffects$1[_].countsAsEffect && (m += 1)
                    }
                    g && this.filters.push(g)
                }
                m && (l.globalData.defs.appendChild(p), l.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + u + ")")), this.filters.length && l.addRenderableComponent(this)
            }
            SVGEffects.prototype.renderFrame = function(l) {
                var i, o = this.filters.length;
                for (i = 0; i < o; i += 1) this.filters[i].renderFrame(l)
            }, SVGEffects.prototype.getEffects = function(l) {
                var i, o = this.filters.length,
                    c = [];
                for (i = 0; i < o; i += 1) this.filters[i].type === l && c.push(this.filters[i]);
                return c
            };

            function registerEffect$1(l, i, o) {
                registeredEffects$1[l] = {
                    effect: i,
                    countsAsEffect: o
                }
            }

            function SVGBaseElement() {}
            SVGBaseElement.prototype = {
                initRendererElement: function() {
                    this.layerElement = createNS("g")
                },
                createContainerElements: function() {
                    this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
                    var i = null;
                    if (this.data.td) {
                        this.matteMasks = {};
                        var o = createNS("g");
                        o.setAttribute("id", this.layerId), o.appendChild(this.layerElement), i = o, this.globalData.defs.appendChild(o)
                    } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), i = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                    if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.ty === 0 && !this.data.hd) {
                        var c = createNS("clipPath"),
                            u = createNS("path");
                        u.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                        var p = createElementID();
                        if (c.setAttribute("id", p), c.appendChild(u), this.globalData.defs.appendChild(c), this.checkMasks()) {
                            var m = createNS("g");
                            m.setAttribute("clip-path", "url(" + getLocationHref() + "#" + p + ")"), m.appendChild(this.layerElement), this.transformedElement = m, i ? i.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                        } else this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + p + ")")
                    }
                    this.data.bm !== 0 && this.setBlendMode()
                },
                renderElement: function() {
                    this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity)
                },
                destroyBaseElement: function() {
                    this.layerElement = null, this.matteElement = null, this.maskManager.destroy()
                },
                getBaseElement: function() {
                    return this.data.hd ? null : this.baseElement
                },
                createRenderableComponents: function() {
                    this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this), this.searchEffectTransforms()
                },
                getMatte: function(i) {
                    if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[i]) {
                        var o = this.layerId + "_" + i,
                            c, u, p, m;
                        if (i === 1 || i === 3) {
                            var g = createNS("mask");
                            g.setAttribute("id", o), g.setAttribute("mask-type", i === 3 ? "luminance" : "alpha"), p = createNS("use"), p.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), g.appendChild(p), this.globalData.defs.appendChild(g), !featureSupport.maskType && i === 1 && (g.setAttribute("mask-type", "luminance"), c = createElementID(), u = filtersFactory.createFilter(c), this.globalData.defs.appendChild(u), u.appendChild(filtersFactory.createAlphaToLuminanceFilter()), m = createNS("g"), m.appendChild(p), g.appendChild(m), m.setAttribute("filter", "url(" + getLocationHref() + "#" + c + ")"))
                        } else if (i === 2) {
                            var _ = createNS("mask");
                            _.setAttribute("id", o), _.setAttribute("mask-type", "alpha");
                            var v = createNS("g");
                            _.appendChild(v), c = createElementID(), u = filtersFactory.createFilter(c);
                            var x = createNS("feComponentTransfer");
                            x.setAttribute("in", "SourceGraphic"), u.appendChild(x);
                            var y = createNS("feFuncA");
                            y.setAttribute("type", "table"), y.setAttribute("tableValues", "1.0 0.0"), x.appendChild(y), this.globalData.defs.appendChild(u);
                            var b = createNS("rect");
                            b.setAttribute("width", this.comp.data.w), b.setAttribute("height", this.comp.data.h), b.setAttribute("x", "0"), b.setAttribute("y", "0"), b.setAttribute("fill", "#ffffff"), b.setAttribute("opacity", "0"), v.setAttribute("filter", "url(" + getLocationHref() + "#" + c + ")"), v.appendChild(b), p = createNS("use"), p.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), v.appendChild(p), featureSupport.maskType || (_.setAttribute("mask-type", "luminance"), u.appendChild(filtersFactory.createAlphaToLuminanceFilter()), m = createNS("g"), v.appendChild(b), m.appendChild(this.layerElement), v.appendChild(m)), this.globalData.defs.appendChild(_)
                        }
                        this.matteMasks[i] = o
                    }
                    return this.matteMasks[i]
                },
                setMatte: function(i) {
                    this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + i + ")")
                }
            };

            function HierarchyElement() {}
            HierarchyElement.prototype = {
                initHierarchy: function() {
                    this.hierarchy = [], this._isParent = !1, this.checkParenting()
                },
                setHierarchy: function(i) {
                    this.hierarchy = i
                },
                setAsParent: function() {
                    this._isParent = !0
                },
                checkParenting: function() {
                    this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, [])
                }
            };

            function RenderableDOMElement() {}(function() {
                var l = {
                    initElement: function(o, c, u) {
                        this.initFrame(), this.initBaseData(o, c, u), this.initTransform(o, c, u), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide()
                    },
                    hide: function() {
                        if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                            var o = this.baseElement || this.layerElement;
                            o.style.display = "none", this.hidden = !0
                        }
                    },
                    show: function() {
                        if (this.isInRange && !this.isTransparent) {
                            if (!this.data.hd) {
                                var o = this.baseElement || this.layerElement;
                                o.style.display = "block"
                            }
                            this.hidden = !1, this._isFirstFrame = !0
                        }
                    },
                    renderFrame: function() {
                        this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                    },
                    renderInnerContent: function() {},
                    prepareFrame: function(o) {
                        this._mdf = !1, this.prepareRenderableFrame(o), this.prepareProperties(o, this.isInRange), this.checkTransparency()
                    },
                    destroy: function() {
                        this.innerElem = null, this.destroyBaseElement()
                    }
                };
                extendPrototype([RenderableElement, createProxyFunction(l)], RenderableDOMElement)
            })();

            function IImageElement(l, i, o) {
                this.assetData = i.getAssetData(l.refId), this.assetData && this.assetData.sid && (this.assetData = i.slotManager.getProp(this.assetData)), this.initElement(l, i, o), this.sourceRect = {
                    top: 0,
                    left: 0,
                    width: this.assetData.w,
                    height: this.assetData.h
                }
            }
            extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function() {
                var l = this.globalData.getAssetsPath(this.assetData);
                this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", l), this.layerElement.appendChild(this.innerElem)
            }, IImageElement.prototype.sourceRectAtTime = function() {
                return this.sourceRect
            };

            function ProcessedElement(l, i) {
                this.elem = l, this.pos = i
            }

            function IShapeElement() {}
            IShapeElement.prototype = {
                addShapeToModifiers: function(i) {
                    var o, c = this.shapeModifiers.length;
                    for (o = 0; o < c; o += 1) this.shapeModifiers[o].addShape(i)
                },
                isShapeInAnimatedModifiers: function(i) {
                    for (var o = 0, c = this.shapeModifiers.length; o < c;)
                        if (this.shapeModifiers[o].isAnimatedWithShape(i)) return !0;
                    return !1
                },
                renderModifiers: function() {
                    if (this.shapeModifiers.length) {
                        var i, o = this.shapes.length;
                        for (i = 0; i < o; i += 1) this.shapes[i].sh.reset();
                        o = this.shapeModifiers.length;
                        var c;
                        for (i = o - 1; i >= 0 && (c = this.shapeModifiers[i].processShapes(this._isFirstFrame), !c); i -= 1);
                    }
                },
                searchProcessedElement: function(i) {
                    for (var o = this.processedElements, c = 0, u = o.length; c < u;) {
                        if (o[c].elem === i) return o[c].pos;
                        c += 1
                    }
                    return 0
                },
                addProcessedElement: function(i, o) {
                    for (var c = this.processedElements, u = c.length; u;)
                        if (u -= 1, c[u].elem === i) {
                            c[u].pos = o;
                            return
                        }
                    c.push(new ProcessedElement(i, o))
                },
                prepareFrame: function(i) {
                    this.prepareRenderableFrame(i), this.prepareProperties(i, this.isInRange)
                }
            };
            var lineCapEnum = {
                    1: "butt",
                    2: "round",
                    3: "square"
                },
                lineJoinEnum = {
                    1: "miter",
                    2: "round",
                    3: "bevel"
                };

            function SVGShapeData(l, i, o) {
                this.caches = [], this.styles = [], this.transformers = l, this.lStr = "", this.sh = o, this.lvl = i, this._isAnimated = !!o.k;
                for (var c = 0, u = l.length; c < u;) {
                    if (l[c].mProps.dynamicProperties.length) {
                        this._isAnimated = !0;
                        break
                    }
                    c += 1
                }
            }
            SVGShapeData.prototype.setAsAnimated = function() {
                this._isAnimated = !0
            };

            function SVGStyleData(l, i) {
                this.data = l, this.type = l.ty, this.d = "", this.lvl = i, this._mdf = !1, this.closed = l.hd === !0, this.pElem = createNS("path"), this.msElem = null
            }
            SVGStyleData.prototype.reset = function() {
                this.d = "", this._mdf = !1
            };

            function DashProperty(l, i, o, c) {
                this.elem = l, this.frameId = -1, this.dataProps = createSizedArray(i.length), this.renderer = o, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", i.length ? i.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(c);
                var u, p = i.length || 0,
                    m;
                for (u = 0; u < p; u += 1) m = PropertyFactory.getProp(l, i[u].v, 0, 0, this), this.k = m.k || this.k, this.dataProps[u] = {
                    n: i[u].n,
                    p: m
                };
                this.k || this.getValue(!0), this._isAnimated = this.k
            }
            DashProperty.prototype.getValue = function(l) {
                if (!(this.elem.globalData.frameId === this.frameId && !l) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || l, this._mdf)) {
                    var i = 0,
                        o = this.dataProps.length;
                    for (this.renderer === "svg" && (this.dashStr = ""), i = 0; i < o; i += 1) this.dataProps[i].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[i].p.v : this.dashArray[i] = this.dataProps[i].p.v : this.dashoffset[0] = this.dataProps[i].p.v
                }
            }, extendPrototype([DynamicPropertyContainer], DashProperty);

            function SVGStrokeStyleData(l, i, o) {
                this.initDynamicPropertyContainer(l), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(l, i.o, 0, .01, this), this.w = PropertyFactory.getProp(l, i.w, 0, null, this), this.d = new DashProperty(l, i.d || {}, "svg", this), this.c = PropertyFactory.getProp(l, i.c, 1, 255, this), this.style = o, this._isAnimated = !!this._isAnimated
            }
            extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

            function SVGFillStyleData(l, i, o) {
                this.initDynamicPropertyContainer(l), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(l, i.o, 0, .01, this), this.c = PropertyFactory.getProp(l, i.c, 1, 255, this), this.style = o
            }
            extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

            function SVGNoStyleData(l, i, o) {
                this.initDynamicPropertyContainer(l), this.getValue = this.iterateDynamicProperties, this.style = o
            }
            extendPrototype([DynamicPropertyContainer], SVGNoStyleData);

            function GradientProperty(l, i, o) {
                this.data = i, this.c = createTypedArray("uint8c", i.p * 4);
                var c = i.k.k[0].s ? i.k.k[0].s.length - i.p * 4 : i.k.k.length - i.p * 4;
                this.o = createTypedArray("float32", c), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = c, this.initDynamicPropertyContainer(o), this.prop = PropertyFactory.getProp(l, i.k, 1, null, this), this.k = this.prop.k, this.getValue(!0)
            }
            GradientProperty.prototype.comparePoints = function(l, i) {
                for (var o = 0, c = this.o.length / 2, u; o < c;) {
                    if (u = Math.abs(l[o * 4] - l[i * 4 + o * 2]), u > .01) return !1;
                    o += 1
                }
                return !0
            }, GradientProperty.prototype.checkCollapsable = function() {
                if (this.o.length / 2 !== this.c.length / 4) return !1;
                if (this.data.k.k[0].s)
                    for (var l = 0, i = this.data.k.k.length; l < i;) {
                        if (!this.comparePoints(this.data.k.k[l].s, this.data.p)) return !1;
                        l += 1
                    } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
                return !0
            }, GradientProperty.prototype.getValue = function(l) {
                if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || l) {
                    var i, o = this.data.p * 4,
                        c, u;
                    for (i = 0; i < o; i += 1) c = i % 4 === 0 ? 100 : 255, u = Math.round(this.prop.v[i] * c), this.c[i] !== u && (this.c[i] = u, this._cmdf = !l);
                    if (this.o.length)
                        for (o = this.prop.v.length, i = this.data.p * 4; i < o; i += 1) c = i % 2 === 0 ? 100 : 1, u = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i], this.o[i - this.data.p * 4] !== u && (this.o[i - this.data.p * 4] = u, this._omdf = !l);
                    this._mdf = !l
                }
            }, extendPrototype([DynamicPropertyContainer], GradientProperty);

            function SVGGradientFillStyleData(l, i, o) {
                this.initDynamicPropertyContainer(l), this.getValue = this.iterateDynamicProperties, this.initGradientData(l, i, o)
            }
            SVGGradientFillStyleData.prototype.initGradientData = function(l, i, o) {
                this.o = PropertyFactory.getProp(l, i.o, 0, .01, this), this.s = PropertyFactory.getProp(l, i.s, 1, null, this), this.e = PropertyFactory.getProp(l, i.e, 1, null, this), this.h = PropertyFactory.getProp(l, i.h || {
                    k: 0
                }, 0, .01, this), this.a = PropertyFactory.getProp(l, i.a || {
                    k: 0
                }, 0, degToRads, this), this.g = new GradientProperty(l, i.g, this), this.style = o, this.stops = [], this.setGradientData(o.pElem, i), this.setGradientOpacity(i, o), this._isAnimated = !!this._isAnimated
            }, SVGGradientFillStyleData.prototype.setGradientData = function(l, i) {
                var o = createElementID(),
                    c = createNS(i.t === 1 ? "linearGradient" : "radialGradient");
                c.setAttribute("id", o), c.setAttribute("spreadMethod", "pad"), c.setAttribute("gradientUnits", "userSpaceOnUse");
                var u = [],
                    p, m, g;
                for (g = i.g.p * 4, m = 0; m < g; m += 4) p = createNS("stop"), c.appendChild(p), u.push(p);
                l.setAttribute(i.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + o + ")"), this.gf = c, this.cst = u
            }, SVGGradientFillStyleData.prototype.setGradientOpacity = function(l, i) {
                if (this.g._hasOpacity && !this.g._collapsable) {
                    var o, c, u, p = createNS("mask"),
                        m = createNS("path");
                    p.appendChild(m);
                    var g = createElementID(),
                        _ = createElementID();
                    p.setAttribute("id", _);
                    var v = createNS(l.t === 1 ? "linearGradient" : "radialGradient");
                    v.setAttribute("id", g), v.setAttribute("spreadMethod", "pad"), v.setAttribute("gradientUnits", "userSpaceOnUse"), u = l.g.k.k[0].s ? l.g.k.k[0].s.length : l.g.k.k.length;
                    var x = this.stops;
                    for (c = l.g.p * 4; c < u; c += 2) o = createNS("stop"), o.setAttribute("stop-color", "rgb(255,255,255)"), v.appendChild(o), x.push(o);
                    m.setAttribute(l.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + g + ")"), l.ty === "gs" && (m.setAttribute("stroke-linecap", lineCapEnum[l.lc || 2]), m.setAttribute("stroke-linejoin", lineJoinEnum[l.lj || 2]), l.lj === 1 && m.setAttribute("stroke-miterlimit", l.ml)), this.of = v, this.ms = p, this.ost = x, this.maskId = _, i.msElem = m
                }
            }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

            function SVGGradientStrokeStyleData(l, i, o) {
                this.initDynamicPropertyContainer(l), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(l, i.w, 0, null, this), this.d = new DashProperty(l, i.d || {}, "svg", this), this.initGradientData(l, i, o), this._isAnimated = !!this._isAnimated
            }
            extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

            function ShapeGroupData() {
                this.it = [], this.prevViewData = [], this.gr = createNS("g")
            }

            function SVGTransformData(l, i, o) {
                this.transform = {
                    mProps: l,
                    op: i,
                    container: o
                }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
            }
            var buildShapeString = function(i, o, c, u) {
                    if (o === 0) return "";
                    var p = i.o,
                        m = i.i,
                        g = i.v,
                        _, v = " M" + u.applyToPointStringified(g[0][0], g[0][1]);
                    for (_ = 1; _ < o; _ += 1) v += " C" + u.applyToPointStringified(p[_ - 1][0], p[_ - 1][1]) + " " + u.applyToPointStringified(m[_][0], m[_][1]) + " " + u.applyToPointStringified(g[_][0], g[_][1]);
                    return c && o && (v += " C" + u.applyToPointStringified(p[_ - 1][0], p[_ - 1][1]) + " " + u.applyToPointStringified(m[0][0], m[0][1]) + " " + u.applyToPointStringified(g[0][0], g[0][1]), v += "z"), v
                },
                SVGElementsRenderer = function() {
                    var l = new Matrix,
                        i = new Matrix,
                        o = {
                            createRenderFunction: c
                        };

                    function c(y) {
                        switch (y.ty) {
                            case "fl":
                                return g;
                            case "gf":
                                return v;
                            case "gs":
                                return _;
                            case "st":
                                return x;
                            case "sh":
                            case "el":
                            case "rc":
                            case "sr":
                                return m;
                            case "tr":
                                return u;
                            case "no":
                                return p;
                            default:
                                return null
                        }
                    }

                    function u(y, b, S) {
                        (S || b.transform.op._mdf) && b.transform.container.setAttribute("opacity", b.transform.op.v), (S || b.transform.mProps._mdf) && b.transform.container.setAttribute("transform", b.transform.mProps.v.to2dCSS())
                    }

                    function p() {}

                    function m(y, b, S) {
                        var C, E, P, w, T, M, A = b.styles.length,
                            D = b.lvl,
                            R, I, k, F;
                        for (M = 0; M < A; M += 1) {
                            if (w = b.sh._mdf || S, b.styles[M].lvl < D) {
                                for (I = i.reset(), k = D - b.styles[M].lvl, F = b.transformers.length - 1; !w && k > 0;) w = b.transformers[F].mProps._mdf || w, k -= 1, F -= 1;
                                if (w)
                                    for (k = D - b.styles[M].lvl, F = b.transformers.length - 1; k > 0;) I.multiply(b.transformers[F].mProps.v), k -= 1, F -= 1
                            } else I = l;
                            if (R = b.sh.paths, E = R._length, w) {
                                for (P = "", C = 0; C < E; C += 1) T = R.shapes[C], T && T._length && (P += buildShapeString(T, T._length, T.c, I));
                                b.caches[M] = P
                            } else P = b.caches[M];
                            b.styles[M].d += y.hd === !0 ? "" : P, b.styles[M]._mdf = w || b.styles[M]._mdf
                        }
                    }

                    function g(y, b, S) {
                        var C = b.style;
                        (b.c._mdf || S) && C.pElem.setAttribute("fill", "rgb(" + bmFloor(b.c.v[0]) + "," + bmFloor(b.c.v[1]) + "," + bmFloor(b.c.v[2]) + ")"), (b.o._mdf || S) && C.pElem.setAttribute("fill-opacity", b.o.v)
                    }

                    function _(y, b, S) {
                        v(y, b, S), x(y, b, S)
                    }

                    function v(y, b, S) {
                        var C = b.gf,
                            E = b.g._hasOpacity,
                            P = b.s.v,
                            w = b.e.v;
                        if (b.o._mdf || S) {
                            var T = y.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                            b.style.pElem.setAttribute(T, b.o.v)
                        }
                        if (b.s._mdf || S) {
                            var M = y.t === 1 ? "x1" : "cx",
                                A = M === "x1" ? "y1" : "cy";
                            C.setAttribute(M, P[0]), C.setAttribute(A, P[1]), E && !b.g._collapsable && (b.of.setAttribute(M, P[0]), b.of.setAttribute(A, P[1]))
                        }
                        var D, R, I, k;
                        if (b.g._cmdf || S) {
                            D = b.cst;
                            var F = b.g.c;
                            for (I = D.length, R = 0; R < I; R += 1) k = D[R], k.setAttribute("offset", F[R * 4] + "%"), k.setAttribute("stop-color", "rgb(" + F[R * 4 + 1] + "," + F[R * 4 + 2] + "," + F[R * 4 + 3] + ")")
                        }
                        if (E && (b.g._omdf || S)) {
                            var V = b.g.o;
                            for (b.g._collapsable ? D = b.cst : D = b.ost, I = D.length, R = 0; R < I; R += 1) k = D[R], b.g._collapsable || k.setAttribute("offset", V[R * 2] + "%"), k.setAttribute("stop-opacity", V[R * 2 + 1])
                        }
                        if (y.t === 1)(b.e._mdf || S) && (C.setAttribute("x2", w[0]), C.setAttribute("y2", w[1]), E && !b.g._collapsable && (b.of.setAttribute("x2", w[0]), b.of.setAttribute("y2", w[1])));
                        else {
                            var B;
                            if ((b.s._mdf || b.e._mdf || S) && (B = Math.sqrt(Math.pow(P[0] - w[0], 2) + Math.pow(P[1] - w[1], 2)), C.setAttribute("r", B), E && !b.g._collapsable && b.of.setAttribute("r", B)), b.s._mdf || b.e._mdf || b.h._mdf || b.a._mdf || S) {
                                B || (B = Math.sqrt(Math.pow(P[0] - w[0], 2) + Math.pow(P[1] - w[1], 2)));
                                var U = Math.atan2(w[1] - P[1], w[0] - P[0]),
                                    H = b.h.v;
                                H >= 1 ? H = .99 : H <= -1 && (H = -.99);
                                var Q = B * H,
                                    Y = Math.cos(U + b.a.v) * Q + P[0],
                                    O = Math.sin(U + b.a.v) * Q + P[1];
                                C.setAttribute("fx", Y), C.setAttribute("fy", O), E && !b.g._collapsable && (b.of.setAttribute("fx", Y), b.of.setAttribute("fy", O))
                            }
                        }
                    }

                    function x(y, b, S) {
                        var C = b.style,
                            E = b.d;
                        E && (E._mdf || S) && E.dashStr && (C.pElem.setAttribute("stroke-dasharray", E.dashStr), C.pElem.setAttribute("stroke-dashoffset", E.dashoffset[0])), b.c && (b.c._mdf || S) && C.pElem.setAttribute("stroke", "rgb(" + bmFloor(b.c.v[0]) + "," + bmFloor(b.c.v[1]) + "," + bmFloor(b.c.v[2]) + ")"), (b.o._mdf || S) && C.pElem.setAttribute("stroke-opacity", b.o.v), (b.w._mdf || S) && (C.pElem.setAttribute("stroke-width", b.w.v), C.msElem && C.msElem.setAttribute("stroke-width", b.w.v))
                    }
                    return o
                }();

            function SVGShapeElement(l, i, o) {
                this.shapes = [], this.shapesData = l.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(l, i, o), this.prevViewData = []
            }
            extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function() {}, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function() {}, SVGShapeElement.prototype.createContent = function() {
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes()
            }, SVGShapeElement.prototype.filterUniqueShapes = function() {
                var l, i = this.shapes.length,
                    o, c, u = this.stylesList.length,
                    p, m = [],
                    g = !1;
                for (c = 0; c < u; c += 1) {
                    for (p = this.stylesList[c], g = !1, m.length = 0, l = 0; l < i; l += 1) o = this.shapes[l], o.styles.indexOf(p) !== -1 && (m.push(o), g = o._isAnimated || g);
                    m.length > 1 && g && this.setShapesAsAnimated(m)
                }
            }, SVGShapeElement.prototype.setShapesAsAnimated = function(l) {
                var i, o = l.length;
                for (i = 0; i < o; i += 1) l[i].setAsAnimated()
            }, SVGShapeElement.prototype.createStyleElement = function(l, i) {
                var o, c = new SVGStyleData(l, i),
                    u = c.pElem;
                if (l.ty === "st") o = new SVGStrokeStyleData(this, l, c);
                else if (l.ty === "fl") o = new SVGFillStyleData(this, l, c);
                else if (l.ty === "gf" || l.ty === "gs") {
                    var p = l.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
                    o = new p(this, l, c), this.globalData.defs.appendChild(o.gf), o.maskId && (this.globalData.defs.appendChild(o.ms), this.globalData.defs.appendChild(o.of), u.setAttribute("mask", "url(" + getLocationHref() + "#" + o.maskId + ")"))
                } else l.ty === "no" && (o = new SVGNoStyleData(this, l, c));
                return (l.ty === "st" || l.ty === "gs") && (u.setAttribute("stroke-linecap", lineCapEnum[l.lc || 2]), u.setAttribute("stroke-linejoin", lineJoinEnum[l.lj || 2]), u.setAttribute("fill-opacity", "0"), l.lj === 1 && u.setAttribute("stroke-miterlimit", l.ml)), l.r === 2 && u.setAttribute("fill-rule", "evenodd"), l.ln && u.setAttribute("id", l.ln), l.cl && u.setAttribute("class", l.cl), l.bm && (u.style["mix-blend-mode"] = getBlendMode(l.bm)), this.stylesList.push(c), this.addToAnimatedContents(l, o), o
            }, SVGShapeElement.prototype.createGroupElement = function(l) {
                var i = new ShapeGroupData;
                return l.ln && i.gr.setAttribute("id", l.ln), l.cl && i.gr.setAttribute("class", l.cl), l.bm && (i.gr.style["mix-blend-mode"] = getBlendMode(l.bm)), i
            }, SVGShapeElement.prototype.createTransformElement = function(l, i) {
                var o = TransformPropertyFactory.getTransformProperty(this, l, this),
                    c = new SVGTransformData(o, o.o, i);
                return this.addToAnimatedContents(l, c), c
            }, SVGShapeElement.prototype.createShapeElement = function(l, i, o) {
                var c = 4;
                l.ty === "rc" ? c = 5 : l.ty === "el" ? c = 6 : l.ty === "sr" && (c = 7);
                var u = ShapePropertyFactory.getShapeProp(this, l, c, this),
                    p = new SVGShapeData(i, o, u);
                return this.shapes.push(p), this.addShapeToModifiers(p), this.addToAnimatedContents(l, p), p
            }, SVGShapeElement.prototype.addToAnimatedContents = function(l, i) {
                for (var o = 0, c = this.animatedContents.length; o < c;) {
                    if (this.animatedContents[o].element === i) return;
                    o += 1
                }
                this.animatedContents.push({
                    fn: SVGElementsRenderer.createRenderFunction(l),
                    element: i,
                    data: l
                })
            }, SVGShapeElement.prototype.setElementStyles = function(l) {
                var i = l.styles,
                    o, c = this.stylesList.length;
                for (o = 0; o < c; o += 1) i.indexOf(this.stylesList[o]) === -1 && !this.stylesList[o].closed && i.push(this.stylesList[o])
            }, SVGShapeElement.prototype.reloadShapes = function() {
                this._isFirstFrame = !0;
                var l, i = this.itemsData.length;
                for (l = 0; l < i; l += 1) this.prevViewData[l] = this.itemsData[l];
                for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), i = this.dynamicProperties.length, l = 0; l < i; l += 1) this.dynamicProperties[l].getValue();
                this.renderModifiers()
            }, SVGShapeElement.prototype.searchShapes = function(l, i, o, c, u, p, m) {
                var g = [].concat(p),
                    _, v = l.length - 1,
                    x, y, b = [],
                    S = [],
                    C, E, P;
                for (_ = v; _ >= 0; _ -= 1) {
                    if (P = this.searchProcessedElement(l[_]), P ? i[_] = o[P - 1] : l[_]._render = m, l[_].ty === "fl" || l[_].ty === "st" || l[_].ty === "gf" || l[_].ty === "gs" || l[_].ty === "no") P ? i[_].style.closed = l[_].hd : i[_] = this.createStyleElement(l[_], u), l[_]._render && i[_].style.pElem.parentNode !== c && c.appendChild(i[_].style.pElem), b.push(i[_].style);
                    else if (l[_].ty === "gr") {
                        if (!P) i[_] = this.createGroupElement(l[_]);
                        else
                            for (y = i[_].it.length, x = 0; x < y; x += 1) i[_].prevViewData[x] = i[_].it[x];
                        this.searchShapes(l[_].it, i[_].it, i[_].prevViewData, i[_].gr, u + 1, g, m), l[_]._render && i[_].gr.parentNode !== c && c.appendChild(i[_].gr)
                    } else l[_].ty === "tr" ? (P || (i[_] = this.createTransformElement(l[_], c)), C = i[_].transform, g.push(C)) : l[_].ty === "sh" || l[_].ty === "rc" || l[_].ty === "el" || l[_].ty === "sr" ? (P || (i[_] = this.createShapeElement(l[_], g, u)), this.setElementStyles(i[_])) : l[_].ty === "tm" || l[_].ty === "rd" || l[_].ty === "ms" || l[_].ty === "pb" || l[_].ty === "zz" || l[_].ty === "op" ? (P ? (E = i[_], E.closed = !1) : (E = ShapeModifiers.getModifier(l[_].ty), E.init(this, l[_]), i[_] = E, this.shapeModifiers.push(E)), S.push(E)) : l[_].ty === "rp" && (P ? (E = i[_], E.closed = !0) : (E = ShapeModifiers.getModifier(l[_].ty), i[_] = E, E.init(this, l, _, i), this.shapeModifiers.push(E), m = !1), S.push(E));
                    this.addProcessedElement(l[_], _ + 1)
                }
                for (v = b.length, _ = 0; _ < v; _ += 1) b[_].closed = !0;
                for (v = S.length, _ = 0; _ < v; _ += 1) S[_].closed = !0
            }, SVGShapeElement.prototype.renderInnerContent = function() {
                this.renderModifiers();
                var l, i = this.stylesList.length;
                for (l = 0; l < i; l += 1) this.stylesList[l].reset();
                for (this.renderShape(), l = 0; l < i; l += 1)(this.stylesList[l]._mdf || this._isFirstFrame) && (this.stylesList[l].msElem && (this.stylesList[l].msElem.setAttribute("d", this.stylesList[l].d), this.stylesList[l].d = "M0 0" + this.stylesList[l].d), this.stylesList[l].pElem.setAttribute("d", this.stylesList[l].d || "M0 0"))
            }, SVGShapeElement.prototype.renderShape = function() {
                var l, i = this.animatedContents.length,
                    o;
                for (l = 0; l < i; l += 1) o = this.animatedContents[l], (this._isFirstFrame || o.element._isAnimated) && o.data !== !0 && o.fn(o.data, o.element, this._isFirstFrame)
            }, SVGShapeElement.prototype.destroy = function() {
                this.destroyBaseElement(), this.shapesData = null, this.itemsData = null
            };

            function LetterProps(l, i, o, c, u, p) {
                this.o = l, this.sw = i, this.sc = o, this.fc = c, this.m = u, this.p = p, this._mdf = {
                    o: !0,
                    sw: !!i,
                    sc: !!o,
                    fc: !!c,
                    m: !0,
                    p: !0
                }
            }
            LetterProps.prototype.update = function(l, i, o, c, u, p) {
                this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
                var m = !1;
                return this.o !== l && (this.o = l, this._mdf.o = !0, m = !0), this.sw !== i && (this.sw = i, this._mdf.sw = !0, m = !0), this.sc !== o && (this.sc = o, this._mdf.sc = !0, m = !0), this.fc !== c && (this.fc = c, this._mdf.fc = !0, m = !0), this.m !== u && (this.m = u, this._mdf.m = !0, m = !0), p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13]) && (this.p = p, this._mdf.p = !0, m = !0), m
            };

            function TextProperty(l, i) {
                this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, i.d && i.d.sid && (i.d = l.globalData.slotManager.getProp(i.d)), this.data = i, this.elem = l, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
                    ascent: 0,
                    boxWidth: this.defaultBoxWidth,
                    f: "",
                    fStyle: "",
                    fWeight: "",
                    fc: "",
                    j: "",
                    justifyOffset: "",
                    l: [],
                    lh: 0,
                    lineWidths: [],
                    ls: "",
                    of: "",
                    s: "",
                    sc: "",
                    sw: 0,
                    t: 0,
                    tr: 0,
                    sz: 0,
                    ps: null,
                    fillColorAnim: !1,
                    strokeColorAnim: !1,
                    strokeWidthAnim: !1,
                    yOffset: 0,
                    finalSize: 0,
                    finalText: [],
                    finalLineHeight: 0,
                    __complete: !1
                }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData)
            }
            TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function(l, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (l[o] = i[o]);
                return l
            }, TextProperty.prototype.setCurrentData = function(l) {
                l.__complete || this.completeTextData(l), this.currentData = l, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0
            }, TextProperty.prototype.searchProperty = function() {
                return this.searchKeyframes()
            }, TextProperty.prototype.searchKeyframes = function() {
                return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf
            }, TextProperty.prototype.addEffect = function(l) {
                this.effectsSequence.push(l), this.elem.addDynamicProperty(this)
            }, TextProperty.prototype.getValue = function(l) {
                if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !l)) {
                    this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                    var i = this.currentData,
                        o = this.keysIndex;
                    if (this.lock) {
                        this.setCurrentData(this.currentData);
                        return
                    }
                    this.lock = !0, this._mdf = !1;
                    var c, u = this.effectsSequence.length,
                        p = l || this.data.d.k[this.keysIndex].s;
                    for (c = 0; c < u; c += 1) o !== this.keysIndex ? p = this.effectsSequence[c](p, p.t) : p = this.effectsSequence[c](this.currentData, p.t);
                    i !== p && this.setCurrentData(p), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId
                }
            }, TextProperty.prototype.getKeyframeValue = function() {
                for (var l = this.data.d.k, i = this.elem.comp.renderedFrame, o = 0, c = l.length; o <= c - 1 && !(o === c - 1 || l[o + 1].t > i);) o += 1;
                return this.keysIndex !== o && (this.keysIndex = o), this.data.d.k[this.keysIndex].s
            }, TextProperty.prototype.buildFinalText = function(l) {
                for (var i = [], o = 0, c = l.length, u, p, m = !1, g = !1, _ = ""; o < c;) m = g, g = !1, u = l.charCodeAt(o), _ = l.charAt(o), FontManager.isCombinedCharacter(u) ? m = !0 : u >= 55296 && u <= 56319 ? FontManager.isRegionalFlag(l, o) ? _ = l.substr(o, 14) : (p = l.charCodeAt(o + 1), p >= 56320 && p <= 57343 && (FontManager.isModifier(u, p) ? (_ = l.substr(o, 2), m = !0) : FontManager.isFlagEmoji(l.substr(o, 4)) ? _ = l.substr(o, 4) : _ = l.substr(o, 2))) : u > 56319 ? (p = l.charCodeAt(o + 1), FontManager.isVariationSelector(u) && (m = !0)) : FontManager.isZeroWidthJoiner(u) && (m = !0, g = !0), m ? (i[i.length - 1] += _, m = !1) : i.push(_), o += _.length;
                return i
            }, TextProperty.prototype.completeTextData = function(l) {
                l.__complete = !0;
                var i = this.elem.globalData.fontManager,
                    o = this.data,
                    c = [],
                    u, p, m, g = 0,
                    _, v = o.m.g,
                    x = 0,
                    y = 0,
                    b = 0,
                    S = [],
                    C = 0,
                    E = 0,
                    P, w, T = i.getFontByName(l.f),
                    M, A = 0,
                    D = getFontProperties(T);
                l.fWeight = D.weight, l.fStyle = D.style, l.finalSize = l.s, l.finalText = this.buildFinalText(l.t), p = l.finalText.length, l.finalLineHeight = l.lh;
                var R = l.tr / 1e3 * l.finalSize,
                    I;
                if (l.sz)
                    for (var k = !0, F = l.sz[0], V = l.sz[1], B, U; k;) {
                        U = this.buildFinalText(l.t), B = 0, C = 0, p = U.length, R = l.tr / 1e3 * l.finalSize;
                        var H = -1;
                        for (u = 0; u < p; u += 1) I = U[u].charCodeAt(0), m = !1, U[u] === " " ? H = u : (I === 13 || I === 3) && (C = 0, m = !0, B += l.finalLineHeight || l.finalSize * 1.2), i.chars ? (M = i.getCharData(U[u], T.fStyle, T.fFamily), A = m ? 0 : M.w * l.finalSize / 100) : A = i.measureText(U[u], l.f, l.finalSize), C + A > F && U[u] !== " " ? (H === -1 ? p += 1 : u = H, B += l.finalLineHeight || l.finalSize * 1.2, U.splice(u, H === u ? 1 : 0, "\r"), H = -1, C = 0) : (C += A, C += R);
                        B += T.ascent * l.finalSize / 100, this.canResize && l.finalSize > this.minimumFontSize && V < B ? (l.finalSize -= 1, l.finalLineHeight = l.finalSize * l.lh / l.s) : (l.finalText = U, p = l.finalText.length, k = !1)
                    }
                C = -R, A = 0;
                var Q = 0,
                    Y;
                for (u = 0; u < p; u += 1)
                    if (m = !1, Y = l.finalText[u], I = Y.charCodeAt(0), I === 13 || I === 3 ? (Q = 0, S.push(C), E = C > E ? C : E, C = -2 * R, _ = "", m = !0, b += 1) : _ = Y, i.chars ? (M = i.getCharData(Y, T.fStyle, i.getFontByName(l.f).fFamily), A = m ? 0 : M.w * l.finalSize / 100) : A = i.measureText(_, l.f, l.finalSize), Y === " " ? Q += A + R : (C += A + R + Q, Q = 0), c.push({
                            l: A,
                            an: A,
                            add: x,
                            n: m,
                            anIndexes: [],
                            val: _,
                            line: b,
                            animatorJustifyOffset: 0
                        }), v == 2) {
                        if (x += A, _ === "" || _ === " " || u === p - 1) {
                            for ((_ === "" || _ === " ") && (x -= A); y <= u;) c[y].an = x, c[y].ind = g, c[y].extra = A, y += 1;
                            g += 1, x = 0
                        }
                    } else if (v == 3) {
                    if (x += A, _ === "" || u === p - 1) {
                        for (_ === "" && (x -= A); y <= u;) c[y].an = x, c[y].ind = g, c[y].extra = A, y += 1;
                        x = 0, g += 1
                    }
                } else c[g].ind = g, c[g].extra = 0, g += 1;
                if (l.l = c, E = C > E ? C : E, S.push(C), l.sz) l.boxWidth = l.sz[0], l.justifyOffset = 0;
                else switch (l.boxWidth = E, l.j) {
                    case 1:
                        l.justifyOffset = -l.boxWidth;
                        break;
                    case 2:
                        l.justifyOffset = -l.boxWidth / 2;
                        break;
                    default:
                        l.justifyOffset = 0
                }
                l.lineWidths = S;
                var O = o.a,
                    G, L;
                w = O.length;
                var N, K, Z = [];
                for (P = 0; P < w; P += 1) {
                    for (G = O[P], G.a.sc && (l.strokeColorAnim = !0), G.a.sw && (l.strokeWidthAnim = !0), (G.a.fc || G.a.fh || G.a.fs || G.a.fb) && (l.fillColorAnim = !0), K = 0, N = G.s.b, u = 0; u < p; u += 1) L = c[u], L.anIndexes[P] = K, (N == 1 && L.val !== "" || N == 2 && L.val !== "" && L.val !== " " || N == 3 && (L.n || L.val == " " || u == p - 1) || N == 4 && (L.n || u == p - 1)) && (G.s.rn === 1 && Z.push(K), K += 1);
                    o.a[P].s.totalChars = K;
                    var he = -1,
                        we;
                    if (G.s.rn === 1)
                        for (u = 0; u < p; u += 1) L = c[u], he != L.anIndexes[P] && (he = L.anIndexes[P], we = Z.splice(Math.floor(Math.random() * Z.length), 1)[0]), L.anIndexes[P] = we
                }
                l.yOffset = l.finalLineHeight || l.finalSize * 1.2, l.ls = l.ls || 0, l.ascent = T.ascent * l.finalSize / 100
            }, TextProperty.prototype.updateDocumentData = function(l, i) {
                i = i === void 0 ? this.keysIndex : i;
                var o = this.copyData({}, this.data.d.k[i].s);
                o = this.copyData(o, l), this.data.d.k[i].s = o, this.recalculate(i), this.setCurrentData(o), this.elem.addDynamicProperty(this)
            }, TextProperty.prototype.recalculate = function(l) {
                var i = this.data.d.k[l].s;
                i.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(i)
            }, TextProperty.prototype.canResizeFont = function(l) {
                this.canResize = l, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
            }, TextProperty.prototype.setMinimumFontSize = function(l) {
                this.minimumFontSize = Math.floor(l) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
            };
            var TextSelectorProp = function() {
                var l = Math.max,
                    i = Math.min,
                    o = Math.floor;

                function c(p, m) {
                    this._currentTextLength = -1, this.k = !1, this.data = m, this.elem = p, this.comp = p.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(p), this.s = PropertyFactory.getProp(p, m.s || {
                        k: 0
                    }, 0, 0, this), "e" in m ? this.e = PropertyFactory.getProp(p, m.e, 0, 0, this) : this.e = {
                        v: 100
                    }, this.o = PropertyFactory.getProp(p, m.o || {
                        k: 0
                    }, 0, 0, this), this.xe = PropertyFactory.getProp(p, m.xe || {
                        k: 0
                    }, 0, 0, this), this.ne = PropertyFactory.getProp(p, m.ne || {
                        k: 0
                    }, 0, 0, this), this.sm = PropertyFactory.getProp(p, m.sm || {
                        k: 100
                    }, 0, 0, this), this.a = PropertyFactory.getProp(p, m.a, 0, .01, this), this.dynamicProperties.length || this.getValue()
                }
                c.prototype = {
                    getMult: function(m) {
                        this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                        var g = 0,
                            _ = 0,
                            v = 1,
                            x = 1;
                        this.ne.v > 0 ? g = this.ne.v / 100 : _ = -this.ne.v / 100, this.xe.v > 0 ? v = 1 - this.xe.v / 100 : x = 1 + this.xe.v / 100;
                        var y = BezierFactory.getBezierEasing(g, _, v, x).get,
                            b = 0,
                            S = this.finalS,
                            C = this.finalE,
                            E = this.data.sh;
                        if (E === 2) C === S ? b = m >= C ? 1 : 0 : b = l(0, i(.5 / (C - S) + (m - S) / (C - S), 1)), b = y(b);
                        else if (E === 3) C === S ? b = m >= C ? 0 : 1 : b = 1 - l(0, i(.5 / (C - S) + (m - S) / (C - S), 1)), b = y(b);
                        else if (E === 4) C === S ? b = 0 : (b = l(0, i(.5 / (C - S) + (m - S) / (C - S), 1)), b < .5 ? b *= 2 : b = 1 - 2 * (b - .5)), b = y(b);
                        else if (E === 5) {
                            if (C === S) b = 0;
                            else {
                                var P = C - S;
                                m = i(l(0, m + .5 - S), C - S);
                                var w = -P / 2 + m,
                                    T = P / 2;
                                b = Math.sqrt(1 - w * w / (T * T))
                            }
                            b = y(b)
                        } else E === 6 ? (C === S ? b = 0 : (m = i(l(0, m + .5 - S), C - S), b = (1 + Math.cos(Math.PI + Math.PI * 2 * m / (C - S))) / 2), b = y(b)) : (m >= o(S) && (m - S < 0 ? b = l(0, i(i(C, 1) - (S - m), 1)) : b = l(0, i(C - m, 1))), b = y(b));
                        if (this.sm.v !== 100) {
                            var M = this.sm.v * .01;
                            M === 0 && (M = 1e-8);
                            var A = .5 - M * .5;
                            b < A ? b = 0 : (b = (b - A) / M, b > 1 && (b = 1))
                        }
                        return b * this.a.v
                    },
                    getValue: function(m) {
                        this.iterateDynamicProperties(), this._mdf = m || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, m && this.data.r === 2 && (this.e.v = this._currentTextLength);
                        var g = this.data.r === 2 ? 1 : 100 / this.data.totalChars,
                            _ = this.o.v / g,
                            v = this.s.v / g + _,
                            x = this.e.v / g + _;
                        if (v > x) {
                            var y = v;
                            v = x, x = y
                        }
                        this.finalS = v, this.finalE = x
                    }
                }, extendPrototype([DynamicPropertyContainer], c);

                function u(p, m, g) {
                    return new c(p, m)
                }
                return {
                    getTextSelectorProp: u
                }
            }();

            function TextAnimatorDataProperty(l, i, o) {
                var c = {
                        propType: !1
                    },
                    u = PropertyFactory.getProp,
                    p = i.a;
                this.a = {
                    r: p.r ? u(l, p.r, 0, degToRads, o) : c,
                    rx: p.rx ? u(l, p.rx, 0, degToRads, o) : c,
                    ry: p.ry ? u(l, p.ry, 0, degToRads, o) : c,
                    sk: p.sk ? u(l, p.sk, 0, degToRads, o) : c,
                    sa: p.sa ? u(l, p.sa, 0, degToRads, o) : c,
                    s: p.s ? u(l, p.s, 1, .01, o) : c,
                    a: p.a ? u(l, p.a, 1, 0, o) : c,
                    o: p.o ? u(l, p.o, 0, .01, o) : c,
                    p: p.p ? u(l, p.p, 1, 0, o) : c,
                    sw: p.sw ? u(l, p.sw, 0, 0, o) : c,
                    sc: p.sc ? u(l, p.sc, 1, 0, o) : c,
                    fc: p.fc ? u(l, p.fc, 1, 0, o) : c,
                    fh: p.fh ? u(l, p.fh, 0, 0, o) : c,
                    fs: p.fs ? u(l, p.fs, 0, .01, o) : c,
                    fb: p.fb ? u(l, p.fb, 0, .01, o) : c,
                    t: p.t ? u(l, p.t, 0, 0, o) : c
                }, this.s = TextSelectorProp.getTextSelectorProp(l, i.s, o), this.s.t = i.s.t
            }

            function TextAnimatorProperty(l, i, o) {
                this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = l, this._renderType = i, this._elem = o, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
                    alignment: {}
                }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(o)
            }
            TextAnimatorProperty.prototype.searchProperties = function() {
                var l, i = this._textData.a.length,
                    o, c = PropertyFactory.getProp;
                for (l = 0; l < i; l += 1) o = this._textData.a[l], this._animatorsData[l] = new TextAnimatorDataProperty(this._elem, o, this);
                this._textData.p && "m" in this._textData.p ? (this._pathData = {
                    a: c(this._elem, this._textData.p.a, 0, 0, this),
                    f: c(this._elem, this._textData.p.f, 0, 0, this),
                    l: c(this._elem, this._textData.p.l, 0, 0, this),
                    r: c(this._elem, this._textData.p.r, 0, 0, this),
                    p: c(this._elem, this._textData.p.p, 0, 0, this),
                    m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
                }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = c(this._elem, this._textData.m.a, 1, 0, this)
            }, TextAnimatorProperty.prototype.getMeasures = function(l, i) {
                if (this.lettersChangedFlag = i, !(!this._mdf && !this._isFirstFrame && !i && (!this._hasMaskedPath || !this._pathData.m._mdf))) {
                    this._isFirstFrame = !1;
                    var o = this._moreOptions.alignment.v,
                        c = this._animatorsData,
                        u = this._textData,
                        p = this.mHelper,
                        m = this._renderType,
                        g = this.renderedLetters.length,
                        _, v, x, y, b = l.l,
                        S, C, E, P, w, T, M, A, D, R, I, k, F, V, B;
                    if (this._hasMaskedPath) {
                        if (B = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
                            var U = B.v;
                            this._pathData.r.v && (U = U.reverse()), S = {
                                tLength: 0,
                                segments: []
                            }, y = U._length - 1;
                            var H;
                            for (k = 0, x = 0; x < y; x += 1) H = bez.buildBezierData(U.v[x], U.v[x + 1], [U.o[x][0] - U.v[x][0], U.o[x][1] - U.v[x][1]], [U.i[x + 1][0] - U.v[x + 1][0], U.i[x + 1][1] - U.v[x + 1][1]]), S.tLength += H.segmentLength, S.segments.push(H), k += H.segmentLength;
                            x = y, B.v.c && (H = bez.buildBezierData(U.v[x], U.v[0], [U.o[x][0] - U.v[x][0], U.o[x][1] - U.v[x][1]], [U.i[0][0] - U.v[0][0], U.i[0][1] - U.v[0][1]]), S.tLength += H.segmentLength, S.segments.push(H), k += H.segmentLength), this._pathData.pi = S
                        }
                        if (S = this._pathData.pi, C = this._pathData.f.v, M = 0, T = 1, P = 0, w = !0, R = S.segments, C < 0 && B.v.c)
                            for (S.tLength < Math.abs(C) && (C = -Math.abs(C) % S.tLength), M = R.length - 1, D = R[M].points, T = D.length - 1; C < 0;) C += D[T].partialLength, T -= 1, T < 0 && (M -= 1, D = R[M].points, T = D.length - 1);
                        D = R[M].points, A = D[T - 1], E = D[T], I = E.partialLength
                    }
                    y = b.length, _ = 0, v = 0;
                    var Q = l.finalSize * 1.2 * .714,
                        Y = !0,
                        O, G, L, N, K;
                    N = c.length;
                    var Z, he = -1,
                        we, ie, _e, Te = C,
                        Me = M,
                        Pe = T,
                        be = -1,
                        Be, De, We, Re, q, At, dt, tt, ke = "",
                        ot = this.defaultPropsArray,
                        ze;
                    if (l.j === 2 || l.j === 1) {
                        var Ie = 0,
                            Dt = 0,
                            J = l.j === 2 ? -.5 : -1,
                            $ = 0,
                            ae = !0;
                        for (x = 0; x < y; x += 1)
                            if (b[x].n) {
                                for (Ie && (Ie += Dt); $ < x;) b[$].animatorJustifyOffset = Ie, $ += 1;
                                Ie = 0, ae = !0
                            } else {
                                for (L = 0; L < N; L += 1) O = c[L].a, O.t.propType && (ae && l.j === 2 && (Dt += O.t.v * J), G = c[L].s, Z = G.getMult(b[x].anIndexes[L], u.a[L].s.totalChars), Z.length ? Ie += O.t.v * Z[0] * J : Ie += O.t.v * Z * J);
                                ae = !1
                            }
                        for (Ie && (Ie += Dt); $ < x;) b[$].animatorJustifyOffset = Ie, $ += 1
                    }
                    for (x = 0; x < y; x += 1) {
                        if (p.reset(), Be = 1, b[x].n) _ = 0, v += l.yOffset, v += Y ? 1 : 0, C = Te, Y = !1, this._hasMaskedPath && (M = Me, T = Pe, D = R[M].points, A = D[T - 1], E = D[T], I = E.partialLength, P = 0), ke = "", tt = "", At = "", ze = "", ot = this.defaultPropsArray;
                        else {
                            if (this._hasMaskedPath) {
                                if (be !== b[x].line) {
                                    switch (l.j) {
                                        case 1:
                                            C += k - l.lineWidths[b[x].line];
                                            break;
                                        case 2:
                                            C += (k - l.lineWidths[b[x].line]) / 2;
                                            break
                                    }
                                    be = b[x].line
                                }
                                he !== b[x].ind && (b[he] && (C += b[he].extra), C += b[x].an / 2, he = b[x].ind), C += o[0] * b[x].an * .005;
                                var ge = 0;
                                for (L = 0; L < N; L += 1) O = c[L].a, O.p.propType && (G = c[L].s, Z = G.getMult(b[x].anIndexes[L], u.a[L].s.totalChars), Z.length ? ge += O.p.v[0] * Z[0] : ge += O.p.v[0] * Z), O.a.propType && (G = c[L].s, Z = G.getMult(b[x].anIndexes[L], u.a[L].s.totalChars), Z.length ? ge += O.a.v[0] * Z[0] : ge += O.a.v[0] * Z);
                                for (w = !0, this._pathData.a.v && (C = b[0].an * .5 + (k - this._pathData.f.v - b[0].an * .5 - b[b.length - 1].an * .5) * he / (y - 1), C += this._pathData.f.v); w;) P + I >= C + ge || !D ? (F = (C + ge - P) / E.partialLength, ie = A.point[0] + (E.point[0] - A.point[0]) * F, _e = A.point[1] + (E.point[1] - A.point[1]) * F, p.translate(-o[0] * b[x].an * .005, -(o[1] * Q) * .01), w = !1) : D && (P += E.partialLength, T += 1, T >= D.length && (T = 0, M += 1, R[M] ? D = R[M].points : B.v.c ? (T = 0, M = 0, D = R[M].points) : (P -= E.partialLength, D = null)), D && (A = E, E = D[T], I = E.partialLength));
                                we = b[x].an / 2 - b[x].add, p.translate(-we, 0, 0)
                            } else we = b[x].an / 2 - b[x].add, p.translate(-we, 0, 0), p.translate(-o[0] * b[x].an * .005, -o[1] * Q * .01, 0);
                            for (L = 0; L < N; L += 1) O = c[L].a, O.t.propType && (G = c[L].s, Z = G.getMult(b[x].anIndexes[L], u.a[L].s.totalChars), (_ !== 0 || l.j !== 0) && (this._hasMaskedPath ? Z.length ? C += O.t.v * Z[0] : C += O.t.v * Z : Z.length ? _ += O.t.v * Z[0] : _ += O.t.v * Z));
                            for (l.strokeWidthAnim && (We = l.sw || 0), l.strokeColorAnim && (l.sc ? De = [l.sc[0], l.sc[1], l.sc[2]] : De = [0, 0, 0]), l.fillColorAnim && l.fc && (Re = [l.fc[0], l.fc[1], l.fc[2]]), L = 0; L < N; L += 1) O = c[L].a, O.a.propType && (G = c[L].s, Z = G.getMult(b[x].anIndexes[L], u.a[L].s.totalChars), Z.length ? p.translate(-O.a.v[0] * Z[0], -O.a.v[1] * Z[1], O.a.v[2] * Z[2]) : p.translate(-O.a.v[0] * Z, -O.a.v[1] * Z, O.a.v[2] * Z));
                            for (L = 0; L < N; L += 1) O = c[L].a, O.s.propType && (G = c[L].s, Z = G.getMult(b[x].anIndexes[L], u.a[L].s.totalChars), Z.length ? p.scale(1 + (O.s.v[0] - 1) * Z[0], 1 + (O.s.v[1] - 1) * Z[1], 1) : p.scale(1 + (O.s.v[0] - 1) * Z, 1 + (O.s.v[1] - 1) * Z, 1));
                            for (L = 0; L < N; L += 1) {
                                if (O = c[L].a, G = c[L].s, Z = G.getMult(b[x].anIndexes[L], u.a[L].s.totalChars), O.sk.propType && (Z.length ? p.skewFromAxis(-O.sk.v * Z[0], O.sa.v * Z[1]) : p.skewFromAxis(-O.sk.v * Z, O.sa.v * Z)), O.r.propType && (Z.length ? p.rotateZ(-O.r.v * Z[2]) : p.rotateZ(-O.r.v * Z)), O.ry.propType && (Z.length ? p.rotateY(O.ry.v * Z[1]) : p.rotateY(O.ry.v * Z)), O.rx.propType && (Z.length ? p.rotateX(O.rx.v * Z[0]) : p.rotateX(O.rx.v * Z)), O.o.propType && (Z.length ? Be += (O.o.v * Z[0] - Be) * Z[0] : Be += (O.o.v * Z - Be) * Z), l.strokeWidthAnim && O.sw.propType && (Z.length ? We += O.sw.v * Z[0] : We += O.sw.v * Z), l.strokeColorAnim && O.sc.propType)
                                    for (q = 0; q < 3; q += 1) Z.length ? De[q] += (O.sc.v[q] - De[q]) * Z[0] : De[q] += (O.sc.v[q] - De[q]) * Z;
                                if (l.fillColorAnim && l.fc) {
                                    if (O.fc.propType)
                                        for (q = 0; q < 3; q += 1) Z.length ? Re[q] += (O.fc.v[q] - Re[q]) * Z[0] : Re[q] += (O.fc.v[q] - Re[q]) * Z;
                                    O.fh.propType && (Z.length ? Re = addHueToRGB(Re, O.fh.v * Z[0]) : Re = addHueToRGB(Re, O.fh.v * Z)), O.fs.propType && (Z.length ? Re = addSaturationToRGB(Re, O.fs.v * Z[0]) : Re = addSaturationToRGB(Re, O.fs.v * Z)), O.fb.propType && (Z.length ? Re = addBrightnessToRGB(Re, O.fb.v * Z[0]) : Re = addBrightnessToRGB(Re, O.fb.v * Z))
                                }
                            }
                            for (L = 0; L < N; L += 1) O = c[L].a, O.p.propType && (G = c[L].s, Z = G.getMult(b[x].anIndexes[L], u.a[L].s.totalChars), this._hasMaskedPath ? Z.length ? p.translate(0, O.p.v[1] * Z[0], -O.p.v[2] * Z[1]) : p.translate(0, O.p.v[1] * Z, -O.p.v[2] * Z) : Z.length ? p.translate(O.p.v[0] * Z[0], O.p.v[1] * Z[1], -O.p.v[2] * Z[2]) : p.translate(O.p.v[0] * Z, O.p.v[1] * Z, -O.p.v[2] * Z));
                            if (l.strokeWidthAnim && (At = We < 0 ? 0 : We), l.strokeColorAnim && (dt = "rgb(" + Math.round(De[0] * 255) + "," + Math.round(De[1] * 255) + "," + Math.round(De[2] * 255) + ")"), l.fillColorAnim && l.fc && (tt = "rgb(" + Math.round(Re[0] * 255) + "," + Math.round(Re[1] * 255) + "," + Math.round(Re[2] * 255) + ")"), this._hasMaskedPath) {
                                if (p.translate(0, -l.ls), p.translate(0, o[1] * Q * .01 + v, 0), this._pathData.p.v) {
                                    V = (E.point[1] - A.point[1]) / (E.point[0] - A.point[0]);
                                    var ye = Math.atan(V) * 180 / Math.PI;
                                    E.point[0] < A.point[0] && (ye += 180), p.rotate(-ye * Math.PI / 180)
                                }
                                p.translate(ie, _e, 0), C -= o[0] * b[x].an * .005, b[x + 1] && he !== b[x + 1].ind && (C += b[x].an / 2, C += l.tr * .001 * l.finalSize)
                            } else {
                                switch (p.translate(_, v, 0), l.ps && p.translate(l.ps[0], l.ps[1] + l.ascent, 0), l.j) {
                                    case 1:
                                        p.translate(b[x].animatorJustifyOffset + l.justifyOffset + (l.boxWidth - l.lineWidths[b[x].line]), 0, 0);
                                        break;
                                    case 2:
                                        p.translate(b[x].animatorJustifyOffset + l.justifyOffset + (l.boxWidth - l.lineWidths[b[x].line]) / 2, 0, 0);
                                        break
                                }
                                p.translate(0, -l.ls), p.translate(we, 0, 0), p.translate(o[0] * b[x].an * .005, o[1] * Q * .01, 0), _ += b[x].l + l.tr * .001 * l.finalSize
                            }
                            m === "html" ? ke = p.toCSS() : m === "svg" ? ke = p.to2dCSS() : ot = [p.props[0], p.props[1], p.props[2], p.props[3], p.props[4], p.props[5], p.props[6], p.props[7], p.props[8], p.props[9], p.props[10], p.props[11], p.props[12], p.props[13], p.props[14], p.props[15]], ze = Be
                        }
                        g <= x ? (K = new LetterProps(ze, At, dt, tt, ke, ot), this.renderedLetters.push(K), g += 1, this.lettersChangedFlag = !0) : (K = this.renderedLetters[x], this.lettersChangedFlag = K.update(ze, At, dt, tt, ke, ot) || this.lettersChangedFlag)
                    }
                }
            }, TextAnimatorProperty.prototype.getValue = function() {
                this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties())
            }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

            function ITextElement() {}
            ITextElement.prototype.initElement = function(l, i, o) {
                this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(l, i, o), this.textProperty = new TextProperty(this, l.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(l.t, this.renderType, this), this.initTransform(l, i, o), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties)
            }, ITextElement.prototype.prepareFrame = function(l) {
                this._mdf = !1, this.prepareRenderableFrame(l), this.prepareProperties(l, this.isInRange)
            }, ITextElement.prototype.createPathShape = function(l, i) {
                var o, c = i.length,
                    u, p = "";
                for (o = 0; o < c; o += 1) i[o].ty === "sh" && (u = i[o].ks.k, p += buildShapeString(u, u.i.length, !0, l));
                return p
            }, ITextElement.prototype.updateDocumentData = function(l, i) {
                this.textProperty.updateDocumentData(l, i)
            }, ITextElement.prototype.canResizeFont = function(l) {
                this.textProperty.canResizeFont(l)
            }, ITextElement.prototype.setMinimumFontSize = function(l) {
                this.textProperty.setMinimumFontSize(l)
            }, ITextElement.prototype.applyTextPropertiesToMatrix = function(l, i, o, c, u) {
                switch (l.ps && i.translate(l.ps[0], l.ps[1] + l.ascent, 0), i.translate(0, -l.ls, 0), l.j) {
                    case 1:
                        i.translate(l.justifyOffset + (l.boxWidth - l.lineWidths[o]), 0, 0);
                        break;
                    case 2:
                        i.translate(l.justifyOffset + (l.boxWidth - l.lineWidths[o]) / 2, 0, 0);
                        break
                }
                i.translate(c, u, 0)
            }, ITextElement.prototype.buildColor = function(l) {
                return "rgb(" + Math.round(l[0] * 255) + "," + Math.round(l[1] * 255) + "," + Math.round(l[2] * 255) + ")"
            }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function() {}, ITextElement.prototype.validateText = function() {
                (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1)
            };
            var emptyShapeData = {
                shapes: []
            };

            function SVGTextLottieElement(l, i, o) {
                this.textSpans = [], this.renderType = "svg", this.initElement(l, i, o)
            }
            extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function() {
                this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
            }, SVGTextLottieElement.prototype.buildTextContents = function(l) {
                for (var i = 0, o = l.length, c = [], u = ""; i < o;) l[i] === "\r" || l[i] === "" ? (c.push(u), u = "") : u += l[i], i += 1;
                return c.push(u), c
            }, SVGTextLottieElement.prototype.buildShapeData = function(l, i) {
                if (l.shapes && l.shapes.length) {
                    var o = l.shapes[0];
                    if (o.it) {
                        var c = o.it[o.it.length - 1];
                        c.s && (c.s.k[0] = i, c.s.k[1] = i)
                    }
                }
                return l
            }, SVGTextLottieElement.prototype.buildNewText = function() {
                this.addDynamicProperty(this);
                var l, i, o = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(o ? o.l.length : 0), o.fc ? this.layerElement.setAttribute("fill", this.buildColor(o.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), o.sc && (this.layerElement.setAttribute("stroke", this.buildColor(o.sc)), this.layerElement.setAttribute("stroke-width", o.sw)), this.layerElement.setAttribute("font-size", o.finalSize);
                var c = this.globalData.fontManager.getFontByName(o.f);
                if (c.fClass) this.layerElement.setAttribute("class", c.fClass);
                else {
                    this.layerElement.setAttribute("font-family", c.fFamily);
                    var u = o.fWeight,
                        p = o.fStyle;
                    this.layerElement.setAttribute("font-style", p), this.layerElement.setAttribute("font-weight", u)
                }
                this.layerElement.setAttribute("aria-label", o.t);
                var m = o.l || [],
                    g = !!this.globalData.fontManager.chars;
                i = m.length;
                var _, v = this.mHelper,
                    x = "",
                    y = this.data.singleShape,
                    b = 0,
                    S = 0,
                    C = !0,
                    E = o.tr * .001 * o.finalSize;
                if (y && !g && !o.sz) {
                    var P = this.textContainer,
                        w = "start";
                    switch (o.j) {
                        case 1:
                            w = "end";
                            break;
                        case 2:
                            w = "middle";
                            break;
                        default:
                            w = "start";
                            break
                    }
                    P.setAttribute("text-anchor", w), P.setAttribute("letter-spacing", E);
                    var T = this.buildTextContents(o.finalText);
                    for (i = T.length, S = o.ps ? o.ps[1] + o.ascent : 0, l = 0; l < i; l += 1) _ = this.textSpans[l].span || createNS("tspan"), _.textContent = T[l], _.setAttribute("x", 0), _.setAttribute("y", S), _.style.display = "inherit", P.appendChild(_), this.textSpans[l] || (this.textSpans[l] = {
                        span: null,
                        glyph: null
                    }), this.textSpans[l].span = _, S += o.finalLineHeight;
                    this.layerElement.appendChild(P)
                } else {
                    var M = this.textSpans.length,
                        A;
                    for (l = 0; l < i; l += 1) {
                        if (this.textSpans[l] || (this.textSpans[l] = {
                                span: null,
                                childSpan: null,
                                glyph: null
                            }), !g || !y || l === 0) {
                            if (_ = M > l ? this.textSpans[l].span : createNS(g ? "g" : "text"), M <= l) {
                                if (_.setAttribute("stroke-linecap", "butt"), _.setAttribute("stroke-linejoin", "round"), _.setAttribute("stroke-miterlimit", "4"), this.textSpans[l].span = _, g) {
                                    var D = createNS("g");
                                    _.appendChild(D), this.textSpans[l].childSpan = D
                                }
                                this.textSpans[l].span = _, this.layerElement.appendChild(_)
                            }
                            _.style.display = "inherit"
                        }
                        if (v.reset(), y && (m[l].n && (b = -E, S += o.yOffset, S += C ? 1 : 0, C = !1), this.applyTextPropertiesToMatrix(o, v, m[l].line, b, S), b += m[l].l || 0, b += E), g) {
                            A = this.globalData.fontManager.getCharData(o.finalText[l], c.fStyle, this.globalData.fontManager.getFontByName(o.f).fFamily);
                            var R;
                            if (A.t === 1) R = new SVGCompElement(A.data, this.globalData, this);
                            else {
                                var I = emptyShapeData;
                                A.data && A.data.shapes && (I = this.buildShapeData(A.data, o.finalSize)), R = new SVGShapeElement(I, this.globalData, this)
                            }
                            if (this.textSpans[l].glyph) {
                                var k = this.textSpans[l].glyph;
                                this.textSpans[l].childSpan.removeChild(k.layerElement), k.destroy()
                            }
                            this.textSpans[l].glyph = R, R._debug = !0, R.prepareFrame(0), R.renderFrame(), this.textSpans[l].childSpan.appendChild(R.layerElement), A.t === 1 && this.textSpans[l].childSpan.setAttribute("transform", "scale(" + o.finalSize / 100 + "," + o.finalSize / 100 + ")")
                        } else y && _.setAttribute("transform", "translate(" + v.props[12] + "," + v.props[13] + ")"), _.textContent = m[l].val, _.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve")
                    }
                    y && _ && _.setAttribute("d", x)
                }
                for (; l < this.textSpans.length;) this.textSpans[l].span.style.display = "none", l += 1;
                this._sizeChanged = !0
            }, SVGTextLottieElement.prototype.sourceRectAtTime = function() {
                if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
                    this._sizeChanged = !1;
                    var l = this.layerElement.getBBox();
                    this.bbox = {
                        top: l.y,
                        left: l.x,
                        width: l.width,
                        height: l.height
                    }
                }
                return this.bbox
            }, SVGTextLottieElement.prototype.getValue = function() {
                var l, i = this.textSpans.length,
                    o;
                for (this.renderedFrame = this.comp.renderedFrame, l = 0; l < i; l += 1) o = this.textSpans[l].glyph, o && (o.prepareFrame(this.comp.renderedFrame - this.data.st), o._mdf && (this._mdf = !0))
            }, SVGTextLottieElement.prototype.renderInnerContent = function() {
                if (this.validateText(), (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                    this._sizeChanged = !0;
                    var l, i, o = this.textAnimator.renderedLetters,
                        c = this.textProperty.currentData.l;
                    i = c.length;
                    var u, p, m;
                    for (l = 0; l < i; l += 1) c[l].n || (u = o[l], p = this.textSpans[l].span, m = this.textSpans[l].glyph, m && m.renderFrame(), u._mdf.m && p.setAttribute("transform", u.m), u._mdf.o && p.setAttribute("opacity", u.o), u._mdf.sw && p.setAttribute("stroke-width", u.sw), u._mdf.sc && p.setAttribute("stroke", u.sc), u._mdf.fc && p.setAttribute("fill", u.fc))
                }
            };

            function ISolidElement(l, i, o) {
                this.initElement(l, i, o)
            }
            extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function() {
                var l = createNS("rect");
                l.setAttribute("width", this.data.sw), l.setAttribute("height", this.data.sh), l.setAttribute("fill", this.data.sc), this.layerElement.appendChild(l)
            };

            function NullElement(l, i, o) {
                this.initFrame(), this.initBaseData(l, i, o), this.initFrame(), this.initTransform(l, i, o), this.initHierarchy()
            }
            NullElement.prototype.prepareFrame = function(l) {
                this.prepareProperties(l, !0)
            }, NullElement.prototype.renderFrame = function() {}, NullElement.prototype.getBaseElement = function() {
                return null
            }, NullElement.prototype.destroy = function() {}, NullElement.prototype.sourceRectAtTime = function() {}, NullElement.prototype.hide = function() {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

            function SVGRendererBase() {}
            extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function(l) {
                return new NullElement(l, this.globalData, this)
            }, SVGRendererBase.prototype.createShape = function(l) {
                return new SVGShapeElement(l, this.globalData, this)
            }, SVGRendererBase.prototype.createText = function(l) {
                return new SVGTextLottieElement(l, this.globalData, this)
            }, SVGRendererBase.prototype.createImage = function(l) {
                return new IImageElement(l, this.globalData, this)
            }, SVGRendererBase.prototype.createSolid = function(l) {
                return new ISolidElement(l, this.globalData, this)
            }, SVGRendererBase.prototype.configAnimation = function(l) {
                this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + l.w + " " + l.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", l.w), this.svgElement.setAttribute("height", l.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
                var i = this.globalData.defs;
                this.setupGlobalData(l, i), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = l;
                var o = createNS("clipPath"),
                    c = createNS("rect");
                c.setAttribute("width", l.w), c.setAttribute("height", l.h), c.setAttribute("x", 0), c.setAttribute("y", 0);
                var u = createElementID();
                o.setAttribute("id", u), o.appendChild(c), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + u + ")"), i.appendChild(o), this.layers = l.layers, this.elements = createSizedArray(l.layers.length)
            }, SVGRendererBase.prototype.destroy = function() {
                this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
                var l, i = this.layers ? this.layers.length : 0;
                for (l = 0; l < i; l += 1) this.elements[l] && this.elements[l].destroy && this.elements[l].destroy();
                this.elements.length = 0, this.destroyed = !0, this.animationItem = null
            }, SVGRendererBase.prototype.updateContainerSize = function() {}, SVGRendererBase.prototype.findIndexByInd = function(l) {
                var i = 0,
                    o = this.layers.length;
                for (i = 0; i < o; i += 1)
                    if (this.layers[i].ind === l) return i;
                return -1
            }, SVGRendererBase.prototype.buildItem = function(l) {
                var i = this.elements;
                if (!(i[l] || this.layers[l].ty === 99)) {
                    i[l] = !0;
                    var o = this.createItem(this.layers[l]);
                    if (i[l] = o, getExpressionsPlugin() && (this.layers[l].ty === 0 && this.globalData.projectInterface.registerComposition(o), o.initExpressions()), this.appendElementInPos(o, l), this.layers[l].tt) {
                        var c = "tp" in this.layers[l] ? this.findIndexByInd(this.layers[l].tp) : l - 1;
                        if (c === -1) return;
                        if (!this.elements[c] || this.elements[c] === !0) this.buildItem(c), this.addPendingElement(o);
                        else {
                            var u = i[c],
                                p = u.getMatte(this.layers[l].tt);
                            o.setMatte(p)
                        }
                    }
                }
            }, SVGRendererBase.prototype.checkPendingElements = function() {
                for (; this.pendingElements.length;) {
                    var l = this.pendingElements.pop();
                    if (l.checkParenting(), l.data.tt)
                        for (var i = 0, o = this.elements.length; i < o;) {
                            if (this.elements[i] === l) {
                                var c = "tp" in l.data ? this.findIndexByInd(l.data.tp) : i - 1,
                                    u = this.elements[c],
                                    p = u.getMatte(this.layers[i].tt);
                                l.setMatte(p);
                                break
                            }
                            i += 1
                        }
                }
            }, SVGRendererBase.prototype.renderFrame = function(l) {
                if (!(this.renderedFrame === l || this.destroyed)) {
                    l === null ? l = this.renderedFrame : this.renderedFrame = l, this.globalData.frameNum = l, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = l, this.globalData._mdf = !1;
                    var i, o = this.layers.length;
                    for (this.completeLayers || this.checkLayers(l), i = o - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && this.elements[i].prepareFrame(l - this.layers[i].st);
                    if (this.globalData._mdf)
                        for (i = 0; i < o; i += 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
                }
            }, SVGRendererBase.prototype.appendElementInPos = function(l, i) {
                var o = l.getBaseElement();
                if (o) {
                    for (var c = 0, u; c < i;) this.elements[c] && this.elements[c] !== !0 && this.elements[c].getBaseElement() && (u = this.elements[c].getBaseElement()), c += 1;
                    u ? this.layerElement.insertBefore(o, u) : this.layerElement.appendChild(o)
                }
            }, SVGRendererBase.prototype.hide = function() {
                this.layerElement.style.display = "none"
            }, SVGRendererBase.prototype.show = function() {
                this.layerElement.style.display = "block"
            };

            function ICompElement() {}
            extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function(l, i, o) {
                this.initFrame(), this.initBaseData(l, i, o), this.initTransform(l, i, o), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), (this.data.xt || !i.progressiveLoad) && this.buildAllItems(), this.hide()
            }, ICompElement.prototype.prepareFrame = function(l) {
                if (this._mdf = !1, this.prepareRenderableFrame(l), this.prepareProperties(l, this.isInRange), !(!this.isInRange && !this.data.xt)) {
                    if (this.tm._placeholder) this.renderedFrame = l / this.data.sr;
                    else {
                        var i = this.tm.v;
                        i === this.data.op && (i = this.data.op - 1), this.renderedFrame = i
                    }
                    var o, c = this.elements.length;
                    for (this.completeLayers || this.checkLayers(this.renderedFrame), o = c - 1; o >= 0; o -= 1)(this.completeLayers || this.elements[o]) && (this.elements[o].prepareFrame(this.renderedFrame - this.layers[o].st), this.elements[o]._mdf && (this._mdf = !0))
                }
            }, ICompElement.prototype.renderInnerContent = function() {
                var l, i = this.layers.length;
                for (l = 0; l < i; l += 1)(this.completeLayers || this.elements[l]) && this.elements[l].renderFrame()
            }, ICompElement.prototype.setElements = function(l) {
                this.elements = l
            }, ICompElement.prototype.getElements = function() {
                return this.elements
            }, ICompElement.prototype.destroyElements = function() {
                var l, i = this.layers.length;
                for (l = 0; l < i; l += 1) this.elements[l] && this.elements[l].destroy()
            }, ICompElement.prototype.destroy = function() {
                this.destroyElements(), this.destroyBaseElement()
            };

            function SVGCompElement(l, i, o) {
                this.layers = l.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(l, i, o), this.tm = l.tm ? PropertyFactory.getProp(this, l.tm, 0, i.frameRate, this) : {
                    _placeholder: !0
                }
            }
            extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function(l) {
                return new SVGCompElement(l, this.globalData, this)
            };

            function SVGRenderer(l, i) {
                this.animationItem = l, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
                var o = "";
                if (i && i.title) {
                    var c = createNS("title"),
                        u = createElementID();
                    c.setAttribute("id", u), c.textContent = i.title, this.svgElement.appendChild(c), o += u
                }
                if (i && i.description) {
                    var p = createNS("desc"),
                        m = createElementID();
                    p.setAttribute("id", m), p.textContent = i.description, this.svgElement.appendChild(p), o += " " + m
                }
                o && this.svgElement.setAttribute("aria-labelledby", o);
                var g = createNS("defs");
                this.svgElement.appendChild(g);
                var _ = createNS("g");
                this.svgElement.appendChild(_), this.layerElement = _, this.renderConfig = {
                    preserveAspectRatio: i && i.preserveAspectRatio || "xMidYMid meet",
                    imagePreserveAspectRatio: i && i.imagePreserveAspectRatio || "xMidYMid slice",
                    contentVisibility: i && i.contentVisibility || "visible",
                    progressiveLoad: i && i.progressiveLoad || !1,
                    hideOnTransparent: !(i && i.hideOnTransparent === !1),
                    viewBoxOnly: i && i.viewBoxOnly || !1,
                    viewBoxSize: i && i.viewBoxSize || !1,
                    className: i && i.className || "",
                    id: i && i.id || "",
                    focusable: i && i.focusable,
                    filterSize: {
                        width: i && i.filterSize && i.filterSize.width || "100%",
                        height: i && i.filterSize && i.filterSize.height || "100%",
                        x: i && i.filterSize && i.filterSize.x || "0%",
                        y: i && i.filterSize && i.filterSize.y || "0%"
                    },
                    width: i && i.width,
                    height: i && i.height,
                    runExpressions: !i || i.runExpressions === void 0 || i.runExpressions
                }, this.globalData = {
                    _mdf: !1,
                    frameNum: -1,
                    defs: g,
                    renderConfig: this.renderConfig
                }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg"
            }
            extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function(l) {
                return new SVGCompElement(l, this.globalData, this)
            };

            function ShapeTransformManager() {
                this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0
            }
            ShapeTransformManager.prototype = {
                addTransformSequence: function(i) {
                    var o, c = i.length,
                        u = "_";
                    for (o = 0; o < c; o += 1) u += i[o].transform.key + "_";
                    var p = this.sequences[u];
                    return p || (p = {
                        transforms: [].concat(i),
                        finalTransform: new Matrix,
                        _mdf: !1
                    }, this.sequences[u] = p, this.sequenceList.push(p)), p
                },
                processSequence: function(i, o) {
                    for (var c = 0, u = i.transforms.length, p = o; c < u && !o;) {
                        if (i.transforms[c].transform.mProps._mdf) {
                            p = !0;
                            break
                        }
                        c += 1
                    }
                    if (p)
                        for (i.finalTransform.reset(), c = u - 1; c >= 0; c -= 1) i.finalTransform.multiply(i.transforms[c].transform.mProps.v);
                    i._mdf = p
                },
                processSequences: function(i) {
                    var o, c = this.sequenceList.length;
                    for (o = 0; o < c; o += 1) this.processSequence(this.sequenceList[o], i)
                },
                getNewKey: function() {
                    return this.transform_key_count += 1, "_" + this.transform_key_count
                }
            };
            var lumaLoader = function() {
                var i = "__lottie_element_luma_buffer",
                    o = null,
                    c = null,
                    u = null;

                function p() {
                    var _ = createNS("svg"),
                        v = createNS("filter"),
                        x = createNS("feColorMatrix");
                    return v.setAttribute("id", i), x.setAttribute("type", "matrix"), x.setAttribute("color-interpolation-filters", "sRGB"), x.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), v.appendChild(x), _.appendChild(v), _.setAttribute("id", i + "_svg"), featureSupport.svgLumaHidden && (_.style.display = "none"), _
                }

                function m() {
                    o || (u = p(), document.body.appendChild(u), o = createTag("canvas"), c = o.getContext("2d"), c.filter = "url(#" + i + ")", c.fillStyle = "rgba(0,0,0,0)", c.fillRect(0, 0, 1, 1))
                }

                function g(_) {
                    return o || m(), o.width = _.width, o.height = _.height, c.filter = "url(#" + i + ")", o
                }
                return {
                    load: m,
                    get: g
                }
            };

            function createCanvas(l, i) {
                if (featureSupport.offscreenCanvas) return new OffscreenCanvas(l, i);
                var o = createTag("canvas");
                return o.width = l, o.height = i, o
            }
            var assetLoader = function() {
                    return {
                        loadLumaCanvas: lumaLoader.load,
                        getLumaCanvas: lumaLoader.get,
                        createCanvas
                    }
                }(),
                registeredEffects = {};

            function CVEffects(l) {
                var i, o = l.data.ef ? l.data.ef.length : 0;
                this.filters = [];
                var c;
                for (i = 0; i < o; i += 1) {
                    c = null;
                    var u = l.data.ef[i].ty;
                    if (registeredEffects[u]) {
                        var p = registeredEffects[u].effect;
                        c = new p(l.effectsManager.effectElements[i], l)
                    }
                    c && this.filters.push(c)
                }
                this.filters.length && l.addRenderableComponent(this)
            }
            CVEffects.prototype.renderFrame = function(l) {
                var i, o = this.filters.length;
                for (i = 0; i < o; i += 1) this.filters[i].renderFrame(l)
            }, CVEffects.prototype.getEffects = function(l) {
                var i, o = this.filters.length,
                    c = [];
                for (i = 0; i < o; i += 1) this.filters[i].type === l && c.push(this.filters[i]);
                return c
            };

            function registerEffect(l, i) {
                registeredEffects[l] = {
                    effect: i
                }
            }

            function CVMaskElement(l, i) {
                this.data = l, this.element = i, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
                var o, c = this.masksProperties.length,
                    u = !1;
                for (o = 0; o < c; o += 1) this.masksProperties[o].mode !== "n" && (u = !0), this.viewData[o] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[o], 3);
                this.hasMasks = u, u && this.element.addRenderableComponent(this)
            }
            CVMaskElement.prototype.renderFrame = function() {
                if (this.hasMasks) {
                    var l = this.element.finalTransform.mat,
                        i = this.element.canvasContext,
                        o, c = this.masksProperties.length,
                        u, p, m;
                    for (i.beginPath(), o = 0; o < c; o += 1)
                        if (this.masksProperties[o].mode !== "n") {
                            this.masksProperties[o].inv && (i.moveTo(0, 0), i.lineTo(this.element.globalData.compSize.w, 0), i.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), i.lineTo(0, this.element.globalData.compSize.h), i.lineTo(0, 0)), m = this.viewData[o].v, u = l.applyToPointArray(m.v[0][0], m.v[0][1], 0), i.moveTo(u[0], u[1]);
                            var g, _ = m._length;
                            for (g = 1; g < _; g += 1) p = l.applyToTriplePoints(m.o[g - 1], m.i[g], m.v[g]), i.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                            p = l.applyToTriplePoints(m.o[g - 1], m.i[0], m.v[0]), i.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5])
                        }
                    this.element.globalData.renderer.save(!0), i.clip()
                }
            }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function() {
                this.element = null
            };

            function CVBaseElement() {}
            var operationsMap = {
                1: "source-in",
                2: "source-out",
                3: "source-in",
                4: "source-out"
            };
            CVBaseElement.prototype = {
                createElements: function() {},
                initRendererElement: function() {},
                createContainerElements: function() {
                    if (this.data.tt >= 1) {
                        this.buffers = [];
                        var i = this.globalData.canvasContext,
                            o = assetLoader.createCanvas(i.canvas.width, i.canvas.height);
                        this.buffers.push(o);
                        var c = assetLoader.createCanvas(i.canvas.width, i.canvas.height);
                        this.buffers.push(c), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas()
                    }
                    this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this), this.searchEffectTransforms()
                },
                createContent: function() {},
                setBlendMode: function() {
                    var i = this.globalData;
                    if (i.blendMode !== this.data.bm) {
                        i.blendMode = this.data.bm;
                        var o = getBlendMode(this.data.bm);
                        i.canvasContext.globalCompositeOperation = o
                    }
                },
                createRenderableComponents: function() {
                    this.maskManager = new CVMaskElement(this.data, this), this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT)
                },
                hideElement: function() {
                    !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0)
                },
                showElement: function() {
                    this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0)
                },
                clearCanvas: function(i) {
                    i.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy)
                },
                prepareLayer: function() {
                    if (this.data.tt >= 1) {
                        var i = this.buffers[0],
                            o = i.getContext("2d");
                        this.clearCanvas(o), o.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform)
                    }
                },
                exitLayer: function() {
                    if (this.data.tt >= 1) {
                        var i = this.buffers[1],
                            o = i.getContext("2d");
                        this.clearCanvas(o), o.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform);
                        var c = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
                        if (c.renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) {
                            var u = assetLoader.getLumaCanvas(this.canvasContext.canvas),
                                p = u.getContext("2d");
                            p.drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(u, 0, 0)
                        }
                        this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(i, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over"
                    }
                },
                renderFrame: function(i) {
                    if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !i)) {
                        this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.setBlendMode();
                        var o = this.data.ty === 0;
                        this.prepareLayer(), this.globalData.renderer.save(o), this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity), this.renderInnerContent(), this.globalData.renderer.restore(o), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1)
                    }
                },
                destroy: function() {
                    this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy()
                },
                mHelper: new Matrix
            }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

            function CVShapeData(l, i, o, c) {
                this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
                var u = 4;
                i.ty === "rc" ? u = 5 : i.ty === "el" ? u = 6 : i.ty === "sr" && (u = 7), this.sh = ShapePropertyFactory.getShapeProp(l, i, u, l);
                var p, m = o.length,
                    g;
                for (p = 0; p < m; p += 1) o[p].closed || (g = {
                    transforms: c.addTransformSequence(o[p].transforms),
                    trNodes: []
                }, this.styledShapes.push(g), o[p].elements.push(g))
            }
            CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

            function CVShapeElement(l, i, o) {
                this.shapes = [], this.shapesData = l.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(l, i, o)
            }
            extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
                opacity: 1,
                _opMdf: !1
            }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function() {
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
            }, CVShapeElement.prototype.createStyleElement = function(l, i) {
                var o = {
                        data: l,
                        type: l.ty,
                        preTransforms: this.transformsManager.addTransformSequence(i),
                        transforms: [],
                        elements: [],
                        closed: l.hd === !0
                    },
                    c = {};
                if (l.ty === "fl" || l.ty === "st" ? (c.c = PropertyFactory.getProp(this, l.c, 1, 255, this), c.c.k || (o.co = "rgb(" + bmFloor(c.c.v[0]) + "," + bmFloor(c.c.v[1]) + "," + bmFloor(c.c.v[2]) + ")")) : (l.ty === "gf" || l.ty === "gs") && (c.s = PropertyFactory.getProp(this, l.s, 1, null, this), c.e = PropertyFactory.getProp(this, l.e, 1, null, this), c.h = PropertyFactory.getProp(this, l.h || {
                        k: 0
                    }, 0, .01, this), c.a = PropertyFactory.getProp(this, l.a || {
                        k: 0
                    }, 0, degToRads, this), c.g = new GradientProperty(this, l.g, this)), c.o = PropertyFactory.getProp(this, l.o, 0, .01, this), l.ty === "st" || l.ty === "gs") {
                    if (o.lc = lineCapEnum[l.lc || 2], o.lj = lineJoinEnum[l.lj || 2], l.lj == 1 && (o.ml = l.ml), c.w = PropertyFactory.getProp(this, l.w, 0, null, this), c.w.k || (o.wi = c.w.v), l.d) {
                        var u = new DashProperty(this, l.d, "canvas", this);
                        c.d = u, c.d.k || (o.da = c.d.dashArray, o.do = c.d.dashoffset[0])
                    }
                } else o.r = l.r === 2 ? "evenodd" : "nonzero";
                return this.stylesList.push(o), c.style = o, c
            }, CVShapeElement.prototype.createGroupElement = function() {
                var l = {
                    it: [],
                    prevViewData: []
                };
                return l
            }, CVShapeElement.prototype.createTransformElement = function(l) {
                var i = {
                    transform: {
                        opacity: 1,
                        _opMdf: !1,
                        key: this.transformsManager.getNewKey(),
                        op: PropertyFactory.getProp(this, l.o, 0, .01, this),
                        mProps: TransformPropertyFactory.getTransformProperty(this, l, this)
                    }
                };
                return i
            }, CVShapeElement.prototype.createShapeElement = function(l) {
                var i = new CVShapeData(this, l, this.stylesList, this.transformsManager);
                return this.shapes.push(i), this.addShapeToModifiers(i), i
            }, CVShapeElement.prototype.reloadShapes = function() {
                this._isFirstFrame = !0;
                var l, i = this.itemsData.length;
                for (l = 0; l < i; l += 1) this.prevViewData[l] = this.itemsData[l];
                for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), i = this.dynamicProperties.length, l = 0; l < i; l += 1) this.dynamicProperties[l].getValue();
                this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame)
            }, CVShapeElement.prototype.addTransformToStyleList = function(l) {
                var i, o = this.stylesList.length;
                for (i = 0; i < o; i += 1) this.stylesList[i].closed || this.stylesList[i].transforms.push(l)
            }, CVShapeElement.prototype.removeTransformFromStyleList = function() {
                var l, i = this.stylesList.length;
                for (l = 0; l < i; l += 1) this.stylesList[l].closed || this.stylesList[l].transforms.pop()
            }, CVShapeElement.prototype.closeStyles = function(l) {
                var i, o = l.length;
                for (i = 0; i < o; i += 1) l[i].closed = !0
            }, CVShapeElement.prototype.searchShapes = function(l, i, o, c, u) {
                var p, m = l.length - 1,
                    g, _, v = [],
                    x = [],
                    y, b, S, C = [].concat(u);
                for (p = m; p >= 0; p -= 1) {
                    if (y = this.searchProcessedElement(l[p]), y ? i[p] = o[y - 1] : l[p]._shouldRender = c, l[p].ty === "fl" || l[p].ty === "st" || l[p].ty === "gf" || l[p].ty === "gs") y ? i[p].style.closed = !1 : i[p] = this.createStyleElement(l[p], C), v.push(i[p].style);
                    else if (l[p].ty === "gr") {
                        if (!y) i[p] = this.createGroupElement(l[p]);
                        else
                            for (_ = i[p].it.length, g = 0; g < _; g += 1) i[p].prevViewData[g] = i[p].it[g];
                        this.searchShapes(l[p].it, i[p].it, i[p].prevViewData, c, C)
                    } else l[p].ty === "tr" ? (y || (S = this.createTransformElement(l[p]), i[p] = S), C.push(i[p]), this.addTransformToStyleList(i[p])) : l[p].ty === "sh" || l[p].ty === "rc" || l[p].ty === "el" || l[p].ty === "sr" ? y || (i[p] = this.createShapeElement(l[p])) : l[p].ty === "tm" || l[p].ty === "rd" || l[p].ty === "pb" || l[p].ty === "zz" || l[p].ty === "op" ? (y ? (b = i[p], b.closed = !1) : (b = ShapeModifiers.getModifier(l[p].ty), b.init(this, l[p]), i[p] = b, this.shapeModifiers.push(b)), x.push(b)) : l[p].ty === "rp" && (y ? (b = i[p], b.closed = !0) : (b = ShapeModifiers.getModifier(l[p].ty), i[p] = b, b.init(this, l, p, i), this.shapeModifiers.push(b), c = !1), x.push(b));
                    this.addProcessedElement(l[p], p + 1)
                }
                for (this.removeTransformFromStyleList(), this.closeStyles(v), m = x.length, p = 0; p < m; p += 1) x[p].closed = !0
            }, CVShapeElement.prototype.renderInnerContent = function() {
                this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
            }, CVShapeElement.prototype.renderShapeTransform = function(l, i) {
                (l._opMdf || i.op._mdf || this._isFirstFrame) && (i.opacity = l.opacity, i.opacity *= i.op.v, i._opMdf = !0)
            }, CVShapeElement.prototype.drawLayer = function() {
                var l, i = this.stylesList.length,
                    o, c, u, p, m, g, _ = this.globalData.renderer,
                    v = this.globalData.canvasContext,
                    x, y;
                for (l = 0; l < i; l += 1)
                    if (y = this.stylesList[l], x = y.type, !((x === "st" || x === "gs") && y.wi === 0 || !y.data._shouldRender || y.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
                        for (_.save(), m = y.elements, x === "st" || x === "gs" ? (_.ctxStrokeStyle(x === "st" ? y.co : y.grd), _.ctxLineWidth(y.wi), _.ctxLineCap(y.lc), _.ctxLineJoin(y.lj), _.ctxMiterLimit(y.ml || 0)) : _.ctxFillStyle(x === "fl" ? y.co : y.grd), _.ctxOpacity(y.coOp), x !== "st" && x !== "gs" && v.beginPath(), _.ctxTransform(y.preTransforms.finalTransform.props), c = m.length, o = 0; o < c; o += 1) {
                            for ((x === "st" || x === "gs") && (v.beginPath(), y.da && (v.setLineDash(y.da), v.lineDashOffset = y.do)), g = m[o].trNodes, p = g.length, u = 0; u < p; u += 1) g[u].t === "m" ? v.moveTo(g[u].p[0], g[u].p[1]) : g[u].t === "c" ? v.bezierCurveTo(g[u].pts[0], g[u].pts[1], g[u].pts[2], g[u].pts[3], g[u].pts[4], g[u].pts[5]) : v.closePath();
                            (x === "st" || x === "gs") && (_.ctxStroke(), y.da && v.setLineDash(this.dashResetter))
                        }
                        x !== "st" && x !== "gs" && this.globalData.renderer.ctxFill(y.r), _.restore()
                    }
            }, CVShapeElement.prototype.renderShape = function(l, i, o, c) {
                var u, p = i.length - 1,
                    m;
                for (m = l, u = p; u >= 0; u -= 1) i[u].ty === "tr" ? (m = o[u].transform, this.renderShapeTransform(l, m)) : i[u].ty === "sh" || i[u].ty === "el" || i[u].ty === "rc" || i[u].ty === "sr" ? this.renderPath(i[u], o[u]) : i[u].ty === "fl" ? this.renderFill(i[u], o[u], m) : i[u].ty === "st" ? this.renderStroke(i[u], o[u], m) : i[u].ty === "gf" || i[u].ty === "gs" ? this.renderGradientFill(i[u], o[u], m) : i[u].ty === "gr" ? this.renderShape(m, i[u].it, o[u].it) : i[u].ty;
                c && this.drawLayer()
            }, CVShapeElement.prototype.renderStyledShape = function(l, i) {
                if (this._isFirstFrame || i._mdf || l.transforms._mdf) {
                    var o = l.trNodes,
                        c = i.paths,
                        u, p, m, g = c._length;
                    o.length = 0;
                    var _ = l.transforms.finalTransform;
                    for (m = 0; m < g; m += 1) {
                        var v = c.shapes[m];
                        if (v && v.v) {
                            for (p = v._length, u = 1; u < p; u += 1) u === 1 && o.push({
                                t: "m",
                                p: _.applyToPointArray(v.v[0][0], v.v[0][1], 0)
                            }), o.push({
                                t: "c",
                                pts: _.applyToTriplePoints(v.o[u - 1], v.i[u], v.v[u])
                            });
                            p === 1 && o.push({
                                t: "m",
                                p: _.applyToPointArray(v.v[0][0], v.v[0][1], 0)
                            }), v.c && p && (o.push({
                                t: "c",
                                pts: _.applyToTriplePoints(v.o[u - 1], v.i[0], v.v[0])
                            }), o.push({
                                t: "z"
                            }))
                        }
                    }
                    l.trNodes = o
                }
            }, CVShapeElement.prototype.renderPath = function(l, i) {
                if (l.hd !== !0 && l._shouldRender) {
                    var o, c = i.styledShapes.length;
                    for (o = 0; o < c; o += 1) this.renderStyledShape(i.styledShapes[o], i.sh)
                }
            }, CVShapeElement.prototype.renderFill = function(l, i, o) {
                var c = i.style;
                (i.c._mdf || this._isFirstFrame) && (c.co = "rgb(" + bmFloor(i.c.v[0]) + "," + bmFloor(i.c.v[1]) + "," + bmFloor(i.c.v[2]) + ")"), (i.o._mdf || o._opMdf || this._isFirstFrame) && (c.coOp = i.o.v * o.opacity)
            }, CVShapeElement.prototype.renderGradientFill = function(l, i, o) {
                var c = i.style,
                    u;
                if (!c.grd || i.g._mdf || i.s._mdf || i.e._mdf || l.t !== 1 && (i.h._mdf || i.a._mdf)) {
                    var p = this.globalData.canvasContext,
                        m = i.s.v,
                        g = i.e.v;
                    if (l.t === 1) u = p.createLinearGradient(m[0], m[1], g[0], g[1]);
                    else {
                        var _ = Math.sqrt(Math.pow(m[0] - g[0], 2) + Math.pow(m[1] - g[1], 2)),
                            v = Math.atan2(g[1] - m[1], g[0] - m[0]),
                            x = i.h.v;
                        x >= 1 ? x = .99 : x <= -1 && (x = -.99);
                        var y = _ * x,
                            b = Math.cos(v + i.a.v) * y + m[0],
                            S = Math.sin(v + i.a.v) * y + m[1];
                        u = p.createRadialGradient(b, S, 0, m[0], m[1], _)
                    }
                    var C, E = l.g.p,
                        P = i.g.c,
                        w = 1;
                    for (C = 0; C < E; C += 1) i.g._hasOpacity && i.g._collapsable && (w = i.g.o[C * 2 + 1]), u.addColorStop(P[C * 4] / 100, "rgba(" + P[C * 4 + 1] + "," + P[C * 4 + 2] + "," + P[C * 4 + 3] + "," + w + ")");
                    c.grd = u
                }
                c.coOp = i.o.v * o.opacity
            }, CVShapeElement.prototype.renderStroke = function(l, i, o) {
                var c = i.style,
                    u = i.d;
                u && (u._mdf || this._isFirstFrame) && (c.da = u.dashArray, c.do = u.dashoffset[0]), (i.c._mdf || this._isFirstFrame) && (c.co = "rgb(" + bmFloor(i.c.v[0]) + "," + bmFloor(i.c.v[1]) + "," + bmFloor(i.c.v[2]) + ")"), (i.o._mdf || o._opMdf || this._isFirstFrame) && (c.coOp = i.o.v * o.opacity), (i.w._mdf || this._isFirstFrame) && (c.wi = i.w.v)
            }, CVShapeElement.prototype.destroy = function() {
                this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0
            };

            function CVTextElement(l, i, o) {
                this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
                    fill: "rgba(0,0,0,0)",
                    stroke: "rgba(0,0,0,0)",
                    sWidth: 0,
                    fValue: ""
                }, this.initElement(l, i, o)
            }
            extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function() {
                var l = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(l.l ? l.l.length : 0);
                var i = !1;
                l.fc ? (i = !0, this.values.fill = this.buildColor(l.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = i;
                var o = !1;
                l.sc && (o = !0, this.values.stroke = this.buildColor(l.sc), this.values.sWidth = l.sw);
                var c = this.globalData.fontManager.getFontByName(l.f),
                    u, p, m = l.l,
                    g = this.mHelper;
                this.stroke = o, this.values.fValue = l.finalSize + "px " + this.globalData.fontManager.getFontByName(l.f).fFamily, p = l.finalText.length;
                var _, v, x, y, b, S, C, E, P, w, T = this.data.singleShape,
                    M = l.tr * .001 * l.finalSize,
                    A = 0,
                    D = 0,
                    R = !0,
                    I = 0;
                for (u = 0; u < p; u += 1) {
                    _ = this.globalData.fontManager.getCharData(l.finalText[u], c.fStyle, this.globalData.fontManager.getFontByName(l.f).fFamily), v = _ && _.data || {}, g.reset(), T && m[u].n && (A = -M, D += l.yOffset, D += R ? 1 : 0, R = !1), b = v.shapes ? v.shapes[0].it : [], C = b.length, g.scale(l.finalSize / 100, l.finalSize / 100), T && this.applyTextPropertiesToMatrix(l, g, m[u].line, A, D), P = createSizedArray(C - 1);
                    var k = 0;
                    for (S = 0; S < C; S += 1)
                        if (b[S].ty === "sh") {
                            for (y = b[S].ks.k.i.length, E = b[S].ks.k, w = [], x = 1; x < y; x += 1) x === 1 && w.push(g.applyToX(E.v[0][0], E.v[0][1], 0), g.applyToY(E.v[0][0], E.v[0][1], 0)), w.push(g.applyToX(E.o[x - 1][0], E.o[x - 1][1], 0), g.applyToY(E.o[x - 1][0], E.o[x - 1][1], 0), g.applyToX(E.i[x][0], E.i[x][1], 0), g.applyToY(E.i[x][0], E.i[x][1], 0), g.applyToX(E.v[x][0], E.v[x][1], 0), g.applyToY(E.v[x][0], E.v[x][1], 0));
                            w.push(g.applyToX(E.o[x - 1][0], E.o[x - 1][1], 0), g.applyToY(E.o[x - 1][0], E.o[x - 1][1], 0), g.applyToX(E.i[0][0], E.i[0][1], 0), g.applyToY(E.i[0][0], E.i[0][1], 0), g.applyToX(E.v[0][0], E.v[0][1], 0), g.applyToY(E.v[0][0], E.v[0][1], 0)), P[k] = w, k += 1
                        }
                    T && (A += m[u].l, A += M), this.textSpans[I] ? this.textSpans[I].elem = P : this.textSpans[I] = {
                        elem: P
                    }, I += 1
                }
            }, CVTextElement.prototype.renderInnerContent = function() {
                this.validateText();
                var l = this.canvasContext;
                l.font = this.values.fValue, this.globalData.renderer.ctxLineCap("butt"), this.globalData.renderer.ctxLineJoin("miter"), this.globalData.renderer.ctxMiterLimit(4), this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                var i, o, c, u, p, m, g = this.textAnimator.renderedLetters,
                    _ = this.textProperty.currentData.l;
                o = _.length;
                var v, x = null,
                    y = null,
                    b = null,
                    S, C, E = this.globalData.renderer;
                for (i = 0; i < o; i += 1)
                    if (!_[i].n) {
                        if (v = g[i], v && (E.save(), E.ctxTransform(v.p), E.ctxOpacity(v.o)), this.fill) {
                            for (v && v.fc ? x !== v.fc && (E.ctxFillStyle(v.fc), x = v.fc) : x !== this.values.fill && (x = this.values.fill, E.ctxFillStyle(this.values.fill)), S = this.textSpans[i].elem, u = S.length, this.globalData.canvasContext.beginPath(), c = 0; c < u; c += 1)
                                for (C = S[c], m = C.length, this.globalData.canvasContext.moveTo(C[0], C[1]), p = 2; p < m; p += 6) this.globalData.canvasContext.bezierCurveTo(C[p], C[p + 1], C[p + 2], C[p + 3], C[p + 4], C[p + 5]);
                            this.globalData.canvasContext.closePath(), E.ctxFill()
                        }
                        if (this.stroke) {
                            for (v && v.sw ? b !== v.sw && (b = v.sw, E.ctxLineWidth(v.sw)) : b !== this.values.sWidth && (b = this.values.sWidth, E.ctxLineWidth(this.values.sWidth)), v && v.sc ? y !== v.sc && (y = v.sc, E.ctxStrokeStyle(v.sc)) : y !== this.values.stroke && (y = this.values.stroke, E.ctxStrokeStyle(this.values.stroke)), S = this.textSpans[i].elem, u = S.length, this.globalData.canvasContext.beginPath(), c = 0; c < u; c += 1)
                                for (C = S[c], m = C.length, this.globalData.canvasContext.moveTo(C[0], C[1]), p = 2; p < m; p += 6) this.globalData.canvasContext.bezierCurveTo(C[p], C[p + 1], C[p + 2], C[p + 3], C[p + 4], C[p + 5]);
                            this.globalData.canvasContext.closePath(), E.ctxStroke()
                        }
                        v && this.globalData.renderer.restore()
                    }
            };

            function CVImageElement(l, i, o) {
                this.assetData = i.getAssetData(l.refId), this.img = i.imageLoader.getAsset(this.assetData), this.initElement(l, i, o)
            }
            extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function() {
                if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                    var l = createTag("canvas");
                    l.width = this.assetData.w, l.height = this.assetData.h;
                    var i = l.getContext("2d"),
                        o = this.img.width,
                        c = this.img.height,
                        u = o / c,
                        p = this.assetData.w / this.assetData.h,
                        m, g, _ = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                    u > p && _ === "xMidYMid slice" || u < p && _ !== "xMidYMid slice" ? (g = c, m = g * p) : (m = o, g = m / p), i.drawImage(this.img, (o - m) / 2, (c - g) / 2, m, g, 0, 0, this.assetData.w, this.assetData.h), this.img = l
                }
            }, CVImageElement.prototype.renderInnerContent = function() {
                this.canvasContext.drawImage(this.img, 0, 0)
            }, CVImageElement.prototype.destroy = function() {
                this.img = null
            };

            function CVSolidElement(l, i, o) {
                this.initElement(l, i, o)
            }
            extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function() {
                this.globalData.renderer.ctxFillStyle(this.data.sc), this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh)
            };

            function CanvasRendererBase() {}
            extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function(l) {
                return new CVShapeElement(l, this.globalData, this)
            }, CanvasRendererBase.prototype.createText = function(l) {
                return new CVTextElement(l, this.globalData, this)
            }, CanvasRendererBase.prototype.createImage = function(l) {
                return new CVImageElement(l, this.globalData, this)
            }, CanvasRendererBase.prototype.createSolid = function(l) {
                return new CVSolidElement(l, this.globalData, this)
            }, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function(l) {
                l[0] === 1 && l[1] === 0 && l[4] === 0 && l[5] === 1 && l[12] === 0 && l[13] === 0 || this.canvasContext.transform(l[0], l[1], l[4], l[5], l[12], l[13])
            }, CanvasRendererBase.prototype.ctxOpacity = function(l) {
                this.canvasContext.globalAlpha *= l < 0 ? 0 : l
            }, CanvasRendererBase.prototype.ctxFillStyle = function(l) {
                this.canvasContext.fillStyle = l
            }, CanvasRendererBase.prototype.ctxStrokeStyle = function(l) {
                this.canvasContext.strokeStyle = l
            }, CanvasRendererBase.prototype.ctxLineWidth = function(l) {
                this.canvasContext.lineWidth = l
            }, CanvasRendererBase.prototype.ctxLineCap = function(l) {
                this.canvasContext.lineCap = l
            }, CanvasRendererBase.prototype.ctxLineJoin = function(l) {
                this.canvasContext.lineJoin = l
            }, CanvasRendererBase.prototype.ctxMiterLimit = function(l) {
                this.canvasContext.miterLimit = l
            }, CanvasRendererBase.prototype.ctxFill = function(l) {
                this.canvasContext.fill(l)
            }, CanvasRendererBase.prototype.ctxFillRect = function(l, i, o, c) {
                this.canvasContext.fillRect(l, i, o, c)
            }, CanvasRendererBase.prototype.ctxStroke = function() {
                this.canvasContext.stroke()
            }, CanvasRendererBase.prototype.reset = function() {
                if (!this.renderConfig.clearCanvas) {
                    this.canvasContext.restore();
                    return
                }
                this.contextData.reset()
            }, CanvasRendererBase.prototype.save = function() {
                this.canvasContext.save()
            }, CanvasRendererBase.prototype.restore = function(l) {
                if (!this.renderConfig.clearCanvas) {
                    this.canvasContext.restore();
                    return
                }
                l && (this.globalData.blendMode = "source-over"), this.contextData.restore(l)
            }, CanvasRendererBase.prototype.configAnimation = function(l) {
                if (this.animationItem.wrapper) {
                    this.animationItem.container = createTag("canvas");
                    var i = this.animationItem.container.style;
                    i.width = "100%", i.height = "100%";
                    var o = "0px 0px 0px";
                    i.transformOrigin = o, i.mozTransformOrigin = o, i.webkitTransformOrigin = o, i["-webkit-transform"] = o, i.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
                } else this.canvasContext = this.renderConfig.context;
                this.contextData.setContext(this.canvasContext), this.data = l, this.layers = l.layers, this.transformCanvas = {
                    w: l.w,
                    h: l.h,
                    sx: 0,
                    sy: 0,
                    tx: 0,
                    ty: 0
                }, this.setupGlobalData(l, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(l.layers.length), this.updateContainerSize()
            }, CanvasRendererBase.prototype.updateContainerSize = function(l, i) {
                this.reset();
                var o, c;
                l ? (o = l, c = i, this.canvasContext.canvas.width = o, this.canvasContext.canvas.height = c) : (this.animationItem.wrapper && this.animationItem.container ? (o = this.animationItem.wrapper.offsetWidth, c = this.animationItem.wrapper.offsetHeight) : (o = this.canvasContext.canvas.width, c = this.canvasContext.canvas.height), this.canvasContext.canvas.width = o * this.renderConfig.dpr, this.canvasContext.canvas.height = c * this.renderConfig.dpr);
                var u, p;
                if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
                    var m = this.renderConfig.preserveAspectRatio.split(" "),
                        g = m[1] || "meet",
                        _ = m[0] || "xMidYMid",
                        v = _.substr(0, 4),
                        x = _.substr(4);
                    u = o / c, p = this.transformCanvas.w / this.transformCanvas.h, p > u && g === "meet" || p < u && g === "slice" ? (this.transformCanvas.sx = o / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = o / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = c / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = c / (this.transformCanvas.h / this.renderConfig.dpr)), v === "xMid" && (p < u && g === "meet" || p > u && g === "slice") ? this.transformCanvas.tx = (o - this.transformCanvas.w * (c / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : v === "xMax" && (p < u && g === "meet" || p > u && g === "slice") ? this.transformCanvas.tx = (o - this.transformCanvas.w * (c / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0, x === "YMid" && (p > u && g === "meet" || p < u && g === "slice") ? this.transformCanvas.ty = (c - this.transformCanvas.h * (o / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : x === "YMax" && (p > u && g === "meet" || p < u && g === "slice") ? this.transformCanvas.ty = (c - this.transformCanvas.h * (o / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0
                } else this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = o / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = c / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
                this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0)
            }, CanvasRendererBase.prototype.destroy = function() {
                this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
                var l, i = this.layers ? this.layers.length : 0;
                for (l = i - 1; l >= 0; l -= 1) this.elements[l] && this.elements[l].destroy && this.elements[l].destroy();
                this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0
            }, CanvasRendererBase.prototype.renderFrame = function(l, i) {
                if (!(this.renderedFrame === l && this.renderConfig.clearCanvas === !0 && !i || this.destroyed || l === -1)) {
                    this.renderedFrame = l, this.globalData.frameNum = l - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || i, this.globalData.projectInterface.currentFrame = l;
                    var o, c = this.layers.length;
                    for (this.completeLayers || this.checkLayers(l), o = c - 1; o >= 0; o -= 1)(this.completeLayers || this.elements[o]) && this.elements[o].prepareFrame(l - this.layers[o].st);
                    if (this.globalData._mdf) {
                        for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), o = c - 1; o >= 0; o -= 1)(this.completeLayers || this.elements[o]) && this.elements[o].renderFrame();
                        this.renderConfig.clearCanvas !== !0 && this.restore()
                    }
                }
            }, CanvasRendererBase.prototype.buildItem = function(l) {
                var i = this.elements;
                if (!(i[l] || this.layers[l].ty === 99)) {
                    var o = this.createItem(this.layers[l], this, this.globalData);
                    i[l] = o, o.initExpressions()
                }
            }, CanvasRendererBase.prototype.checkPendingElements = function() {
                for (; this.pendingElements.length;) {
                    var l = this.pendingElements.pop();
                    l.checkParenting()
                }
            }, CanvasRendererBase.prototype.hide = function() {
                this.animationItem.container.style.display = "none"
            }, CanvasRendererBase.prototype.show = function() {
                this.animationItem.container.style.display = "block"
            };

            function CanvasContext() {
                this.opacity = -1, this.transform = createTypedArray("float32", 16), this.fillStyle = "", this.strokeStyle = "", this.lineWidth = "", this.lineCap = "", this.lineJoin = "", this.miterLimit = "", this.id = Math.random()
            }

            function CVContextData() {
                this.stack = [], this.cArrPos = 0, this.cTr = new Matrix;
                var l, i = 15;
                for (l = 0; l < i; l += 1) {
                    var o = new CanvasContext;
                    this.stack[l] = o
                }
                this._length = i, this.nativeContext = null, this.transformMat = new Matrix, this.currentOpacity = 1, this.currentFillStyle = "", this.appliedFillStyle = "", this.currentStrokeStyle = "", this.appliedStrokeStyle = "", this.currentLineWidth = "", this.appliedLineWidth = "", this.currentLineCap = "", this.appliedLineCap = "", this.currentLineJoin = "", this.appliedLineJoin = "", this.appliedMiterLimit = "", this.currentMiterLimit = ""
            }
            CVContextData.prototype.duplicate = function() {
                var l = this._length * 2,
                    i = 0;
                for (i = this._length; i < l; i += 1) this.stack[i] = new CanvasContext;
                this._length = l
            }, CVContextData.prototype.reset = function() {
                this.cArrPos = 0, this.cTr.reset(), this.stack[this.cArrPos].opacity = 1
            }, CVContextData.prototype.restore = function(l) {
                this.cArrPos -= 1;
                var i = this.stack[this.cArrPos],
                    o = i.transform,
                    c, u = this.cTr.props;
                for (c = 0; c < 16; c += 1) u[c] = o[c];
                if (l) {
                    this.nativeContext.restore();
                    var p = this.stack[this.cArrPos + 1];
                    this.appliedFillStyle = p.fillStyle, this.appliedStrokeStyle = p.strokeStyle, this.appliedLineWidth = p.lineWidth, this.appliedLineCap = p.lineCap, this.appliedLineJoin = p.lineJoin, this.appliedMiterLimit = p.miterLimit
                }
                this.nativeContext.setTransform(o[0], o[1], o[4], o[5], o[12], o[13]), (l || i.opacity !== -1 && this.currentOpacity !== i.opacity) && (this.nativeContext.globalAlpha = i.opacity, this.currentOpacity = i.opacity), this.currentFillStyle = i.fillStyle, this.currentStrokeStyle = i.strokeStyle, this.currentLineWidth = i.lineWidth, this.currentLineCap = i.lineCap, this.currentLineJoin = i.lineJoin, this.currentMiterLimit = i.miterLimit
            }, CVContextData.prototype.save = function(l) {
                l && this.nativeContext.save();
                var i = this.cTr.props;
                this._length <= this.cArrPos && this.duplicate();
                var o = this.stack[this.cArrPos],
                    c;
                for (c = 0; c < 16; c += 1) o.transform[c] = i[c];
                this.cArrPos += 1;
                var u = this.stack[this.cArrPos];
                u.opacity = o.opacity, u.fillStyle = o.fillStyle, u.strokeStyle = o.strokeStyle, u.lineWidth = o.lineWidth, u.lineCap = o.lineCap, u.lineJoin = o.lineJoin, u.miterLimit = o.miterLimit
            }, CVContextData.prototype.setOpacity = function(l) {
                this.stack[this.cArrPos].opacity = l
            }, CVContextData.prototype.setContext = function(l) {
                this.nativeContext = l
            }, CVContextData.prototype.fillStyle = function(l) {
                this.stack[this.cArrPos].fillStyle !== l && (this.currentFillStyle = l, this.stack[this.cArrPos].fillStyle = l)
            }, CVContextData.prototype.strokeStyle = function(l) {
                this.stack[this.cArrPos].strokeStyle !== l && (this.currentStrokeStyle = l, this.stack[this.cArrPos].strokeStyle = l)
            }, CVContextData.prototype.lineWidth = function(l) {
                this.stack[this.cArrPos].lineWidth !== l && (this.currentLineWidth = l, this.stack[this.cArrPos].lineWidth = l)
            }, CVContextData.prototype.lineCap = function(l) {
                this.stack[this.cArrPos].lineCap !== l && (this.currentLineCap = l, this.stack[this.cArrPos].lineCap = l)
            }, CVContextData.prototype.lineJoin = function(l) {
                this.stack[this.cArrPos].lineJoin !== l && (this.currentLineJoin = l, this.stack[this.cArrPos].lineJoin = l)
            }, CVContextData.prototype.miterLimit = function(l) {
                this.stack[this.cArrPos].miterLimit !== l && (this.currentMiterLimit = l, this.stack[this.cArrPos].miterLimit = l)
            }, CVContextData.prototype.transform = function(l) {
                this.transformMat.cloneFromProps(l);
                var i = this.cTr;
                this.transformMat.multiply(i), i.cloneFromProps(this.transformMat.props);
                var o = i.props;
                this.nativeContext.setTransform(o[0], o[1], o[4], o[5], o[12], o[13])
            }, CVContextData.prototype.opacity = function(l) {
                var i = this.stack[this.cArrPos].opacity;
                i *= l < 0 ? 0 : l, this.stack[this.cArrPos].opacity !== i && (this.currentOpacity !== l && (this.nativeContext.globalAlpha = l, this.currentOpacity = l), this.stack[this.cArrPos].opacity = i)
            }, CVContextData.prototype.fill = function(l) {
                this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fill(l)
            }, CVContextData.prototype.fillRect = function(l, i, o, c) {
                this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fillRect(l, i, o, c)
            }, CVContextData.prototype.stroke = function() {
                this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle, this.nativeContext.strokeStyle = this.appliedStrokeStyle), this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth, this.nativeContext.lineWidth = this.appliedLineWidth), this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap, this.nativeContext.lineCap = this.appliedLineCap), this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin, this.nativeContext.lineJoin = this.appliedLineJoin), this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit, this.nativeContext.miterLimit = this.appliedMiterLimit), this.nativeContext.stroke()
            };

            function CVCompElement(l, i, o) {
                this.completeLayers = !1, this.layers = l.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(l, i, o), this.tm = l.tm ? PropertyFactory.getProp(this, l.tm, 0, i.frameRate, this) : {
                    _placeholder: !0
                }
            }
            extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function() {
                var l = this.canvasContext;
                l.beginPath(), l.moveTo(0, 0), l.lineTo(this.data.w, 0), l.lineTo(this.data.w, this.data.h), l.lineTo(0, this.data.h), l.lineTo(0, 0), l.clip();
                var i, o = this.layers.length;
                for (i = o - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
            }, CVCompElement.prototype.destroy = function() {
                var l, i = this.layers.length;
                for (l = i - 1; l >= 0; l -= 1) this.elements[l] && this.elements[l].destroy();
                this.layers = null, this.elements = null
            }, CVCompElement.prototype.createComp = function(l) {
                return new CVCompElement(l, this.globalData, this)
            };

            function CanvasRenderer(l, i) {
                this.animationItem = l, this.renderConfig = {
                    clearCanvas: i && i.clearCanvas !== void 0 ? i.clearCanvas : !0,
                    context: i && i.context || null,
                    progressiveLoad: i && i.progressiveLoad || !1,
                    preserveAspectRatio: i && i.preserveAspectRatio || "xMidYMid meet",
                    imagePreserveAspectRatio: i && i.imagePreserveAspectRatio || "xMidYMid slice",
                    contentVisibility: i && i.contentVisibility || "visible",
                    className: i && i.className || "",
                    id: i && i.id || "",
                    runExpressions: !i || i.runExpressions === void 0 || i.runExpressions
                }, this.renderConfig.dpr = i && i.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = i && i.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
                    frameNum: -1,
                    _mdf: !1,
                    renderConfig: this.renderConfig,
                    currentGlobalAlpha: -1
                }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas", this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData), this.ctxOpacity = this.contextData.opacity.bind(this.contextData), this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData), this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData), this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData), this.ctxLineCap = this.contextData.lineCap.bind(this.contextData), this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData), this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData), this.ctxFill = this.contextData.fill.bind(this.contextData), this.ctxFillRect = this.contextData.fillRect.bind(this.contextData), this.ctxStroke = this.contextData.stroke.bind(this.contextData), this.save = this.contextData.save.bind(this.contextData))
            }
            extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function(l) {
                return new CVCompElement(l, this.globalData, this)
            };

            function HBaseElement() {}
            HBaseElement.prototype = {
                checkBlendMode: function() {},
                initRendererElement: function() {
                    this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement)
                },
                createContainerElements: function() {
                    this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.bm !== 0 && this.setBlendMode()
                },
                renderElement: function() {
                    var i = this.transformedElement ? this.transformedElement.style : {};
                    if (this.finalTransform._matMdf) {
                        var o = this.finalTransform.mat.toCSS();
                        i.transform = o, i.webkitTransform = o
                    }
                    this.finalTransform._opMdf && (i.opacity = this.finalTransform.mProp.o.v)
                },
                renderFrame: function() {
                    this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                },
                destroy: function() {
                    this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null)
                },
                createRenderableComponents: function() {
                    this.maskManager = new MaskElement(this.data, this, this.globalData)
                },
                addEffects: function() {},
                setMatte: function() {}
            }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;

            function HSolidElement(l, i, o) {
                this.initElement(l, i, o)
            }
            extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function() {
                var l;
                this.data.hasMask ? (l = createNS("rect"), l.setAttribute("width", this.data.sw), l.setAttribute("height", this.data.sh), l.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : (l = createTag("div"), l.style.width = this.data.sw + "px", l.style.height = this.data.sh + "px", l.style.backgroundColor = this.data.sc), this.layerElement.appendChild(l)
            };

            function HShapeElement(l, i, o) {
                this.shapes = [], this.shapesData = l.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(l, i, o), this.prevViewData = [], this.currentBBox = {
                    x: 999999,
                    y: -999999,
                    h: 0,
                    w: 0
                }
            }
            extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function() {
                var l;
                if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), l = this.svgElement;
                else {
                    l = createNS("svg");
                    var i = this.comp.data ? this.comp.data : this.globalData.compSize;
                    l.setAttribute("width", i.w), l.setAttribute("height", i.h), l.appendChild(this.shapesContainer), this.layerElement.appendChild(l)
                }
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = l
            }, HShapeElement.prototype.getTransformedPoint = function(l, i) {
                var o, c = l.length;
                for (o = 0; o < c; o += 1) i = l[o].mProps.v.applyToPointArray(i[0], i[1], 0);
                return i
            }, HShapeElement.prototype.calculateShapeBoundingBox = function(l, i) {
                var o = l.sh.v,
                    c = l.transformers,
                    u, p = o._length,
                    m, g, _, v;
                if (!(p <= 1)) {
                    for (u = 0; u < p - 1; u += 1) m = this.getTransformedPoint(c, o.v[u]), g = this.getTransformedPoint(c, o.o[u]), _ = this.getTransformedPoint(c, o.i[u + 1]), v = this.getTransformedPoint(c, o.v[u + 1]), this.checkBounds(m, g, _, v, i);
                    o.c && (m = this.getTransformedPoint(c, o.v[u]), g = this.getTransformedPoint(c, o.o[u]), _ = this.getTransformedPoint(c, o.i[0]), v = this.getTransformedPoint(c, o.v[0]), this.checkBounds(m, g, _, v, i))
                }
            }, HShapeElement.prototype.checkBounds = function(l, i, o, c, u) {
                this.getBoundsOfCurve(l, i, o, c);
                var p = this.shapeBoundingBox;
                u.x = bmMin(p.left, u.x), u.xMax = bmMax(p.right, u.xMax), u.y = bmMin(p.top, u.y), u.yMax = bmMax(p.bottom, u.yMax)
            }, HShapeElement.prototype.shapeBoundingBox = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, HShapeElement.prototype.tempBoundingBox = {
                x: 0,
                xMax: 0,
                y: 0,
                yMax: 0,
                width: 0,
                height: 0
            }, HShapeElement.prototype.getBoundsOfCurve = function(l, i, o, c) {
                for (var u = [
                        [l[0], c[0]],
                        [l[1], c[1]]
                    ], p, m, g, _, v, x, y, b = 0; b < 2; ++b) m = 6 * l[b] - 12 * i[b] + 6 * o[b], p = -3 * l[b] + 9 * i[b] - 9 * o[b] + 3 * c[b], g = 3 * i[b] - 3 * l[b], m |= 0, p |= 0, g |= 0, p === 0 && m === 0 || (p === 0 ? (_ = -g / m, _ > 0 && _ < 1 && u[b].push(this.calculateF(_, l, i, o, c, b))) : (v = m * m - 4 * g * p, v >= 0 && (x = (-m + bmSqrt(v)) / (2 * p), x > 0 && x < 1 && u[b].push(this.calculateF(x, l, i, o, c, b)), y = (-m - bmSqrt(v)) / (2 * p), y > 0 && y < 1 && u[b].push(this.calculateF(y, l, i, o, c, b)))));
                this.shapeBoundingBox.left = bmMin.apply(null, u[0]), this.shapeBoundingBox.top = bmMin.apply(null, u[1]), this.shapeBoundingBox.right = bmMax.apply(null, u[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, u[1])
            }, HShapeElement.prototype.calculateF = function(l, i, o, c, u, p) {
                return bmPow(1 - l, 3) * i[p] + 3 * bmPow(1 - l, 2) * l * o[p] + 3 * (1 - l) * bmPow(l, 2) * c[p] + bmPow(l, 3) * u[p]
            }, HShapeElement.prototype.calculateBoundingBox = function(l, i) {
                var o, c = l.length;
                for (o = 0; o < c; o += 1) l[o] && l[o].sh ? this.calculateShapeBoundingBox(l[o], i) : l[o] && l[o].it ? this.calculateBoundingBox(l[o].it, i) : l[o] && l[o].style && l[o].w && this.expandStrokeBoundingBox(l[o].w, i)
            }, HShapeElement.prototype.expandStrokeBoundingBox = function(l, i) {
                var o = 0;
                if (l.keyframes) {
                    for (var c = 0; c < l.keyframes.length; c += 1) {
                        var u = l.keyframes[c].s;
                        u > o && (o = u)
                    }
                    o *= l.mult
                } else o = l.v * l.mult;
                i.x -= o, i.xMax += o, i.y -= o, i.yMax += o
            }, HShapeElement.prototype.currentBoxContains = function(l) {
                return this.currentBBox.x <= l.x && this.currentBBox.y <= l.y && this.currentBBox.width + this.currentBBox.x >= l.x + l.width && this.currentBBox.height + this.currentBBox.y >= l.y + l.height
            }, HShapeElement.prototype.renderInnerContent = function() {
                if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
                    var l = this.tempBoundingBox,
                        i = 999999;
                    if (l.x = i, l.xMax = -i, l.y = i, l.yMax = -i, this.calculateBoundingBox(this.itemsData, l), l.width = l.xMax < l.x ? 0 : l.xMax - l.x, l.height = l.yMax < l.y ? 0 : l.yMax - l.y, this.currentBoxContains(l)) return;
                    var o = !1;
                    if (this.currentBBox.w !== l.width && (this.currentBBox.w = l.width, this.shapeCont.setAttribute("width", l.width), o = !0), this.currentBBox.h !== l.height && (this.currentBBox.h = l.height, this.shapeCont.setAttribute("height", l.height), o = !0), o || this.currentBBox.x !== l.x || this.currentBBox.y !== l.y) {
                        this.currentBBox.w = l.width, this.currentBBox.h = l.height, this.currentBBox.x = l.x, this.currentBBox.y = l.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                        var c = this.shapeCont.style,
                            u = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                        c.transform = u, c.webkitTransform = u
                    }
                }
            };

            function HTextElement(l, i, o) {
                this.textSpans = [], this.textPaths = [], this.currentBBox = {
                    x: 999999,
                    y: -999999,
                    h: 0,
                    w: 0
                }, this.renderType = "svg", this.isMasked = !1, this.initElement(l, i, o)
            }
            extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function() {
                if (this.isMasked = this.checkMasks(), this.isMasked) {
                    this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
                    var l = createNS("g");
                    this.maskedElement.appendChild(l), this.innerElem = l
                } else this.renderType = "html", this.innerElem = this.layerElement;
                this.checkParenting()
            }, HTextElement.prototype.buildNewText = function() {
                var l = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(l.l ? l.l.length : 0);
                var i = this.innerElem.style,
                    o = l.fc ? this.buildColor(l.fc) : "rgba(0,0,0,0)";
                i.fill = o, i.color = o, l.sc && (i.stroke = this.buildColor(l.sc), i.strokeWidth = l.sw + "px");
                var c = this.globalData.fontManager.getFontByName(l.f);
                if (!this.globalData.fontManager.chars)
                    if (i.fontSize = l.finalSize + "px", i.lineHeight = l.finalSize + "px", c.fClass) this.innerElem.className = c.fClass;
                    else {
                        i.fontFamily = c.fFamily;
                        var u = l.fWeight,
                            p = l.fStyle;
                        i.fontStyle = p, i.fontWeight = u
                    }
                var m, g, _ = l.l;
                g = _.length;
                var v, x, y, b = this.mHelper,
                    S, C = "",
                    E = 0;
                for (m = 0; m < g; m += 1) {
                    if (this.globalData.fontManager.chars ? (this.textPaths[E] ? v = this.textPaths[E] : (v = createNS("path"), v.setAttribute("stroke-linecap", lineCapEnum[1]), v.setAttribute("stroke-linejoin", lineJoinEnum[2]), v.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[E] ? (x = this.textSpans[E], y = x.children[0]) : (x = createTag("div"), x.style.lineHeight = 0, y = createNS("svg"), y.appendChild(v), styleDiv(x)))) : this.isMasked ? v = this.textPaths[E] ? this.textPaths[E] : createNS("text") : this.textSpans[E] ? (x = this.textSpans[E], v = this.textPaths[E]) : (x = createTag("span"), styleDiv(x), v = createTag("span"), styleDiv(v), x.appendChild(v)), this.globalData.fontManager.chars) {
                        var P = this.globalData.fontManager.getCharData(l.finalText[m], c.fStyle, this.globalData.fontManager.getFontByName(l.f).fFamily),
                            w;
                        if (P ? w = P.data : w = null, b.reset(), w && w.shapes && w.shapes.length && (S = w.shapes[0].it, b.scale(l.finalSize / 100, l.finalSize / 100), C = this.createPathShape(b, S), v.setAttribute("d", C)), this.isMasked) this.innerElem.appendChild(v);
                        else {
                            if (this.innerElem.appendChild(x), w && w.shapes) {
                                document.body.appendChild(y);
                                var T = y.getBBox();
                                y.setAttribute("width", T.width + 2), y.setAttribute("height", T.height + 2), y.setAttribute("viewBox", T.x - 1 + " " + (T.y - 1) + " " + (T.width + 2) + " " + (T.height + 2));
                                var M = y.style,
                                    A = "translate(" + (T.x - 1) + "px," + (T.y - 1) + "px)";
                                M.transform = A, M.webkitTransform = A, _[m].yOffset = T.y - 1
                            } else y.setAttribute("width", 1), y.setAttribute("height", 1);
                            x.appendChild(y)
                        }
                    } else if (v.textContent = _[m].val, v.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked) this.innerElem.appendChild(v);
                    else {
                        this.innerElem.appendChild(x);
                        var D = v.style,
                            R = "translate3d(0," + -l.finalSize / 1.2 + "px,0)";
                        D.transform = R, D.webkitTransform = R
                    }
                    this.isMasked ? this.textSpans[E] = v : this.textSpans[E] = x, this.textSpans[E].style.display = "block", this.textPaths[E] = v, E += 1
                }
                for (; E < this.textSpans.length;) this.textSpans[E].style.display = "none", E += 1
            }, HTextElement.prototype.renderInnerContent = function() {
                this.validateText();
                var l;
                if (this.data.singleShape) {
                    if (!this._isFirstFrame && !this.lettersChangedFlag) return;
                    if (this.isMasked && this.finalTransform._matMdf) {
                        this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), l = this.svgElement.style;
                        var i = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                        l.transform = i, l.webkitTransform = i
                    }
                }
                if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) {
                    var o, c, u = 0,
                        p = this.textAnimator.renderedLetters,
                        m = this.textProperty.currentData.l;
                    c = m.length;
                    var g, _, v;
                    for (o = 0; o < c; o += 1) m[o].n ? u += 1 : (_ = this.textSpans[o], v = this.textPaths[o], g = p[u], u += 1, g._mdf.m && (this.isMasked ? _.setAttribute("transform", g.m) : (_.style.webkitTransform = g.m, _.style.transform = g.m)), _.style.opacity = g.o, g.sw && g._mdf.sw && v.setAttribute("stroke-width", g.sw), g.sc && g._mdf.sc && v.setAttribute("stroke", g.sc), g.fc && g._mdf.fc && (v.setAttribute("fill", g.fc), v.style.color = g.fc));
                    if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                        var x = this.innerElem.getBBox();
                        this.currentBBox.w !== x.width && (this.currentBBox.w = x.width, this.svgElement.setAttribute("width", x.width)), this.currentBBox.h !== x.height && (this.currentBBox.h = x.height, this.svgElement.setAttribute("height", x.height));
                        var y = 1;
                        if (this.currentBBox.w !== x.width + y * 2 || this.currentBBox.h !== x.height + y * 2 || this.currentBBox.x !== x.x - y || this.currentBBox.y !== x.y - y) {
                            this.currentBBox.w = x.width + y * 2, this.currentBBox.h = x.height + y * 2, this.currentBBox.x = x.x - y, this.currentBBox.y = x.y - y, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), l = this.svgElement.style;
                            var b = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                            l.transform = b, l.webkitTransform = b
                        }
                    }
                }
            };

            function HCameraElement(l, i, o) {
                this.initFrame(), this.initBaseData(l, i, o), this.initHierarchy();
                var c = PropertyFactory.getProp;
                if (this.pe = c(this, l.pe, 0, 0, this), l.ks.p.s ? (this.px = c(this, l.ks.p.x, 1, 0, this), this.py = c(this, l.ks.p.y, 1, 0, this), this.pz = c(this, l.ks.p.z, 1, 0, this)) : this.p = c(this, l.ks.p, 1, 0, this), l.ks.a && (this.a = c(this, l.ks.a, 1, 0, this)), l.ks.or.k.length && l.ks.or.k[0].to) {
                    var u, p = l.ks.or.k.length;
                    for (u = 0; u < p; u += 1) l.ks.or.k[u].to = null, l.ks.or.k[u].ti = null
                }
                this.or = c(this, l.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = c(this, l.ks.rx, 0, degToRads, this), this.ry = c(this, l.ks.ry, 0, degToRads, this), this.rz = c(this, l.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = {
                    mProp: this
                }
            }
            extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function() {
                var l, i = this.comp.threeDElements.length,
                    o, c, u;
                for (l = 0; l < i; l += 1)
                    if (o = this.comp.threeDElements[l], o.type === "3d") {
                        c = o.perspectiveElem.style, u = o.container.style;
                        var p = this.pe.v + "px",
                            m = "0px 0px 0px",
                            g = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                        c.perspective = p, c.webkitPerspective = p, u.transformOrigin = m, u.mozTransformOrigin = m, u.webkitTransformOrigin = m, c.transform = g, c.webkitTransform = g
                    }
            }, HCameraElement.prototype.createElements = function() {}, HCameraElement.prototype.hide = function() {}, HCameraElement.prototype.renderFrame = function() {
                var l = this._isFirstFrame,
                    i, o;
                if (this.hierarchy)
                    for (o = this.hierarchy.length, i = 0; i < o; i += 1) l = this.hierarchy[i].finalTransform.mProp._mdf || l;
                if (l || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                    if (this.mat.reset(), this.hierarchy)
                        for (o = this.hierarchy.length - 1, i = o; i >= 0; i -= 1) {
                            var c = this.hierarchy[i].finalTransform.mProp;
                            this.mat.translate(-c.p.v[0], -c.p.v[1], c.p.v[2]), this.mat.rotateX(-c.or.v[0]).rotateY(-c.or.v[1]).rotateZ(c.or.v[2]), this.mat.rotateX(-c.rx.v).rotateY(-c.ry.v).rotateZ(c.rz.v), this.mat.scale(1 / c.s.v[0], 1 / c.s.v[1], 1 / c.s.v[2]), this.mat.translate(c.a.v[0], c.a.v[1], c.a.v[2])
                        }
                    if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
                        var u;
                        this.p ? u = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : u = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                        var p = Math.sqrt(Math.pow(u[0], 2) + Math.pow(u[1], 2) + Math.pow(u[2], 2)),
                            m = [u[0] / p, u[1] / p, u[2] / p],
                            g = Math.sqrt(m[2] * m[2] + m[0] * m[0]),
                            _ = Math.atan2(m[1], g),
                            v = Math.atan2(m[0], -m[2]);
                        this.mat.rotateY(v).rotateX(-_)
                    }
                    this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
                    var x = !this._prevMat.equals(this.mat);
                    if ((x || this.pe._mdf) && this.comp.threeDElements) {
                        o = this.comp.threeDElements.length;
                        var y, b, S;
                        for (i = 0; i < o; i += 1)
                            if (y = this.comp.threeDElements[i], y.type === "3d") {
                                if (x) {
                                    var C = this.mat.toCSS();
                                    S = y.container.style, S.transform = C, S.webkitTransform = C
                                }
                                this.pe._mdf && (b = y.perspectiveElem.style, b.perspective = this.pe.v + "px", b.webkitPerspective = this.pe.v + "px")
                            }
                        this.mat.clone(this._prevMat)
                    }
                }
                this._isFirstFrame = !1
            }, HCameraElement.prototype.prepareFrame = function(l) {
                this.prepareProperties(l, !0)
            }, HCameraElement.prototype.destroy = function() {}, HCameraElement.prototype.getBaseElement = function() {
                return null
            };

            function HImageElement(l, i, o) {
                this.assetData = i.getAssetData(l.refId), this.initElement(l, i, o)
            }
            extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function() {
                var l = this.globalData.getAssetsPath(this.assetData),
                    i = new Image;
                this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", l), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(i), i.crossOrigin = "anonymous", i.src = l, this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
            };

            function HybridRendererBase(l, i) {
                this.animationItem = l, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
                    className: i && i.className || "",
                    imagePreserveAspectRatio: i && i.imagePreserveAspectRatio || "xMidYMid slice",
                    hideOnTransparent: !(i && i.hideOnTransparent === !1),
                    filterSize: {
                        width: i && i.filterSize && i.filterSize.width || "400%",
                        height: i && i.filterSize && i.filterSize.height || "400%",
                        x: i && i.filterSize && i.filterSize.x || "-100%",
                        y: i && i.filterSize && i.filterSize.y || "-100%"
                    }
                }, this.globalData = {
                    _mdf: !1,
                    frameNum: -1,
                    renderConfig: this.renderConfig
                }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
            }
            extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function() {
                for (; this.pendingElements.length;) {
                    var l = this.pendingElements.pop();
                    l.checkParenting()
                }
            }, HybridRendererBase.prototype.appendElementInPos = function(l, i) {
                var o = l.getBaseElement();
                if (o) {
                    var c = this.layers[i];
                    if (!c.ddd || !this.supports3d)
                        if (this.threeDElements) this.addTo3dContainer(o, i);
                        else {
                            for (var u = 0, p, m, g; u < i;) this.elements[u] && this.elements[u] !== !0 && this.elements[u].getBaseElement && (m = this.elements[u], g = this.layers[u].ddd ? this.getThreeDContainerByPos(u) : m.getBaseElement(), p = g || p), u += 1;
                            p ? (!c.ddd || !this.supports3d) && this.layerElement.insertBefore(o, p) : (!c.ddd || !this.supports3d) && this.layerElement.appendChild(o)
                        }
                    else this.addTo3dContainer(o, i)
                }
            }, HybridRendererBase.prototype.createShape = function(l) {
                return this.supports3d ? new HShapeElement(l, this.globalData, this) : new SVGShapeElement(l, this.globalData, this)
            }, HybridRendererBase.prototype.createText = function(l) {
                return this.supports3d ? new HTextElement(l, this.globalData, this) : new SVGTextLottieElement(l, this.globalData, this)
            }, HybridRendererBase.prototype.createCamera = function(l) {
                return this.camera = new HCameraElement(l, this.globalData, this), this.camera
            }, HybridRendererBase.prototype.createImage = function(l) {
                return this.supports3d ? new HImageElement(l, this.globalData, this) : new IImageElement(l, this.globalData, this)
            }, HybridRendererBase.prototype.createSolid = function(l) {
                return this.supports3d ? new HSolidElement(l, this.globalData, this) : new ISolidElement(l, this.globalData, this)
            }, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function(l) {
                for (var i = 0, o = this.threeDElements.length; i < o;) {
                    if (this.threeDElements[i].startPos <= l && this.threeDElements[i].endPos >= l) return this.threeDElements[i].perspectiveElem;
                    i += 1
                }
                return null
            }, HybridRendererBase.prototype.createThreeDContainer = function(l, i) {
                var o = createTag("div"),
                    c, u;
                styleDiv(o);
                var p = createTag("div");
                if (styleDiv(p), i === "3d") {
                    c = o.style, c.width = this.globalData.compSize.w + "px", c.height = this.globalData.compSize.h + "px";
                    var m = "50% 50%";
                    c.webkitTransformOrigin = m, c.mozTransformOrigin = m, c.transformOrigin = m, u = p.style;
                    var g = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                    u.transform = g, u.webkitTransform = g
                }
                o.appendChild(p);
                var _ = {
                    container: p,
                    perspectiveElem: o,
                    startPos: l,
                    endPos: l,
                    type: i
                };
                return this.threeDElements.push(_), _
            }, HybridRendererBase.prototype.build3dContainers = function() {
                var l, i = this.layers.length,
                    o, c = "";
                for (l = 0; l < i; l += 1) this.layers[l].ddd && this.layers[l].ty !== 3 ? (c !== "3d" && (c = "3d", o = this.createThreeDContainer(l, "3d")), o.endPos = Math.max(o.endPos, l)) : (c !== "2d" && (c = "2d", o = this.createThreeDContainer(l, "2d")), o.endPos = Math.max(o.endPos, l));
                for (i = this.threeDElements.length, l = i - 1; l >= 0; l -= 1) this.resizerElem.appendChild(this.threeDElements[l].perspectiveElem)
            }, HybridRendererBase.prototype.addTo3dContainer = function(l, i) {
                for (var o = 0, c = this.threeDElements.length; o < c;) {
                    if (i <= this.threeDElements[o].endPos) {
                        for (var u = this.threeDElements[o].startPos, p; u < i;) this.elements[u] && this.elements[u].getBaseElement && (p = this.elements[u].getBaseElement()), u += 1;
                        p ? this.threeDElements[o].container.insertBefore(l, p) : this.threeDElements[o].container.appendChild(l);
                        break
                    }
                    o += 1
                }
            }, HybridRendererBase.prototype.configAnimation = function(l) {
                var i = createTag("div"),
                    o = this.animationItem.wrapper,
                    c = i.style;
                c.width = l.w + "px", c.height = l.h + "px", this.resizerElem = i, styleDiv(i), c.transformStyle = "flat", c.mozTransformStyle = "flat", c.webkitTransformStyle = "flat", this.renderConfig.className && i.setAttribute("class", this.renderConfig.className), o.appendChild(i), c.overflow = "hidden";
                var u = createNS("svg");
                u.setAttribute("width", "1"), u.setAttribute("height", "1"), styleDiv(u), this.resizerElem.appendChild(u);
                var p = createNS("defs");
                u.appendChild(p), this.data = l, this.setupGlobalData(l, u), this.globalData.defs = p, this.layers = l.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize()
            }, HybridRendererBase.prototype.destroy = function() {
                this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
                var l, i = this.layers ? this.layers.length : 0;
                for (l = 0; l < i; l += 1) this.elements[l] && this.elements[l].destroy && this.elements[l].destroy();
                this.elements.length = 0, this.destroyed = !0, this.animationItem = null
            }, HybridRendererBase.prototype.updateContainerSize = function() {
                var l = this.animationItem.wrapper.offsetWidth,
                    i = this.animationItem.wrapper.offsetHeight,
                    o = l / i,
                    c = this.globalData.compSize.w / this.globalData.compSize.h,
                    u, p, m, g;
                c > o ? (u = l / this.globalData.compSize.w, p = l / this.globalData.compSize.w, m = 0, g = (i - this.globalData.compSize.h * (l / this.globalData.compSize.w)) / 2) : (u = i / this.globalData.compSize.h, p = i / this.globalData.compSize.h, m = (l - this.globalData.compSize.w * (i / this.globalData.compSize.h)) / 2, g = 0);
                var _ = this.resizerElem.style;
                _.webkitTransform = "matrix3d(" + u + ",0,0,0,0," + p + ",0,0,0,0,1,0," + m + "," + g + ",0,1)", _.transform = _.webkitTransform
            }, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function() {
                this.resizerElem.style.display = "none"
            }, HybridRendererBase.prototype.show = function() {
                this.resizerElem.style.display = "block"
            }, HybridRendererBase.prototype.initItems = function() {
                if (this.buildAllItems(), this.camera) this.camera.setup();
                else {
                    var l = this.globalData.compSize.w,
                        i = this.globalData.compSize.h,
                        o, c = this.threeDElements.length;
                    for (o = 0; o < c; o += 1) {
                        var u = this.threeDElements[o].perspectiveElem.style;
                        u.webkitPerspective = Math.sqrt(Math.pow(l, 2) + Math.pow(i, 2)) + "px", u.perspective = u.webkitPerspective
                    }
                }
            }, HybridRendererBase.prototype.searchExtraCompositions = function(l) {
                var i, o = l.length,
                    c = createTag("div");
                for (i = 0; i < o; i += 1)
                    if (l[i].xt) {
                        var u = this.createComp(l[i], c, this.globalData.comp, null);
                        u.initExpressions(), this.globalData.projectInterface.registerComposition(u)
                    }
            };

            function HCompElement(l, i, o) {
                this.layers = l.layers, this.supports3d = !l.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(l, i, o), this.tm = l.tm ? PropertyFactory.getProp(this, l.tm, 0, i.frameRate, this) : {
                    _placeholder: !0
                }
            }
            extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function() {
                this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
            }, HCompElement.prototype.addTo3dContainer = function(l, i) {
                for (var o = 0, c; o < i;) this.elements[o] && this.elements[o].getBaseElement && (c = this.elements[o].getBaseElement()), o += 1;
                c ? this.layerElement.insertBefore(l, c) : this.layerElement.appendChild(l)
            }, HCompElement.prototype.createComp = function(l) {
                return this.supports3d ? new HCompElement(l, this.globalData, this) : new SVGCompElement(l, this.globalData, this)
            };

            function HybridRenderer(l, i) {
                this.animationItem = l, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
                    className: i && i.className || "",
                    imagePreserveAspectRatio: i && i.imagePreserveAspectRatio || "xMidYMid slice",
                    hideOnTransparent: !(i && i.hideOnTransparent === !1),
                    filterSize: {
                        width: i && i.filterSize && i.filterSize.width || "400%",
                        height: i && i.filterSize && i.filterSize.height || "400%",
                        x: i && i.filterSize && i.filterSize.x || "-100%",
                        y: i && i.filterSize && i.filterSize.y || "-100%"
                    },
                    runExpressions: !i || i.runExpressions === void 0 || i.runExpressions
                }, this.globalData = {
                    _mdf: !1,
                    frameNum: -1,
                    renderConfig: this.renderConfig
                }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
            }
            extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function(l) {
                return this.supports3d ? new HCompElement(l, this.globalData, this) : new SVGCompElement(l, this.globalData, this)
            };
            var CompExpressionInterface = function() {
                return function(l) {
                    function i(o) {
                        for (var c = 0, u = l.layers.length; c < u;) {
                            if (l.layers[c].nm === o || l.layers[c].ind === o) return l.elements[c].layerInterface;
                            c += 1
                        }
                        return null
                    }
                    return Object.defineProperty(i, "_name", {
                        value: l.data.nm
                    }), i.layer = i, i.pixelAspect = 1, i.height = l.data.h || l.globalData.compSize.h, i.width = l.data.w || l.globalData.compSize.w, i.pixelAspect = 1, i.frameDuration = 1 / l.globalData.frameRate, i.displayStartTime = 0, i.numLayers = l.layers.length, i
                }
            }();

            function _typeof$2(l) {
                "@babel/helpers - typeof";
                return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
                    return typeof i
                } : function(i) {
                    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i
                }, _typeof$2(l)
            }

            function seedRandom(l, i) {
                var o = this,
                    c = 256,
                    u = 6,
                    p = 52,
                    m = "random",
                    g = i.pow(c, u),
                    _ = i.pow(2, p),
                    v = _ * 2,
                    x = c - 1,
                    y;

                function b(M, A, D) {
                    var R = [];
                    A = A === !0 ? {
                        entropy: !0
                    } : A || {};
                    var I = P(E(A.entropy ? [M, T(l)] : M === null ? w() : M, 3), R),
                        k = new S(R),
                        F = function() {
                            for (var B = k.g(u), U = g, H = 0; B < _;) B = (B + H) * c, U *= c, H = k.g(1);
                            for (; B >= v;) B /= 2, U /= 2, H >>>= 1;
                            return (B + H) / U
                        };
                    return F.int32 = function() {
                        return k.g(4) | 0
                    }, F.quick = function() {
                        return k.g(4) / 4294967296
                    }, F.double = F, P(T(k.S), l), (A.pass || D || function(V, B, U, H) {
                        return H && (H.S && C(H, k), V.state = function() {
                            return C(k, {})
                        }), U ? (i[m] = V, B) : V
                    })(F, I, "global" in A ? A.global : this == i, A.state)
                }
                i["seed" + m] = b;

                function S(M) {
                    var A, D = M.length,
                        R = this,
                        I = 0,
                        k = R.i = R.j = 0,
                        F = R.S = [];
                    for (D || (M = [D++]); I < c;) F[I] = I++;
                    for (I = 0; I < c; I++) F[I] = F[k = x & k + M[I % D] + (A = F[I])], F[k] = A;
                    R.g = function(V) {
                        for (var B, U = 0, H = R.i, Q = R.j, Y = R.S; V--;) B = Y[H = x & H + 1], U = U * c + Y[x & (Y[H] = Y[Q = x & Q + B]) + (Y[Q] = B)];
                        return R.i = H, R.j = Q, U
                    }
                }

                function C(M, A) {
                    return A.i = M.i, A.j = M.j, A.S = M.S.slice(), A
                }

                function E(M, A) {
                    var D = [],
                        R = _typeof$2(M),
                        I;
                    if (A && R == "object")
                        for (I in M) try {
                            D.push(E(M[I], A - 1))
                        } catch {}
                    return D.length ? D : R == "string" ? M : M + "\0"
                }

                function P(M, A) {
                    for (var D = M + "", R, I = 0; I < D.length;) A[x & I] = x & (R ^= A[x & I] * 19) + D.charCodeAt(I++);
                    return T(A)
                }

                function w() {
                    try {
                        var M = new Uint8Array(c);
                        return (o.crypto || o.msCrypto).getRandomValues(M), T(M)
                    } catch {
                        var A = o.navigator,
                            D = A && A.plugins;
                        return [+new Date, o, D, o.screen, T(l)]
                    }
                }

                function T(M) {
                    return String.fromCharCode.apply(0, M)
                }
                P(i.random(), l)
            }

            function initialize$2(l) {
                seedRandom([], l)
            }
            var propTypes = {
                SHAPE: "shape"
            };

            function _typeof$1(l) {
                "@babel/helpers - typeof";
                return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
                    return typeof i
                } : function(i) {
                    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i
                }, _typeof$1(l)
            }
            var ExpressionManager = function() {
                    var ob = {},
                        Math = BMMath,
                        window = null,
                        document = null,
                        XMLHttpRequest = null,
                        fetch = null,
                        frames = null,
                        _lottieGlobal = {};
                    initialize$2(BMMath);

                    function resetFrame() {
                        _lottieGlobal = {}
                    }

                    function $bm_isInstanceOfArray(l) {
                        return l.constructor === Array || l.constructor === Float32Array
                    }

                    function isNumerable(l, i) {
                        return l === "number" || i instanceof Number || l === "boolean" || l === "string"
                    }

                    function $bm_neg(l) {
                        var i = _typeof$1(l);
                        if (i === "number" || l instanceof Number || i === "boolean") return -l;
                        if ($bm_isInstanceOfArray(l)) {
                            var o, c = l.length,
                                u = [];
                            for (o = 0; o < c; o += 1) u[o] = -l[o];
                            return u
                        }
                        return l.propType ? l.v : -l
                    }
                    var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get,
                        easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get,
                        easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;

                    function sum(l, i) {
                        var o = _typeof$1(l),
                            c = _typeof$1(i);
                        if (isNumerable(o, l) && isNumerable(c, i) || o === "string" || c === "string") return l + i;
                        if ($bm_isInstanceOfArray(l) && isNumerable(c, i)) return l = l.slice(0), l[0] += i, l;
                        if (isNumerable(o, l) && $bm_isInstanceOfArray(i)) return i = i.slice(0), i[0] = l + i[0], i;
                        if ($bm_isInstanceOfArray(l) && $bm_isInstanceOfArray(i)) {
                            for (var u = 0, p = l.length, m = i.length, g = []; u < p || u < m;)(typeof l[u] == "number" || l[u] instanceof Number) && (typeof i[u] == "number" || i[u] instanceof Number) ? g[u] = l[u] + i[u] : g[u] = i[u] === void 0 ? l[u] : l[u] || i[u], u += 1;
                            return g
                        }
                        return 0
                    }
                    var add = sum;

                    function sub(l, i) {
                        var o = _typeof$1(l),
                            c = _typeof$1(i);
                        if (isNumerable(o, l) && isNumerable(c, i)) return o === "string" && (l = parseInt(l, 10)), c === "string" && (i = parseInt(i, 10)), l - i;
                        if ($bm_isInstanceOfArray(l) && isNumerable(c, i)) return l = l.slice(0), l[0] -= i, l;
                        if (isNumerable(o, l) && $bm_isInstanceOfArray(i)) return i = i.slice(0), i[0] = l - i[0], i;
                        if ($bm_isInstanceOfArray(l) && $bm_isInstanceOfArray(i)) {
                            for (var u = 0, p = l.length, m = i.length, g = []; u < p || u < m;)(typeof l[u] == "number" || l[u] instanceof Number) && (typeof i[u] == "number" || i[u] instanceof Number) ? g[u] = l[u] - i[u] : g[u] = i[u] === void 0 ? l[u] : l[u] || i[u], u += 1;
                            return g
                        }
                        return 0
                    }

                    function mul(l, i) {
                        var o = _typeof$1(l),
                            c = _typeof$1(i),
                            u;
                        if (isNumerable(o, l) && isNumerable(c, i)) return l * i;
                        var p, m;
                        if ($bm_isInstanceOfArray(l) && isNumerable(c, i)) {
                            for (m = l.length, u = createTypedArray("float32", m), p = 0; p < m; p += 1) u[p] = l[p] * i;
                            return u
                        }
                        if (isNumerable(o, l) && $bm_isInstanceOfArray(i)) {
                            for (m = i.length, u = createTypedArray("float32", m), p = 0; p < m; p += 1) u[p] = l * i[p];
                            return u
                        }
                        return 0
                    }

                    function div(l, i) {
                        var o = _typeof$1(l),
                            c = _typeof$1(i),
                            u;
                        if (isNumerable(o, l) && isNumerable(c, i)) return l / i;
                        var p, m;
                        if ($bm_isInstanceOfArray(l) && isNumerable(c, i)) {
                            for (m = l.length, u = createTypedArray("float32", m), p = 0; p < m; p += 1) u[p] = l[p] / i;
                            return u
                        }
                        if (isNumerable(o, l) && $bm_isInstanceOfArray(i)) {
                            for (m = i.length, u = createTypedArray("float32", m), p = 0; p < m; p += 1) u[p] = l / i[p];
                            return u
                        }
                        return 0
                    }

                    function mod(l, i) {
                        return typeof l == "string" && (l = parseInt(l, 10)), typeof i == "string" && (i = parseInt(i, 10)), l % i
                    }
                    var $bm_sum = sum,
                        $bm_sub = sub,
                        $bm_mul = mul,
                        $bm_div = div,
                        $bm_mod = mod;

                    function clamp(l, i, o) {
                        if (i > o) {
                            var c = o;
                            o = i, i = c
                        }
                        return Math.min(Math.max(l, i), o)
                    }

                    function radiansToDegrees(l) {
                        return l / degToRads
                    }
                    var radians_to_degrees = radiansToDegrees;

                    function degreesToRadians(l) {
                        return l * degToRads
                    }
                    var degrees_to_radians = radiansToDegrees,
                        helperLengthArray = [0, 0, 0, 0, 0, 0];

                    function length(l, i) {
                        if (typeof l == "number" || l instanceof Number) return i = i || 0, Math.abs(l - i);
                        i || (i = helperLengthArray);
                        var o, c = Math.min(l.length, i.length),
                            u = 0;
                        for (o = 0; o < c; o += 1) u += Math.pow(i[o] - l[o], 2);
                        return Math.sqrt(u)
                    }

                    function normalize(l) {
                        return div(l, length(l))
                    }

                    function rgbToHsl(l) {
                        var i = l[0],
                            o = l[1],
                            c = l[2],
                            u = Math.max(i, o, c),
                            p = Math.min(i, o, c),
                            m, g, _ = (u + p) / 2;
                        if (u === p) m = 0, g = 0;
                        else {
                            var v = u - p;
                            switch (g = _ > .5 ? v / (2 - u - p) : v / (u + p), u) {
                                case i:
                                    m = (o - c) / v + (o < c ? 6 : 0);
                                    break;
                                case o:
                                    m = (c - i) / v + 2;
                                    break;
                                case c:
                                    m = (i - o) / v + 4;
                                    break
                            }
                            m /= 6
                        }
                        return [m, g, _, l[3]]
                    }

                    function hue2rgb(l, i, o) {
                        return o < 0 && (o += 1), o > 1 && (o -= 1), o < 1 / 6 ? l + (i - l) * 6 * o : o < 1 / 2 ? i : o < 2 / 3 ? l + (i - l) * (2 / 3 - o) * 6 : l
                    }

                    function hslToRgb(l) {
                        var i = l[0],
                            o = l[1],
                            c = l[2],
                            u, p, m;
                        if (o === 0) u = c, m = c, p = c;
                        else {
                            var g = c < .5 ? c * (1 + o) : c + o - c * o,
                                _ = 2 * c - g;
                            u = hue2rgb(_, g, i + 1 / 3), p = hue2rgb(_, g, i), m = hue2rgb(_, g, i - 1 / 3)
                        }
                        return [u, p, m, l[3]]
                    }

                    function linear(l, i, o, c, u) {
                        if ((c === void 0 || u === void 0) && (c = i, u = o, i = 0, o = 1), o < i) {
                            var p = o;
                            o = i, i = p
                        }
                        if (l <= i) return c;
                        if (l >= o) return u;
                        var m = o === i ? 0 : (l - i) / (o - i);
                        if (!c.length) return c + (u - c) * m;
                        var g, _ = c.length,
                            v = createTypedArray("float32", _);
                        for (g = 0; g < _; g += 1) v[g] = c[g] + (u[g] - c[g]) * m;
                        return v
                    }

                    function random(l, i) {
                        if (i === void 0 && (l === void 0 ? (l = 0, i = 1) : (i = l, l = void 0)), i.length) {
                            var o, c = i.length;
                            l || (l = createTypedArray("float32", c));
                            var u = createTypedArray("float32", c),
                                p = BMMath.random();
                            for (o = 0; o < c; o += 1) u[o] = l[o] + p * (i[o] - l[o]);
                            return u
                        }
                        l === void 0 && (l = 0);
                        var m = BMMath.random();
                        return l + m * (i - l)
                    }

                    function createPath(l, i, o, c) {
                        var u, p = l.length,
                            m = shapePool.newElement();
                        m.setPathData(!!c, p);
                        var g = [0, 0],
                            _, v;
                        for (u = 0; u < p; u += 1) _ = i && i[u] ? i[u] : g, v = o && o[u] ? o[u] : g, m.setTripleAt(l[u][0], l[u][1], v[0] + l[u][0], v[1] + l[u][1], _[0] + l[u][0], _[1] + l[u][1], u, !0);
                        return m
                    }

                    function initiateExpression(elem, data, property) {
                        function noOp(l) {
                            return l
                        }
                        if (!elem.globalData.renderConfig.runExpressions) return noOp;
                        var val = data.x,
                            needsVelocity = /velocity(?![\w\d])/.test(val),
                            _needsRandom = val.indexOf("random") !== -1,
                            elemType = elem.data.ty,
                            transform, $bm_transform, content, effect, thisProperty = property;
                        thisProperty._name = elem.data.nm, thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
                            get: function() {
                                return thisProperty.v
                            }
                        }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
                        var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
                            outPoint = elem.data.op / elem.comp.globalData.frameRate,
                            width = elem.data.sw ? elem.data.sw : 0,
                            height = elem.data.sh ? elem.data.sh : 0,
                            name = elem.data.nm,
                            loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0],
                            numKeys = property.kf ? data.k.length : 0,
                            active = !this.data || this.data.hd !== !0,
                            wiggle = function l(i, o) {
                                var c, u, p = this.pv.length ? this.pv.length : 1,
                                    m = createTypedArray("float32", p);
                                i = 5;
                                var g = Math.floor(time * i);
                                for (c = 0, u = 0; c < g;) {
                                    for (u = 0; u < p; u += 1) m[u] += -o + o * 2 * BMMath.random();
                                    c += 1
                                }
                                var _ = time * i,
                                    v = _ - Math.floor(_),
                                    x = createTypedArray("float32", p);
                                if (p > 1) {
                                    for (u = 0; u < p; u += 1) x[u] = this.pv[u] + m[u] + (-o + o * 2 * BMMath.random()) * v;
                                    return x
                                }
                                return this.pv + m[0] + (-o + o * 2 * BMMath.random()) * v
                            }.bind(this);
                        thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty));

                        function loopInDuration(l, i) {
                            return loopIn(l, i, !0)
                        }

                        function loopOutDuration(l, i) {
                            return loopOut(l, i, !0)
                        }
                        this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

                        function lookAt(l, i) {
                            var o = [i[0] - l[0], i[1] - l[1], i[2] - l[2]],
                                c = Math.atan2(o[0], Math.sqrt(o[1] * o[1] + o[2] * o[2])) / degToRads,
                                u = -Math.atan2(o[1], o[2]) / degToRads;
                            return [u, c, 0]
                        }

                        function easeOut(l, i, o, c, u) {
                            return applyEase(easeOutBez, l, i, o, c, u)
                        }

                        function easeIn(l, i, o, c, u) {
                            return applyEase(easeInBez, l, i, o, c, u)
                        }

                        function ease(l, i, o, c, u) {
                            return applyEase(easeInOutBez, l, i, o, c, u)
                        }

                        function applyEase(l, i, o, c, u, p) {
                            u === void 0 ? (u = o, p = c) : i = (i - o) / (c - o), i > 1 ? i = 1 : i < 0 && (i = 0);
                            var m = l(i);
                            if ($bm_isInstanceOfArray(u)) {
                                var g, _ = u.length,
                                    v = createTypedArray("float32", _);
                                for (g = 0; g < _; g += 1) v[g] = (p[g] - u[g]) * m + u[g];
                                return v
                            }
                            return (p - u) * m + u
                        }

                        function nearestKey(l) {
                            var i, o = data.k.length,
                                c, u;
                            if (!data.k.length || typeof data.k[0] == "number") c = 0, u = 0;
                            else if (c = -1, l *= elem.comp.globalData.frameRate, l < data.k[0].t) c = 1, u = data.k[0].t;
                            else {
                                for (i = 0; i < o - 1; i += 1)
                                    if (l === data.k[i].t) {
                                        c = i + 1, u = data.k[i].t;
                                        break
                                    } else if (l > data.k[i].t && l < data.k[i + 1].t) {
                                    l - data.k[i].t > data.k[i + 1].t - l ? (c = i + 2, u = data.k[i + 1].t) : (c = i + 1, u = data.k[i].t);
                                    break
                                }
                                c === -1 && (c = i + 1, u = data.k[i].t)
                            }
                            var p = {};
                            return p.index = c, p.time = u / elem.comp.globalData.frameRate, p
                        }

                        function key(l) {
                            var i, o, c;
                            if (!data.k.length || typeof data.k[0] == "number") throw new Error("The property has no keyframe at index " + l);
                            l -= 1, i = {
                                time: data.k[l].t / elem.comp.globalData.frameRate,
                                value: []
                            };
                            var u = Object.prototype.hasOwnProperty.call(data.k[l], "s") ? data.k[l].s : data.k[l - 1].e;
                            for (c = u.length, o = 0; o < c; o += 1) i[o] = u[o], i.value[o] = u[o];
                            return i
                        }

                        function framesToTime(l, i) {
                            return i || (i = elem.comp.globalData.frameRate), l / i
                        }

                        function timeToFrames(l, i) {
                            return !l && l !== 0 && (l = time), i || (i = elem.comp.globalData.frameRate), l * i
                        }

                        function seedRandom(l) {
                            BMMath.seedrandom(randSeed + l)
                        }

                        function sourceRectAtTime() {
                            return elem.sourceRectAtTime()
                        }

                        function substring(l, i) {
                            return typeof value == "string" ? i === void 0 ? value.substring(l) : value.substring(l, i) : ""
                        }

                        function substr(l, i) {
                            return typeof value == "string" ? i === void 0 ? value.substr(l) : value.substr(l, i) : ""
                        }

                        function posterizeTime(l) {
                            time = l === 0 ? 0 : Math.floor(time * l) / l, value = valueAtTime(time)
                        }
                        var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind,
                            hasParent = !!(elem.hierarchy && elem.hierarchy.length),
                            parent, randSeed = Math.floor(Math.random() * 1e6),
                            globalData = elem.globalData;

                        function executeExpression(l) {
                            return value = l, this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), hasParent = !!(elem.hierarchy && elem.hierarchy.length), hasParent && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt, scoped_bm_rt)
                        }
                        return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression
                    }
                    return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal], ob.resetFrame = resetFrame, ob
                }(),
                Expressions = function() {
                    var l = {};
                    l.initExpressions = i, l.resetFrame = ExpressionManager.resetFrame;

                    function i(o) {
                        var c = 0,
                            u = [];

                        function p() {
                            c += 1
                        }

                        function m() {
                            c -= 1, c === 0 && _()
                        }

                        function g(v) {
                            u.indexOf(v) === -1 && u.push(v)
                        }

                        function _() {
                            var v, x = u.length;
                            for (v = 0; v < x; v += 1) u[v].release();
                            u.length = 0
                        }
                        o.renderer.compInterface = CompExpressionInterface(o.renderer), o.renderer.globalData.projectInterface.registerComposition(o.renderer), o.renderer.globalData.pushExpression = p, o.renderer.globalData.popExpression = m, o.renderer.globalData.registerExpressionProperty = g
                    }
                    return l
                }(),
                MaskManagerInterface = function() {
                    function l(o, c) {
                        this._mask = o, this._data = c
                    }
                    Object.defineProperty(l.prototype, "maskPath", {
                        get: function() {
                            return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
                        }
                    }), Object.defineProperty(l.prototype, "maskOpacity", {
                        get: function() {
                            return this._mask.op.k && this._mask.op.getValue(), this._mask.op.v * 100
                        }
                    });
                    var i = function(c) {
                        var u = createSizedArray(c.viewData.length),
                            p, m = c.viewData.length;
                        for (p = 0; p < m; p += 1) u[p] = new l(c.viewData[p], c.masksProperties[p]);
                        var g = function(v) {
                            for (p = 0; p < m;) {
                                if (c.masksProperties[p].nm === v) return u[p];
                                p += 1
                            }
                            return null
                        };
                        return g
                    };
                    return i
                }(),
                ExpressionPropertyInterface = function() {
                    var l = {
                            pv: 0,
                            v: 0,
                            mult: 1
                        },
                        i = {
                            pv: [0, 0, 0],
                            v: [0, 0, 0],
                            mult: 1
                        };

                    function o(m, g, _) {
                        Object.defineProperty(m, "velocity", {
                            get: function() {
                                return g.getVelocityAtTime(g.comp.currentFrame)
                            }
                        }), m.numKeys = g.keyframes ? g.keyframes.length : 0, m.key = function(v) {
                            if (!m.numKeys) return 0;
                            var x = "";
                            "s" in g.keyframes[v - 1] ? x = g.keyframes[v - 1].s : "e" in g.keyframes[v - 2] ? x = g.keyframes[v - 2].e : x = g.keyframes[v - 2].s;
                            var y = _ === "unidimensional" ? new Number(x) : Object.assign({}, x);
                            return y.time = g.keyframes[v - 1].t / g.elem.comp.globalData.frameRate, y.value = _ === "unidimensional" ? x[0] : x, y
                        }, m.valueAtTime = g.getValueAtTime, m.speedAtTime = g.getSpeedAtTime, m.velocityAtTime = g.getVelocityAtTime, m.propertyGroup = g.propertyGroup
                    }

                    function c(m) {
                        (!m || !("pv" in m)) && (m = l);
                        var g = 1 / m.mult,
                            _ = m.pv * g,
                            v = new Number(_);
                        return v.value = _, o(v, m, "unidimensional"),
                            function() {
                                return m.k && m.getValue(), _ = m.v * g, v.value !== _ && (v = new Number(_), v.value = _, v[0] = _, o(v, m, "unidimensional")), v
                            }
                    }

                    function u(m) {
                        (!m || !("pv" in m)) && (m = i);
                        var g = 1 / m.mult,
                            _ = m.data && m.data.l || m.pv.length,
                            v = createTypedArray("float32", _),
                            x = createTypedArray("float32", _);
                        return v.value = x, o(v, m, "multidimensional"),
                            function() {
                                m.k && m.getValue();
                                for (var y = 0; y < _; y += 1) x[y] = m.v[y] * g, v[y] = x[y];
                                return v
                            }
                    }

                    function p() {
                        return l
                    }
                    return function(m) {
                        return m ? m.propType === "unidimensional" ? c(m) : u(m) : p
                    }
                }(),
                TransformExpressionInterface = function() {
                    return function(l) {
                        function i(m) {
                            switch (m) {
                                case "scale":
                                case "Scale":
                                case "ADBE Scale":
                                case 6:
                                    return i.scale;
                                case "rotation":
                                case "Rotation":
                                case "ADBE Rotation":
                                case "ADBE Rotate Z":
                                case 10:
                                    return i.rotation;
                                case "ADBE Rotate X":
                                    return i.xRotation;
                                case "ADBE Rotate Y":
                                    return i.yRotation;
                                case "position":
                                case "Position":
                                case "ADBE Position":
                                case 2:
                                    return i.position;
                                case "ADBE Position_0":
                                    return i.xPosition;
                                case "ADBE Position_1":
                                    return i.yPosition;
                                case "ADBE Position_2":
                                    return i.zPosition;
                                case "anchorPoint":
                                case "AnchorPoint":
                                case "Anchor Point":
                                case "ADBE AnchorPoint":
                                case 1:
                                    return i.anchorPoint;
                                case "opacity":
                                case "Opacity":
                                case 11:
                                    return i.opacity;
                                default:
                                    return null
                            }
                        }
                        Object.defineProperty(i, "rotation", {
                            get: ExpressionPropertyInterface(l.r || l.rz)
                        }), Object.defineProperty(i, "zRotation", {
                            get: ExpressionPropertyInterface(l.rz || l.r)
                        }), Object.defineProperty(i, "xRotation", {
                            get: ExpressionPropertyInterface(l.rx)
                        }), Object.defineProperty(i, "yRotation", {
                            get: ExpressionPropertyInterface(l.ry)
                        }), Object.defineProperty(i, "scale", {
                            get: ExpressionPropertyInterface(l.s)
                        });
                        var o, c, u, p;
                        return l.p ? p = ExpressionPropertyInterface(l.p) : (o = ExpressionPropertyInterface(l.px), c = ExpressionPropertyInterface(l.py), l.pz && (u = ExpressionPropertyInterface(l.pz))), Object.defineProperty(i, "position", {
                            get: function() {
                                return l.p ? p() : [o(), c(), u ? u() : 0]
                            }
                        }), Object.defineProperty(i, "xPosition", {
                            get: ExpressionPropertyInterface(l.px)
                        }), Object.defineProperty(i, "yPosition", {
                            get: ExpressionPropertyInterface(l.py)
                        }), Object.defineProperty(i, "zPosition", {
                            get: ExpressionPropertyInterface(l.pz)
                        }), Object.defineProperty(i, "anchorPoint", {
                            get: ExpressionPropertyInterface(l.a)
                        }), Object.defineProperty(i, "opacity", {
                            get: ExpressionPropertyInterface(l.o)
                        }), Object.defineProperty(i, "skew", {
                            get: ExpressionPropertyInterface(l.sk)
                        }), Object.defineProperty(i, "skewAxis", {
                            get: ExpressionPropertyInterface(l.sa)
                        }), Object.defineProperty(i, "orientation", {
                            get: ExpressionPropertyInterface(l.or)
                        }), i
                    }
                }(),
                LayerExpressionInterface = function() {
                    function l(v) {
                        var x = new Matrix;
                        if (v !== void 0) {
                            var y = this._elem.finalTransform.mProp.getValueAtTime(v);
                            y.clone(x)
                        } else {
                            var b = this._elem.finalTransform.mProp;
                            b.applyToMatrix(x)
                        }
                        return x
                    }

                    function i(v, x) {
                        var y = this.getMatrix(x);
                        return y.props[12] = 0, y.props[13] = 0, y.props[14] = 0, this.applyPoint(y, v)
                    }

                    function o(v, x) {
                        var y = this.getMatrix(x);
                        return this.applyPoint(y, v)
                    }

                    function c(v, x) {
                        var y = this.getMatrix(x);
                        return y.props[12] = 0, y.props[13] = 0, y.props[14] = 0, this.invertPoint(y, v)
                    }

                    function u(v, x) {
                        var y = this.getMatrix(x);
                        return this.invertPoint(y, v)
                    }

                    function p(v, x) {
                        if (this._elem.hierarchy && this._elem.hierarchy.length) {
                            var y, b = this._elem.hierarchy.length;
                            for (y = 0; y < b; y += 1) this._elem.hierarchy[y].finalTransform.mProp.applyToMatrix(v)
                        }
                        return v.applyToPointArray(x[0], x[1], x[2] || 0)
                    }

                    function m(v, x) {
                        if (this._elem.hierarchy && this._elem.hierarchy.length) {
                            var y, b = this._elem.hierarchy.length;
                            for (y = 0; y < b; y += 1) this._elem.hierarchy[y].finalTransform.mProp.applyToMatrix(v)
                        }
                        return v.inversePoint(x)
                    }

                    function g(v) {
                        var x = new Matrix;
                        if (x.reset(), this._elem.finalTransform.mProp.applyToMatrix(x), this._elem.hierarchy && this._elem.hierarchy.length) {
                            var y, b = this._elem.hierarchy.length;
                            for (y = 0; y < b; y += 1) this._elem.hierarchy[y].finalTransform.mProp.applyToMatrix(x);
                            return x.inversePoint(v)
                        }
                        return x.inversePoint(v)
                    }

                    function _() {
                        return [1, 1, 1, 1]
                    }
                    return function(v) {
                        var x;

                        function y(E) {
                            S.mask = new MaskManagerInterface(E, v)
                        }

                        function b(E) {
                            S.effect = E
                        }

                        function S(E) {
                            switch (E) {
                                case "ADBE Root Vectors Group":
                                case "Contents":
                                case 2:
                                    return S.shapeInterface;
                                case 1:
                                case 6:
                                case "Transform":
                                case "transform":
                                case "ADBE Transform Group":
                                    return x;
                                case 4:
                                case "ADBE Effect Parade":
                                case "effects":
                                case "Effects":
                                    return S.effect;
                                case "ADBE Text Properties":
                                    return S.textInterface;
                                default:
                                    return null
                            }
                        }
                        S.getMatrix = l, S.invertPoint = m, S.applyPoint = p, S.toWorld = o, S.toWorldVec = i, S.fromWorld = u, S.fromWorldVec = c, S.toComp = o, S.fromComp = g, S.sampleImage = _, S.sourceRectAtTime = v.sourceRectAtTime.bind(v), S._elem = v, x = TransformExpressionInterface(v.finalTransform.mProp);
                        var C = getDescriptor(x, "anchorPoint");
                        return Object.defineProperties(S, {
                            hasParent: {
                                get: function() {
                                    return v.hierarchy.length
                                }
                            },
                            parent: {
                                get: function() {
                                    return v.hierarchy[0].layerInterface
                                }
                            },
                            rotation: getDescriptor(x, "rotation"),
                            scale: getDescriptor(x, "scale"),
                            position: getDescriptor(x, "position"),
                            opacity: getDescriptor(x, "opacity"),
                            anchorPoint: C,
                            anchor_point: C,
                            transform: {
                                get: function() {
                                    return x
                                }
                            },
                            active: {
                                get: function() {
                                    return v.isInRange
                                }
                            }
                        }), S.startTime = v.data.st, S.index = v.data.ind, S.source = v.data.refId, S.height = v.data.ty === 0 ? v.data.h : 100, S.width = v.data.ty === 0 ? v.data.w : 100, S.inPoint = v.data.ip / v.comp.globalData.frameRate, S.outPoint = v.data.op / v.comp.globalData.frameRate, S._name = v.data.nm, S.registerMaskInterface = y, S.registerEffectsInterface = b, S
                    }
                }(),
                propertyGroupFactory = function() {
                    return function(l, i) {
                        return function(o) {
                            return o = o === void 0 ? 1 : o, o <= 0 ? l : i(o - 1)
                        }
                    }
                }(),
                PropertyInterface = function() {
                    return function(l, i) {
                        var o = {
                            _name: l
                        };

                        function c(u) {
                            return u = u === void 0 ? 1 : u, u <= 0 ? o : i(u - 1)
                        }
                        return c
                    }
                }(),
                EffectsExpressionInterface = function() {
                    var l = {
                        createEffectsInterface: i
                    };

                    function i(u, p) {
                        if (u.effectsManager) {
                            var m = [],
                                g = u.data.ef,
                                _, v = u.effectsManager.effectElements.length;
                            for (_ = 0; _ < v; _ += 1) m.push(o(g[_], u.effectsManager.effectElements[_], p, u));
                            var x = u.data.ef || [],
                                y = function(S) {
                                    for (_ = 0, v = x.length; _ < v;) {
                                        if (S === x[_].nm || S === x[_].mn || S === x[_].ix) return m[_];
                                        _ += 1
                                    }
                                    return null
                                };
                            return Object.defineProperty(y, "numProperties", {
                                get: function() {
                                    return x.length
                                }
                            }), y
                        }
                        return null
                    }

                    function o(u, p, m, g) {
                        function _(S) {
                            for (var C = u.ef, E = 0, P = C.length; E < P;) {
                                if (S === C[E].nm || S === C[E].mn || S === C[E].ix) return C[E].ty === 5 ? x[E] : x[E]();
                                E += 1
                            }
                            throw new Error
                        }
                        var v = propertyGroupFactory(_, m),
                            x = [],
                            y, b = u.ef.length;
                        for (y = 0; y < b; y += 1) u.ef[y].ty === 5 ? x.push(o(u.ef[y], p.effectElements[y], p.effectElements[y].propertyGroup, g)) : x.push(c(p.effectElements[y], u.ef[y].ty, g, v));
                        return u.mn === "ADBE Color Control" && Object.defineProperty(_, "color", {
                            get: function() {
                                return x[0]()
                            }
                        }), Object.defineProperties(_, {
                            numProperties: {
                                get: function() {
                                    return u.np
                                }
                            },
                            _name: {
                                value: u.nm
                            },
                            propertyGroup: {
                                value: v
                            }
                        }), _.enabled = u.en !== 0, _.active = _.enabled, _
                    }

                    function c(u, p, m, g) {
                        var _ = ExpressionPropertyInterface(u.p);

                        function v() {
                            return p === 10 ? m.comp.compInterface(u.p.v) : _()
                        }
                        return u.p.setGroupProperty && u.p.setGroupProperty(PropertyInterface("", g)), v
                    }
                    return l
                }(),
                ShapePathInterface = function() {
                    return function(i, o, c) {
                        var u = o.sh;

                        function p(g) {
                            return g === "Shape" || g === "shape" || g === "Path" || g === "path" || g === "ADBE Vector Shape" || g === 2 ? p.path : null
                        }
                        var m = propertyGroupFactory(p, c);
                        return u.setGroupProperty(PropertyInterface("Path", m)), Object.defineProperties(p, {
                            path: {
                                get: function() {
                                    return u.k && u.getValue(), u
                                }
                            },
                            shape: {
                                get: function() {
                                    return u.k && u.getValue(), u
                                }
                            },
                            _name: {
                                value: i.nm
                            },
                            ix: {
                                value: i.ix
                            },
                            propertyIndex: {
                                value: i.ix
                            },
                            mn: {
                                value: i.mn
                            },
                            propertyGroup: {
                                value: c
                            }
                        }), p
                    }
                }(),
                ShapeExpressionInterface = function() {
                    function l(C, E, P) {
                        var w = [],
                            T, M = C ? C.length : 0;
                        for (T = 0; T < M; T += 1) C[T].ty === "gr" ? w.push(o(C[T], E[T], P)) : C[T].ty === "fl" ? w.push(c(C[T], E[T], P)) : C[T].ty === "st" ? w.push(m(C[T], E[T], P)) : C[T].ty === "tm" ? w.push(g(C[T], E[T], P)) : C[T].ty === "tr" || (C[T].ty === "el" ? w.push(v(C[T], E[T], P)) : C[T].ty === "sr" ? w.push(x(C[T], E[T], P)) : C[T].ty === "sh" ? w.push(ShapePathInterface(C[T], E[T], P)) : C[T].ty === "rc" ? w.push(y(C[T], E[T], P)) : C[T].ty === "rd" ? w.push(b(C[T], E[T], P)) : C[T].ty === "rp" ? w.push(S(C[T], E[T], P)) : C[T].ty === "gf" ? w.push(u(C[T], E[T], P)) : w.push(p(C[T], E[T])));
                        return w
                    }

                    function i(C, E, P) {
                        var w, T = function(D) {
                            for (var R = 0, I = w.length; R < I;) {
                                if (w[R]._name === D || w[R].mn === D || w[R].propertyIndex === D || w[R].ix === D || w[R].ind === D) return w[R];
                                R += 1
                            }
                            return typeof D == "number" ? w[D - 1] : null
                        };
                        T.propertyGroup = propertyGroupFactory(T, P), w = l(C.it, E.it, T.propertyGroup), T.numProperties = w.length;
                        var M = _(C.it[C.it.length - 1], E.it[E.it.length - 1], T.propertyGroup);
                        return T.transform = M, T.propertyIndex = C.cix, T._name = C.nm, T
                    }

                    function o(C, E, P) {
                        var w = function(D) {
                            switch (D) {
                                case "ADBE Vectors Group":
                                case "Contents":
                                case 2:
                                    return w.content;
                                default:
                                    return w.transform
                            }
                        };
                        w.propertyGroup = propertyGroupFactory(w, P);
                        var T = i(C, E, w.propertyGroup),
                            M = _(C.it[C.it.length - 1], E.it[E.it.length - 1], w.propertyGroup);
                        return w.content = T, w.transform = M, Object.defineProperty(w, "_name", {
                            get: function() {
                                return C.nm
                            }
                        }), w.numProperties = C.np, w.propertyIndex = C.ix, w.nm = C.nm, w.mn = C.mn, w
                    }

                    function c(C, E, P) {
                        function w(T) {
                            return T === "Color" || T === "color" ? w.color : T === "Opacity" || T === "opacity" ? w.opacity : null
                        }
                        return Object.defineProperties(w, {
                            color: {
                                get: ExpressionPropertyInterface(E.c)
                            },
                            opacity: {
                                get: ExpressionPropertyInterface(E.o)
                            },
                            _name: {
                                value: C.nm
                            },
                            mn: {
                                value: C.mn
                            }
                        }), E.c.setGroupProperty(PropertyInterface("Color", P)), E.o.setGroupProperty(PropertyInterface("Opacity", P)), w
                    }

                    function u(C, E, P) {
                        function w(T) {
                            return T === "Start Point" || T === "start point" ? w.startPoint : T === "End Point" || T === "end point" ? w.endPoint : T === "Opacity" || T === "opacity" ? w.opacity : null
                        }
                        return Object.defineProperties(w, {
                            startPoint: {
                                get: ExpressionPropertyInterface(E.s)
                            },
                            endPoint: {
                                get: ExpressionPropertyInterface(E.e)
                            },
                            opacity: {
                                get: ExpressionPropertyInterface(E.o)
                            },
                            type: {
                                get: function() {
                                    return "a"
                                }
                            },
                            _name: {
                                value: C.nm
                            },
                            mn: {
                                value: C.mn
                            }
                        }), E.s.setGroupProperty(PropertyInterface("Start Point", P)), E.e.setGroupProperty(PropertyInterface("End Point", P)), E.o.setGroupProperty(PropertyInterface("Opacity", P)), w
                    }

                    function p() {
                        function C() {
                            return null
                        }
                        return C
                    }

                    function m(C, E, P) {
                        var w = propertyGroupFactory(I, P),
                            T = propertyGroupFactory(R, w);

                        function M(k) {
                            Object.defineProperty(R, C.d[k].nm, {
                                get: ExpressionPropertyInterface(E.d.dataProps[k].p)
                            })
                        }
                        var A, D = C.d ? C.d.length : 0,
                            R = {};
                        for (A = 0; A < D; A += 1) M(A), E.d.dataProps[A].p.setGroupProperty(T);

                        function I(k) {
                            return k === "Color" || k === "color" ? I.color : k === "Opacity" || k === "opacity" ? I.opacity : k === "Stroke Width" || k === "stroke width" ? I.strokeWidth : null
                        }
                        return Object.defineProperties(I, {
                            color: {
                                get: ExpressionPropertyInterface(E.c)
                            },
                            opacity: {
                                get: ExpressionPropertyInterface(E.o)
                            },
                            strokeWidth: {
                                get: ExpressionPropertyInterface(E.w)
                            },
                            dash: {
                                get: function() {
                                    return R
                                }
                            },
                            _name: {
                                value: C.nm
                            },
                            mn: {
                                value: C.mn
                            }
                        }), E.c.setGroupProperty(PropertyInterface("Color", w)), E.o.setGroupProperty(PropertyInterface("Opacity", w)), E.w.setGroupProperty(PropertyInterface("Stroke Width", w)), I
                    }

                    function g(C, E, P) {
                        function w(M) {
                            return M === C.e.ix || M === "End" || M === "end" ? w.end : M === C.s.ix ? w.start : M === C.o.ix ? w.offset : null
                        }
                        var T = propertyGroupFactory(w, P);
                        return w.propertyIndex = C.ix, E.s.setGroupProperty(PropertyInterface("Start", T)), E.e.setGroupProperty(PropertyInterface("End", T)), E.o.setGroupProperty(PropertyInterface("Offset", T)), w.propertyIndex = C.ix, w.propertyGroup = P, Object.defineProperties(w, {
                            start: {
                                get: ExpressionPropertyInterface(E.s)
                            },
                            end: {
                                get: ExpressionPropertyInterface(E.e)
                            },
                            offset: {
                                get: ExpressionPropertyInterface(E.o)
                            },
                            _name: {
                                value: C.nm
                            }
                        }), w.mn = C.mn, w
                    }

                    function _(C, E, P) {
                        function w(M) {
                            return C.a.ix === M || M === "Anchor Point" ? w.anchorPoint : C.o.ix === M || M === "Opacity" ? w.opacity : C.p.ix === M || M === "Position" ? w.position : C.r.ix === M || M === "Rotation" || M === "ADBE Vector Rotation" ? w.rotation : C.s.ix === M || M === "Scale" ? w.scale : C.sk && C.sk.ix === M || M === "Skew" ? w.skew : C.sa && C.sa.ix === M || M === "Skew Axis" ? w.skewAxis : null
                        }
                        var T = propertyGroupFactory(w, P);
                        return E.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", T)), E.transform.mProps.p.setGroupProperty(PropertyInterface("Position", T)), E.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", T)), E.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", T)), E.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", T)), E.transform.mProps.sk && (E.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", T)), E.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", T))), E.transform.op.setGroupProperty(PropertyInterface("Opacity", T)), Object.defineProperties(w, {
                            opacity: {
                                get: ExpressionPropertyInterface(E.transform.mProps.o)
                            },
                            position: {
                                get: ExpressionPropertyInterface(E.transform.mProps.p)
                            },
                            anchorPoint: {
                                get: ExpressionPropertyInterface(E.transform.mProps.a)
                            },
                            scale: {
                                get: ExpressionPropertyInterface(E.transform.mProps.s)
                            },
                            rotation: {
                                get: ExpressionPropertyInterface(E.transform.mProps.r)
                            },
                            skew: {
                                get: ExpressionPropertyInterface(E.transform.mProps.sk)
                            },
                            skewAxis: {
                                get: ExpressionPropertyInterface(E.transform.mProps.sa)
                            },
                            _name: {
                                value: C.nm
                            }
                        }), w.ty = "tr", w.mn = C.mn, w.propertyGroup = P, w
                    }

                    function v(C, E, P) {
                        function w(A) {
                            return C.p.ix === A ? w.position : C.s.ix === A ? w.size : null
                        }
                        var T = propertyGroupFactory(w, P);
                        w.propertyIndex = C.ix;
                        var M = E.sh.ty === "tm" ? E.sh.prop : E.sh;
                        return M.s.setGroupProperty(PropertyInterface("Size", T)), M.p.setGroupProperty(PropertyInterface("Position", T)), Object.defineProperties(w, {
                            size: {
                                get: ExpressionPropertyInterface(M.s)
                            },
                            position: {
                                get: ExpressionPropertyInterface(M.p)
                            },
                            _name: {
                                value: C.nm
                            }
                        }), w.mn = C.mn, w
                    }

                    function x(C, E, P) {
                        function w(A) {
                            return C.p.ix === A ? w.position : C.r.ix === A ? w.rotation : C.pt.ix === A ? w.points : C.or.ix === A || A === "ADBE Vector Star Outer Radius" ? w.outerRadius : C.os.ix === A ? w.outerRoundness : C.ir && (C.ir.ix === A || A === "ADBE Vector Star Inner Radius") ? w.innerRadius : C.is && C.is.ix === A ? w.innerRoundness : null
                        }
                        var T = propertyGroupFactory(w, P),
                            M = E.sh.ty === "tm" ? E.sh.prop : E.sh;
                        return w.propertyIndex = C.ix, M.or.setGroupProperty(PropertyInterface("Outer Radius", T)), M.os.setGroupProperty(PropertyInterface("Outer Roundness", T)), M.pt.setGroupProperty(PropertyInterface("Points", T)), M.p.setGroupProperty(PropertyInterface("Position", T)), M.r.setGroupProperty(PropertyInterface("Rotation", T)), C.ir && (M.ir.setGroupProperty(PropertyInterface("Inner Radius", T)), M.is.setGroupProperty(PropertyInterface("Inner Roundness", T))), Object.defineProperties(w, {
                            position: {
                                get: ExpressionPropertyInterface(M.p)
                            },
                            rotation: {
                                get: ExpressionPropertyInterface(M.r)
                            },
                            points: {
                                get: ExpressionPropertyInterface(M.pt)
                            },
                            outerRadius: {
                                get: ExpressionPropertyInterface(M.or)
                            },
                            outerRoundness: {
                                get: ExpressionPropertyInterface(M.os)
                            },
                            innerRadius: {
                                get: ExpressionPropertyInterface(M.ir)
                            },
                            innerRoundness: {
                                get: ExpressionPropertyInterface(M.is)
                            },
                            _name: {
                                value: C.nm
                            }
                        }), w.mn = C.mn, w
                    }

                    function y(C, E, P) {
                        function w(A) {
                            return C.p.ix === A ? w.position : C.r.ix === A ? w.roundness : C.s.ix === A || A === "Size" || A === "ADBE Vector Rect Size" ? w.size : null
                        }
                        var T = propertyGroupFactory(w, P),
                            M = E.sh.ty === "tm" ? E.sh.prop : E.sh;
                        return w.propertyIndex = C.ix, M.p.setGroupProperty(PropertyInterface("Position", T)), M.s.setGroupProperty(PropertyInterface("Size", T)), M.r.setGroupProperty(PropertyInterface("Rotation", T)), Object.defineProperties(w, {
                            position: {
                                get: ExpressionPropertyInterface(M.p)
                            },
                            roundness: {
                                get: ExpressionPropertyInterface(M.r)
                            },
                            size: {
                                get: ExpressionPropertyInterface(M.s)
                            },
                            _name: {
                                value: C.nm
                            }
                        }), w.mn = C.mn, w
                    }

                    function b(C, E, P) {
                        function w(A) {
                            return C.r.ix === A || A === "Round Corners 1" ? w.radius : null
                        }
                        var T = propertyGroupFactory(w, P),
                            M = E;
                        return w.propertyIndex = C.ix, M.rd.setGroupProperty(PropertyInterface("Radius", T)), Object.defineProperties(w, {
                            radius: {
                                get: ExpressionPropertyInterface(M.rd)
                            },
                            _name: {
                                value: C.nm
                            }
                        }), w.mn = C.mn, w
                    }

                    function S(C, E, P) {
                        function w(A) {
                            return C.c.ix === A || A === "Copies" ? w.copies : C.o.ix === A || A === "Offset" ? w.offset : null
                        }
                        var T = propertyGroupFactory(w, P),
                            M = E;
                        return w.propertyIndex = C.ix, M.c.setGroupProperty(PropertyInterface("Copies", T)), M.o.setGroupProperty(PropertyInterface("Offset", T)), Object.defineProperties(w, {
                            copies: {
                                get: ExpressionPropertyInterface(M.c)
                            },
                            offset: {
                                get: ExpressionPropertyInterface(M.o)
                            },
                            _name: {
                                value: C.nm
                            }
                        }), w.mn = C.mn, w
                    }
                    return function(C, E, P) {
                        var w;

                        function T(A) {
                            if (typeof A == "number") return A = A === void 0 ? 1 : A, A === 0 ? P : w[A - 1];
                            for (var D = 0, R = w.length; D < R;) {
                                if (w[D]._name === A) return w[D];
                                D += 1
                            }
                            return null
                        }

                        function M() {
                            return P
                        }
                        return T.propertyGroup = propertyGroupFactory(T, M), w = l(C, E, T.propertyGroup), T.numProperties = w.length, T._name = "Contents", T
                    }
                }(),
                TextExpressionInterface = function() {
                    return function(l) {
                        var i;

                        function o(c) {
                            switch (c) {
                                case "ADBE Text Document":
                                    return o.sourceText;
                                default:
                                    return null
                            }
                        }
                        return Object.defineProperty(o, "sourceText", {
                            get: function() {
                                l.textProperty.getValue();
                                var u = l.textProperty.currentData.t;
                                return (!i || u !== i.value) && (i = new String(u), i.value = u || new String(u), Object.defineProperty(i, "style", {
                                    get: function() {
                                        return {
                                            fillColor: l.textProperty.currentData.fc
                                        }
                                    }
                                })), i
                            }
                        }), o
                    }
                }();

            function _typeof(l) {
                "@babel/helpers - typeof";
                return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
                    return typeof i
                } : function(i) {
                    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i
                }, _typeof(l)
            }
            var FootageInterface = function() {
                    var l = function(c) {
                            var u = "",
                                p = c.getFootageData();

                            function m() {
                                return u = "", p = c.getFootageData(), g
                            }

                            function g(_) {
                                if (p[_]) return u = _, p = p[_], _typeof(p) === "object" ? g : p;
                                var v = _.indexOf(u);
                                if (v !== -1) {
                                    var x = parseInt(_.substr(v + u.length), 10);
                                    return p = p[x], _typeof(p) === "object" ? g : p
                                }
                                return ""
                            }
                            return m
                        },
                        i = function(c) {
                            function u(p) {
                                return p === "Outline" ? u.outlineInterface() : null
                            }
                            return u._name = "Outline", u.outlineInterface = l(c), u
                        };
                    return function(o) {
                        function c(u) {
                            return u === "Data" ? c.dataInterface : null
                        }
                        return c._name = "Data", c.dataInterface = i(o), c
                    }
                }(),
                interfaces = {
                    layer: LayerExpressionInterface,
                    effects: EffectsExpressionInterface,
                    comp: CompExpressionInterface,
                    shape: ShapeExpressionInterface,
                    text: TextExpressionInterface,
                    footage: FootageInterface
                };

            function getInterface(l) {
                return interfaces[l] || null
            }
            var expressionHelpers = function() {
                function l(m, g, _) {
                    g.x && (_.k = !0, _.x = !0, _.initiateExpression = ExpressionManager.initiateExpression, _.effectsSequence.push(_.initiateExpression(m, g, _).bind(_)))
                }

                function i(m) {
                    return m *= this.elem.globalData.frameRate, m -= this.offsetTime, m !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < m ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(m, this._cachingAtTime), this._cachingAtTime.lastFrame = m), this._cachingAtTime.value
                }

                function o(m) {
                    var g = -.01,
                        _ = this.getValueAtTime(m),
                        v = this.getValueAtTime(m + g),
                        x = 0;
                    if (_.length) {
                        var y;
                        for (y = 0; y < _.length; y += 1) x += Math.pow(v[y] - _[y], 2);
                        x = Math.sqrt(x) * 100
                    } else x = 0;
                    return x
                }

                function c(m) {
                    if (this.vel !== void 0) return this.vel;
                    var g = -.001,
                        _ = this.getValueAtTime(m),
                        v = this.getValueAtTime(m + g),
                        x;
                    if (_.length) {
                        x = createTypedArray("float32", _.length);
                        var y;
                        for (y = 0; y < _.length; y += 1) x[y] = (v[y] - _[y]) / g
                    } else x = (v - _) / g;
                    return x
                }

                function u() {
                    return this.pv
                }

                function p(m) {
                    this.propertyGroup = m
                }
                return {
                    searchExpressions: l,
                    getSpeedAtTime: o,
                    getVelocityAtTime: c,
                    getValueAtTime: i,
                    getStaticValueAtTime: u,
                    setGroupProperty: p
                }
            }();

            function addPropertyDecorator() {
                function l(b, S, C) {
                    if (!this.k || !this.keyframes) return this.pv;
                    b = b ? b.toLowerCase() : "";
                    var E = this.comp.renderedFrame,
                        P = this.keyframes,
                        w = P[P.length - 1].t;
                    if (E <= w) return this.pv;
                    var T, M;
                    C ? (S ? T = Math.abs(w - this.elem.comp.globalData.frameRate * S) : T = Math.max(0, w - this.elem.data.ip), M = w - T) : ((!S || S > P.length - 1) && (S = P.length - 1), M = P[P.length - 1 - S].t, T = w - M);
                    var A, D, R;
                    if (b === "pingpong") {
                        var I = Math.floor((E - M) / T);
                        if (I % 2 !== 0) return this.getValueAtTime((T - (E - M) % T + M) / this.comp.globalData.frameRate, 0)
                    } else if (b === "offset") {
                        var k = this.getValueAtTime(M / this.comp.globalData.frameRate, 0),
                            F = this.getValueAtTime(w / this.comp.globalData.frameRate, 0),
                            V = this.getValueAtTime(((E - M) % T + M) / this.comp.globalData.frameRate, 0),
                            B = Math.floor((E - M) / T);
                        if (this.pv.length) {
                            for (R = new Array(k.length), D = R.length, A = 0; A < D; A += 1) R[A] = (F[A] - k[A]) * B + V[A];
                            return R
                        }
                        return (F - k) * B + V
                    } else if (b === "continue") {
                        var U = this.getValueAtTime(w / this.comp.globalData.frameRate, 0),
                            H = this.getValueAtTime((w - .001) / this.comp.globalData.frameRate, 0);
                        if (this.pv.length) {
                            for (R = new Array(U.length), D = R.length, A = 0; A < D; A += 1) R[A] = U[A] + (U[A] - H[A]) * ((E - w) / this.comp.globalData.frameRate) / 5e-4;
                            return R
                        }
                        return U + (U - H) * ((E - w) / .001)
                    }
                    return this.getValueAtTime(((E - M) % T + M) / this.comp.globalData.frameRate, 0)
                }

                function i(b, S, C) {
                    if (!this.k) return this.pv;
                    b = b ? b.toLowerCase() : "";
                    var E = this.comp.renderedFrame,
                        P = this.keyframes,
                        w = P[0].t;
                    if (E >= w) return this.pv;
                    var T, M;
                    C ? (S ? T = Math.abs(this.elem.comp.globalData.frameRate * S) : T = Math.max(0, this.elem.data.op - w), M = w + T) : ((!S || S > P.length - 1) && (S = P.length - 1), M = P[S].t, T = M - w);
                    var A, D, R;
                    if (b === "pingpong") {
                        var I = Math.floor((w - E) / T);
                        if (I % 2 === 0) return this.getValueAtTime(((w - E) % T + w) / this.comp.globalData.frameRate, 0)
                    } else if (b === "offset") {
                        var k = this.getValueAtTime(w / this.comp.globalData.frameRate, 0),
                            F = this.getValueAtTime(M / this.comp.globalData.frameRate, 0),
                            V = this.getValueAtTime((T - (w - E) % T + w) / this.comp.globalData.frameRate, 0),
                            B = Math.floor((w - E) / T) + 1;
                        if (this.pv.length) {
                            for (R = new Array(k.length), D = R.length, A = 0; A < D; A += 1) R[A] = V[A] - (F[A] - k[A]) * B;
                            return R
                        }
                        return V - (F - k) * B
                    } else if (b === "continue") {
                        var U = this.getValueAtTime(w / this.comp.globalData.frameRate, 0),
                            H = this.getValueAtTime((w + .001) / this.comp.globalData.frameRate, 0);
                        if (this.pv.length) {
                            for (R = new Array(U.length), D = R.length, A = 0; A < D; A += 1) R[A] = U[A] + (U[A] - H[A]) * (w - E) / .001;
                            return R
                        }
                        return U + (U - H) * (w - E) / .001
                    }
                    return this.getValueAtTime((T - ((w - E) % T + w)) / this.comp.globalData.frameRate, 0)
                }

                function o(b, S) {
                    if (!this.k) return this.pv;
                    if (b = (b || .4) * .5, S = Math.floor(S || 5), S <= 1) return this.pv;
                    var C = this.comp.renderedFrame / this.comp.globalData.frameRate,
                        E = C - b,
                        P = C + b,
                        w = S > 1 ? (P - E) / (S - 1) : 1,
                        T = 0,
                        M = 0,
                        A;
                    this.pv.length ? A = createTypedArray("float32", this.pv.length) : A = 0;
                    for (var D; T < S;) {
                        if (D = this.getValueAtTime(E + T * w), this.pv.length)
                            for (M = 0; M < this.pv.length; M += 1) A[M] += D[M];
                        else A += D;
                        T += 1
                    }
                    if (this.pv.length)
                        for (M = 0; M < this.pv.length; M += 1) A[M] /= S;
                    else A /= S;
                    return A
                }

                function c(b) {
                    this._transformCachingAtTime || (this._transformCachingAtTime = {
                        v: new Matrix
                    });
                    var S = this._transformCachingAtTime.v;
                    if (S.cloneFromProps(this.pre.props), this.appliedTransformations < 1) {
                        var C = this.a.getValueAtTime(b);
                        S.translate(-C[0] * this.a.mult, -C[1] * this.a.mult, C[2] * this.a.mult)
                    }
                    if (this.appliedTransformations < 2) {
                        var E = this.s.getValueAtTime(b);
                        S.scale(E[0] * this.s.mult, E[1] * this.s.mult, E[2] * this.s.mult)
                    }
                    if (this.sk && this.appliedTransformations < 3) {
                        var P = this.sk.getValueAtTime(b),
                            w = this.sa.getValueAtTime(b);
                        S.skewFromAxis(-P * this.sk.mult, w * this.sa.mult)
                    }
                    if (this.r && this.appliedTransformations < 4) {
                        var T = this.r.getValueAtTime(b);
                        S.rotate(-T * this.r.mult)
                    } else if (!this.r && this.appliedTransformations < 4) {
                        var M = this.rz.getValueAtTime(b),
                            A = this.ry.getValueAtTime(b),
                            D = this.rx.getValueAtTime(b),
                            R = this.or.getValueAtTime(b);
                        S.rotateZ(-M * this.rz.mult).rotateY(A * this.ry.mult).rotateX(D * this.rx.mult).rotateZ(-R[2] * this.or.mult).rotateY(R[1] * this.or.mult).rotateX(R[0] * this.or.mult)
                    }
                    if (this.data.p && this.data.p.s) {
                        var I = this.px.getValueAtTime(b),
                            k = this.py.getValueAtTime(b);
                        if (this.data.p.z) {
                            var F = this.pz.getValueAtTime(b);
                            S.translate(I * this.px.mult, k * this.py.mult, -F * this.pz.mult)
                        } else S.translate(I * this.px.mult, k * this.py.mult, 0)
                    } else {
                        var V = this.p.getValueAtTime(b);
                        S.translate(V[0] * this.p.mult, V[1] * this.p.mult, -V[2] * this.p.mult)
                    }
                    return S
                }

                function u() {
                    return this.v.clone(new Matrix)
                }
                var p = TransformPropertyFactory.getTransformProperty;
                TransformPropertyFactory.getTransformProperty = function(b, S, C) {
                    var E = p(b, S, C);
                    return E.dynamicProperties.length ? E.getValueAtTime = c.bind(E) : E.getValueAtTime = u.bind(E), E.setGroupProperty = expressionHelpers.setGroupProperty, E
                };
                var m = PropertyFactory.getProp;
                PropertyFactory.getProp = function(b, S, C, E, P) {
                    var w = m(b, S, C, E, P);
                    w.kf ? w.getValueAtTime = expressionHelpers.getValueAtTime.bind(w) : w.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(w), w.setGroupProperty = expressionHelpers.setGroupProperty, w.loopOut = l, w.loopIn = i, w.smooth = o, w.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(w), w.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(w), w.numKeys = S.a === 1 ? S.k.length : 0, w.propertyIndex = S.ix;
                    var T = 0;
                    return C !== 0 && (T = createTypedArray("float32", S.a === 1 ? S.k[0].s.length : S.k.length)), w._cachingAtTime = {
                        lastFrame: initialDefaultFrame,
                        lastIndex: 0,
                        value: T
                    }, expressionHelpers.searchExpressions(b, S, w), w.k && P.addDynamicProperty(w), w
                };

                function g(b) {
                    return this._cachingAtTime || (this._cachingAtTime = {
                        shapeValue: shapePool.clone(this.pv),
                        lastIndex: 0,
                        lastTime: initialDefaultFrame
                    }), b *= this.elem.globalData.frameRate, b -= this.offsetTime, b !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < b ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = b, this.interpolateShape(b, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue
                }
                var _ = ShapePropertyFactory.getConstructorFunction(),
                    v = ShapePropertyFactory.getKeyframedConstructorFunction();

                function x() {}
                x.prototype = {
                    vertices: function(S, C) {
                        this.k && this.getValue();
                        var E = this.v;
                        C !== void 0 && (E = this.getValueAtTime(C, 0));
                        var P, w = E._length,
                            T = E[S],
                            M = E.v,
                            A = createSizedArray(w);
                        for (P = 0; P < w; P += 1) S === "i" || S === "o" ? A[P] = [T[P][0] - M[P][0], T[P][1] - M[P][1]] : A[P] = [T[P][0], T[P][1]];
                        return A
                    },
                    points: function(S) {
                        return this.vertices("v", S)
                    },
                    inTangents: function(S) {
                        return this.vertices("i", S)
                    },
                    outTangents: function(S) {
                        return this.vertices("o", S)
                    },
                    isClosed: function() {
                        return this.v.c
                    },
                    pointOnPath: function(S, C) {
                        var E = this.v;
                        C !== void 0 && (E = this.getValueAtTime(C, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(E));
                        for (var P = this._segmentsLength, w = P.lengths, T = P.totalLength * S, M = 0, A = w.length, D = 0, R; M < A;) {
                            if (D + w[M].addedLength > T) {
                                var I = M,
                                    k = E.c && M === A - 1 ? 0 : M + 1,
                                    F = (T - D) / w[M].addedLength;
                                R = bez.getPointInSegment(E.v[I], E.v[k], E.o[I], E.i[k], F, w[M]);
                                break
                            } else D += w[M].addedLength;
                            M += 1
                        }
                        return R || (R = E.c ? [E.v[0][0], E.v[0][1]] : [E.v[E._length - 1][0], E.v[E._length - 1][1]]), R
                    },
                    vectorOnPath: function(S, C, E) {
                        S == 1 ? S = this.v.c : S == 0 && (S = .999);
                        var P = this.pointOnPath(S, C),
                            w = this.pointOnPath(S + .001, C),
                            T = w[0] - P[0],
                            M = w[1] - P[1],
                            A = Math.sqrt(Math.pow(T, 2) + Math.pow(M, 2));
                        if (A === 0) return [0, 0];
                        var D = E === "tangent" ? [T / A, M / A] : [-M / A, T / A];
                        return D
                    },
                    tangentOnPath: function(S, C) {
                        return this.vectorOnPath(S, C, "tangent")
                    },
                    normalOnPath: function(S, C) {
                        return this.vectorOnPath(S, C, "normal")
                    },
                    setGroupProperty: expressionHelpers.setGroupProperty,
                    getValueAtTime: expressionHelpers.getStaticValueAtTime
                }, extendPrototype([x], _), extendPrototype([x], v), v.prototype.getValueAtTime = g, v.prototype.initiateExpression = ExpressionManager.initiateExpression;
                var y = ShapePropertyFactory.getShapeProp;
                ShapePropertyFactory.getShapeProp = function(b, S, C, E, P) {
                    var w = y(b, S, C, E, P);
                    return w.propertyIndex = S.ix, w.lock = !1, C === 3 ? expressionHelpers.searchExpressions(b, S.pt, w) : C === 4 && expressionHelpers.searchExpressions(b, S.ks, w), w.k && b.addDynamicProperty(w), w
                }
            }

            function initialize$1() {
                addPropertyDecorator()
            }

            function addDecorator() {
                function l() {
                    return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null
                }
                TextProperty.prototype.getExpressionValue = function(i, o) {
                    var c = this.calculateExpression(o);
                    if (i.t !== c) {
                        var u = {};
                        return this.copyData(u, i), u.t = c.toString(), u.__complete = !1, u
                    }
                    return i
                }, TextProperty.prototype.searchProperty = function() {
                    var i = this.searchKeyframes(),
                        o = this.searchExpressions();
                    return this.kf = i || o, this.kf
                }, TextProperty.prototype.searchExpressions = l
            }

            function initialize() {
                addDecorator()
            }

            function SVGComposableEffect() {}
            SVGComposableEffect.prototype = {
                createMergeNode: function l(i, o) {
                    var c = createNS("feMerge");
                    c.setAttribute("result", i);
                    var u, p;
                    for (p = 0; p < o.length; p += 1) u = createNS("feMergeNode"), u.setAttribute("in", o[p]), c.appendChild(u), c.appendChild(u);
                    return c
                }
            };
            var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";

            function SVGTintFilter(l, i, o, c, u) {
                this.filterManager = i;
                var p = createNS("feColorMatrix");
                p.setAttribute("type", "matrix"), p.setAttribute("color-interpolation-filters", "linearRGB"), p.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = p, p.setAttribute("result", c + "_tint_1"), l.appendChild(p), p = createNS("feColorMatrix"), p.setAttribute("type", "matrix"), p.setAttribute("color-interpolation-filters", "sRGB"), p.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), p.setAttribute("result", c + "_tint_2"), l.appendChild(p), this.matrixFilter = p;
                var m = this.createMergeNode(c, [u, c + "_tint_1", c + "_tint_2"]);
                l.appendChild(m)
            }
            extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function(l) {
                if (l || this.filterManager._mdf) {
                    var i = this.filterManager.effectElements[0].p.v,
                        o = this.filterManager.effectElements[1].p.v,
                        c = this.filterManager.effectElements[2].p.v / 100;
                    this.linearFilter.setAttribute("values", linearFilterValue + " " + c + " 0"), this.matrixFilter.setAttribute("values", o[0] - i[0] + " 0 0 0 " + i[0] + " " + (o[1] - i[1]) + " 0 0 0 " + i[1] + " " + (o[2] - i[2]) + " 0 0 0 " + i[2] + " 0 0 0 1 0")
                }
            };

            function SVGFillFilter(l, i, o, c) {
                this.filterManager = i;
                var u = createNS("feColorMatrix");
                u.setAttribute("type", "matrix"), u.setAttribute("color-interpolation-filters", "sRGB"), u.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), u.setAttribute("result", c), l.appendChild(u), this.matrixFilter = u
            }
            SVGFillFilter.prototype.renderFrame = function(l) {
                if (l || this.filterManager._mdf) {
                    var i = this.filterManager.effectElements[2].p.v,
                        o = this.filterManager.effectElements[6].p.v;
                    this.matrixFilter.setAttribute("values", "0 0 0 0 " + i[0] + " 0 0 0 0 " + i[1] + " 0 0 0 0 " + i[2] + " 0 0 0 " + o + " 0")
                }
            };

            function SVGStrokeEffect(l, i, o) {
                this.initialized = !1, this.filterManager = i, this.elem = o, this.paths = []
            }
            SVGStrokeEffect.prototype.initialize = function() {
                var l = this.elem.layerElement.children || this.elem.layerElement.childNodes,
                    i, o, c, u;
                for (this.filterManager.effectElements[1].p.v === 1 ? (u = this.elem.maskManager.masksProperties.length, c = 0) : (c = this.filterManager.effectElements[0].p.v - 1, u = c + 1), o = createNS("g"), o.setAttribute("fill", "none"), o.setAttribute("stroke-linecap", "round"), o.setAttribute("stroke-dashoffset", 1), c; c < u; c += 1) i = createNS("path"), o.appendChild(i), this.paths.push({
                    p: i,
                    m: c
                });
                if (this.filterManager.effectElements[10].p.v === 3) {
                    var p = createNS("mask"),
                        m = createElementID();
                    p.setAttribute("id", m), p.setAttribute("mask-type", "alpha"), p.appendChild(o), this.elem.globalData.defs.appendChild(p);
                    var g = createNS("g");
                    for (g.setAttribute("mask", "url(" + getLocationHref() + "#" + m + ")"); l[0];) g.appendChild(l[0]);
                    this.elem.layerElement.appendChild(g), this.masker = p, o.setAttribute("stroke", "#fff")
                } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
                    if (this.filterManager.effectElements[10].p.v === 2)
                        for (l = this.elem.layerElement.children || this.elem.layerElement.childNodes; l.length;) this.elem.layerElement.removeChild(l[0]);
                    this.elem.layerElement.appendChild(o), this.elem.layerElement.removeAttribute("mask"), o.setAttribute("stroke", "#fff")
                }
                this.initialized = !0, this.pathMasker = o
            }, SVGStrokeEffect.prototype.renderFrame = function(l) {
                this.initialized || this.initialize();
                var i, o = this.paths.length,
                    c, u;
                for (i = 0; i < o; i += 1)
                    if (this.paths[i].m !== -1 && (c = this.elem.maskManager.viewData[this.paths[i].m], u = this.paths[i].p, (l || this.filterManager._mdf || c.prop._mdf) && u.setAttribute("d", c.lastPath), l || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || c.prop._mdf)) {
                        var p;
                        if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                            var m = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01,
                                g = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01,
                                _ = u.getTotalLength();
                            p = "0 0 0 " + _ * m + " ";
                            var v = _ * (g - m),
                                x = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01,
                                y = Math.floor(v / x),
                                b;
                            for (b = 0; b < y; b += 1) p += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " ";
                            p += "0 " + _ * 10 + " 0 0"
                        } else p = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01;
                        u.setAttribute("stroke-dasharray", p)
                    }
                if ((l || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2), (l || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (l || this.filterManager.effectElements[3].p._mdf)) {
                    var S = this.filterManager.effectElements[3].p.v;
                    this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(S[0] * 255) + "," + bmFloor(S[1] * 255) + "," + bmFloor(S[2] * 255) + ")")
                }
            };

            function SVGTritoneFilter(l, i, o, c) {
                this.filterManager = i;
                var u = createNS("feColorMatrix");
                u.setAttribute("type", "matrix"), u.setAttribute("color-interpolation-filters", "linearRGB"), u.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), l.appendChild(u);
                var p = createNS("feComponentTransfer");
                p.setAttribute("color-interpolation-filters", "sRGB"), p.setAttribute("result", c), this.matrixFilter = p;
                var m = createNS("feFuncR");
                m.setAttribute("type", "table"), p.appendChild(m), this.feFuncR = m;
                var g = createNS("feFuncG");
                g.setAttribute("type", "table"), p.appendChild(g), this.feFuncG = g;
                var _ = createNS("feFuncB");
                _.setAttribute("type", "table"), p.appendChild(_), this.feFuncB = _, l.appendChild(p)
            }
            SVGTritoneFilter.prototype.renderFrame = function(l) {
                if (l || this.filterManager._mdf) {
                    var i = this.filterManager.effectElements[0].p.v,
                        o = this.filterManager.effectElements[1].p.v,
                        c = this.filterManager.effectElements[2].p.v,
                        u = c[0] + " " + o[0] + " " + i[0],
                        p = c[1] + " " + o[1] + " " + i[1],
                        m = c[2] + " " + o[2] + " " + i[2];
                    this.feFuncR.setAttribute("tableValues", u), this.feFuncG.setAttribute("tableValues", p), this.feFuncB.setAttribute("tableValues", m)
                }
            };

            function SVGProLevelsFilter(l, i, o, c) {
                this.filterManager = i;
                var u = this.filterManager.effectElements,
                    p = createNS("feComponentTransfer");
                (u[10].p.k || u[10].p.v !== 0 || u[11].p.k || u[11].p.v !== 1 || u[12].p.k || u[12].p.v !== 1 || u[13].p.k || u[13].p.v !== 0 || u[14].p.k || u[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", p)), (u[17].p.k || u[17].p.v !== 0 || u[18].p.k || u[18].p.v !== 1 || u[19].p.k || u[19].p.v !== 1 || u[20].p.k || u[20].p.v !== 0 || u[21].p.k || u[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", p)), (u[24].p.k || u[24].p.v !== 0 || u[25].p.k || u[25].p.v !== 1 || u[26].p.k || u[26].p.v !== 1 || u[27].p.k || u[27].p.v !== 0 || u[28].p.k || u[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", p)), (u[31].p.k || u[31].p.v !== 0 || u[32].p.k || u[32].p.v !== 1 || u[33].p.k || u[33].p.v !== 1 || u[34].p.k || u[34].p.v !== 0 || u[35].p.k || u[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", p)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (p.setAttribute("color-interpolation-filters", "sRGB"), l.appendChild(p)), (u[3].p.k || u[3].p.v !== 0 || u[4].p.k || u[4].p.v !== 1 || u[5].p.k || u[5].p.v !== 1 || u[6].p.k || u[6].p.v !== 0 || u[7].p.k || u[7].p.v !== 1) && (p = createNS("feComponentTransfer"), p.setAttribute("color-interpolation-filters", "sRGB"), p.setAttribute("result", c), l.appendChild(p), this.feFuncRComposed = this.createFeFunc("feFuncR", p), this.feFuncGComposed = this.createFeFunc("feFuncG", p), this.feFuncBComposed = this.createFeFunc("feFuncB", p))
            }
            SVGProLevelsFilter.prototype.createFeFunc = function(l, i) {
                var o = createNS(l);
                return o.setAttribute("type", "table"), i.appendChild(o), o
            }, SVGProLevelsFilter.prototype.getTableValue = function(l, i, o, c, u) {
                for (var p = 0, m = 256, g, _ = Math.min(l, i), v = Math.max(l, i), x = Array.call(null, {
                        length: m
                    }), y, b = 0, S = u - c, C = i - l; p <= 256;) g = p / 256, g <= _ ? y = C < 0 ? u : c : g >= v ? y = C < 0 ? c : u : y = c + S * Math.pow((g - l) / C, 1 / o), x[b] = y, b += 1, p += 256 / (m - 1);
                return x.join(" ")
            }, SVGProLevelsFilter.prototype.renderFrame = function(l) {
                if (l || this.filterManager._mdf) {
                    var i, o = this.filterManager.effectElements;
                    this.feFuncRComposed && (l || o[3].p._mdf || o[4].p._mdf || o[5].p._mdf || o[6].p._mdf || o[7].p._mdf) && (i = this.getTableValue(o[3].p.v, o[4].p.v, o[5].p.v, o[6].p.v, o[7].p.v), this.feFuncRComposed.setAttribute("tableValues", i), this.feFuncGComposed.setAttribute("tableValues", i), this.feFuncBComposed.setAttribute("tableValues", i)), this.feFuncR && (l || o[10].p._mdf || o[11].p._mdf || o[12].p._mdf || o[13].p._mdf || o[14].p._mdf) && (i = this.getTableValue(o[10].p.v, o[11].p.v, o[12].p.v, o[13].p.v, o[14].p.v), this.feFuncR.setAttribute("tableValues", i)), this.feFuncG && (l || o[17].p._mdf || o[18].p._mdf || o[19].p._mdf || o[20].p._mdf || o[21].p._mdf) && (i = this.getTableValue(o[17].p.v, o[18].p.v, o[19].p.v, o[20].p.v, o[21].p.v), this.feFuncG.setAttribute("tableValues", i)), this.feFuncB && (l || o[24].p._mdf || o[25].p._mdf || o[26].p._mdf || o[27].p._mdf || o[28].p._mdf) && (i = this.getTableValue(o[24].p.v, o[25].p.v, o[26].p.v, o[27].p.v, o[28].p.v), this.feFuncB.setAttribute("tableValues", i)), this.feFuncA && (l || o[31].p._mdf || o[32].p._mdf || o[33].p._mdf || o[34].p._mdf || o[35].p._mdf) && (i = this.getTableValue(o[31].p.v, o[32].p.v, o[33].p.v, o[34].p.v, o[35].p.v), this.feFuncA.setAttribute("tableValues", i))
                }
            };

            function SVGDropShadowEffect(l, i, o, c, u) {
                var p = i.container.globalData.renderConfig.filterSize,
                    m = i.data.fs || p;
                l.setAttribute("x", m.x || p.x), l.setAttribute("y", m.y || p.y), l.setAttribute("width", m.width || p.width), l.setAttribute("height", m.height || p.height), this.filterManager = i;
                var g = createNS("feGaussianBlur");
                g.setAttribute("in", "SourceAlpha"), g.setAttribute("result", c + "_drop_shadow_1"), g.setAttribute("stdDeviation", "0"), this.feGaussianBlur = g, l.appendChild(g);
                var _ = createNS("feOffset");
                _.setAttribute("dx", "25"), _.setAttribute("dy", "0"), _.setAttribute("in", c + "_drop_shadow_1"), _.setAttribute("result", c + "_drop_shadow_2"), this.feOffset = _, l.appendChild(_);
                var v = createNS("feFlood");
                v.setAttribute("flood-color", "#00ff00"), v.setAttribute("flood-opacity", "1"), v.setAttribute("result", c + "_drop_shadow_3"), this.feFlood = v, l.appendChild(v);
                var x = createNS("feComposite");
                x.setAttribute("in", c + "_drop_shadow_3"), x.setAttribute("in2", c + "_drop_shadow_2"), x.setAttribute("operator", "in"), x.setAttribute("result", c + "_drop_shadow_4"), l.appendChild(x);
                var y = this.createMergeNode(c, [c + "_drop_shadow_4", u]);
                l.appendChild(y)
            }
            extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function(l) {
                if (l || this.filterManager._mdf) {
                    if ((l || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), l || this.filterManager.effectElements[0].p._mdf) {
                        var i = this.filterManager.effectElements[0].p.v;
                        this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(i[0] * 255), Math.round(i[1] * 255), Math.round(i[2] * 255)))
                    }
                    if ((l || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), l || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                        var o = this.filterManager.effectElements[3].p.v,
                            c = (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                            u = o * Math.cos(c),
                            p = o * Math.sin(c);
                        this.feOffset.setAttribute("dx", u), this.feOffset.setAttribute("dy", p)
                    }
                }
            };
            var _svgMatteSymbols = [];

            function SVGMatte3Effect(l, i, o) {
                this.initialized = !1, this.filterManager = i, this.filterElem = l, this.elem = o, o.matteElement = createNS("g"), o.matteElement.appendChild(o.layerElement), o.matteElement.appendChild(o.transformedElement), o.baseElement = o.matteElement
            }
            SVGMatte3Effect.prototype.findSymbol = function(l) {
                for (var i = 0, o = _svgMatteSymbols.length; i < o;) {
                    if (_svgMatteSymbols[i] === l) return _svgMatteSymbols[i];
                    i += 1
                }
                return null
            }, SVGMatte3Effect.prototype.replaceInParent = function(l, i) {
                var o = l.layerElement.parentNode;
                if (o) {
                    for (var c = o.children, u = 0, p = c.length; u < p && c[u] !== l.layerElement;) u += 1;
                    var m;
                    u <= p - 2 && (m = c[u + 1]);
                    var g = createNS("use");
                    g.setAttribute("href", "#" + i), m ? o.insertBefore(g, m) : o.appendChild(g)
                }
            }, SVGMatte3Effect.prototype.setElementAsMask = function(l, i) {
                if (!this.findSymbol(i)) {
                    var o = createElementID(),
                        c = createNS("mask");
                    c.setAttribute("id", i.layerId), c.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(i);
                    var u = l.globalData.defs;
                    u.appendChild(c);
                    var p = createNS("symbol");
                    p.setAttribute("id", o), this.replaceInParent(i, o), p.appendChild(i.layerElement), u.appendChild(p);
                    var m = createNS("use");
                    m.setAttribute("href", "#" + o), c.appendChild(m), i.data.hd = !1, i.show()
                }
                l.setMatte(i.layerId)
            }, SVGMatte3Effect.prototype.initialize = function() {
                for (var l = this.filterManager.effectElements[0].p.v, i = this.elem.comp.elements, o = 0, c = i.length; o < c;) i[o] && i[o].data.ind === l && this.setElementAsMask(this.elem, i[o]), o += 1;
                this.initialized = !0
            }, SVGMatte3Effect.prototype.renderFrame = function() {
                this.initialized || this.initialize()
            };

            function SVGGaussianBlurEffect(l, i, o, c) {
                l.setAttribute("x", "-100%"), l.setAttribute("y", "-100%"), l.setAttribute("width", "300%"), l.setAttribute("height", "300%"), this.filterManager = i;
                var u = createNS("feGaussianBlur");
                u.setAttribute("result", c), l.appendChild(u), this.feGaussianBlur = u
            }
            SVGGaussianBlurEffect.prototype.renderFrame = function(l) {
                if (l || this.filterManager._mdf) {
                    var i = .3,
                        o = this.filterManager.effectElements[0].p.v * i,
                        c = this.filterManager.effectElements[1].p.v,
                        u = c == 3 ? 0 : o,
                        p = c == 2 ? 0 : o;
                    this.feGaussianBlur.setAttribute("stdDeviation", u + " " + p);
                    var m = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
                    this.feGaussianBlur.setAttribute("edgeMode", m)
                }
            };

            function TransformEffect() {}
            TransformEffect.prototype.init = function(l) {
                this.effectsManager = l, this.type = effectTypes.TRANSFORM_EFFECT, this.matrix = new Matrix, this.opacity = -1, this._mdf = !1, this._opMdf = !1
            }, TransformEffect.prototype.renderFrame = function(l) {
                if (this._opMdf = !1, this._mdf = !1, l || this.effectsManager._mdf) {
                    var i = this.effectsManager.effectElements,
                        o = i[0].p.v,
                        c = i[1].p.v,
                        u = i[2].p.v === 1,
                        p = i[3].p.v,
                        m = u ? p : i[4].p.v,
                        g = i[5].p.v,
                        _ = i[6].p.v,
                        v = i[7].p.v;
                    this.matrix.reset(), this.matrix.translate(-o[0], -o[1], o[2]), this.matrix.scale(m * .01, p * .01, 1), this.matrix.rotate(-v * degToRads), this.matrix.skewFromAxis(-g * degToRads, (_ + 90) * degToRads), this.matrix.translate(c[0], c[1], 0), this._mdf = !0, this.opacity !== i[8].p.v && (this.opacity = i[8].p.v, this._opMdf = !0)
                }
            };

            function SVGTransformEffect(l, i) {
                this.init(i)
            }
            extendPrototype([TransformEffect], SVGTransformEffect);

            function CVTransformEffect(l) {
                this.init(l)
            }
            return extendPrototype([TransformEffect], CVTransformEffect), registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect$1(20, SVGTintFilter, !0), registerEffect$1(21, SVGFillFilter, !0), registerEffect$1(22, SVGStrokeEffect, !1), registerEffect$1(23, SVGTritoneFilter, !0), registerEffect$1(24, SVGProLevelsFilter, !0), registerEffect$1(25, SVGDropShadowEffect, !0), registerEffect$1(28, SVGMatte3Effect, !1), registerEffect$1(29, SVGGaussianBlurEffect, !0), registerEffect$1(35, SVGTransformEffect, !1), registerEffect(35, CVTransformEffect), lottie
        })
    }(lottie$2, lottie$2.exports)), lottie$2.exports
}
var lottieExports = requireLottie();
const lottie = getDefaultExportFromCjs(lottieExports);
class LottieAnimationController {
    constructor(i) {
        this._config = i, this._loadAnimation()
    }
    _animation = null;
    _totalDuration = 0;
    _isReady = !1;
    _loadAnimation() {
        this._animation = lottie.loadAnimation({
            container: this._config.container,
            renderer: "svg",
            loop: this._config.loop ? ? !1,
            autoplay: this._config.autoplay ? ? !1,
            path: this._config.path,
            rendererSettings: this._config.rendererSettings ? ? {
                preserveAspectRatio: "xMidYMid slice"
            }
        }), this._animation.addEventListener("data_ready", () => {
            this._totalDuration = this._animation.getDuration(!1), this._isReady = !0, this._animation.goToAndStop(0, !0)
        }), this._animation.addEventListener("data_failed", () => {
            console.warn(`LottieAnimationController: Failed to load animation from ${this._config.path}`)
        })
    }
    setFrame(i) {
        if (!this._animation || !this._isReady) return;
        const o = this._animation.frameRate,
            c = i * o;
        "setCurrentRawFrameValue" in this._animation ? this._animation.setCurrentRawFrameValue(c) : this._animation.goToAndStop(c, !0)
    }
    setProgress(i) {
        if (!this._animation || !this._isReady) return;
        const o = Math.max(0, Math.min(1, i)) * this._totalDuration;
        this.setFrame(o)
    }
    reset() {
        this.setFrame(0)
    }
    get totalDuration() {
        return this._totalDuration
    }
    get isReady() {
        return this._isReady
    }
    get animation() {
        return this._animation
    }
    destroy() {
        this._animation && (this._animation.destroy(), this._animation = null), this._isReady = !1, this._totalDuration = 0
    }
}
const planeVert = `#define GLSLIFY 1
varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
    planeFrag = `#define GLSLIFY 1
uniform float uTime;uniform float uVisibility;uniform vec2 uResolution;uniform float uAspectRatio;uniform sampler2D uNoiseTex;varying vec2 vUv;float random(vec2 p){return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);}void main(){vec2 uv=vUv;vec2 centeredUv=(uv-0.5)*2.0;if(uAspectRatio>1.0){centeredUv.x*=uAspectRatio;}else{centeredUv.y/=uAspectRatio;}vec4 noise=texture2D(uNoiseTex,uv);vec3 color=vec3(0.0);color.xyz=vec3(noise.x*0.3,noise.y*0.5,noise.z);color.xyz*=smoothstep(1.0,0.1,length(centeredUv))*0.3;color.xyz*=1.0-random(uv)*0.1;gl_FragColor=vec4(color,uVisibility);}`,
    noiseFrag = `#define GLSLIFY 1
uniform sampler2D uTex;uniform float uScreenAspectRatio;varying vec2 vUv;uniform float uTime;vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float noise3D(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}void main(void){float tn=uTime*0.1;float t=uTime*0.1;vec2 aspUv=vUv*vec2(uScreenAspectRatio,1.0)-0.5;vec2 nuv=aspUv*0.5;float n1=noise3D(vec3(nuv+1234.0,tn+0.0));float n2=noise3D(vec3(nuv+5678.0,tn+10.0));vec2 uv=aspUv*0.6+vec2(n1,n2)*0.7;vec4 col=vec4(0.0);col.x+=noise3D(vec3(uv+1.0,t+0.0));col.y+=noise3D(vec3(uv+2.0,t+1.0));col.z+=noise3D(vec3(uv+3.0,t+2.0));col.w+=noise3D(vec3(aspUv+noise3D(vec3(nuv+1234.0,t*0.)),t*0.05+3.0));col=col*0.5+0.5;gl_FragColor=col;}`;
class OutroGL {
    _renderer;
    _scene;
    _camera;
    _canvas;
    _plane;
    _material;
    _animator;
    _resolution;
    _noiseTexture;
    constructor() {
        this._canvas = null, this._resolution = new Vector2(1, 1), this._renderer = new WebGLRenderer({
            antialias: !1,
            alpha: !0,
            powerPreference: "high-performance"
        }), this._renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this._renderer.setClearColor(0, 1), this._scene = new Scene, this._camera = new OrthographicCamera(-1, 1, 1, -1, .1, 10), this._camera.position.z = 1, this._animator = new Animator, this._animator.add({
            name: "visibility",
            initValue: 0
        }), this._animator.add({
            name: "time",
            initValue: 0
        });
        const i = {
            uScreenResolution: {
                value: this._resolution.clone()
            },
            uScreenResolutionInverse: {
                value: new Vector2(1 / this._resolution.x, 1 / this._resolution.y)
            },
            uScreenAspectRatio: {
                value: 1
            },
            uTime: this._animator.getVariableObject("time")
        };
        this._noiseTexture = new ProceduralTexture({
            uniforms: i,
            renderer: this._renderer,
            fragmentShader: noiseFrag,
            resolution: new Vector2(64, 64),
            renderTarget: new WebGLRenderTarget(1, 1, {
                type: FloatType
            })
        }), this._material = new ShaderMaterial({
            vertexShader: planeVert,
            fragmentShader: planeFrag,
            uniforms: {
                uTime: this._animator.getVariableObject("time"),
                uVisibility: this._animator.getVariableObject("visibility"),
                uResolution: {
                    value: this._resolution.clone()
                },
                uAspectRatio: {
                    value: 1
                },
                uNoiseTex: {
                    value: this._noiseTexture.texture
                }
            },
            transparent: !0
        });
        const o = new PlaneGeometry(2, 2);
        this._plane = new Mesh(o, this._material), this._scene.add(this._plane)
    }
    update(i) {
        this._animator.update(i);
        const o = this._animator.get("time") || 0;
        this._animator.setValue("time", o + i), this._noiseTexture.render(), this._canvas && this._renderer.render(this._scene, this._camera)
    }
    resize() {
        if (!this._canvas) return;
        const i = this._canvas.parentElement;
        if (!i) return;
        const o = i.clientWidth,
            c = i.clientHeight,
            u = Math.min(window.devicePixelRatio, 2);
        this._resolution.set(Math.floor(o * u * .5), Math.floor(c * u * .5)), this._renderer.setSize(this._resolution.x, this._resolution.y), this._noiseTexture.resize(this._resolution.clone().multiplyScalar(.25)), this._material && (this._material.uniforms.uResolution.value.copy(this._resolution), this._material.uniforms.uAspectRatio.value = o / c)
    }
    registerCanvas(i) {
        this._canvas = i;
        const o = i.parentNode;
        o && (o.replaceChild(this._renderer.domElement, i), this._renderer.domElement.className = i.className, this._renderer.domElement.id = i.id), this.resize()
    }
    show(i = 1) {
        this._animator.animate("visibility", 1, i)
    }
    hide(i = 1) {
        this._animator.animate("visibility", 0, i)
    }
    dispose() {
        this._noiseTexture.dispose(), this._plane && (this._plane.geometry.dispose(), this._material && this._material.dispose(), this._scene.remove(this._plane)), this._renderer.dispose(), this._canvas = null, this._plane = null, this._material = null
    }
    get canvas() {
        return this._renderer.domElement
    }
    get isVisible() {
        return (this._animator.get("visibility") || 0) > 0
    }
}
class OutroController {
    _lottieController = null;
    _outroGL = null;
    _container = null;
    _logoElement = null;
    _scrollTrigger = null;
    _timeline = null;
    _isInitialized = !1;
    _animationStarted = !1;
    _animationLoopId = null;
    init() {
        const i = document.querySelector("[data-outro-wrapper]");
        if (!i) {
            console.error("OutroController: TopPageOutro wrapper not found");
            return
        }
        if (this._logoElement = i.querySelector("[data-outro-logo]"), !this._logoElement) {
            console.error("OutroController: Logo element not found");
            return
        }
        this._container = i.querySelector("[data-outro-lottie]"), this._container || (this._container = document.createElement("div"), this._container.setAttribute("data-outro-lottie", ""), this._container.style.cssText = `
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				pointer-events: none;
			`, i.appendChild(this._container)), this._outroGL = new OutroGL;
        const o = i.querySelector("#outro-canvas");
        o ? this._outroGL.registerCanvas(o) : console.error("OutroController: Canvas element not found"), this._lottieController = new LottieAnimationController({
            container: this._container,
            path: "/top/outro/data.json",
            loop: !1,
            autoplay: !1,
            rendererSettings: {
                preserveAspectRatio: "xMidYMid slice"
            }
        }), this._scrollTrigger = ScrollTriggerExports.ScrollTrigger.create({
            trigger: i,
            start: "top bottom",
            end: "300px bottom",
            onUpdate: c => {
                !this._animationStarted && c.progress >= 1 && (this.startSequenceAnimation(), this._animationStarted = !0)
            },
            onLeave: () => {
                this._animationStarted || (this.startSequenceAnimation(), this._animationStarted = !0)
            },
            onLeaveBack: () => {
                this.reverseSequenceAnimation(), this._animationStarted = !1
            }
        }), this.startAnimationLoop(), this._isInitialized = !0
    }
    startAnimationLoop() {
        let i = 0;
        const o = c => {
            const u = Math.min((c - i) / 1e3, .03333333333333333);
            i = c, this._outroGL && this._outroGL.update(u), this._animationLoopId = requestAnimationFrame(o)
        };
        this._animationLoopId = requestAnimationFrame(o)
    }
    stopAnimationLoop() {
        this._animationLoopId !== null && (cancelAnimationFrame(this._animationLoopId), this._animationLoopId = null)
    }
    startSequenceAnimation() {
        !this._isInitialized || !this._lottieController || !this._logoElement || (this._outroGL && this._outroGL.show(1), this._timeline = gsapWithCSS.timeline(), this._timeline.to(this._logoElement, {
            left: "17.1%",
            duration: 1,
            ease: "power2.inOut"
        }), setTimeout(() => {
            this._lottieController && this._lottieController.animation && this._lottieController.animation.play()
        }, 100))
    }
    reverseSequenceAnimation() {
        !this._isInitialized || !this._logoElement || (this._timeline && (this._timeline.kill(), this._timeline = null), this._lottieController && this._lottieController.animation && (this._lottieController.animation.stop(), this._lottieController.animation.goToAndStop(0)), this._outroGL && this._outroGL.hide(1), this._timeline = gsapWithCSS.timeline(), this._timeline.to(this._logoElement, {
            left: "50%",
            duration: 1,
            ease: "power2.inOut"
        }))
    }
    reset() {
        this._timeline && (this._timeline.kill(), this._timeline = null), this._logoElement && gsapWithCSS.set(this._logoElement, {
            x: 0
        }), this._lottieController && this._lottieController.reset(), this._outroGL && this._outroGL.hide(0), this._animationStarted = !1
    }
    get isInitialized() {
        return this._isInitialized
    }
    get isReady() {
        return this._lottieController ? .isReady ? ? !1
    }
    resize() {
        this._outroGL && this._outroGL.resize()
    }
    dispose() {
        this.stopAnimationLoop(), this._scrollTrigger && (this._scrollTrigger.kill(), this._scrollTrigger = null), this._timeline && (this._timeline.kill(), this._timeline = null), this._outroGL && (this._outroGL.dispose(), this._outroGL = null), this._lottieController && (this._lottieController.destroy(), this._lottieController = null), this._container = null, this._logoElement = null, this._isInitialized = !1, this._animationStarted = !1
    }
}
class SideMenuController {
    _hamburgerElement = null;
    _sideMenuElement = null;
    _backdropElement = null;
    _menuLinks = null;
    _menuItems = null;
    _isMenuOpen = !1;
    constructor() {
        this.setupElements(), this.setupEventListeners()
    }
    setupElements() {
        if (this._hamburgerElement = document.querySelector("[data-hamburger]"), this._sideMenuElement = document.querySelector("[data-side-menu]"), this._backdropElement = this._sideMenuElement ? .querySelector("[data-backdrop]"), this._menuLinks = this._sideMenuElement ? .querySelectorAll("a"), this._menuItems = this._sideMenuElement ? .querySelectorAll('[class*="menu_item"]'), !this._hamburgerElement || !this._sideMenuElement) {
            console.warn("SideMenuController: ");
            return
        }
    }
    setupEventListeners() {
        if (!this._hamburgerElement || !this._sideMenuElement) {
            console.warn("Cannot setup event listeners - elements not found");
            return
        }
        this._hamburgerElement.addEventListener("click", this.toggleMenu.bind(this)), this._backdropElement && this._backdropElement.addEventListener("click", this.closeMenu.bind(this)), this._menuLinks && this._menuLinks.forEach(i => {
            i.addEventListener("click", this.onMenuLinkClick.bind(this))
        }), document.addEventListener("keydown", this.onKeyDown.bind(this))
    }
    toggleMenu() {
        this._isMenuOpen ? this.closeMenu() : this.openMenu()
    }
    onMenuLinkClick() {
        this._isMenuOpen && this.closeMenu()
    }
    onKeyDown(i) {
        i.key === "Escape" && this._isMenuOpen && this.closeMenu()
    }
    openMenu() {
        !this._hamburgerElement || !this._sideMenuElement || (this._isMenuOpen = !0, this._hamburgerElement.setAttribute("data-open", "true"), this._sideMenuElement.setAttribute("data-open", "true"), document.body.style.overflow = "hidden")
    }
    closeMenu() {
        !this._hamburgerElement || !this._sideMenuElement || (this._isMenuOpen = !1, this._hamburgerElement.removeAttribute("data-open"), this._sideMenuElement.removeAttribute("data-open"), document.body.style.overflow = "")
    }
    updateActiveMenuItem() {
        if (!this._menuItems) return;
        const i = document.body.getAttribute("data-page") || "",
            o = ["top", "news", "works", "about", "stellla", "contact"];
        this._menuItems.forEach((c, u) => {
            const p = o[u];
            if (p) {
                const m = this.isActiveByPageName(p, i);
                c.setAttribute("data-active", m.toString())
            }
        })
    }
    isActiveByPageName(i, o) {
        return !!(i === o || i === "news" && o === "news-detail" || i === "works" && (o === "works-detail" || o.startsWith("works")))
    }
}
const swupPromise = new Promise(l => {
        if (window.swup && window.swup.hooks) l(window.swup);
        else {
            const i = () => {
                window.swup && l(window.swup)
            };
            document.addEventListener("swup:enable", i)
        }
    }),
    lenis = new Lenis({}),
    transition = new Transition,
    lerper = new Lerper,
    topScrollManager = new TopScrollManager,
    topScrollIndicatorController = new TopScrollIndicatorController,
    pageManager = new PageManager,
    animator = new Animator;
new ObjectScroller;
const easyRaycaster = new EasyRaycaster,
    deviceManager = new DeviceManager,
    debugController = new DebugController,
    gl = new GL,
    debugManager = new DebugManager,
    pageLoadingManager = new PageLoadingManager,
    soundManager = new SoundManager,
    outroController = new OutroController,
    sideMenuController = new SideMenuController,
    soundToggleController = new SoundToggleController;
class GLImageManager {
    static elms = new Map;
    static isPaused = !1;
    static inStart(i) {}
    static contentReplace(i) {
        const o = Array.from(document.querySelectorAll("[data-gl_img]"));
        gl.sceneThumbnail.domMeshMap.forEach(c => {
            c && c.endLoading()
        }), gl.sceneThumbnail.domMeshMap.forEach((c, u) => {
            o.some(m => m.getAttribute("data-gl_img") === u) || (gl.sceneThumbnail.detachElm(u), this.elms.delete(u))
        }), o.forEach(c => {
            const u = c.getAttribute("data-gl_img");
            gl.sceneThumbnail.attachElm(u, c), this.elms.set(u, c)
        })
    }
    static outStart(i) {
        const o = this._analyzeTransitionTypes(i),
            c = this._determineRemainingMeshes(i, o);
        this._applyLoadingState(c, i, o)
    }
    static _analyzeTransitionTypes(i) {
        return {
            isWorksTransition: i && TransitionUtils.isWorksTransition(i),
            isWorksDetailToDetail: i && TransitionUtils.isWorksDetailToDetail(i),
            isWorksDetailToCategory: i && TransitionUtils.isWorksDetailToCategory(i),
            isWorksCategoryToDetail: i && TransitionUtils.isWorksCategoryToDetail(i)
        }
    }
    static _determineRemainingMeshes(i, o) {
        return o.isWorksTransition ? o.isWorksDetailToDetail ? [] : o.isWorksDetailToCategory ? this._handleWorksDetailToCategory() : o.isWorksCategoryToDetail ? this._handleWorksCategoryToDetail(i) : this._handleOtherWorksTransition() : this._handleNonWorksTransition()
    }
    static _handleNonWorksTransition() {
        return gl.sceneThumbnail.domMeshMap.forEach((i, o) => {
            gl.sceneThumbnail.detachElm(o), this.elms.delete(o)
        }), []
    }
    static _handleWorksDetailToCategory() {
        const i = [];
        return gl.sceneThumbnail.domMeshMap.forEach((o, c) => {
            this._isMeshOutOfView(o) ? (gl.sceneThumbnail.detachElm(c), this.elms.delete(c)) : i.push(c)
        }), i
    }
    static _handleWorksCategoryToDetail(i) {
        const o = [],
            c = this._extractWorkIdFromUrl(i ? .to.url);
        return gl.sceneThumbnail.domMeshMap.forEach((u, p) => {
            p === c ? o.push(p) : (gl.sceneThumbnail.detachElm(p), this.elms.delete(p))
        }), o
    }
    static _handleOtherWorksTransition() {
        const i = [];
        return gl.sceneThumbnail.domMeshMap.forEach((o, c) => {
            i.push(c)
        }), i
    }
    static _isMeshOutOfView(i) {
        if (!i || !i.material.uniforms.screenSpacePos || !i.material.uniforms.screenSpaceSize) return !1;
        const o = i.material.uniforms.screenSpacePos.value,
            c = i.material.uniforms.screenSpaceSize.value,
            u = o.y + c.y,
            p = o.y - c.y,
            m = o.x - c.x,
            g = o.x + c.x;
        return u < -1 || p > 1 || g < -1 || m > 1
    }
    static _extractWorkIdFromUrl(i) {
        return i ? .match(/\/works\/detail\/([^/]+)/) ? .[1]
    }
    static _applyLoadingState(i, o, c) {
        c.isWorksDetailToDetail || i.forEach(u => {
            const p = gl.sceneThumbnail.domMeshMap.get(u);
            if (p) {
                let m = "default";
                c.isWorksCategoryToDetail && u === this._extractWorkIdFromUrl(o ? .to.url) && (m = "center"), p.startLoading({
                    type: m
                })
            }
        })
    }
    static pause() {
        this.isPaused = !0, gl.sceneThumbnail.domMeshMap.forEach(i => {
            i.enableUpdate = !1
        })
    }
    static resume() {
        this.isPaused = !1, gl.sceneThumbnail.domMeshMap.forEach(i => {
            i.enableUpdate = !0
        })
    }
    static getIsPaused() {
        return this.isPaused
    }
}
gsapWithCSS.registerPlugin(ScrambleTextPluginExports.ScrambleTextPlugin, SplitText);
const ease = Easings.cubicBezier(.53, .25, .3, .99);
class LoadingUIController {
    _overlay;
    _lottieContainer;
    _logoContainer;
    _textElement;
    _textSplit = null;
    _scrambleInterval = null;
    _charStates = [];
    _progressController = null;
    _logoController = null;
    _currentProgress = 0;
    _realProgress = 0;
    _displayProgress = 0;
    _isProgressComplete = !1;
    _targetTime = 0;
    _currentTime = 0;
    _timeAnimationSpeed = .1;
    _minAnimationDuration = 1;
    _animationStartTime = 0;
    _isAnimating = !1;
    _isLogoPlaying = !1;
    _logoStartTime = 0;
    _logoCurrentTime = 0;
    _hidePromise = null;
    _progressCompletePromise = null;
    _progressCompleteResolve = null;
    _isEnabled = !1;
    _currentPageName = "";
    _isScrollDisabled = !1;
    _getPageNameFromUrl(i) {
        return i.split("?")[0] === "/" ? "top" : "sub"
    }
    constructor() {
        if (this._overlay = document.getElementById("loading-overlay"), !this._overlay) {
            console.warn("LoadingUIController: loading-overlay element not found. Disabling loading UI."), this._lottieContainer = null, this._logoContainer = null, this._isEnabled = !1, this._textElement = null;
            return
        }
        this._isEnabled = !0, this._lottieContainer = this._overlay.querySelector("#loading-lottie"), this._logoContainer = this._overlay.querySelector("#loading-logo"), this._textElement = this._overlay.querySelector("#loading-text"), this._currentPageName = this._getPageNameFromUrl(window.location.pathname), this._initializeAnimations()
    }
    _initializeAnimations() {
        this._lottieContainer && (this._progressController = new LottieAnimationController({
            container: this._lottieContainer,
            path: "/common/loading/bg/data.json"
        }), gsapWithCSS.set(this._lottieContainer, {
            opacity: 1
        })), this._logoContainer && (this._logoController = new LottieAnimationController({
            container: this._logoContainer,
            path: "/common/loading/logo/data.json"
        }), gsapWithCSS.set(this._logoContainer, {
            opacity: 0
        }))
    }
    async _disableScroll() {
        this._isScrollDisabled = !0, this._currentPageName === "top" && (window.scrollTo(0, 0), lenis && lenis.scrollTo(0, {
            immediate: !0
        }))
    }
    async _enableScroll() {
        this._isScrollDisabled = !1, document.body.style.overflow = ""
    }
    async show() {
        !this._isEnabled || !this._overlay || !this._progressController || (this._overlay.removeAttribute("data-hidden"), this._overlay.style.opacity = "1", this._isAnimating = !0, this._resetState(), await this._disableScroll(), this._animationStartTime = Date.now(), this._progressController.reset(), this._currentPageName === "top" && setTimeout(() => {
            this._startTextAnimation()
        }, 400))
    }
    _resetState() {
        this._currentProgress = 0, this._realProgress = 0, this._displayProgress = 0, this._targetTime = 0, this._currentTime = 0, this._isProgressComplete = !1, this._isLogoPlaying = !1, this._logoStartTime = 0, this._logoCurrentTime = 0
    }
    update(i) {
        !this._isEnabled || !this._isAnimating || (this._updateProgressAnimation(), this._isLogoPlaying && this._updateLogoAnimation(i))
    }
    _updateProgressAnimation() {
        if (!this._progressController) return;
        const i = (Date.now() - this._animationStartTime) / 1e3,
            o = Math.min(1, i / this._minAnimationDuration);
        this._currentPageName !== "top" && this._isLogoPlaying ? this._displayProgress = o : this._displayProgress = Math.min(this._realProgress, o);
        const c = this._progressController.totalDuration * .45;
        this._targetTime = this._displayProgress * c;
        const u = this._targetTime - this._currentTime;
        this._currentTime += u * this._timeAnimationSpeed, this._progressController.setFrame(this._currentTime), this._isProgressComplete || (this._currentPageName === "top" ? this._realProgress >= .999 && o >= .999 && Math.abs(this._currentTime - this._targetTime) < .01 && (this._isProgressComplete = !0, this._startLogoAnimation()) : this._realProgress >= .999 && (this._isProgressComplete = !0, this._startLogoAnimation()))
    }
    _startLogoAnimation() {
        if (!this._logoController || !this._logoContainer) {
            this._completeProgress();
            return
        }
        this._isLogoPlaying = !0, this._logoStartTime = Date.now(), this._logoCurrentTime = 0, gsapWithCSS.set(this._logoContainer, {
            opacity: 1
        }), this._logoController.reset()
    }
    _startTextAnimation() {
        if (!this._textElement) return;
        this._textElement.textContent = "Architect worlds that move hearts and spark hope.", this._textElement.style.opacity = "1", this._textSplit = new SplitText(this._textElement, {
            type: "chars"
        });
        const i = "ALCHE".split("");
        this._charStates = [];
        const o = Date.now();
        this._textSplit.chars.forEach((c, u) => {
            const p = c,
                m = p.textContent || "";
            if (m.trim() !== "") {
                const g = o + u * 40 + 300;
                this._charStates.push({
                    element: p,
                    originalChar: m,
                    isRevealed: !1,
                    revealTime: g
                }), p.style.opacity = "0.3", p.style.transformOrigin = "50% 50%", p.textContent = i[Math.floor(Math.random() * i.length)]
            } else p.style.opacity = "0"
        }), this._scrambleInterval = window.setInterval(() => {
            const c = Date.now();
            let u = !0;
            this._charStates.forEach(p => {
                p.isRevealed || (c >= p.revealTime ? (p.isRevealed = !0, p.element.textContent = p.originalChar, p.element.style.opacity = "1") : (p.element.textContent = i[Math.floor(Math.random() * i.length)], u = !1))
            }), u && this._scrambleInterval && (clearInterval(this._scrambleInterval), this._scrambleInterval = null)
        }, 32)
    }
    _updateLogoAnimation(i) {
        if (!this._logoController) return;
        this._logoCurrentTime += i;
        const o = this._currentPageName === "top" ? 1.8 : 1;
        this._logoCurrentTime >= o && (this._logoCurrentTime = o, this._isLogoPlaying = !1, this._completeProgress());
        const c = this._logoCurrentTime / o,
            u = ease(c);
        this._logoController.setProgress(.144 + u * .3775)
    }
    _completeProgress() {
        this._progressCompleteResolve && (this._progressCompleteResolve(), this._progressCompleteResolve = null)
    }
    hide() {
        return this._isAnimating = !1, !this._isEnabled || !this._overlay ? Promise.resolve() : this._hidePromise ? this._hidePromise : (lenis.scrollTo(0, {
            immediate: !0
        }), this._hidePromise = new Promise(i => {
            gsapWithCSS.to(this._overlay, {
                opacity: 0,
                duration: .8,
                ease: "power2.out",
                onComplete: async () => {
                    this._overlay && this._overlay.setAttribute("data-hidden", ""), await this._enableScroll(), this._resetAnimations(), this._resetState(), this._hidePromise = null, i()
                }
            })
        }), this._hidePromise)
    }
    updateProgress(i) {
        if (!this._isEnabled || !this._isAnimating) return;
        const o = i.totalProgress;
        Math.abs(o - this._realProgress) < .001 || (this._realProgress = o, o >= .999 && !this._progressCompletePromise && (this._progressCompletePromise = new Promise(c => {
            this._progressCompleteResolve = c
        })))
    }
    _resetAnimations() {
        this._progressController && this._progressController.reset(), this._logoController && this._logoContainer && (this._logoController.reset(), gsapWithCSS.set(this._logoContainer, {
            opacity: 0
        })), this._scrambleInterval && (clearInterval(this._scrambleInterval), this._scrambleInterval = null), this._charStates = [], this._textSplit && (this._textSplit.revert(), this._textSplit = null), this._textElement && (gsapWithCSS.set(this._textElement, {
            opacity: 0
        }), this._textElement.textContent = "")
    }
    getHidePromise() {
        return this._hidePromise
    }
    waitForProgressComplete() {
        return !this._isEnabled || this._realProgress >= .999 && !this._progressCompletePromise ? Promise.resolve() : (this._progressCompletePromise || (this._progressCompletePromise = new Promise(i => {
            this._progressCompleteResolve = i
        })), this._progressCompletePromise)
    }
    showError(i) {
        console.error("Loading error:", i), !(!this._isEnabled || !this._lottieContainer) && gsapWithCSS.to(this._lottieContainer, {
            filter: "hue-rotate(0deg) brightness(2) saturate(2)",
            duration: .3,
            yoyo: !0,
            repeat: 3,
            onComplete: () => {
                gsapWithCSS.set(this._lottieContainer, {
                    filter: "none"
                })
            }
        })
    }
}
gsapWithCSS.registerPlugin(ScrambleTextPluginExports.ScrambleTextPlugin);
class HeaderController {
    static _instance = null;
    _navItems = null;
    _eventHandlers = new Map;
    constructor() {
        this.initialize()
    }
    static getInstance() {
        return HeaderController._instance || (HeaderController._instance = new HeaderController), HeaderController._instance
    }
    initialize() {
        document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => {
            this.setupElements()
        }) : this.setupElements()
    }
    setupElements() {
        this._navItems = document.querySelectorAll('header nav div[class*="nav_item"]'), this._navItems && this._navItems.forEach(i => {
            const o = i.querySelector("span");
            if (o) {
                const c = o.textContent || "";
                o.dataset.originalText = c;
                const u = () => this.onMouseEnter(o),
                    p = () => this.onMouseLeave(o);
                this._eventHandlers.set(i, {
                    enter: u,
                    leave: p
                }), i.addEventListener("mouseenter", u), i.addEventListener("mouseleave", p)
            }
        })
    }
    onMouseEnter(i) {
        const o = i.dataset.originalText;
        o && this.scrambleText(i, o, .4)
    }
    onMouseLeave(i) {}
    scrambleText(i, o, c) {
        gsapWithCSS.to(i, {
            duration: c,
            scrambleText: {
                text: o,
                chars: "AlcheALCHE",
                revealDelay: .2,
                speed: 1
            },
            ease: "power2.out"
        })
    }
    init() {
        this.setupElements()
    }
    dispose() {
        this._navItems && this._navItems.forEach(i => {
            const o = this._eventHandlers.get(i);
            o && (i.removeEventListener("mouseenter", o.enter), i.removeEventListener("mouseleave", o.leave))
        }), this._eventHandlers.clear(), this._navItems = null
    }
}
const headerController = HeaderController.getInstance();
gsapWithCSS.registerPlugin(ScrambleTextPluginExports.ScrambleTextPlugin);
class FooterController {
    static _instance = null;
    _scrambleElements = null;
    _eventHandlers = new Map;
    constructor() {
        this.initialize()
    }
    static getInstance() {
        return FooterController._instance || (FooterController._instance = new FooterController), FooterController._instance
    }
    initialize() {
        document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => {
            this.setupElements()
        }) : this.setupElements()
    }
    setupElements() {
        this._scrambleElements = document.querySelectorAll("footer [data-scramble]"), this._scrambleElements && this._scrambleElements.forEach(i => {
            const o = i,
                c = o.textContent || "";
            o.dataset.originalText = c;
            const u = () => this.onMouseEnter(o),
                p = () => this.onMouseLeave(o);
            this._eventHandlers.set(i, {
                enter: u,
                leave: p
            }), i.addEventListener("mouseenter", u), i.addEventListener("mouseleave", p)
        })
    }
    onMouseEnter(i) {
        const o = i.dataset.originalText;
        o && this.scrambleText(i, o, .4)
    }
    onMouseLeave(i) {}
    scrambleText(i, o, c) {
        gsapWithCSS.to(i, {
            duration: c,
            scrambleText: {
                text: o,
                chars: "ALCHE",
                revealDelay: .2,
                speed: 1
            },
            ease: "power2.out"
        })
    }
    init() {
        this.setupElements()
    }
    dispose() {
        this._scrambleElements && this._scrambleElements.forEach(i => {
            const o = this._eventHandlers.get(i);
            o && (i.removeEventListener("mouseenter", o.enter), i.removeEventListener("mouseleave", o.leave))
        }), this._eventHandlers.clear(), this._scrambleElements = null
    }
}
const footerController = FooterController.getInstance();

function r() {
    return r = Object.assign ? Object.assign.bind() : function(l) {
        for (var i = 1; i < arguments.length; i++) {
            var o = arguments[i];
            for (var c in o) Object.prototype.hasOwnProperty.call(o, c) && (l[c] = o[c])
        }
        return l
    }, r.apply(this, arguments)
}
const n = l => String(l).split(".").map(i => String(parseInt(i || "0", 10))).concat(["0", "0"]).slice(0, 3).join(".");
let e$1 = class {
    constructor() {
        this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = []
    }
    mount() {}
    unmount() {
        this.handlersToUnregister.forEach(i => i()), this.handlersToUnregister = []
    }
    _beforeMount() {
        if (!this.name) throw new Error("You must define a name of plugin when creating a class.")
    }
    _afterUnmount() {}
    _checkRequirements() {
        return typeof this.requires != "object" || Object.entries(this.requires).forEach(([i, o]) => {
            if (! function(c, u, p) {
                    const m = function(g, _) {
                        var v;
                        if (g === "swup") return (v = _.version) != null ? v : ""; {
                            var x;
                            const y = _.findPlugin(g);
                            return (x = y ? .version) != null ? x : ""
                        }
                    }(c, p);
                    return !!m && ((g, _) => _.every(v => {
                        const [, x, y] = v.match(/^([\D]+)?(.*)$/) || [];
                        var b, S;
                        return ((C, E) => {
                            const P = {
                                "": w => w === 0,
                                ">": w => w > 0,
                                ">=": w => w >= 0,
                                "<": w => w < 0,
                                "<=": w => w <= 0
                            };
                            return (P[E] || P[""])(C)
                        })((S = y, b = n(b = g), S = n(S), b.localeCompare(S, void 0, {
                            numeric: !0
                        })), x || ">=")
                    }))(m, u)
                }(i, o = Array.isArray(o) ? o : [o], this.swup)) {
                const c = `${i} ${o.join(", ")}`;
                throw new Error(`Plugin version mismatch: ${this.name} requires ${c}`)
            }
        }), !0
    }
    on(i, o, c = {}) {
        var u;
        o = !(u = o).name.startsWith("bound ") || u.hasOwnProperty("prototype") ? o.bind(this) : o;
        const p = this.swup.hooks.on(i, o, c);
        return this.handlersToUnregister.push(p), p
    }
    once(i, o, c = {}) {
        return this.on(i, o, r({}, c, {
            once: !0
        }))
    }
    before(i, o, c = {}) {
        return this.on(i, o, r({}, c, {
            before: !0
        }))
    }
    replace(i, o, c = {}) {
        return this.on(i, o, r({}, c, {
            replace: !0
        }))
    }
    off(i, o) {
        return this.swup.hooks.off(i, o)
    }
};

function e() {
    return e = Object.assign ? Object.assign.bind() : function(l) {
        for (var i = 1; i < arguments.length; i++) {
            var o = arguments[i];
            for (var c in o) Object.prototype.hasOwnProperty.call(o, c) && (l[c] = o[c])
        }
        return l
    }, e.apply(this, arguments)
}
class a extends e$1 {
    constructor(i = {}) {
        super(), this.name = "SwupGaPlugin", this.requires = {
            swup: ">=4"
        }, this.defaults = {
            gaMeasurementId: null
        }, this.options = e({}, this.defaults, i)
    }
    mount() {
        this.on("page:view", this.trackPageView)
    }
    trackPageView() {
        const i = document.title,
            o = window.location.pathname + window.location.search;
        typeof window.gtag == "function" ? (this.trackPageViewInGtag({
            title: i,
            url: o
        }), this.swup.log(`GA page view: ${o} (gtag.js)`)) : typeof window.ga == "function" ? (this.trackPageViewInGa({
            title: i,
            url: o
        }), this.swup.log(`GA page view: ${o} (analytics.js)`)) : console.warn("Neither window.gtag nor window.ga are present on the page")
    }
    trackPageViewInGtag({
        title: i,
        url: o
    }) {
        const {
            gaMeasurementId: c
        } = this.options;
        c ? window.gtag("config", c, {
            page_title: i,
            page_path: o
        }) : console.error("The gaMeasurementId option is required for gtag.js")
    }
    trackPageViewInGa({
        title: i,
        url: o
    }) {
        window.ga("set", "title", i), window.ga("set", "page", o), window.ga("send", "pageview")
    }
}
const loadingUIController = new LoadingUIController;
loadingUIController.show();
pageLoadingManager.on("progress", l => {
    loadingUIController.updateProgress(l)
});
const glContainer = document.getElementById("gl-canvas");
glContainer.appendChild(gl.canvas);
gl.registerElm(glContainer);
const onResizeGL = () => {
        gl.resize(), outroController.resize()
    },
    glResizeObserver = new ResizeObserver(() => {
        onResizeGL()
    });
glResizeObserver.observe(glContainer);
window.addEventListener("resize", onResizeGL, !1);
const tweakPaneSectionManager = TweakPaneSectionManager.getInstance(),
    tweakPaneManager = TweakPaneManager.getInstance();
tweakPaneSectionManager.configure({
    sections: {
        kv: {
            windows: ["mainlogo-material", "mainlogo-rotation", "mainlogo-quaternion"],
            theme: "dark"
        },
        works_intro: {
            windows: ["mainlogo-quaternion"],
            theme: "dark"
        },
        works: {
            windows: ["mainlogo-quaternion"],
            theme: "dark"
        },
        works_outro: {
            windows: [],
            theme: "dark"
        },
        mission_in: {
            windows: [],
            theme: "dark"
        },
        mission: {
            windows: [],
            theme: "dark"
        },
        vision: {
            windows: ["mainlogo-screen"],
            theme: "light"
        },
        service_in: {
            windows: [],
            theme: "dark"
        },
        service: {
            windows: [],
            theme: "dark"
        },
        stellla: {
            windows: [],
            theme: "dark"
        }
    }
});
const onPageInStart = l => {
        const i = new Pane;
        i.registerPlugin(TweakpaneRotationInputPlugin), i.dispose(), l.to.url.includes("works/detail") || WorksDetailSwiper.deleteInstance();
        const o = pageManager.getPageNameFromUrl(l.to.url);
        document.body.setAttribute("data-page", o), sideMenuController.updateActiveMenuItem(), pageManager.inStart(l), gl.inStart(), GLImageManager.resume(), l.to.url === "/" ? gl.switchToTopPage() : gl.switchToSubPage(), document.getElementById("404page") ? gl.switchToNotFoundPage() : gl.hideNotFoundPage()
    },
    onPageInAwait = async l => {
        await pageLoadingManager.waitForLoading();
        try {
            if (TransitionUtils.shouldUsePartialTransition(l)) {
                await transition.endPartial();
                return
            }
            if (TransitionUtils.shouldSkipTransition(l)) return;
            await transition.end()
        } catch {}
    },
    onPageInEnd = l => {
        pageManager.inEnd(l), l.to.url === "/" ? tweakPaneSectionManager.setSection(tweakPaneSectionManager.currentSection) : tweakPaneSectionManager.setSection(null)
    },
    onContentReplace = l => {
        setTimeout(() => {
            GLImageManager.contentReplace(l), footerController.init(), soundToggleController.updateState()
        }, 100)
    },
    scrollToWorksTop = (l = 1.5) => {
        const i = document.getElementById("works-swiper");
        let o = i ? .offsetTop || 0;
        const c = i ? -130 : 0;
        window.scrollY == o + c && (o += 1), lenis.scrollTo(o, {
            offset: c,
            duration: l,
            easing: u => u < .5 ? 4 * u * u * u : 1 - Math.pow(-2 * u + 2, 3) / 2,
            onComplete: () => {},
            lerp: 0,
            force: !0
        })
    };
document.body.setAttribute("data-page_changed", "false");
const onPageOutStart = l => {
        document.body.setAttribute("data-page_changed", "true"), tweakPaneManager.hideAllWindows(), GLImageManager.outStart(l), pageManager.outStart(l), footerController.dispose()
    },
    onPageOutAwait = async l => {
        const i = TransitionUtils.isWorksRelatedPage(l.from.url, pageManager),
            o = TransitionUtils.isWorksRelatedPage(l.to.url, pageManager);
        i && o && (deviceManager.isSPLayout || scrollToWorksTop(1)), i && o || gl.outStart(), l.to.url === "/" ? gl.switchToTopPage() : gl.switchToSubPage(), pageManager.getPageNameFromUrl(l.to.url) === "404" ? gl.switchToNotFoundPage() : gl.hideNotFoundPage(), !TransitionUtils.shouldSkipTransition(l) && (TransitionUtils.shouldUsePartialTransition(l) ? await transition.startPartial() : await transition.start(), i && o || deviceManager.isSPLayout || scrollToWorksTop(0))
    },
    onPageOutEnd = l => {
        pageManager.outEnd(l), gl.outEnd(), GLImageManager.pause()
    };
swupPromise.then(l => {
    l.use(new a({
        gaMeasurementId: "G-R00M7W3JTS"
    }));
    const i = () => ({
            from: {
                url: window.location.pathname
            },
            to: {
                url: window.location.pathname
            }
        }),
        o = () => {
            onPageInStart(i()), onPageInAwait(i()), onPageInEnd(i())
        },
        c = i();
    transition.setPageInfo("", pageManager.getPageNameFromUrl(c.to.url)), pageLoadingManager.setCurrentPathname(window.location.pathname), sideMenuController.updateActiveMenuItem(), pageManager.getPageNameFromUrl(c.to.url) === "404" && gl.switchToNotFoundPage(), onContentReplace(c), headerController.init(), footerController.init(), setTimeout(() => {
        outroController.init()
    }, 500), (async () => {
        o(), pageLoadingManager.startShaderPrecompile();
        try {
            await gl.precompileShaders({
                verbose: !0,
                includeInvisible: !1,
                onProgress: p => {
                    pageLoadingManager.updateShaderPrecompileProgress(p), loadingUIController.updateProgress({
                        phase: "Compiling Shaders",
                        phaseProgress: p.percentage / 100,
                        totalProgress: .5 + p.percentage / 100 * .5
                    })
                },
                onComplete: p => {
                    pageLoadingManager.completeShaderPrecompile()
                }
            })
        } catch (p) {
            console.error("Shader precompilation failed:", p), pageLoadingManager.completeShaderPrecompile()
        }
        await loadingUIController.waitForProgressComplete(), c.from.url !== "/" && gl.onLoadingComplete(!0), await loadingUIController.hide(), c.from.url == "/" && gl.onLoadingComplete()
    })(), l.hooks.on("animation:in:start", onPageInStart), l.hooks.on("animation:in:await", onPageInAwait), l.hooks.on("animation:in:end", onPageInEnd), l.hooks.on("content:replace", onContentReplace), l.hooks.on("animation:out:start", onPageOutStart), l.hooks.on("animation:out:await", onPageOutAwait), l.hooks.on("animation:out:end", onPageOutEnd), l.hooks.on("history:popstate", () => {
        document.body.dataset.phase = "force-in", GLImageManager.pause();
        const p = () => {
            setTimeout(() => {
                transition.rejectAllActivePromises(), o(), document.body.dataset.phase = "ready"
            }, 10), l.hooks.off("content:replace", p), GLImageManager.resume()
        };
        l.hooks.on("content:replace", p)
    })
});
const mainLoop = l => {
    lenis.raf(l);
    const i = gl.update();
    lerper.update(l), topScrollIndicatorController.update(), soundToggleController.update(), i !== void 0 && loadingUIController.update(i), requestAnimationFrame(mainLoop)
};
requestAnimationFrame(mainLoop);
window.addEventListener("click", () => {
    soundManager.startBGM()
});
window.addEventListener("wheel", () => {
    soundManager.startBGM()
});
const d = document,
    config = {
        kitId: "ukr2yqt",
        scriptTimeout: 3e3,
        async: !0
    },
    h = d.documentElement,
    t = setTimeout(function() {
        h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive"
    }, config.scriptTimeout),
    tk = d.createElement("script");
let f = !1;
const s = d.getElementsByTagName("script")[0];
h.className += " wf-loading";
tk.src = "https://use.typekit.net/" + config.kitId + ".js";
tk.async = !0;
tk.onload = function() {
    if (!f) {
        f = !0, clearTimeout(t);
        try {
            window.Typekit.load(config)
        } catch {}
    }
};
s && s.parentNode && s.parentNode.insertBefore(tk, s);